(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyPR2137 = void 0;
const utils_1 = require("bip174/src/lib/utils");
const bip341_1 = require("bitcoinjs-lib/src/payments/bip341");
const bip371_1 = require("bitcoinjs-lib/src/psbt/bip371");
const crypto_1 = require("bitcoinjs-lib/src/crypto");
const toXOnly = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
function range(n) {
    return [...Array(n).keys()];
}
function tapBranchHash(a, b) {
    return (0, crypto_1.taggedHash)('TapBranch', Buffer.concat([a, b]));
}
function calculateScriptTreeMerkleRoot(leafHashes) {
    if (!leafHashes || leafHashes.length === 0) {
        return undefined;
    }
    // sort the leaf nodes
    leafHashes.sort(Buffer.compare);
    // create the initial hash node
    let currentLevel = leafHashes;
    // build Merkle Tree
    while (currentLevel.length > 1) {
        const nextLevel = [];
        for (let i = 0; i < currentLevel.length; i += 2) {
            const left = currentLevel[i];
            const right = i + 1 < currentLevel.length ? currentLevel[i + 1] : left;
            nextLevel.push(i + 1 < currentLevel.length ? tapBranchHash(left, right) : left);
        }
        currentLevel = nextLevel;
    }
    return currentLevel[0];
}
function getTweakSignersFromHD(inputIndex, inputs, hdKeyPair) {
    const input = (0, utils_1.checkForInput)(inputs, inputIndex);
    if (!input.tapBip32Derivation || input.tapBip32Derivation.length === 0) {
        throw new Error('Need tapBip32Derivation to sign with HD');
    }
    const myDerivations = input.tapBip32Derivation
        .map(bipDv => {
        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
            return bipDv;
        }
        else {
            return;
        }
    })
        .filter(v => !!v);
    if (myDerivations.length === 0) {
        throw new Error('Need one tapBip32Derivation masterFingerprint to match the HDSigner fingerprint');
    }
    const signers = myDerivations.map(bipDv => {
        const node = hdKeyPair.derivePath(bipDv.path);
        if (!bipDv.pubkey.equals(toXOnly(node.publicKey))) {
            throw new Error('pubkey did not match tapBip32Derivation');
        }
        const h = calculateScriptTreeMerkleRoot(bipDv.leafHashes);
        const tweakValue = (0, bip341_1.tapTweakHash)(toXOnly(node.publicKey), h);
        return node.tweak(tweakValue);
    });
    return signers;
}
function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
    const input = (0, utils_1.checkForInput)(inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input)) {
        return getTweakSignersFromHD(inputIndex, inputs, hdKeyPair);
    }
    if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
        throw new Error('Need bip32Derivation to sign with HD');
    }
    const myDerivations = input.bip32Derivation
        .map(bipDv => {
        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
            return bipDv;
        }
        else {
            return;
        }
    })
        .filter(v => !!v);
    if (myDerivations.length === 0) {
        throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');
    }
    const signers = myDerivations.map(bipDv => {
        const node = hdKeyPair.derivePath(bipDv.path);
        if (!bipDv.pubkey.equals(node.publicKey)) {
            throw new Error('pubkey did not match bip32Derivation');
        }
        return node;
    });
    return signers;
}
const applyPR2137 = (psbt) => {
    psbt.signInputHD = function signInputHD(inputIndex, hdKeyPair, sighashTypes) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));
        return this;
    };
    psbt.signAllInputsHD = function signAllInputsHD(hdKeyPair, sighashTypes) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const results = [];
        for (const i of range(psbt.data.inputs.length)) {
            try {
                psbt.signInputHD(i, hdKeyPair, sighashTypes);
                results.push(true);
            }
            catch (err) {
                results.push(false);
            }
        }
        if (results.every(v => v === false)) {
            throw new Error('No inputs were signed');
        }
        return psbt;
    };
};
exports.applyPR2137 = applyPR2137;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bip174/src/lib/utils":83,"bitcoinjs-lib/src/crypto":107,"bitcoinjs-lib/src/payments/bip341":113,"bitcoinjs-lib/src/psbt/bip371":125,"buffer":167}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DescriptorChecksum = exports.CHECKSUM_CHARSET = void 0;
// Converted to Javascript by Jose-Luis Landabaso, 2023 - https://bitcoinerlab.com
// Source: https://github.com/bitcoin/bitcoin/blob/master/src/script/descriptor.cpp
// Distributed under the MIT software license
const PolyMod = (c, val) => {
    const c0 = c >> 35n;
    c = ((c & 0x7ffffffffn) << 5n) ^ val;
    if (c0 & 1n)
        c ^= 0xf5dee51989n;
    if (c0 & 2n)
        c ^= 0xa9fdca3312n;
    if (c0 & 4n)
        c ^= 0x1bab10e32dn;
    if (c0 & 8n)
        c ^= 0x3706b1677an;
    if (c0 & 16n)
        c ^= 0x644d626ffdn;
    return c;
};
exports.CHECKSUM_CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
/**
 * Implements the Bitcoin descriptor's checksum algorithm described in
 * {@link https://github.com/bitcoin/bitcoin/blob/master/src/script/descriptor.cpp}
 */
const DescriptorChecksum = (span) => {
    const INPUT_CHARSET = '0123456789()[],\'/*abcdefgh@:$%{}IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~ijklmnopqrstuvwxyzABCDEFGH`#"\\ ';
    let c = 1n;
    let cls = 0n;
    let clscount = 0n;
    for (const ch of span) {
        const pos = BigInt(INPUT_CHARSET.indexOf(ch));
        if (pos === -1n)
            return '';
        c = PolyMod(c, pos & 31n);
        cls = cls * 3n + (pos >> 5n);
        if (++clscount === 3n) {
            c = PolyMod(c, cls);
            cls = 0n;
            clscount = 0n;
        }
    }
    if (clscount > 0n)
        c = PolyMod(c, cls);
    for (let j = 0; j < 8; ++j)
        c = PolyMod(c, 0n);
    c ^= 1n;
    let ret = '';
    for (let j = 0; j < 8; ++j) {
        const index = (c >> (5n * (7n - BigInt(j)))) & 31n;
        if (index < 0 || index > Number.MAX_SAFE_INTEGER)
            throw new Error(`Error: could not compute checksum, invalid index ${index}`);
        ret += exports.CHECKSUM_CHARSET[Number(index)];
    }
    return ret;
};
exports.DescriptorChecksum = DescriptorChecksum;

},{}],3:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
// Copyright (c) 2025 Jose-Luis Landabaso - https://bitcoinerlab.com
// Distributed under the MIT software license
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DescriptorsFactory = void 0;
const lodash_memoize_1 = __importDefault(require("lodash.memoize"));
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const varuint_bitcoin_1 = require("varuint-bitcoin");
const { p2sh, p2wpkh, p2pkh, p2pk, p2wsh, p2tr } = bitcoinjs_lib_1.payments;
const bip32_1 = require("bip32");
const ecpair_1 = require("ecpair");
const psbt_1 = require("./psbt");
const checksum_1 = require("./checksum");
const keyExpressions_1 = require("./keyExpressions");
const RE = __importStar(require("./re"));
const miniscript_1 = require("./miniscript");
//See "Resource limitations" https://bitcoin.sipa.be/miniscript/
//https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017306.html
const MAX_SCRIPT_ELEMENT_SIZE = 520;
const MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;
const MAX_OPS_PER_SCRIPT = 201;
function countNonPushOnlyOPs(script) {
    const decompile = bitcoinjs_lib_1.script.decompile(script);
    if (!decompile)
        throw new Error(`Error: cound not decompile ${script}`);
    return decompile.filter(op => typeof op === 'number' && op > bitcoinjs_lib_1.script.OPS['OP_16']).length;
}
function vectorSize(someVector) {
    const length = someVector.length;
    return ((0, varuint_bitcoin_1.encodingLength)(length) +
        someVector.reduce((sum, witness) => {
            return sum + varSliceSize(witness);
        }, 0));
}
function varSliceSize(someScript) {
    const length = someScript.length;
    return (0, varuint_bitcoin_1.encodingLength)(length) + length;
}
/**
 * This function will typically return 73; since it assumes a signature size of
 * 72 bytes (this is the max size of a DER encoded signature) and it adds 1
 * extra byte for encoding its length
 */
function signatureSize(signature) {
    const length = signature === 'DANGEROUSLY_USE_FAKE_SIGNATURES'
        ? 72
        : signature.signature.length;
    return (0, varuint_bitcoin_1.encodingLength)(length) + length;
}
/*
 * Returns a bare descriptor without checksum and particularized for a certain
 * index (if desc was a range descriptor)
 * @hidden
 */
function evaluate({ descriptor, checksumRequired, index }) {
    if (!descriptor)
        throw new Error('You must provide a descriptor.');
    const mChecksum = descriptor.match(String.raw `(${RE.reChecksum})$`);
    if (mChecksum === null && checksumRequired === true)
        throw new Error(`Error: descriptor ${descriptor} has not checksum`);
    //evaluatedDescriptor: a bare desc without checksum and particularized for a certain
    //index (if desc was a range descriptor)
    let evaluatedDescriptor = descriptor;
    if (mChecksum !== null) {
        const checksum = mChecksum[0].substring(1); //remove the leading #
        evaluatedDescriptor = descriptor.substring(0, descriptor.length - mChecksum[0].length);
        if (checksum !== (0, checksum_1.DescriptorChecksum)(evaluatedDescriptor)) {
            throw new Error(`Error: invalid descriptor checksum for ${descriptor}`);
        }
    }
    if (index !== undefined) {
        const mWildcard = evaluatedDescriptor.match(/\*/g);
        if (mWildcard && mWildcard.length > 0) {
            //From  https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md
            //To prevent a combinatorial explosion of the search space, if more than
            //one of the multi() key arguments is a BIP32 wildcard path ending in /* or
            //*', the multi() descriptor only matches multisig scripts with the ith
            //child key from each wildcard path in lockstep, rather than scripts with
            //any combination of child keys from each wildcard path.
            //We extend this reasoning for musig for all cases
            evaluatedDescriptor = evaluatedDescriptor.replaceAll('*', index.toString());
        }
        else
            throw new Error(`Error: index passed for non-ranged descriptor: ${descriptor}`);
    }
    return evaluatedDescriptor;
}
/**
 * Constructs the necessary functions and classes for working with descriptors
 * using an external elliptic curve (ecc) library.
 *
 * Notably, it returns the {@link _Internal_.Output | `Output`} class, which
 * provides methods to create, sign, and finalize PSBTs based on descriptor
 * expressions.
 *
 * While this Factory function includes the `Descriptor` class, note that
 * this class was deprecated in v2.0 in favor of `Output`. For backward
 * compatibility, the `Descriptor` class remains, but using `Output` is advised.
 *
 * The Factory also returns utility methods like `expand` (detailed below)
 * and `parseKeyExpression` (see {@link ParseKeyExpression}).
 *
 * Additionally, for convenience, the function returns `BIP32` and `ECPair`.
 * These are {@link https://github.com/bitcoinjs bitcoinjs-lib} classes designed
 * for managing {@link https://github.com/bitcoinjs/bip32 | `BIP32`} keys and
 * public/private key pairs:
 * {@link https://github.com/bitcoinjs/ecpair | `ECPair`}, respectively.
 *
 * @param {Object} ecc - An object with elliptic curve operations, such as
 * [tiny-secp256k1](https://github.com/bitcoinjs/tiny-secp256k1) or
 * [@bitcoinerlab/secp256k1](https://github.com/bitcoinerlab/secp256k1).
 */
function DescriptorsFactory(ecc) {
    var _Output_instances, _Output_payment, _Output_preimages, _Output_signersPubKeys, _Output_miniscript, _Output_witnessScript, _Output_redeemScript, _Output_isSegwit, _Output_isTaproot, _Output_expandedExpression, _Output_expandedMiniscript, _Output_expansionMap, _Output_network, _Output_getTimeConstraints, _Output_assertPsbtInput;
    (0, bitcoinjs_lib_1.initEccLib)(ecc); //Taproot requires initEccLib
    const BIP32 = (0, bip32_1.BIP32Factory)(ecc);
    const ECPair = (0, ecpair_1.ECPairFactory)(ecc);
    const signatureValidator = (pubkey, msghash, signature) => {
        if (pubkey.length === 32) {
            //x-only
            if (!ecc.verifySchnorr) {
                throw new Error('TinySecp256k1Interface is not initialized properly: verifySchnorr is missing.');
            }
            return ecc.verifySchnorr(msghash, pubkey, signature);
        }
        else {
            return ECPair.fromPublicKey(pubkey).verify(msghash, signature);
        }
    };
    /**
     * Takes a string key expression (xpub, xprv, pubkey or wif) and parses it
     */
    const parseKeyExpression = ({ keyExpression, isSegwit, isTaproot, network = bitcoinjs_lib_1.networks.bitcoin }) => {
        return (0, keyExpressions_1.parseKeyExpression)({
            keyExpression,
            network,
            ...(typeof isSegwit === 'boolean' ? { isSegwit } : {}),
            ...(typeof isTaproot === 'boolean' ? { isTaproot } : {}),
            ECPair,
            BIP32
        });
    };
    /**
     * @hidden
     * To be removed in v3.0 and replaced by the version with the signature that
     * does not accept descriptors
     */
    function expand({ descriptor, expression, index, checksumRequired = false, network = bitcoinjs_lib_1.networks.bitcoin, allowMiniscriptInP2SH = false }) {
        if (descriptor && expression)
            throw new Error(`expression param has been deprecated`);
        descriptor = descriptor || expression;
        if (!descriptor)
            throw new Error(`descriptor not provided`);
        let expandedExpression;
        let miniscript;
        let expansionMap;
        let isSegwit;
        let isTaproot;
        let expandedMiniscript;
        let payment;
        let witnessScript;
        let redeemScript;
        const isRanged = descriptor.indexOf('*') !== -1;
        if (index !== undefined)
            if (!Number.isInteger(index) || index < 0)
                throw new Error(`Error: invalid index ${index}`);
        //Verify and remove checksum (if exists) and
        //particularize range descriptor for index (if desc is range descriptor)
        const canonicalExpression = evaluate({
            descriptor,
            ...(index !== undefined ? { index } : {}),
            checksumRequired
        });
        const isCanonicalRanged = canonicalExpression.indexOf('*') !== -1;
        //addr(ADDR)
        if (canonicalExpression.match(RE.reAddrAnchored)) {
            if (isRanged)
                throw new Error(`Error: addr() cannot be ranged`);
            const matchedAddress = canonicalExpression.match(RE.reAddrAnchored)?.[1]; //[1]-> whatever is found addr(->HERE<-)
            if (!matchedAddress)
                throw new Error(`Error: could not get an address in ${descriptor}`);
            let output;
            try {
                output = bitcoinjs_lib_1.address.toOutputScript(matchedAddress, network);
            }
            catch (e) {
                throw new Error(`Error: invalid address ${matchedAddress}`);
            }
            try {
                payment = p2pkh({ output, network });
                isSegwit = false;
                isTaproot = false;
            }
            catch (e) { }
            try {
                payment = p2sh({ output, network });
                // It assumes that an addr(SH_ADDRESS) is always a add(SH_WPKH) address
                isSegwit = true;
                isTaproot = false;
            }
            catch (e) { }
            try {
                payment = p2wpkh({ output, network });
                isSegwit = true;
                isTaproot = false;
            }
            catch (e) { }
            try {
                payment = p2wsh({ output, network });
                isSegwit = true;
                isTaproot = false;
            }
            catch (e) { }
            try {
                payment = p2tr({ output, network });
                isSegwit = true;
                isTaproot = true;
            }
            catch (e) { }
            if (!payment) {
                throw new Error(`Error: invalid address ${matchedAddress}`);
            }
        }
        //pk(KEY)
        else if (canonicalExpression.match(RE.rePkAnchored)) {
            isSegwit = false;
            isTaproot = false;
            const keyExpression = canonicalExpression.match(RE.reNonSegwitKeyExp)?.[0];
            if (!keyExpression)
                throw new Error(`Error: keyExpression could not me extracted`);
            if (canonicalExpression !== `pk(${keyExpression})`)
                throw new Error(`Error: invalid expression ${descriptor}`);
            expandedExpression = 'pk(@0)';
            const pKE = parseKeyExpression({ keyExpression, network, isSegwit });
            expansionMap = { '@0': pKE };
            if (!isCanonicalRanged) {
                const pubkey = pKE.pubkey;
                //Note there exists no address for p2pk, but we can still use the script
                if (!pubkey)
                    throw new Error(`Error: could not extract a pubkey from ${descriptor}`);
                payment = p2pk({ pubkey, network });
            }
        }
        //pkh(KEY) - legacy
        else if (canonicalExpression.match(RE.rePkhAnchored)) {
            isSegwit = false;
            isTaproot = false;
            const keyExpression = canonicalExpression.match(RE.reNonSegwitKeyExp)?.[0];
            if (!keyExpression)
                throw new Error(`Error: keyExpression could not me extracted`);
            if (canonicalExpression !== `pkh(${keyExpression})`)
                throw new Error(`Error: invalid expression ${descriptor}`);
            expandedExpression = 'pkh(@0)';
            const pKE = parseKeyExpression({ keyExpression, network, isSegwit });
            expansionMap = { '@0': pKE };
            if (!isCanonicalRanged) {
                const pubkey = pKE.pubkey;
                if (!pubkey)
                    throw new Error(`Error: could not extract a pubkey from ${descriptor}`);
                payment = p2pkh({ pubkey, network });
            }
        }
        //sh(wpkh(KEY)) - nested segwit
        else if (canonicalExpression.match(RE.reShWpkhAnchored)) {
            isSegwit = true;
            isTaproot = false;
            const keyExpression = canonicalExpression.match(RE.reSegwitKeyExp)?.[0];
            if (!keyExpression)
                throw new Error(`Error: keyExpression could not me extracted`);
            if (canonicalExpression !== `sh(wpkh(${keyExpression}))`)
                throw new Error(`Error: invalid expression ${descriptor}`);
            expandedExpression = 'sh(wpkh(@0))';
            const pKE = parseKeyExpression({ keyExpression, network, isSegwit });
            expansionMap = { '@0': pKE };
            if (!isCanonicalRanged) {
                const pubkey = pKE.pubkey;
                if (!pubkey)
                    throw new Error(`Error: could not extract a pubkey from ${descriptor}`);
                payment = p2sh({ redeem: p2wpkh({ pubkey, network }), network });
                redeemScript = payment.redeem?.output;
                if (!redeemScript)
                    throw new Error(`Error: could not calculate redeemScript for ${descriptor}`);
            }
        }
        //wpkh(KEY) - native segwit
        else if (canonicalExpression.match(RE.reWpkhAnchored)) {
            isSegwit = true;
            isTaproot = false;
            const keyExpression = canonicalExpression.match(RE.reSegwitKeyExp)?.[0];
            if (!keyExpression)
                throw new Error(`Error: keyExpression could not me extracted`);
            if (canonicalExpression !== `wpkh(${keyExpression})`)
                throw new Error(`Error: invalid expression ${descriptor}`);
            expandedExpression = 'wpkh(@0)';
            const pKE = parseKeyExpression({ keyExpression, network, isSegwit });
            expansionMap = { '@0': pKE };
            if (!isCanonicalRanged) {
                const pubkey = pKE.pubkey;
                if (!pubkey)
                    throw new Error(`Error: could not extract a pubkey from ${descriptor}`);
                payment = p2wpkh({ pubkey, network });
            }
        }
        //sh(wsh(miniscript))
        else if (canonicalExpression.match(RE.reShWshMiniscriptAnchored)) {
            isSegwit = true;
            isTaproot = false;
            miniscript = canonicalExpression.match(RE.reShWshMiniscriptAnchored)?.[1]; //[1]-> whatever is found sh(wsh(->HERE<-))
            if (!miniscript)
                throw new Error(`Error: could not get miniscript in ${descriptor}`);
            ({ expandedMiniscript, expansionMap } = expandMiniscript({
                miniscript,
                isSegwit,
                network
            }));
            expandedExpression = `sh(wsh(${expandedMiniscript}))`;
            if (!isCanonicalRanged) {
                const script = (0, miniscript_1.miniscript2Script)({ expandedMiniscript, expansionMap });
                witnessScript = script;
                if (script.byteLength > MAX_STANDARD_P2WSH_SCRIPT_SIZE) {
                    throw new Error(`Error: script is too large, ${script.byteLength} bytes is larger than ${MAX_STANDARD_P2WSH_SCRIPT_SIZE} bytes`);
                }
                const nonPushOnlyOps = countNonPushOnlyOPs(script);
                if (nonPushOnlyOps > MAX_OPS_PER_SCRIPT) {
                    throw new Error(`Error: too many non-push ops, ${nonPushOnlyOps} non-push ops is larger than ${MAX_OPS_PER_SCRIPT}`);
                }
                payment = p2sh({
                    redeem: p2wsh({ redeem: { output: script, network }, network }),
                    network
                });
                redeemScript = payment.redeem?.output;
                if (!redeemScript)
                    throw new Error(`Error: could not calculate redeemScript for ${descriptor}`);
            }
        }
        //sh(miniscript)
        else if (canonicalExpression.match(RE.reShMiniscriptAnchored)) {
            //isSegwit false because we know it's a P2SH of a miniscript and not a
            //P2SH that embeds a witness payment.
            isSegwit = false;
            isTaproot = false;
            miniscript = canonicalExpression.match(RE.reShMiniscriptAnchored)?.[1]; //[1]-> whatever is found sh(->HERE<-)
            if (!miniscript)
                throw new Error(`Error: could not get miniscript in ${descriptor}`);
            if (allowMiniscriptInP2SH === false &&
                //These top-level expressions within sh are allowed within sh.
                //They can be parsed with miniscript2Script, but first we must make sure
                //that other expressions are not accepted (unless forced with allowMiniscriptInP2SH).
                miniscript.search(/^(pk\(|pkh\(|wpkh\(|combo\(|multi\(|sortedmulti\(|multi_a\(|sortedmulti_a\()/) !== 0) {
                throw new Error(`Error: Miniscript expressions can only be used in wsh`);
            }
            ({ expandedMiniscript, expansionMap } = expandMiniscript({
                miniscript,
                isSegwit,
                network
            }));
            expandedExpression = `sh(${expandedMiniscript})`;
            if (!isCanonicalRanged) {
                const script = (0, miniscript_1.miniscript2Script)({ expandedMiniscript, expansionMap });
                redeemScript = script;
                if (script.byteLength > MAX_SCRIPT_ELEMENT_SIZE) {
                    throw new Error(`Error: P2SH script is too large, ${script.byteLength} bytes is larger than ${MAX_SCRIPT_ELEMENT_SIZE} bytes`);
                }
                const nonPushOnlyOps = countNonPushOnlyOPs(script);
                if (nonPushOnlyOps > MAX_OPS_PER_SCRIPT) {
                    throw new Error(`Error: too many non-push ops, ${nonPushOnlyOps} non-push ops is larger than ${MAX_OPS_PER_SCRIPT}`);
                }
                payment = p2sh({ redeem: { output: script, network }, network });
            }
        }
        //wsh(miniscript)
        else if (canonicalExpression.match(RE.reWshMiniscriptAnchored)) {
            isSegwit = true;
            isTaproot = false;
            miniscript = canonicalExpression.match(RE.reWshMiniscriptAnchored)?.[1]; //[1]-> whatever is found wsh(->HERE<-)
            if (!miniscript)
                throw new Error(`Error: could not get miniscript in ${descriptor}`);
            ({ expandedMiniscript, expansionMap } = expandMiniscript({
                miniscript,
                isSegwit,
                network
            }));
            expandedExpression = `wsh(${expandedMiniscript})`;
            if (!isCanonicalRanged) {
                const script = (0, miniscript_1.miniscript2Script)({ expandedMiniscript, expansionMap });
                witnessScript = script;
                if (script.byteLength > MAX_STANDARD_P2WSH_SCRIPT_SIZE) {
                    throw new Error(`Error: script is too large, ${script.byteLength} bytes is larger than ${MAX_STANDARD_P2WSH_SCRIPT_SIZE} bytes`);
                }
                const nonPushOnlyOps = countNonPushOnlyOPs(script);
                if (nonPushOnlyOps > MAX_OPS_PER_SCRIPT) {
                    throw new Error(`Error: too many non-push ops, ${nonPushOnlyOps} non-push ops is larger than ${MAX_OPS_PER_SCRIPT}`);
                }
                payment = p2wsh({ redeem: { output: script, network }, network });
            }
        }
        //tr(KEY) - taproot - TODO: tr(KEY,TREE) not yet supported
        else if (canonicalExpression.match(RE.reTrSingleKeyAnchored)) {
            isSegwit = true;
            isTaproot = true;
            const keyExpression = canonicalExpression.match(RE.reTaprootKeyExp)?.[0];
            if (!keyExpression)
                throw new Error(`Error: keyExpression could not me extracted`);
            if (canonicalExpression !== `tr(${keyExpression})`)
                throw new Error(`Error: invalid expression ${expression}`);
            expandedExpression = 'tr(@0)';
            const pKE = parseKeyExpression({
                keyExpression,
                network,
                isSegwit,
                isTaproot
            });
            expansionMap = { '@0': pKE };
            if (!isCanonicalRanged) {
                const pubkey = pKE.pubkey;
                if (!pubkey)
                    throw new Error(`Error: could not extract a pubkey from ${expression}`);
                payment = p2tr({ internalPubkey: pubkey, network });
                //console.log('TRACE', {
                //  pKE,
                //  pubkey: pubkey?.toString('hex'),
                //  payment,
                //  paymentPubKey: payment.pubkey
                //});
            }
        }
        else {
            throw new Error(`Error: Could not parse descriptor ${descriptor}`);
        }
        return {
            ...(payment !== undefined ? { payment } : {}),
            ...(expandedExpression !== undefined ? { expandedExpression } : {}),
            ...(miniscript !== undefined ? { miniscript } : {}),
            ...(expansionMap !== undefined ? { expansionMap } : {}),
            ...(isSegwit !== undefined ? { isSegwit } : {}),
            ...(isTaproot !== undefined ? { isTaproot } : {}),
            ...(expandedMiniscript !== undefined ? { expandedMiniscript } : {}),
            ...(redeemScript !== undefined ? { redeemScript } : {}),
            ...(witnessScript !== undefined ? { witnessScript } : {}),
            isRanged,
            canonicalExpression
        };
    }
    /**
     * Expand a miniscript to a generalized form using variables instead of key
     * expressions. Variables will be of this form: @0, @1, ...
     * This is done so that it can be compiled with compileMiniscript and
     * satisfied with satisfier.
     * Also compute pubkeys from descriptors to use them later.
     */
    function expandMiniscript({ miniscript, isSegwit, network = bitcoinjs_lib_1.networks.bitcoin }) {
        return (0, miniscript_1.expandMiniscript)({
            miniscript,
            isSegwit,
            isTaproot: false,
            network,
            BIP32,
            ECPair
        });
    }
    /**
     * The `Output` class is the central component for managing descriptors.
     * It facilitates the creation of outputs to receive funds and enables the
     * signing and finalization of PSBTs (Partially Signed Bitcoin Transactions)
     * for spending UTXOs (Unspent Transaction Outputs).
     */
    class Output {
        /**
         * @param options
         * @throws {Error} - when descriptor is invalid
         */
        constructor({ descriptor, index, checksumRequired = false, allowMiniscriptInP2SH = false, network = bitcoinjs_lib_1.networks.bitcoin, preimages = [], signersPubKeys }) {
            _Output_instances.add(this);
            _Output_payment.set(this, void 0);
            _Output_preimages.set(this, []);
            _Output_signersPubKeys.set(this, void 0);
            _Output_miniscript.set(this, void 0);
            _Output_witnessScript.set(this, void 0);
            _Output_redeemScript.set(this, void 0);
            //isSegwit true if witnesses are needed to the spend coins sent to this descriptor.
            //may be unset because we may get addr(P2SH) which we don't know if they have segwit.
            _Output_isSegwit.set(this, void 0);
            _Output_isTaproot.set(this, void 0);
            _Output_expandedExpression.set(this, void 0);
            _Output_expandedMiniscript.set(this, void 0);
            _Output_expansionMap.set(this, void 0);
            _Output_network.set(this, void 0);
            __classPrivateFieldSet(this, _Output_network, network, "f");
            __classPrivateFieldSet(this, _Output_preimages, preimages, "f");
            if (typeof descriptor !== 'string')
                throw new Error(`Error: invalid descriptor type`);
            const expandedResult = expand({
                descriptor,
                ...(index !== undefined ? { index } : {}),
                checksumRequired,
                network,
                allowMiniscriptInP2SH
            });
            if (expandedResult.isRanged && index === undefined)
                throw new Error(`Error: index was not provided for ranged descriptor`);
            if (!expandedResult.payment)
                throw new Error(`Error: could not extract a payment from ${descriptor}`);
            __classPrivateFieldSet(this, _Output_payment, expandedResult.payment, "f");
            if (expandedResult.expandedExpression !== undefined)
                __classPrivateFieldSet(this, _Output_expandedExpression, expandedResult.expandedExpression, "f");
            if (expandedResult.miniscript !== undefined)
                __classPrivateFieldSet(this, _Output_miniscript, expandedResult.miniscript, "f");
            if (expandedResult.expansionMap !== undefined)
                __classPrivateFieldSet(this, _Output_expansionMap, expandedResult.expansionMap, "f");
            if (expandedResult.isSegwit !== undefined)
                __classPrivateFieldSet(this, _Output_isSegwit, expandedResult.isSegwit, "f");
            if (expandedResult.isTaproot !== undefined)
                __classPrivateFieldSet(this, _Output_isTaproot, expandedResult.isTaproot, "f");
            if (expandedResult.expandedMiniscript !== undefined)
                __classPrivateFieldSet(this, _Output_expandedMiniscript, expandedResult.expandedMiniscript, "f");
            if (expandedResult.redeemScript !== undefined)
                __classPrivateFieldSet(this, _Output_redeemScript, expandedResult.redeemScript, "f");
            if (expandedResult.witnessScript !== undefined)
                __classPrivateFieldSet(this, _Output_witnessScript, expandedResult.witnessScript, "f");
            if (signersPubKeys) {
                __classPrivateFieldSet(this, _Output_signersPubKeys, signersPubKeys, "f");
            }
            else {
                if (__classPrivateFieldGet(this, _Output_expansionMap, "f")) {
                    __classPrivateFieldSet(this, _Output_signersPubKeys, Object.values(__classPrivateFieldGet(this, _Output_expansionMap, "f")).map(keyInfo => {
                        const pubkey = keyInfo.pubkey;
                        if (!pubkey)
                            throw new Error(`Error: could not extract a pubkey from ${descriptor}`);
                        return pubkey;
                    }), "f");
                }
                else {
                    //We should only miss expansionMap in addr() expressions:
                    if (!expandedResult.canonicalExpression.match(RE.reAddrAnchored)) {
                        throw new Error(`Error: expansionMap not available for expression ${descriptor} that is not an address`);
                    }
                    __classPrivateFieldSet(this, _Output_signersPubKeys, [this.getScriptPubKey()], "f");
                }
            }
            this.getSequence = (0, lodash_memoize_1.default)(this.getSequence);
            this.getLockTime = (0, lodash_memoize_1.default)(this.getLockTime);
            const getSignaturesKey = (signatures) => signatures === 'DANGEROUSLY_USE_FAKE_SIGNATURES'
                ? signatures
                : signatures
                    .map(s => `${s.pubkey.toString('hex')}-${s.signature.toString('hex')}`)
                    .join('|');
            this.getScriptSatisfaction = (0, lodash_memoize_1.default)(this.getScriptSatisfaction, 
            // resolver function:
            getSignaturesKey);
            this.guessOutput = (0, lodash_memoize_1.default)(this.guessOutput);
            this.inputWeight = (0, lodash_memoize_1.default)(this.inputWeight, 
            // resolver function:
            (isSegwitTx, signatures) => {
                const segwitKey = isSegwitTx ? 'segwit' : 'non-segwit';
                const signaturesKey = getSignaturesKey(signatures);
                return `${segwitKey}-${signaturesKey}`;
            });
            this.outputWeight = (0, lodash_memoize_1.default)(this.outputWeight);
        }
        /**
         * Creates and returns an instance of bitcoinjs-lib
         * [`Payment`](https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/payments/index.ts)'s interface with the `scriptPubKey` of this `Output`.
         */
        getPayment() {
            return __classPrivateFieldGet(this, _Output_payment, "f");
        }
        /**
         * Returns the Bitcoin Address of this `Output`.
         */
        getAddress() {
            if (!__classPrivateFieldGet(this, _Output_payment, "f").address)
                throw new Error(`Error: could extract an address from the payment`);
            return __classPrivateFieldGet(this, _Output_payment, "f").address;
        }
        /**
         * Returns this `Output`'s scriptPubKey.
         */
        getScriptPubKey() {
            if (!__classPrivateFieldGet(this, _Output_payment, "f").output)
                throw new Error(`Error: could extract output.script from the payment`);
            return __classPrivateFieldGet(this, _Output_payment, "f").output;
        }
        /**
         * Returns the compiled Script Satisfaction if this `Output` was created
         * using a miniscript-based descriptor.
         *
         * The Satisfaction is the unlocking script that fulfills
         * (satisfies) this `Output` and it is derived using the Safisfier algorithm
         * [described here](https://bitcoin.sipa.be/miniscript/).
         *
         * Important: As mentioned above, note that this function only applies to
         * miniscript descriptors.
         */
        getScriptSatisfaction(
        /**
         * An array with all the signatures needed to
         * build the Satisfaction of this miniscript-based `Output`.
         *
         * `signatures` must be passed using this format (pairs of `pubKey/signature`):
         * `interface PartialSig { pubkey: Buffer; signature: Buffer; }`
         *
         *  * Alternatively, if you do not have the signatures, you can use the option
         * `'DANGEROUSLY_USE_FAKE_SIGNATURES'`. This will generate script satisfactions
         * using 72-byte zero-padded signatures. While this can be useful in
         * modules like coinselector that require estimating transaction size before
         * signing, it is critical to understand the risks:
         * - Using this option generales invalid unlocking scripts.
         * - It should NEVER be used with real transactions.
         * - Its primary use is for testing and size estimation purposes only.
         *
         * ⚠️ Warning: Misuse of 'DANGEROUSLY_USE_FAKE_SIGNATURES' can lead to security
         * vulnerabilities, including but not limited to invalid transaction generation.
         * Ensure you fully understand the implications before use.
         *
         */
        signatures) {
            if (signatures === 'DANGEROUSLY_USE_FAKE_SIGNATURES')
                signatures = __classPrivateFieldGet(this, _Output_signersPubKeys, "f").map(pubkey => ({
                    pubkey,
                    // https://transactionfee.info/charts/bitcoin-script-ecdsa-length/
                    signature: Buffer.alloc(72, 0)
                }));
            const miniscript = __classPrivateFieldGet(this, _Output_miniscript, "f");
            const expandedMiniscript = __classPrivateFieldGet(this, _Output_expandedMiniscript, "f");
            const expansionMap = __classPrivateFieldGet(this, _Output_expansionMap, "f");
            if (miniscript === undefined ||
                expandedMiniscript === undefined ||
                expansionMap === undefined)
                throw new Error(`Error: cannot get satisfaction from not expanded miniscript ${miniscript}`);
            //Note that we pass the nLockTime and nSequence that is deduced
            //using preimages and signersPubKeys.
            //satisfyMiniscript will make sure
            //that the actual solution given, using real signatures, still meets the
            //same nLockTime and nSequence constraints
            const scriptSatisfaction = (0, miniscript_1.satisfyMiniscript)({
                expandedMiniscript,
                expansionMap,
                signatures,
                preimages: __classPrivateFieldGet(this, _Output_preimages, "f"),
                //Here we pass the TimeConstraints obtained using signersPubKeys to
                //verify that the solutions found using the final signatures have not
                //changed
                timeConstraints: {
                    nLockTime: this.getLockTime(),
                    nSequence: this.getSequence()
                }
            }).scriptSatisfaction;
            if (!scriptSatisfaction)
                throw new Error(`Error: could not produce a valid satisfaction`);
            return scriptSatisfaction;
        }
        /**
         * Gets the nSequence required to fulfill this `Output`.
         */
        getSequence() {
            return __classPrivateFieldGet(this, _Output_instances, "m", _Output_getTimeConstraints).call(this)?.nSequence;
        }
        /**
         * Gets the nLockTime required to fulfill this `Output`.
         */
        getLockTime() {
            return __classPrivateFieldGet(this, _Output_instances, "m", _Output_getTimeConstraints).call(this)?.nLockTime;
        }
        /**
         * Gets the witnessScript required to fulfill this `Output`. Only applies to
         * Segwit outputs.
         */
        getWitnessScript() {
            return __classPrivateFieldGet(this, _Output_witnessScript, "f");
        }
        /**
         * Gets the redeemScript required to fullfill this `Output`. Only applies to
         * SH outputs: sh(wpkh), sh(wsh), sh(lockingScript).
         */
        getRedeemScript() {
            return __classPrivateFieldGet(this, _Output_redeemScript, "f");
        }
        /**
         * Gets the bitcoinjs-lib [`network`](https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/networks.ts) used to create this `Output`.
         */
        getNetwork() {
            return __classPrivateFieldGet(this, _Output_network, "f");
        }
        /**
         * Whether this `Output` is Segwit.
         *
         * *NOTE:* When the descriptor in an input is `addr(address)`, it is assumed
         * that any `addr(SH_TYPE_ADDRESS)` is in fact a Segwit `SH_WPKH`
         * (Script Hash-Witness Public Key Hash).
         * For inputs using arbitrary scripts (not standard addresses),
         * use a descriptor in the format `sh(MINISCRIPT)`.
         *
         */
        isSegwit() {
            return __classPrivateFieldGet(this, _Output_isSegwit, "f");
        }
        /**
         * Whether this `Output` is Taproot.
         */
        isTaproot() {
            return __classPrivateFieldGet(this, _Output_isTaproot, "f");
        }
        /**
         * Attempts to determine the type of output script by testing it against
         * various payment types.
         *
         * This method tries to identify if the output is one of the following types:
         * - P2SH (Pay to Script Hash)
         * - P2WSH (Pay to Witness Script Hash)
         * - P2WPKH (Pay to Witness Public Key Hash)
         * - P2PKH (Pay to Public Key Hash)
         * - P2TR (Pay to Taproot)
         *
         * @returns An object { isPKH: boolean; isWPKH: boolean; isSH: boolean; isWSH: boolean; isTR: boolean;}
         * with boolean properties indicating the detected output type
         */
        guessOutput() {
            function guessSH(output) {
                try {
                    bitcoinjs_lib_1.payments.p2sh({ output });
                    return true;
                }
                catch (err) {
                    return false;
                }
            }
            function guessWSH(output) {
                try {
                    bitcoinjs_lib_1.payments.p2wsh({ output });
                    return true;
                }
                catch (err) {
                    return false;
                }
            }
            function guessWPKH(output) {
                try {
                    bitcoinjs_lib_1.payments.p2wpkh({ output });
                    return true;
                }
                catch (err) {
                    return false;
                }
            }
            function guessPKH(output) {
                try {
                    bitcoinjs_lib_1.payments.p2pkh({ output });
                    return true;
                }
                catch (err) {
                    return false;
                }
            }
            function guessTR(output) {
                try {
                    bitcoinjs_lib_1.payments.p2tr({ output });
                    return true;
                }
                catch (err) {
                    return false;
                }
            }
            const isPKH = guessPKH(this.getScriptPubKey());
            const isWPKH = guessWPKH(this.getScriptPubKey());
            const isSH = guessSH(this.getScriptPubKey());
            const isWSH = guessWSH(this.getScriptPubKey());
            const isTR = guessTR(this.getScriptPubKey());
            if ([isPKH, isWPKH, isSH, isWSH, isTR].filter(Boolean).length > 1)
                throw new Error('Cannot have multiple output types.');
            return { isPKH, isWPKH, isSH, isWSH, isTR };
        }
        // References for inputWeight & outputWeight:
        // https://gist.github.com/junderw/b43af3253ea5865ed52cb51c200ac19c
        // https://bitcoinops.org/en/tools/calc-size/
        // Look for byteLength: https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/transaction.ts
        // https://github.com/bitcoinjs/coinselect/blob/master/utils.js
        // https://bitcoin.stackexchange.com/questions/111395/what-is-the-weight-of-a-p2tr-input
        /**
         * Computes the Weight Unit contributions of this Output as if it were the
         * input in a tx.
         *
         * *NOTE:* When the descriptor in an input is `addr(address)`, it is assumed
         * that any `addr(SH_TYPE_ADDRESS)` is in fact a Segwit `SH_WPKH`
         * (Script Hash-Witness Public Key Hash).
         *, Also any `addr(SINGLE_KEY_ADDRESS)` * is assumed to be a single key Taproot
         * address (like those defined in BIP86).
         * For inputs using arbitrary scripts (not standard addresses),
         * use a descriptor in the format `sh(MINISCRIPT)` or `tr(MINISCRIPT)`.
         * Note however that tr(MINISCRIPT) is not yet supported for non-single-key
         * expressions.
         */
        inputWeight(
        /**
         * Indicates if the transaction is a Segwit transaction.
         * If a transaction isSegwitTx, a single byte is then also required for
         * non-witness inputs to encode the length of the empty witness stack:
         * encodeLength(0) + 0 = 1
         * Read more:
         * https://gist.github.com/junderw/b43af3253ea5865ed52cb51c200ac19c?permalink_comment_id=4760512#gistcomment-4760512
         */
        isSegwitTx, 
        /*
         *  Array of `PartialSig`. Each `PartialSig` includes
         *  a public key and its corresponding signature. This parameter
         *  enables the accurate calculation of signature sizes for ECDSA.
         *  Pass 'DANGEROUSLY_USE_FAKE_SIGNATURES' to assume 72 bytes in length
         *  for ECDSA.
         *  Schnorr signatures are always 64 bytes.
         *  Mainly used for testing.
         */
        signatures) {
            if (this.isSegwit() && !isSegwitTx)
                throw new Error(`a tx is segwit if at least one input is segwit`);
            //expand any miniscript-based descriptor. If not miniscript-based, then it's
            //an addr() descriptor. For those, we can only guess their type.
            const expansion = this.expand().expandedExpression;
            const { isPKH, isWPKH, isSH, isTR } = this.guessOutput();
            const errorMsg = `Input type not implemented. Currently supported: pkh(KEY), wpkh(KEY), tr(KEY), \
sh(wpkh(KEY)), sh(wsh(MINISCRIPT)), sh(MINISCRIPT), wsh(MINISCRIPT), \
addr(PKH_ADDRESS), addr(WPKH_ADDRESS), addr(SH_WPKH_ADDRESS), addr(SINGLE_KEY_ADDRESS). \
expansion=${expansion}, isPKH=${isPKH}, isWPKH=${isWPKH}, isSH=${isSH}, isTR=${isTR}.`;
            if (!expansion && !isPKH && !isWPKH && !isSH && !isTR)
                throw new Error(errorMsg);
            const firstSignature = signatures && typeof signatures[0] === 'object'
                ? signatures[0]
                : 'DANGEROUSLY_USE_FAKE_SIGNATURES';
            if (expansion ? expansion.startsWith('pkh(') : isPKH) {
                return (
                // Non-segwit: (txid:32) + (vout:4) + (sequence:4) + (script_len:1) + (sig:73) + (pubkey:34)
                (32 + 4 + 4 + 1 + signatureSize(firstSignature) + 34) * 4 +
                    //Segwit:
                    (isSegwitTx ? 1 : 0));
            }
            else if (expansion ? expansion.startsWith('wpkh(') : isWPKH) {
                if (!isSegwitTx)
                    throw new Error('Should be SegwitTx');
                return (
                // Non-segwit: (txid:32) + (vout:4) + (sequence:4) + (script_len:1)
                41 * 4 +
                    // Segwit: (push_count:1) + (sig:73) + (pubkey:34)
                    (1 + signatureSize(firstSignature) + 34));
            }
            else if (expansion ? expansion.startsWith('sh(wpkh(') : isSH) {
                if (!isSegwitTx)
                    throw new Error('Should be SegwitTx');
                return (
                // Non-segwit: (txid:32) + (vout:4) + (sequence:4) + (script_len:1) + (p2wpkh:23)
                //  -> p2wpkh_script: OP_0 OP_PUSH20 <public_key_hash>
                //  -> p2wpkh: (script_len:1) + (script:22)
                64 * 4 +
                    // Segwit: (push_count:1) + (sig:73) + (pubkey:34)
                    (1 + signatureSize(firstSignature) + 34));
            }
            else if (expansion?.startsWith('sh(wsh(')) {
                if (!isSegwitTx)
                    throw new Error('Should be SegwitTx');
                const witnessScript = this.getWitnessScript();
                if (!witnessScript)
                    throw new Error('sh(wsh) must provide witnessScript');
                const payment = bitcoinjs_lib_1.payments.p2sh({
                    redeem: bitcoinjs_lib_1.payments.p2wsh({
                        redeem: {
                            input: this.getScriptSatisfaction(signatures || 'DANGEROUSLY_USE_FAKE_SIGNATURES'),
                            output: witnessScript
                        }
                    })
                });
                if (!payment || !payment.input || !payment.witness)
                    throw new Error('Could not create payment');
                return (
                //Non-segwit
                4 * (40 + varSliceSize(payment.input)) +
                    //Segwit
                    vectorSize(payment.witness));
            }
            else if (expansion?.startsWith('sh(')) {
                const redeemScript = this.getRedeemScript();
                if (!redeemScript)
                    throw new Error('sh() must provide redeemScript');
                const payment = bitcoinjs_lib_1.payments.p2sh({
                    redeem: {
                        input: this.getScriptSatisfaction(signatures || 'DANGEROUSLY_USE_FAKE_SIGNATURES'),
                        output: redeemScript
                    }
                });
                if (!payment || !payment.input)
                    throw new Error('Could not create payment');
                if (payment.witness?.length)
                    throw new Error('A legacy p2sh payment should not cointain a witness');
                return (
                //Non-segwit
                4 * (40 + varSliceSize(payment.input)) +
                    //Segwit:
                    (isSegwitTx ? 1 : 0));
            }
            else if (expansion?.startsWith('wsh(')) {
                const witnessScript = this.getWitnessScript();
                if (!witnessScript)
                    throw new Error('wsh must provide witnessScript');
                const payment = bitcoinjs_lib_1.payments.p2wsh({
                    redeem: {
                        input: this.getScriptSatisfaction(signatures || 'DANGEROUSLY_USE_FAKE_SIGNATURES'),
                        output: witnessScript
                    }
                });
                if (!payment || !payment.input || !payment.witness)
                    throw new Error('Could not create payment');
                return (
                //Non-segwit
                4 * (40 + varSliceSize(payment.input)) +
                    //Segwit
                    vectorSize(payment.witness));
                //when addr(SINGLE_KEY_ADDRESS) or tr(KEY) (single key):
                //TODO: only single-key taproot outputs currently supported
            }
            else if (isTR && (!expansion || expansion === 'tr(@0)')) {
                if (!isSegwitTx)
                    throw new Error('Should be SegwitTx');
                return (
                // Non-segwit: (txid:32) + (vout:4) + (sequence:4) + (script_len:1)
                41 * 4 +
                    // Segwit: (push_count:1) + (sig_length(1) + schnorr_sig(64): 65)
                    (1 + 65));
            }
            else {
                throw new Error(errorMsg);
            }
        }
        /**
         * Computes the Weight Unit contributions of this Output as if it were the
         * output in a tx.
         */
        outputWeight() {
            //expand any miniscript-based descriptor. If not miniscript-based, then it's
            //an addr() descriptor. For those, we can only guess their type.
            const { isPKH, isWPKH, isSH, isWSH, isTR } = this.guessOutput();
            const errorMsg = `Output type not implemented. Currently supported: pkh=${isPKH}, wpkh=${isWPKH}, tr=${isTR}, sh=${isSH} and wsh=${isWSH}.`;
            if (isPKH) {
                // (p2pkh:26) + (amount:8)
                return 34 * 4;
            }
            else if (isWPKH) {
                // (p2wpkh:23) + (amount:8)
                return 31 * 4;
            }
            else if (isSH) {
                // (p2sh:24) + (amount:8)
                return 32 * 4;
            }
            else if (isWSH) {
                // (p2wsh:35) + (amount:8)
                return 43 * 4;
            }
            else if (isTR) {
                // (script_pubKey_length:1) + (p2t2(OP_1 OP_PUSH32 <schnorr_public_key>):34) + (amount:8)
                return 43 * 4;
            }
            else {
                throw new Error(errorMsg);
            }
        }
        /** @deprecated - Use updatePsbtAsInput instead
         * @hidden
         */
        updatePsbt(params) {
            this.updatePsbtAsInput(params);
            return params.psbt.data.inputs.length - 1;
        }
        /**
         * Sets this output as an input of the provided `psbt` and updates the
         * `psbt` locktime if required by the descriptor.
         *
         * `psbt` and `vout` are mandatory. Include `txHex` as well. The pair
         * `vout` and `txHex` define the transaction and output number this instance
         * pertains to.
         *
         * Though not advised, for Segwit inputs you can pass `txId` and `value`
         * in lieu of `txHex`. If doing so, ensure `value` accuracy to avoid
         * potential fee attacks -
         * [See this issue](https://github.com/bitcoinjs/bitcoinjs-lib/issues/1625).
         *
         * Note: Hardware wallets need the [full `txHex` for Segwit](https://blog.trezor.io/details-of-firmware-updates-for-trezor-one-version-1-9-1-and-trezor-model-t-version-2-3-1-1eba8f60f2dd).
         *
         * When unsure, always use `txHex`, and skip `txId` and `value` for safety.
         *
         * Use `rbf` to mark whether this tx can be replaced with another with
         * higher fee while being in the mempool. Note that a tx will automatically
         * be marked as replacable if a single input requests it.
         * Note that any transaction using a relative timelock (nSequence < 0x80000000)
         * also falls within the RBF range (nSequence < 0xFFFFFFFE), making it
         * inherently replaceable. So don't set `rbf` to false if this is tx uses
         * relative time locks.
         *
         * @returns A finalizer function to be used after signing the `psbt`.
         * This function ensures that this input is properly finalized.
         * The finalizer has this signature:
         *
         * `( { psbt, validate = true } : { psbt: Psbt; validate: boolean | undefined } ) => void`
         *
         */
        updatePsbtAsInput({ psbt, txHex, txId, value, vout, //vector output index
        rbf = true }) {
            if (txHex === undefined) {
                console.warn(`Warning: missing txHex may allow fee attacks`);
            }
            const isSegwit = this.isSegwit();
            if (isSegwit === undefined) {
                //This should only happen when using addr() expressions
                throw new Error(`Error: could not determine whether this is a segwit descriptor`);
            }
            const isTaproot = this.isTaproot();
            if (isTaproot === undefined) {
                //This should only happen when using addr() expressions
                throw new Error(`Error: could not determine whether this is a taproot descriptor`);
            }
            const index = (0, psbt_1.updatePsbt)({
                psbt,
                vout,
                ...(txHex !== undefined ? { txHex } : {}),
                ...(txId !== undefined ? { txId } : {}),
                ...(value !== undefined ? { value } : {}),
                ...(isTaproot
                    ? { tapInternalKey: this.getPayment().internalPubkey }
                    : {}),
                sequence: this.getSequence(),
                locktime: this.getLockTime(),
                keysInfo: __classPrivateFieldGet(this, _Output_expansionMap, "f") ? Object.values(__classPrivateFieldGet(this, _Output_expansionMap, "f")) : [],
                scriptPubKey: this.getScriptPubKey(),
                isSegwit,
                witnessScript: this.getWitnessScript(),
                redeemScript: this.getRedeemScript(),
                rbf
            });
            const finalizer = ({ psbt, validate = true }) => this.finalizePsbtInput({ index, psbt, validate });
            return finalizer;
        }
        /**
         * Adds this output as an output of the provided `psbt` with the given
         * value.
         *
         * @param psbt - The Partially Signed Bitcoin Transaction.
         * @param value - The value for the output in satoshis.
         */
        updatePsbtAsOutput({ psbt, value }) {
            psbt.addOutput({ script: this.getScriptPubKey(), value });
        }
        /**
         * Finalizes a PSBT input by adding the necessary unlocking script that satisfies this `Output`'s
         * spending conditions.
         *
         * 🔴 IMPORTANT 🔴
         * It is STRONGLY RECOMMENDED to use the finalizer function returned by
         * {@link _Internal_.Output.updatePsbtAsInput | `updatePsbtAsInput`} instead
         * of calling this method directly.
         * This approach eliminates the need to manage the `Output` instance and the
         * input's index, simplifying the process.
         *
         * The `finalizePsbtInput` method completes a PSBT input by adding the
         * unlocking script (`scriptWitness` or `scriptSig`) that satisfies
         * this `Output`'s spending conditions. Bear in mind that both
         * `scriptSig` and `scriptWitness` incorporate signatures. As such, you
         * should complete all necessary signing operations before calling this
         * method.
         *
         * For each unspent output from a previous transaction that you're
         * referencing in a `psbt` as an input to be spent, apply this method as
         * follows: `output.finalizePsbtInput({ index, psbt })`.
         *
         * It's essential to specify the exact position (or `index`) of the input in
         * the `psbt` that references this unspent `Output`. This `index` should
         * align with the value returned by the `updatePsbtAsInput` method.
         * Note:
         * The `index` corresponds to the position of the input in the `psbt`.
         * To get this index, right after calling `updatePsbtAsInput()`, use:
         * `index = psbt.data.inputs.length - 1`.
         */
        finalizePsbtInput({ index, psbt, validate = true }) {
            if (validate &&
                !psbt.validateSignaturesOfInput(index, signatureValidator)) {
                throw new Error(`Error: invalid signatures on input ${index}`);
            }
            //An index must be passed since finding the index in the psbt cannot be
            //done:
            //Imagine the case where you received money twice to
            //the same miniscript-based address. You would have the same scriptPubKey,
            //same sequences, ... The descriptor does not store the hash of the previous
            //transaction since it is a general Descriptor object. Indices must be kept
            //out of the scope of this class and then passed.
            __classPrivateFieldGet(this, _Output_instances, "m", _Output_assertPsbtInput).call(this, { index, psbt });
            if (!__classPrivateFieldGet(this, _Output_miniscript, "f")) {
                //Use standard finalizers
                psbt.finalizeInput(index);
            }
            else {
                const signatures = psbt.data.inputs[index]?.partialSig;
                if (!signatures)
                    throw new Error(`Error: cannot finalize without signatures`);
                const scriptSatisfaction = this.getScriptSatisfaction(signatures);
                psbt.finalizeInput(index, (0, psbt_1.finalScriptsFuncFactory)(scriptSatisfaction, __classPrivateFieldGet(this, _Output_network, "f")));
            }
        }
        /**
         * Decomposes the descriptor used to form this `Output` into its elemental
         * parts. See {@link ExpansionMap ExpansionMap} for a detailed explanation.
         */
        expand() {
            return {
                ...(__classPrivateFieldGet(this, _Output_expandedExpression, "f") !== undefined
                    ? { expandedExpression: __classPrivateFieldGet(this, _Output_expandedExpression, "f") }
                    : {}),
                ...(__classPrivateFieldGet(this, _Output_miniscript, "f") !== undefined
                    ? { miniscript: __classPrivateFieldGet(this, _Output_miniscript, "f") }
                    : {}),
                ...(__classPrivateFieldGet(this, _Output_expandedMiniscript, "f") !== undefined
                    ? { expandedMiniscript: __classPrivateFieldGet(this, _Output_expandedMiniscript, "f") }
                    : {}),
                ...(__classPrivateFieldGet(this, _Output_expansionMap, "f") !== undefined
                    ? { expansionMap: __classPrivateFieldGet(this, _Output_expansionMap, "f") }
                    : {})
            };
        }
    }
    _Output_payment = new WeakMap(), _Output_preimages = new WeakMap(), _Output_signersPubKeys = new WeakMap(), _Output_miniscript = new WeakMap(), _Output_witnessScript = new WeakMap(), _Output_redeemScript = new WeakMap(), _Output_isSegwit = new WeakMap(), _Output_isTaproot = new WeakMap(), _Output_expandedExpression = new WeakMap(), _Output_expandedMiniscript = new WeakMap(), _Output_expansionMap = new WeakMap(), _Output_network = new WeakMap(), _Output_instances = new WeakSet(), _Output_getTimeConstraints = function _Output_getTimeConstraints() {
        const miniscript = __classPrivateFieldGet(this, _Output_miniscript, "f");
        const preimages = __classPrivateFieldGet(this, _Output_preimages, "f");
        const expandedMiniscript = __classPrivateFieldGet(this, _Output_expandedMiniscript, "f");
        const expansionMap = __classPrivateFieldGet(this, _Output_expansionMap, "f");
        const signersPubKeys = __classPrivateFieldGet(this, _Output_signersPubKeys, "f");
        //Create a method. solvePreimages to solve them.
        if (miniscript) {
            if (expandedMiniscript === undefined || expansionMap === undefined)
                throw new Error(`Error: cannot get time constraints from not expanded miniscript ${miniscript}`);
            //We create some fakeSignatures since we may not have them yet.
            //We only want to retrieve the nLockTime and nSequence of the satisfaction and
            //signatures don't matter
            const fakeSignatures = signersPubKeys.map(pubkey => ({
                pubkey,
                // https://transactionfee.info/charts/bitcoin-script-ecdsa-length/
                signature: Buffer.alloc(72, 0)
            }));
            const { nLockTime, nSequence } = (0, miniscript_1.satisfyMiniscript)({
                expandedMiniscript,
                expansionMap,
                signatures: fakeSignatures,
                preimages
            });
            return { nLockTime, nSequence };
        }
        else
            return undefined;
    }, _Output_assertPsbtInput = function _Output_assertPsbtInput({ psbt, index }) {
        const input = psbt.data.inputs[index];
        const txInput = psbt.txInputs[index];
        if (!input || !txInput)
            throw new Error(`Error: invalid input or txInput`);
        const { sequence: inputSequence, index: vout } = txInput;
        let scriptPubKey;
        if (input.witnessUtxo)
            scriptPubKey = input.witnessUtxo.script;
        else {
            if (!input.nonWitnessUtxo)
                throw new Error(`Error: input should have either witnessUtxo or nonWitnessUtxo`);
            const tx = bitcoinjs_lib_1.Transaction.fromBuffer(input.nonWitnessUtxo);
            const out = tx.outs[vout];
            if (!out)
                throw new Error(`Error: utxo should exist`);
            scriptPubKey = out.script;
        }
        const locktime = this.getLockTime() || 0;
        const sequence = this.getSequence();
        //We don't know whether the user opted for RBF or not. So check that
        //at least one of the 2 sequences matches.
        const sequenceNoRBF = sequence !== undefined
            ? sequence
            : locktime === 0
                ? 0xffffffff
                : 0xfffffffe;
        const sequenceRBF = sequence !== undefined ? sequence : 0xfffffffd;
        const eqBuffers = (buf1, buf2) => buf1 instanceof Buffer && buf2 instanceof Buffer
            ? Buffer.compare(buf1, buf2) === 0
            : buf1 === buf2;
        if (Buffer.compare(scriptPubKey, this.getScriptPubKey()) !== 0 ||
            (sequenceRBF !== inputSequence && sequenceNoRBF !== inputSequence) ||
            locktime !== psbt.locktime ||
            !eqBuffers(this.getWitnessScript(), input.witnessScript) ||
            !eqBuffers(this.getRedeemScript(), input.redeemScript)) {
            throw new Error(`Error: cannot finalize psbt index ${index} since it does not correspond to this descriptor`);
        }
    };
    /**
     * @hidden
     * @deprecated Use `Output` instead
     */
    class Descriptor extends Output {
        constructor({ expression, ...rest }) {
            super({ descriptor: expression, ...rest });
        }
    }
    return {
        // deprecated TAG must also be below so it is exported to descriptors.d.ts
        /** @deprecated */ Descriptor,
        Output,
        parseKeyExpression,
        expand,
        ECPair,
        BIP32
    };
}
exports.DescriptorsFactory = DescriptorsFactory;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./checksum":2,"./keyExpressions":5,"./miniscript":7,"./psbt":8,"./re":9,"bip32":87,"bitcoinjs-lib":109,"buffer":167,"ecpair":199,"lodash.memoize":276,"varuint-bitcoin":362}],4:[function(require,module,exports){
"use strict";
// Copyright (c) 2023 Jose-Luis Landabaso - https://bitcoinerlab.com
// Distributed under the MIT software license
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ledger = exports.scriptExpressions = exports.keyExpressionLedger = exports.keyExpressionBIP32 = exports.finalizePsbt = exports.signers = exports.checksum = exports.DescriptorsFactory = void 0;
var descriptors_1 = require("./descriptors");
Object.defineProperty(exports, "DescriptorsFactory", { enumerable: true, get: function () { return descriptors_1.DescriptorsFactory; } });
var checksum_1 = require("./checksum");
Object.defineProperty(exports, "checksum", { enumerable: true, get: function () { return checksum_1.DescriptorChecksum; } });
const signers = __importStar(require("./signers"));
exports.signers = signers;
/**
 * @hidden
 * To be removed in v3.0 and replaced by the version with the signature that
 * does not accept descriptors
 */
function finalizePsbt({ psbt, outputs, descriptors, validate = true }) {
    if (descriptors && outputs)
        throw new Error(`descriptors param has been deprecated`);
    outputs = descriptors || outputs;
    if (!outputs)
        throw new Error(`outputs not provided`);
    outputs.forEach((output, inputIndex) => output.finalizePsbtInput({ index: inputIndex, psbt, validate }));
}
exports.finalizePsbt = finalizePsbt;
var keyExpressions_1 = require("./keyExpressions");
Object.defineProperty(exports, "keyExpressionBIP32", { enumerable: true, get: function () { return keyExpressions_1.keyExpressionBIP32; } });
Object.defineProperty(exports, "keyExpressionLedger", { enumerable: true, get: function () { return keyExpressions_1.keyExpressionLedger; } });
const scriptExpressions = __importStar(require("./scriptExpressions"));
exports.scriptExpressions = scriptExpressions;
const ledger_1 = require("./ledger");
exports.ledger = {
    getLedgerMasterFingerPrint: ledger_1.getLedgerMasterFingerPrint,
    getLedgerXpub: ledger_1.getLedgerXpub,
    registerLedgerWallet: ledger_1.registerLedgerWallet,
    assertLedgerApp: ledger_1.assertLedgerApp
};

},{"./checksum":2,"./descriptors":3,"./keyExpressions":5,"./ledger":6,"./scriptExpressions":10,"./signers":11}],5:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
// Copyright (c) 2023 Jose-Luis Landabaso - https://bitcoinerlab.com
// Distributed under the MIT software license
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.keyExpressionBIP32 = exports.keyExpressionLedger = exports.parseKeyExpression = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const ledger_1 = require("./ledger");
const RE = __importStar(require("./re"));
const derivePath = (node, path) => {
    if (typeof path !== 'string') {
        throw new Error(`Error: invalid derivation path ${path}`);
    }
    const parsedPath = path.replaceAll('H', "'").replaceAll('h', "'").slice(1);
    const splitPath = parsedPath.split('/');
    for (const element of splitPath) {
        const unhardened = element.endsWith("'") ? element.slice(0, -1) : element;
        if (!Number.isInteger(Number(unhardened)) ||
            Number(unhardened) >= 0x80000000)
            throw new Error(`Error: BIP 32 path element overflow`);
    }
    return node.derivePath(parsedPath);
};
/**
 * Parses a key expression (xpub, xprv, pubkey or wif) into {@link KeyInfo | `KeyInfo`}.
 *
 * For example, given this `keyExpression`: `"[d34db33f/49'/0'/0']tpubDCdxmvzJ5QBjTN8oCjjyT2V58AyZvA1fkmCeZRC75QMoaHcVP2m45Bv3hmnR7ttAwkb2UNYyoXdHVt4gwBqRrJqLUU2JrM43HippxiWpHra/1/2/3/4/*"`, this is its parsed result:
 *
 * ```javascript
 *  {
 *    keyExpression:
 *      "[d34db33f/49'/0'/0']tpubDCdxmvzJ5QBjTN8oCjjyT2V58AyZvA1fkmCeZRC75QMoaHcVP2m45Bv3hmnR7ttAwkb2UNYyoXdHVt4gwBqRrJqLUU2JrM43HippxiWpHra/1/2/3/4/*",
 *    keyPath: '/1/2/3/4/*',
 *    originPath: "/49'/0'/0'",
 *    path: "m/49'/0'/0'/1/2/3/4/*",
 *    // Other relevant properties of the type `KeyInfo`: `pubkey`, `ecpair` & `bip32` interfaces, `masterFingerprint`, etc.
 *  }
 * ```
 */
function parseKeyExpression({ keyExpression, isSegwit, isTaproot, ECPair, BIP32, network = bitcoinjs_lib_1.networks.bitcoin }) {
    let pubkey; //won't be computed for ranged keyExpressions
    let ecpair;
    let bip32;
    let masterFingerprint;
    let originPath;
    let keyPath;
    let path;
    const isRanged = keyExpression.indexOf('*') !== -1;
    const reKeyExp = isTaproot
        ? RE.reTaprootKeyExp
        : isSegwit
            ? RE.reSegwitKeyExp
            : RE.reNonSegwitKeyExp;
    const rePubKey = isTaproot
        ? RE.reTaprootPubKey
        : isSegwit
            ? RE.reSegwitPubKey
            : RE.reNonSegwitPubKey;
    //Validate the keyExpression:
    const keyExpressions = keyExpression.match(reKeyExp);
    if (keyExpressions === null || keyExpressions[0] !== keyExpression) {
        throw new Error(`Error: expected a keyExpression but got ${keyExpression}`);
    }
    const reOriginAnchoredStart = RegExp(String.raw `^(${RE.reOrigin})?`); //starts with ^origin
    const mOrigin = keyExpression.match(reOriginAnchoredStart);
    if (mOrigin) {
        const bareOrigin = mOrigin[0].replace(/[[\]]/g, ''); //strip the "[" and "]" in [origin]
        const reMasterFingerprintAnchoredStart = String.raw `^(${RE.reMasterFingerprint})`;
        const mMasterFingerprint = bareOrigin.match(reMasterFingerprintAnchoredStart);
        const masterFingerprintHex = mMasterFingerprint
            ? mMasterFingerprint[0]
            : '';
        originPath = bareOrigin.replace(masterFingerprintHex, '');
        if (masterFingerprintHex.length > 0) {
            if (masterFingerprintHex.length !== 8)
                throw new Error(`Error: masterFingerprint ${masterFingerprintHex} invalid for keyExpression: ${keyExpression}`);
            masterFingerprint = Buffer.from(masterFingerprintHex, 'hex');
        }
    }
    //Remove the origin (if it exists) and store result in actualKey
    const actualKey = keyExpression.replace(reOriginAnchoredStart, '');
    let mPubKey, mWIF, mXpubKey, mXprvKey;
    //match pubkey:
    if ((mPubKey = actualKey.match(RE.anchorStartAndEnd(rePubKey))) !== null) {
        pubkey = Buffer.from(mPubKey[0], 'hex');
        if (isTaproot && pubkey.length === 32)
            //convert the xonly point to a compressed point assuming even parity
            pubkey = Buffer.concat([Buffer.from([0x02]), pubkey]);
        ecpair = ECPair.fromPublicKey(pubkey, { network });
        //Validate the pubkey (compressed or uncompressed)
        if (!ECPair.isPoint(pubkey) ||
            !(pubkey.length === 33 || pubkey.length === 65)) {
            throw new Error(`Error: invalid pubkey`);
        }
        //Do an extra check in case we know this pubkey refers to a segwit input
        if (typeof isSegwit === 'boolean' &&
            isSegwit &&
            pubkey.length !== 33 //Inside wpkh and wsh, only compressed public keys are permitted.
        ) {
            throw new Error(`Error: invalid pubkey`);
        }
        //match WIF:
    }
    else if ((mWIF = actualKey.match(RE.anchorStartAndEnd(RE.reWIF))) !== null) {
        ecpair = ECPair.fromWIF(mWIF[0], network);
        //fromWIF will throw if the wif is not valid
        pubkey = ecpair.publicKey;
        //match xpub:
    }
    else if ((mXpubKey = actualKey.match(RE.anchorStartAndEnd(RE.reXpubKey))) !== null) {
        const xPubKey = mXpubKey[0];
        const xPub = xPubKey.match(RE.reXpub)?.[0];
        if (!xPub)
            throw new Error(`Error: xpub could not be matched`);
        bip32 = BIP32.fromBase58(xPub, network);
        const mPath = xPubKey.match(RE.rePath);
        if (mPath !== null) {
            keyPath = xPubKey.match(RE.rePath)?.[0];
            if (!keyPath)
                throw new Error(`Error: could not extract a path`);
            //fromBase58 and derivePath will throw if xPub or path are not valid
            if (!isRanged)
                pubkey = derivePath(bip32, keyPath).publicKey;
        }
        else {
            pubkey = bip32.publicKey;
        }
        //match xprv:
    }
    else if ((mXprvKey = actualKey.match(RE.anchorStartAndEnd(RE.reXprvKey))) !== null) {
        const xPrvKey = mXprvKey[0];
        const xPrv = xPrvKey.match(RE.reXprv)?.[0];
        if (!xPrv)
            throw new Error(`Error: xprv could not be matched`);
        bip32 = BIP32.fromBase58(xPrv, network);
        const mPath = xPrvKey.match(RE.rePath);
        if (mPath !== null) {
            keyPath = xPrvKey.match(RE.rePath)?.[0];
            if (!keyPath)
                throw new Error(`Error: could not extract a path`);
            //fromBase58 and derivePath will throw if xPrv or path are not valid
            if (!isRanged)
                pubkey = derivePath(bip32, keyPath).publicKey;
        }
        else {
            pubkey = bip32.publicKey;
        }
    }
    else {
        throw new Error(`Error: could not get pubkey for keyExpression ${keyExpression}`);
    }
    if (originPath || keyPath) {
        path = `m${originPath ?? ''}${keyPath ?? ''}`;
    }
    if (pubkey !== undefined && isTaproot && pubkey.length === 33)
        // If we get a 33-byte compressed key, drop the first byte.
        pubkey = pubkey.slice(1, 33);
    return {
        keyExpression,
        ...(pubkey !== undefined ? { pubkey } : {}),
        ...(ecpair !== undefined ? { ecpair } : {}),
        ...(bip32 !== undefined ? { bip32 } : {}),
        ...(masterFingerprint !== undefined ? { masterFingerprint } : {}),
        ...(originPath !== undefined && originPath !== '' ? { originPath } : {}),
        ...(keyPath !== undefined && keyPath !== '' ? { keyPath } : {}),
        ...(path !== undefined ? { path } : {})
    };
}
exports.parseKeyExpression = parseKeyExpression;
function assertChangeIndexKeyPath({ change, index, keyPath }) {
    if (!((change === undefined && index === undefined) ||
        (change !== undefined && index !== undefined)))
        throw new Error(`Error: Pass change and index or neither`);
    if ((change !== undefined) === (keyPath !== undefined))
        throw new Error(`Error: Pass either change and index or a keyPath`);
}
/** @hidden */
async function keyExpressionLedger({ ledgerClient, ledgerState, ledgerManager, originPath, keyPath, change, index }) {
    if (ledgerManager && (ledgerClient || ledgerState))
        throw new Error(`ledgerClient and ledgerState have been deprecated`);
    if (ledgerManager)
        ({ ledgerClient, ledgerState } = ledgerManager);
    if (!ledgerClient || !ledgerState)
        throw new Error(`Could not retrieve ledgerClient or ledgerState`);
    assertChangeIndexKeyPath({ change, index, keyPath });
    const masterFingerprint = await (0, ledger_1.getLedgerMasterFingerPrint)({
        ledgerClient,
        ledgerState
    });
    const origin = `[${masterFingerprint.toString('hex')}${originPath}]`;
    const xpub = await (0, ledger_1.getLedgerXpub)({ originPath, ledgerClient, ledgerState });
    const keyRoot = `${origin}${xpub}`;
    if (keyPath !== undefined)
        return `${keyRoot}${keyPath}`;
    else
        return `${keyRoot}/${change}/${index}`;
}
exports.keyExpressionLedger = keyExpressionLedger;
/**
 * Constructs a key expression string from its constituent components.
 *
 * This function essentially performs the reverse operation of
 * {@link _Internal_.ParseKeyExpression | ParseKeyExpression}. For detailed
 * explanations and examples of the terms used here, refer to
 * {@link _Internal_.ParseKeyExpression | ParseKeyExpression}.
 */
function keyExpressionBIP32({ masterNode, originPath, keyPath, change, index, isPublic = true }) {
    assertChangeIndexKeyPath({ change, index, keyPath });
    const masterFingerprint = masterNode.fingerprint;
    const origin = `[${masterFingerprint.toString('hex')}${originPath}]`;
    const xpub = isPublic
        ? masterNode.derivePath(`m${originPath}`).neutered().toBase58().toString()
        : masterNode.derivePath(`m${originPath}`).toBase58().toString();
    const keyRoot = `${origin}${xpub}`;
    if (keyPath !== undefined)
        return `${keyRoot}${keyPath}`;
    else
        return `${keyRoot}/${change}/${index}`;
}
exports.keyExpressionBIP32 = keyExpressionBIP32;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./ledger":6,"./re":9,"bitcoinjs-lib":109,"buffer":167}],6:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
// Copyright (c) 2023 Jose-Luis Landabaso - https://bitcoinerlab.com
// Distributed under the MIT software license
Object.defineProperty(exports, "__esModule", { value: true });
exports.ledgerPolicyFromState = exports.comparePolicies = exports.ledgerPolicyFromStandard = exports.registerLedgerWallet = exports.ledgerPolicyFromOutput = exports.ledgerPolicyFromPsbtInput = exports.getLedgerXpub = exports.getLedgerMasterFingerPrint = exports.assertLedgerApp = exports.importAndValidateLedgerBitcoin = void 0;
/*
 * Notes on Ledger implementation:
 *
 * Ledger assumes as external all keyRoots that do not have origin information.
 *
 * Some known Ledger Limitations (based on my tests as of Febr 2023):
 *
 * 1) All keyExpressions must be expanded into @i. In other words,
 * this template is not valid:
 * wsh(and_v(v:pk(03ed0b41d808b012b3a77dd7f6a30c4180dfbcab604133d90ce7593ec7f3e4037b),and_v(v:sha256(6c60f404f8167a38fc70eaf8aa17ac351023bef86bcb9d1086a19afe95bd5333),and_v(and_v(v:pk(@0/**),v:pk(@1/**)),older(5)))))
 * (note the fixed 03ed0b41d808b012b3a77dd7f6a30c4180dfbcab604133d90ce7593ec7f3e4037b pubkey)
 *
 * 2) All elements in the keyRoot vector must be xpub-type (no xprv-type, no pubkey-type, ...)
 *
 * 3) All originPaths of the expressions in the keyRoot vector must be the same.
 * On the other hand, an empty originPath is permitted for external keys.
 *
 * 4) Since all originPaths must be the same and originPaths for the Ledger are
 * necessary, a Ledger device can only sign at most 1 key per policy and input.
 *
 * All the conditions above are checked in function ledgerPolicyFromOutput.
 */
const descriptors_1 = require("./descriptors");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const re_1 = require("./re");
/**
 * Dynamically imports the 'ledger-bitcoin' module and, if provided, checks if `ledgerClient` is an instance of `AppClient`.
 *
 * @async
 * @param {unknown} ledgerClient - An optional parameter that, if provided, is checked to see if it's an instance of `AppClient`.
 * @throws {Error} Throws an error if `ledgerClient` is provided but is not an instance of `AppClient`.
 * @throws {Error} Throws an error if the 'ledger-bitcoin' module cannot be imported. This typically indicates that the 'ledger-bitcoin' peer dependency is not installed.
 * @returns {Promise<unknown>} Returns a promise that resolves with the entire 'ledger-bitcoin' module if it can be successfully imported. We force it to return an unknown type so that the declaration of this function won't break projects that don't use ledger-bitcoin as dependency
 *
 * @example
 *
 * importAndValidateLedgerBitcoin(ledgerClient)
 *   .then((module) => {
 *     const { AppClient, PsbtV2, DefaultWalletPolicy, WalletPolicy, DefaultDescriptorTemplate, PartialSignature } = module;
 *     // Use the imported objects...
 *   })
 *   .catch((error) => console.error(error));
 */
async function importAndValidateLedgerBitcoin(ledgerClient) {
    let ledgerBitcoinModule;
    try {
        // Originally, the code used dynamic imports:
        // ledgerBitcoinModule = await import('ledger-bitcoin');
        // However, in React Native with the Metro bundler, there's an issue with
        // recognizing dynamic imports inside try-catch blocks. For details, refer to:
        // https://github.com/react-native-community/discussions-and-proposals/issues/120
        // The dynamic import gets transpiled to:
        // ledgerBitcoinModule = Promise.resolve().then(() => __importStar(require('ledger-bitcoin')));
        // Metro bundler fails to recognize the above as conditional. Hence, it tries
        // to require 'ledger-bitcoin' unconditionally, leading to potential errors if
        // 'ledger-bitcoin' is not installed (given it's an optional peerDependency).
        // To bypass this, we directly use require:
        ledgerBitcoinModule = require('ledger-bitcoin');
    }
    catch (error) {
        throw new Error('Could not import "ledger-bitcoin". This is a peer dependency and needs to be installed explicitly. Please run "npm install ledger-bitcoin" to use Ledger Hardware Wallet functionality.');
    }
    const { AppClient } = ledgerBitcoinModule;
    if (ledgerClient !== undefined && !(ledgerClient instanceof AppClient)) {
        throw new Error('Error: invalid AppClient instance');
    }
    return ledgerBitcoinModule;
}
exports.importAndValidateLedgerBitcoin = importAndValidateLedgerBitcoin;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function ledgerAppInfo(transport) {
    const r = await transport.send(0xb0, 0x01, 0x00, 0x00);
    let i = 0;
    const format = r[i++];
    const nameLength = r[i++];
    const name = r.slice(i, (i += nameLength)).toString('ascii');
    const versionLength = r[i++];
    const version = r.slice(i, (i += versionLength)).toString('ascii');
    const flagLength = r[i++];
    const flags = r.slice(i, (i += flagLength));
    return { name, version, flags, format };
}
/**
 * Verifies if the Ledger device is connected, if the required Bitcoin App is opened,
 * and if the version of the app meets the minimum requirements.
 *
 * @throws Will throw an error if the Ledger device is not connected, the required
 * Bitcoin App is not opened, or if the version is below the required number.
 *
 * @returns Promise<void> - A promise that resolves if all assertions pass, or throws otherwise.
 */
async function assertLedgerApp({ transport, name, minVersion }) {
    const { name: openName, version } = await ledgerAppInfo(transport);
    if (openName !== name) {
        throw new Error(`Open the ${name} app and try again`);
    }
    else {
        const [mVmajor, mVminor, mVpatch] = minVersion.split('.').map(Number);
        const [major, minor, patch] = version.split('.').map(Number);
        if (mVmajor === undefined ||
            mVminor === undefined ||
            mVpatch === undefined) {
            throw new Error(`Pass a minVersion using semver notation: major.minor.patch`);
        }
        if (major < mVmajor ||
            (major === mVmajor && minor < mVminor) ||
            (major === mVmajor && minor === mVminor && patch < mVpatch))
            throw new Error(`Error: please upgrade ${name} to version ${minVersion}`);
    }
}
exports.assertLedgerApp = assertLedgerApp;
function isLedgerStandard({ ledgerTemplate, keyRoots, network = bitcoinjs_lib_1.networks.bitcoin }) {
    if (keyRoots.length !== 1)
        return false;
    const originPath = keyRoots[0]?.match(re_1.reOriginPath)?.[1];
    if (!originPath)
        return false;
    //Network is the 6th character: /44'/0'
    if (originPath[5] !== (network === bitcoinjs_lib_1.networks.bitcoin ? '0' : '1'))
        return false;
    if ((ledgerTemplate === 'pkh(@0/**)' &&
        originPath.match(/^\/44'\/[01]'\/(\d+)'$/)) ||
        (ledgerTemplate === 'wpkh(@0/**)' &&
            originPath.match(/^\/84'\/[01]'\/(\d+)'$/)) ||
        (ledgerTemplate === 'sh(wpkh(@0/**))' &&
            originPath.match(/^\/49'\/[01]'\/(\d+)'$/)) ||
        (ledgerTemplate === 'tr(@0/**)' &&
            originPath.match(/^\/86'\/[01]'\/(\d+)'$/)))
        return true;
    return false;
}
/** @hidden */
async function getLedgerMasterFingerPrint({ ledgerClient, ledgerState, ledgerManager }) {
    if (ledgerManager && (ledgerClient || ledgerState))
        throw new Error(`ledgerClient and ledgerState have been deprecated`);
    if (ledgerManager)
        ({ ledgerClient, ledgerState } = ledgerManager);
    if (!ledgerClient || !ledgerState)
        throw new Error(`Could not retrieve ledgerClient or ledgerState`);
    const { AppClient } = (await importAndValidateLedgerBitcoin(ledgerClient));
    if (!(ledgerClient instanceof AppClient))
        throw new Error(`Error: pass a valid ledgerClient`);
    let masterFingerprint = ledgerState.masterFingerprint;
    if (!masterFingerprint) {
        masterFingerprint = Buffer.from(await ledgerClient.getMasterFingerprint(), 'hex');
        ledgerState.masterFingerprint = masterFingerprint;
    }
    return masterFingerprint;
}
exports.getLedgerMasterFingerPrint = getLedgerMasterFingerPrint;
/** @hidden */
async function getLedgerXpub({ originPath, ledgerClient, ledgerState, ledgerManager }) {
    if (ledgerManager && (ledgerClient || ledgerState))
        throw new Error(`ledgerClient and ledgerState have been deprecated`);
    if (ledgerManager)
        ({ ledgerClient, ledgerState } = ledgerManager);
    if (!ledgerClient || !ledgerState)
        throw new Error(`Could not retrieve ledgerClient or ledgerState`);
    const { AppClient } = (await importAndValidateLedgerBitcoin(ledgerClient));
    if (!(ledgerClient instanceof AppClient))
        throw new Error(`Error: pass a valid ledgerClient`);
    if (!ledgerState.xpubs)
        ledgerState.xpubs = {};
    let xpub = ledgerState.xpubs[originPath];
    if (!xpub) {
        try {
            //Try getting the xpub without user confirmation
            xpub = await ledgerClient.getExtendedPubkey(`m${originPath}`, false);
        }
        catch (err) {
            xpub = await ledgerClient.getExtendedPubkey(`m${originPath}`, true);
        }
        if (typeof xpub !== 'string')
            throw new Error(`Error: ledgerClient did not return a valid xpub`);
        ledgerState.xpubs[originPath] = xpub;
    }
    return xpub;
}
exports.getLedgerXpub = getLedgerXpub;
/**
 * Checks whether there is a policy in ledgerState that the ledger
 * could use to sign this psbt input.
 *
 * It found return the policy, otherwise, return undefined
 *
 * All considerations in the header of this file are applied
 */
async function ledgerPolicyFromPsbtInput({ ledgerManager, psbt, index }) {
    const { ledgerState, ledgerClient, ecc, network } = ledgerManager;
    const { Output } = (0, descriptors_1.DescriptorsFactory)(ecc);
    const input = psbt.data.inputs[index];
    if (!input)
        throw new Error(`Input numer ${index} not set.`);
    let scriptPubKey;
    if (input.nonWitnessUtxo) {
        const vout = psbt.txInputs[index]?.index;
        if (vout === undefined)
            throw new Error(`Could not extract vout from nonWitnessUtxo for input ${index}.`);
        scriptPubKey = bitcoinjs_lib_1.Transaction.fromBuffer(input.nonWitnessUtxo).outs[vout]
            ?.script;
    }
    else if (input.witnessUtxo) {
        scriptPubKey = input.witnessUtxo.script;
    }
    if (!scriptPubKey)
        throw new Error(`Could not retrieve scriptPubKey for input ${index}.`);
    const bip32Derivations = input.bip32Derivation;
    if (!bip32Derivations || !bip32Derivations.length)
        throw new Error(`Input ${index} does not contain bip32 derivations.`);
    const ledgerMasterFingerprint = await getLedgerMasterFingerPrint({
        ledgerManager
    });
    for (const bip32Derivation of bip32Derivations) {
        //get the keyRoot and keyPath. If it matches one of our policies then
        //we are still not sure this is the policy that must be used yet
        //So we must use the template and the keyRoot of each policy and compute the
        //scriptPubKey:
        if (Buffer.compare(bip32Derivation.masterFingerprint, ledgerMasterFingerprint) === 0) {
            // Match /m followed by n consecutive hardened levels and then 2 consecutive unhardened levels:
            const match = bip32Derivation.path.match(/m((\/\d+['hH])*)(\/\d+\/\d+)?/);
            const originPath = match ? match[1] : undefined; //n consecutive hardened levels
            const keyPath = match ? match[3] : undefined; //2 unhardened levels or undefined
            if (originPath && keyPath) {
                const [, strChange, strIndex] = keyPath.split('/');
                if (!strChange || !strIndex)
                    throw new Error(`keyPath ${keyPath} incorrectly extracted`);
                const change = parseInt(strChange, 10);
                const index = parseInt(strIndex, 10);
                const coinType = network === bitcoinjs_lib_1.networks.bitcoin ? 0 : 1;
                //standard policy candidate. This policy will be added to the pool
                //of policies below and check if it produces the correct scriptPubKey
                let standardPolicy;
                if (change === 0 || change === 1) {
                    const standardTemplate = originPath.match(new RegExp(`^/44'/${coinType}'/(\\d+)'$`))
                        ? 'pkh(@0/**)'
                        : originPath.match(new RegExp(`^/84'/${coinType}'/(\\d+)'$`))
                            ? 'wpkh(@0/**)'
                            : originPath.match(new RegExp(`^/49'/${coinType}'/(\\d+)'$`))
                                ? 'sh(wpkh(@0/**))'
                                : originPath.match(new RegExp(`^/86'/${coinType}'/(\\d+)'$`))
                                    ? 'tr(@0/**)'
                                    : undefined;
                    if (standardTemplate) {
                        const xpub = await getLedgerXpub({
                            originPath,
                            ledgerClient,
                            ledgerState
                        });
                        standardPolicy = {
                            ledgerTemplate: standardTemplate,
                            keyRoots: [
                                `[${ledgerMasterFingerprint.toString('hex')}${originPath}]${xpub}`
                            ]
                        };
                    }
                }
                const policies = [...(ledgerState.policies || [])];
                if (standardPolicy)
                    policies.push(standardPolicy);
                for (const policy of policies) {
                    //Build the descriptor from the ledgerTemplate + keyRoots
                    //then get the scriptPubKey
                    let descriptor = policy.ledgerTemplate;
                    // Replace change (making sure the value in the change level for the
                    // template of the policy meets the change in bip32Derivation):
                    descriptor = descriptor.replace(/\/\*\*/g, `/<0;1>/*`);
                    const regExpMN = new RegExp(`/<(\\d+);(\\d+)>`, 'g');
                    let matchMN;
                    while (descriptor && (matchMN = regExpMN.exec(descriptor)) !== null) {
                        const [M, N] = [
                            parseInt(matchMN[1], 10),
                            parseInt(matchMN[2], 10)
                        ];
                        if (M === change || N === change)
                            descriptor = descriptor.replace(`/<${M};${N}>`, `/${change}`);
                        else
                            descriptor = undefined;
                    }
                    if (descriptor) {
                        // Replace index:
                        descriptor = descriptor.replace(/\/\*/g, `/${index}`);
                        // Replace origin in reverse order to prevent
                        // misreplacements, e.g., @10 being mistaken for @1 and leaving a 0.
                        for (let i = policy.keyRoots.length - 1; i >= 0; i--) {
                            const keyRoot = policy.keyRoots[i];
                            if (!keyRoot)
                                throw new Error(`keyRoot ${keyRoot} invalidly extracted.`);
                            const match = keyRoot.match(/\[([^]+)\]/);
                            const keyRootOrigin = match && match[1];
                            if (keyRootOrigin) {
                                const [, ...arrKeyRootOriginPath] = keyRootOrigin.split('/');
                                const keyRootOriginPath = '/' + arrKeyRootOriginPath.join('/');
                                //We check all origins to be the same even if they do not
                                //belong to the ledger (read the header in this file)
                                if (descriptor && keyRootOriginPath === originPath)
                                    descriptor = descriptor.replace(new RegExp(`@${i}`, 'g'), keyRoot);
                                else
                                    descriptor = undefined;
                            }
                            else
                                descriptor = undefined;
                        }
                        //verify the scriptPubKey from the input vs. the one obtained from
                        //the policy after having filled in the keyPath in the template
                        if (descriptor) {
                            const policyScriptPubKey = new Output({
                                descriptor,
                                network
                            }).getScriptPubKey();
                            if (Buffer.compare(policyScriptPubKey, scriptPubKey) === 0) {
                                return policy;
                            }
                        }
                    }
                }
            }
        }
    }
    return;
}
exports.ledgerPolicyFromPsbtInput = ledgerPolicyFromPsbtInput;
/**
 * Given an output, it extracts its descriptor and converts it to a Ledger
 * Wallet Policy, that is, its keyRoots and template.
 *
 * keyRoots and template follow Ledger's specifications:
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/develop/doc/wallet.md
 *
 * keyRoots and template are a generalization of a descriptor and serve to
 * describe internal and external addresses and any index.
 *
 * So, this function starts from a descriptor and obtains generalized Ledger
 * wallet policy.
 *
 * keyRoots is an array of strings, encoding xpub-type key expressions up to the origin.
 * F.ex.: [76223a6e/48'/1'/0'/2']tpubDE7NQymr4AFtewpAsWtnreyq9ghkzQBXpCZjWLFVRAvnbf7vya2eMTvT2fPapNqL8SuVvLQdbUbMfWLVDCZKnsEBqp6UK93QEzL8Ck23AwF
 *
 * Template encodes the descriptor script expression, where its key
 * expressions are represented using variables for each keyRoot and finished with "/**"
 * (for change 1 or 0 and any index). F.ex.:
 * wsh(sortedmulti(2,@0/**,@1/**)), where @0 corresponds the first element in the keyRoots array.
 *
 * If this descriptor does not contain any key that can be signed with the ledger
 * (non-matching masterFingerprint), then this function returns null.
 *
 * This function takes into account all the considerations regarding Ledger
 * policy implementation details expressed in the header of this file.
 */
async function ledgerPolicyFromOutput({ output, ledgerClient, ledgerState }) {
    const expandedExpression = output.expand().expandedExpression;
    const expansionMap = output.expand().expansionMap;
    if (!expandedExpression || !expansionMap)
        throw new Error(`Error: invalid output`);
    const ledgerMasterFingerprint = await getLedgerMasterFingerPrint({
        ledgerClient,
        ledgerState
    });
    //It's important to have keys sorted in ascii order. keys
    //are of this type: @0, @1, @2, ....  and they also appear in the expandedExpression
    //in ascending ascii order. Note that Object.keys(expansionMap ) does not ensure
    //that the order is respected and so we force it.
    const allKeys = Object.keys(expansionMap).sort();
    const ledgerKeys = allKeys.filter(key => {
        const masterFingerprint = expansionMap[key]?.masterFingerprint;
        return (masterFingerprint &&
            Buffer.compare(masterFingerprint, ledgerMasterFingerprint) === 0);
    });
    if (ledgerKeys.length === 0)
        return null;
    if (ledgerKeys.length > 1)
        throw new Error(`Error: descriptor ${expandedExpression} does not contain exactly 1 ledger key`);
    const ledgerKey = ledgerKeys[0];
    const masterFingerprint = expansionMap[ledgerKey].masterFingerprint;
    const originPath = expansionMap[ledgerKey].originPath;
    const keyPath = expansionMap[ledgerKey].keyPath;
    const bip32 = expansionMap[ledgerKey].bip32;
    if (!masterFingerprint || !originPath || !keyPath || !bip32) {
        throw new Error(`Error: Ledger key expression must have a valid masterFingerprint: ${masterFingerprint}, originPath: ${originPath}, keyPath: ${keyPath} and a valid bip32 node`);
    }
    if (!/^\/[01]\/\d+$/.test(keyPath))
        throw new Error(`Error: key paths must be /<1;0>/index, where change is 1 or 0 and index >= 0`);
    const keyRoots = [];
    let ledgerTemplate = expandedExpression;
    allKeys.forEach(key => {
        if (key !== ledgerKey) {
            //This block here only does data integrity assertions:
            const otherKeyInfo = expansionMap[key];
            if (!otherKeyInfo.bip32) {
                throw new Error(`Error: ledger only allows xpub-type key expressions`);
            }
            if (otherKeyInfo.originPath) {
                if (otherKeyInfo.originPath !== originPath) {
                    throw new Error(`Error: all originPaths must be the same for Ledger being able to sign. On the other hand, you can leave the origin info empty for external keys: ${otherKeyInfo.originPath} !== ${originPath}`);
                }
            }
            if (otherKeyInfo.keyPath !== keyPath) {
                throw new Error(`Error: all keyPaths must be the same for Ledger being able to sign: ${otherKeyInfo.keyPath} !== ${keyPath}`);
            }
        }
        ledgerTemplate = ledgerTemplate.replaceAll(key, `@${keyRoots.length}/**`);
        const keyInfo = expansionMap[key];
        if (keyInfo.masterFingerprint && keyInfo.originPath)
            keyRoots.push(`[${keyInfo.masterFingerprint?.toString('hex')}${keyInfo.originPath}]${keyInfo?.bip32?.neutered().toBase58()}`);
        else
            keyRoots.push(`${keyInfo?.bip32?.neutered().toBase58()}`);
    });
    return { ledgerTemplate, keyRoots };
}
exports.ledgerPolicyFromOutput = ledgerPolicyFromOutput;
/**
 * To be removed in v3.0 and replaced by a version that does not accept
 * descriptors
 * @hidden
 **/
async function registerLedgerWallet({ descriptor, ledgerClient, ledgerState, ledgerManager, policyName }) {
    if (typeof descriptor !== 'string' && ledgerManager)
        throw new Error(`Invalid usage: descriptor must be a string`);
    if (ledgerManager && (ledgerClient || ledgerState))
        throw new Error(`Invalid usage: either ledgerManager or ledgerClient + ledgerState`);
    if (ledgerManager)
        ({ ledgerClient, ledgerState } = ledgerManager);
    if (!ledgerClient)
        throw new Error(`ledgerManager not provided`);
    if (!ledgerState)
        throw new Error(`ledgerManager not provided`);
    const { WalletPolicy, AppClient } = (await importAndValidateLedgerBitcoin(ledgerClient));
    if (!(ledgerClient instanceof AppClient))
        throw new Error(`Error: pass a valid ledgerClient`);
    let output;
    if (typeof descriptor === 'string') {
        if (!ledgerManager)
            throw new Error(`ledgerManager not provided`);
        const { Output } = (0, descriptors_1.DescriptorsFactory)(ledgerManager.ecc);
        output = new Output({
            descriptor,
            ...(descriptor.includes('*') ? { index: 0 } : {}),
            network: ledgerManager.network
        });
    }
    else
        output = descriptor;
    if (await ledgerPolicyFromStandard({ output, ledgerClient, ledgerState }))
        return;
    const result = await ledgerPolicyFromOutput({
        output,
        ledgerClient,
        ledgerState
    });
    if (await ledgerPolicyFromStandard({ output, ledgerClient, ledgerState }))
        return;
    if (!result)
        throw new Error(`Error: output does not have a ledger input`);
    const { ledgerTemplate, keyRoots } = result;
    if (!ledgerState.policies)
        ledgerState.policies = [];
    let walletPolicy, policyHmac;
    //Search in ledgerState first
    const policy = await ledgerPolicyFromState({
        output,
        ledgerClient,
        ledgerState
    });
    if (policy) {
        if (policy.policyName !== policyName)
            throw new Error(`Error: policy was already registered with a different name: ${policy.policyName}`);
        //It already existed. No need to register it again.
    }
    else {
        walletPolicy = new WalletPolicy(policyName, ledgerTemplate, keyRoots);
        let policyId;
        [policyId, policyHmac] = await ledgerClient.registerWallet(walletPolicy);
        const policy = {
            policyName,
            ledgerTemplate,
            keyRoots,
            policyId,
            policyHmac
        };
        ledgerState.policies.push(policy);
    }
}
exports.registerLedgerWallet = registerLedgerWallet;
/**
 * Retrieve a standard ledger policy or null if it does correspond.
 **/
async function ledgerPolicyFromStandard({ output, ledgerClient, ledgerState }) {
    const result = await ledgerPolicyFromOutput({
        output,
        ledgerClient,
        ledgerState
    });
    if (!result)
        throw new Error(`Error: descriptor does not have a ledger input`);
    const { ledgerTemplate, keyRoots } = result;
    if (isLedgerStandard({
        ledgerTemplate,
        keyRoots,
        network: output.getNetwork()
    }))
        return { ledgerTemplate, keyRoots };
    return null;
}
exports.ledgerPolicyFromStandard = ledgerPolicyFromStandard;
function compareKeyRoots(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function comparePolicies(policyA, policyB) {
    return (compareKeyRoots(policyA.keyRoots, policyB.keyRoots) &&
        policyA.ledgerTemplate === policyB.ledgerTemplate);
}
exports.comparePolicies = comparePolicies;
/**
 * Retrieve a ledger policy from ledgerState or null if it does not exist yet.
 **/
async function ledgerPolicyFromState({ output, ledgerClient, ledgerState }) {
    const result = await ledgerPolicyFromOutput({
        output,
        ledgerClient,
        ledgerState
    });
    if (!result)
        throw new Error(`Error: output does not have a ledger input`);
    const { ledgerTemplate, keyRoots } = result;
    if (!ledgerState.policies)
        ledgerState.policies = [];
    //Search in ledgerState:
    const policies = ledgerState.policies.filter(policy => comparePolicies(policy, { ledgerTemplate, keyRoots }));
    if (policies.length > 1)
        throw new Error(`Error: duplicated policy`);
    if (policies.length === 1) {
        return policies[0];
    }
    else {
        return null;
    }
}
exports.ledgerPolicyFromState = ledgerPolicyFromState;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./descriptors":3,"./re":9,"bitcoinjs-lib":109,"buffer":167,"ledger-bitcoin":265}],7:[function(require,module,exports){
"use strict";
// Copyright (c) 2023 Jose-Luis Landabaso - https://bitcoinerlab.com
// Distributed under the MIT software license
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.numberEncodeAsm = exports.satisfyMiniscript = exports.miniscript2Script = exports.expandMiniscript = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const keyExpressions_1 = require("./keyExpressions");
const RE = __importStar(require("./re"));
const miniscript_1 = require("@bitcoinerlab/miniscript");
/**
 * Expand a miniscript to a generalized form using variables instead of key
 * expressions. Variables will be of this form: @0, @1, ...
 * This is done so that it can be compiled with compileMiniscript and
 * satisfied with satisfier.
 * Also compute pubkeys from descriptors to use them later.
 */
function expandMiniscript({ miniscript, isSegwit, isTaproot, network = bitcoinjs_lib_1.networks.bitcoin, ECPair, BIP32 }) {
    if (isTaproot)
        throw new Error('Taproot miniscript not yet supported.');
    const reKeyExp = isTaproot
        ? RE.reTaprootKeyExp
        : isSegwit
            ? RE.reSegwitKeyExp
            : RE.reNonSegwitKeyExp;
    const expansionMap = {};
    const expandedMiniscript = miniscript.replace(RegExp(reKeyExp, 'g'), (keyExpression) => {
        const key = '@' + Object.keys(expansionMap).length;
        expansionMap[key] = (0, keyExpressions_1.parseKeyExpression)({
            keyExpression,
            isSegwit,
            network,
            ECPair,
            BIP32
        });
        return key;
    });
    //Do some assertions. Miniscript must not have duplicate keys, also all
    //keyExpressions must produce a valid pubkey (unless it's ranged and we want
    //to expand a generalized form, then we don't check)
    const pubkeysHex = Object.values(expansionMap)
        .filter(keyInfo => keyInfo.keyExpression.indexOf('*') === -1)
        .map(keyInfo => {
        if (!keyInfo.pubkey)
            throw new Error(`Error: keyExpression ${keyInfo.keyExpression} does not have a pubkey`);
        return keyInfo.pubkey.toString('hex');
    });
    if (new Set(pubkeysHex).size !== pubkeysHex.length) {
        throw new Error(`Error: miniscript ${miniscript} is not sane: contains duplicate public keys.`);
    }
    return { expandedMiniscript, expansionMap };
}
exports.expandMiniscript = expandMiniscript;
/**
 * Particularize an expanded ASM expression using the variables in
 * expansionMap.
 * This is the kind of the opposite to what expandMiniscript does.
 * Signatures and preimages are already subsituted by the satisfier calling
 * this function.
 */
function substituteAsm({ expandedAsm, expansionMap }) {
    //Replace back variables into the pubkeys previously computed.
    let asm = Object.keys(expansionMap).reduce((accAsm, key) => {
        const pubkey = expansionMap[key]?.pubkey;
        if (!pubkey) {
            throw new Error(`Error: invalid expansionMap for ${key}`);
        }
        return accAsm
            .replaceAll(`<${key}>`, `<${pubkey.toString('hex')}>`)
            .replaceAll(`<HASH160(${key})>`, `<${bitcoinjs_lib_1.crypto.hash160(pubkey).toString('hex')}>`);
    }, expandedAsm);
    //Now clean it and prepare it so that fromASM can be called:
    asm = asm
        .trim()
        //Replace one or more consecutive whitespace characters (spaces, tabs,
        //or line breaks) with a single space.
        .replace(/\s+/g, ' ')
        //Now encode numbers to little endian hex. Note that numbers are not
        //enclosed in <>, since <> represents hex code already encoded.
        //The regex below will match one or more digits within a string,
        //except if the sequence is surrounded by "<" and ">"
        .replace(/(<\d+>)|\b\d+\b/g, match => match.startsWith('<') ? match : numberEncodeAsm(Number(match)))
        //we don't have numbers anymore, now it's safe to remove < and > since we
        //know that every remaining is either an op_code or a hex encoded number
        .replace(/[<>]/g, '');
    return asm;
}
function miniscript2Script({ expandedMiniscript, expansionMap }) {
    const compiled = (0, miniscript_1.compileMiniscript)(expandedMiniscript);
    if (compiled.issane !== true) {
        throw new Error(`Error: Miniscript ${expandedMiniscript} is not sane`);
    }
    return bitcoinjs_lib_1.script.fromASM(substituteAsm({ expandedAsm: compiled.asm, expansionMap }));
}
exports.miniscript2Script = miniscript2Script;
/**
 * Assumptions:
 * The attacker does not have access to any of the private keys of public keys
 * that participate in the Script.
 *
 * The attacker only has access to hash preimages that honest users have access
 * to as well.
 *
 * Pass timeConstraints to search for the first solution with this nLockTime and
 * nSequence. Throw if no solution is possible using these constraints.
 *
 * Don't pass timeConstraints (this is the default) if you want to get the
 * smallest size solution altogether.
 *
 * If a solution is not found this function throws.
 */
function satisfyMiniscript({ expandedMiniscript, expansionMap, signatures = [], preimages = [], timeConstraints }) {
    //convert 'sha256(6c...33)' to: { ['<sha256_preimage(6c...33)>']: '10...5f'}
    const preimageMap = {};
    preimages.forEach(preimage => {
        preimageMap['<' + preimage.digest.replace('(', '_preimage(') + '>'] =
            '<' + preimage.preimage + '>';
    });
    //convert the pubkeys in signatures into [{['<sig(@0)>']: '30450221'}, ...]
    //get the keyExpressions: @0, @1 from the keys in expansionMap
    const expandedSignatureMap = {};
    signatures.forEach(signature => {
        const pubkeyHex = signature.pubkey.toString('hex');
        const keyExpression = Object.keys(expansionMap).find(k => expansionMap[k]?.pubkey?.toString('hex') === pubkeyHex);
        expandedSignatureMap['<sig(' + keyExpression + ')>'] =
            '<' + signature.signature.toString('hex') + '>';
    });
    const expandedKnownsMap = { ...preimageMap, ...expandedSignatureMap };
    const knowns = Object.keys(expandedKnownsMap);
    //satisfier verifies again internally whether expandedKnownsMap with given knowns is sane
    const { nonMalleableSats } = (0, miniscript_1.satisfier)(expandedMiniscript, { knowns });
    if (!Array.isArray(nonMalleableSats) || !nonMalleableSats[0])
        throw new Error(`Error: unresolvable miniscript ${expandedMiniscript}`);
    let sat;
    if (!timeConstraints) {
        sat = nonMalleableSats[0];
    }
    else {
        sat = nonMalleableSats.find(nonMalleableSat => nonMalleableSat.nSequence === timeConstraints.nSequence &&
            nonMalleableSat.nLockTime === timeConstraints.nLockTime);
        if (sat === undefined) {
            throw new Error(`Error: unresolvable miniscript ${expandedMiniscript}. Could not find solutions for sequence ${timeConstraints.nSequence} & locktime=${timeConstraints.nLockTime}. Signatures are applied to a hash that depends on sequence and locktime. Did you provide all the signatures wrt the signers keys declared and include all preimages?`);
        }
    }
    //substitute signatures and preimages:
    let expandedAsm = sat.asm;
    //replace in expandedAsm all the <sig(@0)> and <sha256_preimage(6c...33)>
    //to <304...01> and <107...5f> ...
    for (const search in expandedKnownsMap) {
        const replace = expandedKnownsMap[search];
        if (!replace || replace === '<>')
            throw new Error(`Error: invalid expandedKnownsMap`);
        expandedAsm = expandedAsm.replaceAll(search, replace);
    }
    const scriptSatisfaction = bitcoinjs_lib_1.script.fromASM(substituteAsm({ expandedAsm, expansionMap }));
    return {
        scriptSatisfaction,
        nLockTime: sat.nLockTime,
        nSequence: sat.nSequence
    };
}
exports.satisfyMiniscript = satisfyMiniscript;
/**
 *
 * Use this function instead of bitcoinjs-lib's equivalent `script.number.encode`
 * when encoding numbers to be compiled with `fromASM` to avoid problems.
 *
 * Motivation:
 *
 * Numbers in Bitcoin assembly code are represented in hex and in Little Endian.
 * Decimal: 32766 - Big endian: 0x7FFE - Little Endian: 0xFE7F.
 *
 * This function takes an integer and encodes it so that bitcoinjs-lib `fromASM`
 * can compile it. This is basically what bitcoinjs-lib's `script.number.encode`
 * does.
 *
 * Note that `fromASM` already converts integers from 1 to 16 to
 * OP_1 ... OP_16 {@link https://github.com/bitcoinjs/bitcoinjs-lib/blob/59b21162a2c4645c64271ca004c7a3755a3d72fb/src/script.js#L33 here}.
 * This is done in Bitcoin to save some bits.
 *
 * Neither this function nor `script.number.encode` convert numbers to
 * their op code equivalent since this is done later in `fromASM`.
 *
 * Both functions simply convert numbers to Little Endian.
 *
 * However, the `0` number is an edge case that we specially handle with this
 * function.
 *
 * bitcoinjs-lib's `bscript.number.encode(0)` produces an empty Buffer.
 * This is what the Bitcoin interpreter does and it is what `script.number.encode` was
 * implemented to do.
 *
 * The problem is `bscript.number.encode(0).toString('hex')` produces an
 * empty string and thus it should not be used to serialize number zero before `fromASM`.
 *
 * A zero should produce the OP_0 ASM symbolic code (corresponding to a `0` when
 * compiled).
 *
 * So, this function will produce a string in hex format in Little Endian
 * encoding for integers not equal to `0` and it will return `OP_0` for `0`.
 *
 * Read more about the this {@link https://github.com/bitcoinjs/bitcoinjs-lib/issues/1799#issuecomment-1122591738 here}.
 *
 * Use it in combination with `fromASM` like this:
 *
 * ```javascript
 * //To produce "0 1 OP_ADD":
 * fromASM(
 * `${numberEncodeAsm(0)} ${numberEncodeAsm(1)} OP_ADD`
 *   .trim().replace(/\s+/g, ' ')
 * )
 * ```
 *
 * @param {number} number An integer.
 * @returns {string} Returns `"OP_0"` for `number === 0` and a hex string representing other numbers in Little Endian encoding.
 */
function numberEncodeAsm(number) {
    if (Number.isSafeInteger(number) === false) {
        throw new Error(`Error: invalid number ${number}`);
    }
    if (number === 0) {
        return 'OP_0';
    }
    else
        return bitcoinjs_lib_1.script.number.encode(number).toString('hex');
}
exports.numberEncodeAsm = numberEncodeAsm;

},{"./keyExpressions":5,"./re":9,"@bitcoinerlab/miniscript":12,"bitcoinjs-lib":109}],8:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
// Copyright (c) 2025 Jose-Luis Landabaso - https://bitcoinerlab.com
// Distributed under the MIT software license
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePsbt = exports.finalScriptsFuncFactory = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const varuint_bitcoin_1 = require("varuint-bitcoin");
function reverseBuffer(buffer) {
    if (buffer.length < 1)
        return buffer;
    let j = buffer.length - 1;
    let tmp = 0;
    for (let i = 0; i < buffer.length / 2; i++) {
        tmp = buffer[i];
        buffer[i] = buffer[j];
        buffer[j] = tmp;
        j--;
    }
    return buffer;
}
function witnessStackToScriptWitness(witness) {
    let buffer = Buffer.allocUnsafe(0);
    function writeSlice(slice) {
        buffer = Buffer.concat([buffer, Buffer.from(slice)]);
    }
    function writeVarInt(i) {
        const currentLen = buffer.length;
        const varintLen = (0, varuint_bitcoin_1.encodingLength)(i);
        buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
        (0, varuint_bitcoin_1.encode)(i, buffer, currentLen);
    }
    function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
    }
    function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
    }
    writeVector(witness);
    return buffer;
}
function finalScriptsFuncFactory(scriptSatisfaction, network) {
    const finalScriptsFunc = (_index, _input, lockingScript /*witnessScript or redeemScript*/, isSegwit, isP2SH, _isP2WSH) => {
        let finalScriptWitness;
        let finalScriptSig;
        //p2wsh
        if (isSegwit && !isP2SH) {
            const payment = bitcoinjs_lib_1.payments.p2wsh({
                redeem: { input: scriptSatisfaction, output: lockingScript },
                network
            });
            if (!payment.witness)
                throw new Error(`Error: p2wsh failed producing a witness`);
            finalScriptWitness = witnessStackToScriptWitness(payment.witness);
        }
        //p2sh-p2wsh
        else if (isSegwit && isP2SH) {
            const payment = bitcoinjs_lib_1.payments.p2sh({
                redeem: bitcoinjs_lib_1.payments.p2wsh({
                    redeem: { input: scriptSatisfaction, output: lockingScript },
                    network
                }),
                network
            });
            if (!payment.witness)
                throw new Error(`Error: p2sh-p2wsh failed producing a witness`);
            finalScriptWitness = witnessStackToScriptWitness(payment.witness);
            finalScriptSig = payment.input;
        }
        //p2sh
        else {
            finalScriptSig = bitcoinjs_lib_1.payments.p2sh({
                redeem: { input: scriptSatisfaction, output: lockingScript },
                network
            }).input;
        }
        return {
            finalScriptWitness,
            finalScriptSig
        };
    };
    return finalScriptsFunc;
}
exports.finalScriptsFuncFactory = finalScriptsFuncFactory;
/**
 * Important: Read comments on descriptor.updatePsbt regarding not passing txHex
 */
function updatePsbt({ psbt, vout, txHex, txId, value, sequence, locktime, keysInfo, scriptPubKey, isSegwit, tapInternalKey, witnessScript, redeemScript, rbf }) {
    //Some data-sanity checks:
    if (sequence !== undefined && rbf && sequence > 0xfffffffd)
        throw new Error(`Error: incompatible sequence and rbf settings`);
    if (!isSegwit && txHex === undefined)
        throw new Error(`Error: txHex is mandatory for Non-Segwit inputs`);
    if (isSegwit &&
        txHex === undefined &&
        (txId === undefined || value === undefined))
        throw new Error(`Error: pass txHex or txId+value for Segwit inputs`);
    if (txHex !== undefined) {
        const tx = bitcoinjs_lib_1.Transaction.fromHex(txHex);
        const out = tx?.outs?.[vout];
        if (!out)
            throw new Error(`Error: tx ${txHex} does not have vout ${vout}`);
        const outputScript = out.script;
        if (!outputScript)
            throw new Error(`Error: could not extract outputScript for txHex ${txHex} and vout ${vout}`);
        if (Buffer.compare(outputScript, scriptPubKey) !== 0)
            throw new Error(`Error: txHex ${txHex} for vout ${vout} does not correspond to scriptPubKey ${scriptPubKey}`);
        if (txId !== undefined) {
            if (tx.getId() !== txId)
                throw new Error(`Error: txId for ${txHex} and vout ${vout} does not correspond to ${txId}`);
        }
        else {
            txId = tx.getId();
        }
        if (value !== undefined) {
            if (out.value !== value)
                throw new Error(`Error: value for ${txHex} and vout ${vout} does not correspond to ${value}`);
        }
        else {
            value = out.value;
        }
    }
    if (txId === undefined || !value)
        throw new Error(`Error: txHex+vout required. Alternatively, but ONLY for Segwit inputs, txId+value can also be passed.`);
    if (locktime) {
        if (psbt.locktime && psbt.locktime !== locktime)
            throw new Error(`Error: transaction locktime was already set with a different value: ${locktime} != ${psbt.locktime}`);
        // nLockTime only works if at least one of the transaction inputs has an
        // nSequence value that is below 0xffffffff. Let's make sure that at least
        // this input's sequence < 0xffffffff
        if (sequence === undefined) {
            //NOTE: if sequence is undefined, bitcoinjs-lib uses 0xffffffff as default
            sequence = rbf ? 0xfffffffd : 0xfffffffe;
        }
        else if (sequence > 0xfffffffe) {
            throw new Error(`Error: incompatible sequence: ${sequence} and locktime: ${locktime}`);
        }
        if (sequence === undefined && rbf)
            sequence = 0xfffffffd;
        psbt.setLocktime(locktime);
    }
    else {
        if (sequence === undefined) {
            if (rbf)
                sequence = 0xfffffffd;
            else
                sequence = 0xffffffff;
        }
    }
    const input = {
        hash: reverseBuffer(Buffer.from(txId, 'hex')),
        index: vout
    };
    if (txHex !== undefined) {
        input.nonWitnessUtxo = bitcoinjs_lib_1.Transaction.fromHex(txHex).toBuffer();
    }
    if (tapInternalKey) {
        //Taproot
        const tapBip32Derivation = keysInfo
            .filter((keyInfo) => keyInfo.pubkey && keyInfo.masterFingerprint && keyInfo.path)
            .map((keyInfo) => {
            const pubkey = keyInfo.pubkey;
            if (!pubkey)
                throw new Error(`key ${keyInfo.keyExpression} missing pubkey`);
            return {
                masterFingerprint: keyInfo.masterFingerprint,
                pubkey,
                path: keyInfo.path,
                leafHashes: [] // TODO: Empty array for tr(KEY) taproot key spend - this is the only type currently supported
            };
        });
        if (tapBip32Derivation.length)
            input.tapBip32Derivation = tapBip32Derivation;
        input.tapInternalKey = tapInternalKey;
        //TODO: currently only single-key taproot supported.
        //https://github.com/bitcoinjs/bitcoinjs-lib/blob/6ba8bb3ce20ba533eeaba6939cfc2891576d9969/test/integration/taproot.spec.ts#L243
        if (tapBip32Derivation.length > 1)
            throw new Error('Only single key taproot inputs are currently supported');
    }
    else {
        const bip32Derivation = keysInfo
            .filter((keyInfo) => keyInfo.pubkey && keyInfo.masterFingerprint && keyInfo.path)
            .map((keyInfo) => {
            const pubkey = keyInfo.pubkey;
            if (!pubkey)
                throw new Error(`key ${keyInfo.keyExpression} missing pubkey`);
            return {
                masterFingerprint: keyInfo.masterFingerprint,
                pubkey,
                path: keyInfo.path
            };
        });
        if (bip32Derivation.length)
            input.bip32Derivation = bip32Derivation;
    }
    if (isSegwit && txHex !== undefined) {
        //There's no need to put both witnessUtxo and nonWitnessUtxo
        input.witnessUtxo = { script: scriptPubKey, value };
    }
    if (sequence !== undefined)
        input.sequence = sequence;
    if (witnessScript)
        input.witnessScript = witnessScript;
    if (redeemScript)
        input.redeemScript = redeemScript;
    psbt.addInput(input);
    return psbt.data.inputs.length - 1;
}
exports.updatePsbt = updatePsbt;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bitcoinjs-lib":109,"buffer":167,"varuint-bitcoin":362}],9:[function(require,module,exports){
"use strict";
// Copyright (c) 2025 Jose-Luis Landabaso - https://bitcoinerlab.com
// Distributed under the MIT software license
Object.defineProperty(exports, "__esModule", { value: true });
exports.reWshMiniscriptAnchored = exports.reShWshMiniscriptAnchored = exports.reShMiniscriptAnchored = exports.reTrSingleKeyAnchored = exports.reShWpkhAnchored = exports.reWpkhAnchored = exports.rePkhAnchored = exports.reAddrAnchored = exports.rePkAnchored = exports.anchorStartAndEnd = exports.reTaprootKeyExp = exports.reSegwitKeyExp = exports.reNonSegwitKeyExp = exports.reXprvKey = exports.reXpubKey = exports.rePath = exports.reXprv = exports.reXpub = exports.reWIF = exports.reTaprootPubKey = exports.reSegwitPubKey = exports.reNonSegwitPubKey = exports.reChecksum = exports.reOrigin = exports.reMasterFingerprint = exports.reOriginPath = void 0;
const checksum_1 = require("./checksum");
//Regular expressions cheat sheet:
//https://www.keycdn.com/support/regex-cheat-sheet
//hardened characters
const reHardened = String.raw `(['hH])`;
//a level is a series of integers followed (optional) by a hardener char
const reLevel = String.raw `(\d+${reHardened}?)`;
//a path component is a level followed by a slash "/" char
const rePathComponent = String.raw `(${reLevel}\/)`;
//A path formed by a series of path components that can be hardened: /2'/23H/23
exports.reOriginPath = String.raw `(\/${rePathComponent}*${reLevel})`; //The "*" means: "match 0 or more of the previous"
//an origin is something like this: [d34db33f/44'/0'/0'] where the path is optional. The fingerPrint is 8 chars hex
exports.reMasterFingerprint = String.raw `[0-9a-fA-F]{8}`;
exports.reOrigin = String.raw `(\[${exports.reMasterFingerprint}(${exports.reOriginPath})?\])`;
exports.reChecksum = String.raw `(#[${checksum_1.CHECKSUM_CHARSET}]{8})`;
//Something like this: 0252972572d465d016d4c501887b8df303eee3ed602c056b1eb09260dfa0da0ab2
//as explained here: github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md#reference
const reCompressedPubKey = String.raw `((02|03)[0-9a-fA-F]{64})`;
const reUncompressedPubKey = String.raw `(04[0-9a-fA-F]{128})`;
const reXOnlyPubKey = String.raw `([0-9a-fA-F]{64})`;
exports.reNonSegwitPubKey = String.raw `(${reCompressedPubKey}|${reUncompressedPubKey})`;
exports.reSegwitPubKey = String.raw `(${reCompressedPubKey})`;
exports.reTaprootPubKey = String.raw `(${reCompressedPubKey}|${reXOnlyPubKey})`;
//https://learnmeabitcoin.com/technical/wif
//5, K, L for mainnet, 5: uncompressed, {K, L}: compressed
//c, 9, testnet, c: compressed, 9: uncompressed
exports.reWIF = String.raw `([5KLc9][1-9A-HJ-NP-Za-km-z]{50,51})`;
//x for mainnet, t for testnet
exports.reXpub = String.raw `([xXtT]pub[1-9A-HJ-NP-Za-km-z]{79,108})`;
exports.reXprv = String.raw `([xXtT]prv[1-9A-HJ-NP-Za-km-z]{79,108})`;
//reRangeLevel is like reLevel but using a wildcard "*"
const reRangeLevel = String.raw `(\*(${reHardened})?)`;
//A path can be finished with stuff like this: /23 or /23h or /* or /*'
exports.rePath = String.raw `(\/(${rePathComponent})*(${reRangeLevel}|${reLevel}))`;
//rePath is optional (note the "zero"): Followed by zero or more /NUM or /NUM' path elements to indicate unhardened or hardened derivation steps between the fingerprint and the key or xpub/xprv root that follows
exports.reXpubKey = String.raw `(${exports.reXpub})(${exports.rePath})?`;
exports.reXprvKey = String.raw `(${exports.reXprv})(${exports.rePath})?`;
//actualKey is the keyExpression without optional origin
const reNonSegwitActualKey = String.raw `(${exports.reXpubKey}|${exports.reXprvKey}|${exports.reNonSegwitPubKey}|${exports.reWIF})`;
const reSegwitActualKey = String.raw `(${exports.reXpubKey}|${exports.reXprvKey}|${exports.reSegwitPubKey}|${exports.reWIF})`;
const reTaprootActualKey = String.raw `(${exports.reXpubKey}|${exports.reXprvKey}|${exports.reTaprootPubKey}|${exports.reWIF})`;
//reOrigin is optional: Optionally, key origin information, consisting of:
//Matches a key expression: wif, xpub, xprv or pubkey:
exports.reNonSegwitKeyExp = String.raw `(${exports.reOrigin})?(${reNonSegwitActualKey})`;
exports.reSegwitKeyExp = String.raw `(${exports.reOrigin})?(${reSegwitActualKey})`;
exports.reTaprootKeyExp = String.raw `(${exports.reOrigin})?(${reTaprootActualKey})`;
const rePk = String.raw `pk\((.*?)\)`; //Matches anything. We assert later in the code that the pubkey is valid.
const reAddr = String.raw `addr\((.*?)\)`; //Matches anything. We assert later in the code that the address is valid.
const rePkh = String.raw `pkh\(${exports.reNonSegwitKeyExp}\)`;
const reWpkh = String.raw `wpkh\(${exports.reSegwitKeyExp}\)`;
const reShWpkh = String.raw `sh\(wpkh\(${exports.reSegwitKeyExp}\)\)`;
const reTrSingleKey = String.raw `tr\(${exports.reTaprootKeyExp}\)`; // TODO: tr(KEY,TREE) not yet supported. TrSingleKey used for tr(KEY)
const reMiniscript = String.raw `(.*?)`; //Matches anything. We assert later in the code that miniscripts are valid and sane.
//RegExp makers:
const makeReSh = (re) => String.raw `sh\(${re}\)`;
const makeReWsh = (re) => String.raw `wsh\(${re}\)`;
const makeReShWsh = (re) => makeReSh(makeReWsh(re));
const anchorStartAndEnd = (re) => String.raw `^${re}$`; //starts and finishes like re (not composable)
exports.anchorStartAndEnd = anchorStartAndEnd;
const composeChecksum = (re) => String.raw `${re}(${exports.reChecksum})?`; //it's optional (note the "?")
exports.rePkAnchored = (0, exports.anchorStartAndEnd)(composeChecksum(rePk));
exports.reAddrAnchored = (0, exports.anchorStartAndEnd)(composeChecksum(reAddr));
exports.rePkhAnchored = (0, exports.anchorStartAndEnd)(composeChecksum(rePkh));
exports.reWpkhAnchored = (0, exports.anchorStartAndEnd)(composeChecksum(reWpkh));
exports.reShWpkhAnchored = (0, exports.anchorStartAndEnd)(composeChecksum(reShWpkh));
exports.reTrSingleKeyAnchored = (0, exports.anchorStartAndEnd)(composeChecksum(reTrSingleKey));
exports.reShMiniscriptAnchored = (0, exports.anchorStartAndEnd)(composeChecksum(makeReSh(reMiniscript)));
exports.reShWshMiniscriptAnchored = (0, exports.anchorStartAndEnd)(composeChecksum(makeReShWsh(reMiniscript)));
exports.reWshMiniscriptAnchored = (0, exports.anchorStartAndEnd)(composeChecksum(makeReWsh(reMiniscript)));

},{"./checksum":2}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trLedger = exports.wpkhLedger = exports.shWpkhLedger = exports.pkhLedger = exports.trBIP32 = exports.wpkhBIP32 = exports.shWpkhBIP32 = exports.pkhBIP32 = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const keyExpressions_1 = require("./keyExpressions");
function assertStandardKeyPath(keyPath) {
    // Regular expression to match "/change/index" or "/change/*" format
    const regex = /^\/[01]\/(\d+|\*)$/;
    if (!regex.test(keyPath)) {
        throw new Error("Error: Key path must be in the format '/change/index', where change is either 0 or 1 and index is a non-negative integer.");
    }
}
function standardExpressionsBIP32Maker(purpose, scriptTemplate) {
    /**
     * Computes the standard descriptor based on given parameters.
     *
     * You can define the output location either by:
     * - Providing the full `keyPath` (e.g., "/0/2").
     * OR
     * - Specifying the `change` and `index` values separately (e.g., `{change:0, index:2}`).
     *
     * For ranged indexing, the `index` can be set as a wildcard '*'. For example:
     * - `keyPath="/0/*"`
     * OR
     * - `{change:0, index:'*'}`.
     */
    function standardScriptExpressionBIP32({ masterNode, network = bitcoinjs_lib_1.networks.bitcoin, keyPath, account, change, index, isPublic = true }) {
        const originPath = `/${purpose}'/${network === bitcoinjs_lib_1.networks.bitcoin ? 0 : 1}'/${account}'`;
        if (keyPath !== undefined)
            assertStandardKeyPath(keyPath);
        const keyExpression = (0, keyExpressions_1.keyExpressionBIP32)({
            masterNode,
            originPath,
            keyPath,
            change,
            index,
            isPublic
        });
        return scriptTemplate.replace('KEYEXPRESSION', keyExpression);
    }
    return standardScriptExpressionBIP32;
}
exports.pkhBIP32 = standardExpressionsBIP32Maker(44, 'pkh(KEYEXPRESSION)');
exports.shWpkhBIP32 = standardExpressionsBIP32Maker(49, 'sh(wpkh(KEYEXPRESSION))');
exports.wpkhBIP32 = standardExpressionsBIP32Maker(84, 'wpkh(KEYEXPRESSION)');
exports.trBIP32 = standardExpressionsBIP32Maker(86, 'tr(KEYEXPRESSION)');
function standardExpressionsLedgerMaker(purpose, scriptTemplate) {
    /** @hidden */
    async function standardScriptExpressionLedger({ ledgerClient, ledgerState, ledgerManager, network, account, keyPath, change, index }) {
        if (ledgerManager && (ledgerClient || ledgerState))
            throw new Error(`ledgerClient and ledgerState have been deprecated`);
        if (ledgerManager && network)
            throw new Error(`ledgerManager already includes the network object`);
        if (!ledgerManager && !network)
            network = bitcoinjs_lib_1.networks.bitcoin;
        if (ledgerManager)
            ({ ledgerClient, ledgerState, network } = ledgerManager);
        if (!ledgerClient || !ledgerState)
            throw new Error(`Could not retrieve ledgerClient or ledgerState`);
        const originPath = `/${purpose}'/${network === bitcoinjs_lib_1.networks.bitcoin ? 0 : 1}'/${account}'`;
        if (keyPath !== undefined)
            assertStandardKeyPath(keyPath);
        const keyExpression = await (0, keyExpressions_1.keyExpressionLedger)({
            ledgerClient,
            ledgerState,
            originPath,
            keyPath,
            change,
            index
        });
        return scriptTemplate.replace('KEYEXPRESSION', keyExpression);
    }
    return standardScriptExpressionLedger;
}
exports.pkhLedger = standardExpressionsLedgerMaker(44, 'pkh(KEYEXPRESSION)');
exports.shWpkhLedger = standardExpressionsLedgerMaker(49, 'sh(wpkh(KEYEXPRESSION))');
exports.wpkhLedger = standardExpressionsLedgerMaker(84, 'wpkh(KEYEXPRESSION)');
exports.trLedger = standardExpressionsLedgerMaker(86, 'tr(KEYEXPRESSION)');

},{"./keyExpressions":5,"bitcoinjs-lib":109}],11:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
// Copyright (c) 2025 Jose-Luis Landabaso - https://bitcoinerlab.com
// Distributed under the MIT software license
Object.defineProperty(exports, "__esModule", { value: true });
exports.signLedger = exports.signInputLedger = exports.signBIP32 = exports.signInputBIP32 = exports.signECPair = exports.signInputECPair = void 0;
const bip371_1 = require("bitcoinjs-lib/src/psbt/bip371");
const bip341_1 = require("bitcoinjs-lib/src/payments/bip341");
const ledger_1 = require("./ledger");
const applyPR2137_1 = require("./applyPR2137");
function range(n) {
    return [...Array(n).keys()];
}
/**
 * Signs a specific input of a PSBT with an ECPair.
 *
 * Unlike bitcoinjs-lib's native `psbt.signInput()`, this function automatically detects
 * if the input is a Taproot input and internally tweaks the key if needed.
 *
 * This behavior matches how `signInputBIP32` works, where the BIP32 node is automatically
 * tweaked for Taproot inputs. In contrast, bitcoinjs-lib's native implementation requires
 * manual pre-tweaking of ECPair signers for Taproot inputs.
 *
 * @see https://github.com/bitcoinjs/bitcoinjs-lib/pull/2137#issuecomment-2713264848
 *
 * @param {Object} params - The parameters object
 * @param {Psbt} params.psbt - The PSBT to sign
 * @param {number} params.index - The input index to sign
 * @param {ECPairInterface} params.ecpair - The ECPair to sign with
 */
function signInputECPair({ psbt, index, ecpair }) {
    //psbt.signInput(index, ecpair); <- Replaced for the code below
    //that can handle taroot inputs automatically.
    //See https://github.com/bitcoinjs/bitcoinjs-lib/pull/2137#issuecomment-2713264848
    const input = psbt.data.inputs[index];
    if (!input)
        throw new Error('Invalid index');
    if ((0, bip371_1.isTaprootInput)(input)) {
        const hash = (0, bip341_1.tapTweakHash)(Buffer.from(ecpair.publicKey.slice(1, 33)), undefined);
        const tweakedEcpair = ecpair.tweak(hash);
        psbt.signInput(index, tweakedEcpair);
    }
    else
        psbt.signInput(index, ecpair);
}
exports.signInputECPair = signInputECPair;
/**
 * Signs all inputs of a PSBT with an ECPair.
 *
 * This function improves upon bitcoinjs-lib's native `psbt.signAllInputs()` by automatically
 * handling Taproot inputs. For each input, it detects if it's a Taproot input and internally
 * tweaks the key if needed.
 *
 * This creates consistency with the BIP32 signing methods (`signBIP32`/`signInputBIP32`),
 * which also automatically handle key tweaking for Taproot inputs. In contrast, bitcoinjs-lib's
 * native implementation requires users to manually pre-tweak ECPair signers for Taproot inputs.
 *
 * With this implementation, you can use a single ECPair to sign both Taproot and non-Taproot
 * inputs in the same PSBT, similar to how `signBIP32` allows using a common node for both types.
 *
 * @see https://github.com/bitcoinjs/bitcoinjs-lib/pull/2137#issuecomment-2713264848
 *
 * @param {Object} params - The parameters object
 * @param {Psbt} params.psbt - The PSBT to sign
 * @param {ECPairInterface} params.ecpair - The ECPair to sign with
 */
function signECPair({ psbt, ecpair }) {
    //psbt.signAllInputs(ecpair); <- replaced for the code below that handles
    //taptoot automatically.
    //See https://github.com/bitcoinjs/bitcoinjs-lib/pull/2137#issuecomment-2713264848
    const results = [];
    for (const index of range(psbt.data.inputs.length)) {
        try {
            signInputECPair({ psbt, index, ecpair });
            results.push(true);
        }
        catch (err) {
            results.push(false);
        }
    }
    if (results.every(v => v === false)) {
        throw new Error('No inputs were signed');
    }
}
exports.signECPair = signECPair;
function signInputBIP32({ psbt, index, node }) {
    (0, applyPR2137_1.applyPR2137)(psbt);
    psbt.signInputHD(index, node);
}
exports.signInputBIP32 = signInputBIP32;
function signBIP32({ psbt, masterNode }) {
    (0, applyPR2137_1.applyPR2137)(psbt);
    psbt.signAllInputsHD(masterNode);
}
exports.signBIP32 = signBIP32;
const ledgerSignaturesForInputIndex = (index, ledgerSignatures) => ledgerSignatures
    .filter(([i]) => i === index)
    .map(([_i, partialSignature]) => ({
    pubkey: partialSignature.pubkey,
    signature: partialSignature.signature
}));
/**
 * To be removed in v3.0 and replaced by a version that does not accept
 * descriptor
 * @hidden
 */
async function signInputLedger({ psbt, index, descriptor, ledgerClient, ledgerState, ledgerManager }) {
    if (!descriptor && !ledgerManager)
        throw new Error(`ledgerManager not provided`);
    if (descriptor && ledgerManager)
        throw new Error(`Invalid usage: don't pass descriptor`);
    if (ledgerManager && (ledgerClient || ledgerState))
        throw new Error(`Invalid usage: either ledgerManager or ledgerClient + ledgerState`);
    const output = descriptor;
    if (ledgerManager)
        ({ ledgerClient, ledgerState } = ledgerManager);
    if (!ledgerClient)
        throw new Error(`ledgerManager not provided`);
    if (!ledgerState)
        throw new Error(`ledgerManager not provided`);
    const { PsbtV2, DefaultWalletPolicy, WalletPolicy, AppClient } = (await (0, ledger_1.importAndValidateLedgerBitcoin)(ledgerClient));
    if (!(ledgerClient instanceof AppClient))
        throw new Error(`Error: pass a valid ledgerClient`);
    let ledgerSignatures;
    if (ledgerManager) {
        if (psbt.data.inputs[index]?.tapInternalKey)
            throw new Error('Taproot inputs not yet supported for the Ledger device');
        const policy = await (0, ledger_1.ledgerPolicyFromPsbtInput)({
            psbt,
            index,
            ledgerManager
        });
        if (!policy)
            throw new Error(`Error: the ledger cannot sign this pstb input`);
        if (policy.policyName && policy.policyHmac && policy.policyId) {
            //non-standard policy
            const walletPolicy = new WalletPolicy(policy.policyName, policy.ledgerTemplate, policy.keyRoots);
            ledgerSignatures = await ledgerClient.signPsbt(new PsbtV2().fromBitcoinJS(psbt), walletPolicy, policy.policyHmac);
        }
        else {
            //standard policy
            ledgerSignatures = await ledgerClient.signPsbt(new PsbtV2().fromBitcoinJS(psbt), new DefaultWalletPolicy(policy.ledgerTemplate, policy.keyRoots[0]), null);
        }
    }
    else {
        if (!output)
            throw new Error(`outputs not provided`);
        const result = await (0, ledger_1.ledgerPolicyFromOutput)({
            output,
            ledgerClient,
            ledgerState
        });
        if (!result)
            throw new Error(`Error: output does not have a ledger input`);
        const { ledgerTemplate, keyRoots } = result;
        const standardPolicy = await (0, ledger_1.ledgerPolicyFromStandard)({
            output,
            ledgerClient,
            ledgerState
        });
        if (standardPolicy) {
            ledgerSignatures = await ledgerClient.signPsbt(new PsbtV2().fromBitcoinJS(psbt), new DefaultWalletPolicy(ledgerTemplate, keyRoots[0]), null);
        }
        else {
            const policy = await (0, ledger_1.ledgerPolicyFromState)({
                output,
                ledgerClient,
                ledgerState
            });
            if (!policy || !policy.policyName || !policy.policyHmac)
                throw new Error(`Error: the descriptor's policy is not registered`);
            const walletPolicy = new WalletPolicy(policy.policyName, ledgerTemplate, keyRoots);
            ledgerSignatures = await ledgerClient.signPsbt(new PsbtV2().fromBitcoinJS(psbt), walletPolicy, policy.policyHmac);
        }
    }
    //Add the signatures to the Psbt object using PartialSig format:
    psbt.updateInput(index, {
        partialSig: ledgerSignaturesForInputIndex(index, ledgerSignatures)
    });
}
exports.signInputLedger = signInputLedger;
/**
 * To be removed in v3.0 and replaced by a version that does not accept
 * descriptors
 * @hidden
 */
async function signLedger({ psbt, descriptors, ledgerClient, ledgerState, ledgerManager }) {
    if (!descriptors && !ledgerManager)
        throw new Error(`ledgerManager not provided`);
    if (descriptors && ledgerManager)
        throw new Error(`Invalid usage: don't pass descriptors`);
    if (ledgerManager && (ledgerClient || ledgerState))
        throw new Error(`Invalid usage: either ledgerManager or ledgerClient + ledgerState`);
    const outputs = descriptors;
    if (ledgerManager)
        ({ ledgerClient, ledgerState } = ledgerManager);
    if (!ledgerClient)
        throw new Error(`ledgerManager not provided`);
    if (!ledgerState)
        throw new Error(`ledgerManager not provided`);
    const { PsbtV2, DefaultWalletPolicy, WalletPolicy, AppClient } = (await (0, ledger_1.importAndValidateLedgerBitcoin)(ledgerClient));
    if (!(ledgerClient instanceof AppClient))
        throw new Error(`Error: pass a valid ledgerClient`);
    const ledgerPolicies = [];
    if (ledgerManager)
        for (let index = 0; index < psbt.data.inputs.length; index++) {
            if (psbt.data.inputs[index]?.tapInternalKey)
                throw new Error('Taproot inputs not yet supported for the Ledger device');
            const policy = await (0, ledger_1.ledgerPolicyFromPsbtInput)({
                psbt,
                index,
                ledgerManager
            });
            if (policy)
                ledgerPolicies.push(policy);
        }
    else {
        if (!outputs)
            throw new Error(`outputs not provided`);
        for (const output of outputs) {
            const policy = (await (0, ledger_1.ledgerPolicyFromState)({ output, ledgerClient, ledgerState })) ||
                (await (0, ledger_1.ledgerPolicyFromStandard)({ output, ledgerClient, ledgerState }));
            if (policy)
                ledgerPolicies.push(policy);
        }
        if (ledgerPolicies.length === 0)
            throw new Error(`Error: there are no inputs which could be signed`);
    }
    //cluster unique LedgerPolicies
    const uniquePolicies = [];
    for (const policy of ledgerPolicies) {
        if (!uniquePolicies.find((uniquePolicy) => (0, ledger_1.comparePolicies)(uniquePolicy, policy)))
            uniquePolicies.push(policy);
    }
    for (const uniquePolicy of uniquePolicies) {
        let ledgerSignatures;
        if (uniquePolicy.policyName &&
            uniquePolicy.policyHmac &&
            uniquePolicy.policyId) {
            //non-standard policy
            const walletPolicy = new WalletPolicy(uniquePolicy.policyName, uniquePolicy.ledgerTemplate, uniquePolicy.keyRoots);
            ledgerSignatures = await ledgerClient.signPsbt(new PsbtV2().fromBitcoinJS(psbt), walletPolicy, uniquePolicy.policyHmac);
        }
        else {
            //standard policy
            ledgerSignatures = await ledgerClient.signPsbt(new PsbtV2().fromBitcoinJS(psbt), new DefaultWalletPolicy(uniquePolicy.ledgerTemplate, uniquePolicy.keyRoots[0]), null);
        }
        for (const [index, ,] of ledgerSignatures) {
            psbt.updateInput(index, {
                partialSig: ledgerSignaturesForInputIndex(index, ledgerSignatures)
            });
        }
    }
}
exports.signLedger = signLedger;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./applyPR2137":1,"./ledger":6,"bitcoinjs-lib/src/payments/bip341":113,"bitcoinjs-lib/src/psbt/bip371":125,"buffer":167}],12:[function(require,module,exports){
'use strict';

var bip68 = require('bip68');

// Copyright (c) 2022 Jose-Luis Landabaso - https://bitcoinerlab.com

const ABSOLUTE = 'ABSOLUTE';
const RELATIVE = 'RELATIVE';

/**
 * Calculates the maximum lock time value between two lock time values (a and b)
 * using the specified lock type (ABSOLUTE or RELATIVE).
 * It asserts that there are no timeLock mixings.
 * It asserts that a or b are correctly encoded in bip68 format if they are
 * RELATIVE.
 * Either both a and b are block based or time based.
 * https://medium.com/blockstream/dont-mix-your-timelocks-d9939b665094
 *
 * If only a or b is undefined it asserts the value and returns it.
 * If none are defined it returns undefined.
 * @param {string|number} [a] - The first lock time value to compare.
 * @param {string|number} [b] - The second lock time value to compare.
 * @param {string} lockType - The type of lock time to use. Can be either "ABSOLUTE" or "RELATIVE".
 * @return {number} - The maximum lock time value between a and b.
 */

function maxLock(a, b, lockType) {
  if (typeof a === 'undefined' && typeof b === 'undefined') {
    return undefined;
  }
  if (typeof lockType === 'undefined')
    throw new Error('lockType must be specified');
  // Check that lockType is either "ABSOLUTE" or "RELATIVE"
  if (lockType !== ABSOLUTE && lockType !== RELATIVE)
    throw new Error('lockType must be either "ABSOLUTE" or "RELATIVE"');

  function isInteger(number) {
    const isNumeric = !isNaN(number) && !isNaN(parseFloat(number));
    if (isNumeric && Number.isInteger(Number(number))) return true;
    else return false;
  }
  if (typeof a !== 'undefined') {
    if (isInteger(a) === false)
      throw new Error('nSequence/nLockTime must be an integer: ' + a);
    a = Number(a);
    if (
      lockType === RELATIVE &&
      !bip68.decode(a).hasOwnProperty('seconds') &&
      !bip68.decode(a).hasOwnProperty('blocks')
    )
      throw new Error('Invalid bip68 encoded a value: ' + a);
  }
  if (typeof b !== 'undefined') {
    if (isInteger(b) === false)
      throw new Error('nSequence/nLockTime must be an integer: ' + b);
    b = Number(b);
    if (
      lockType === RELATIVE &&
      !bip68.decode(b).hasOwnProperty('seconds') &&
      !bip68.decode(b).hasOwnProperty('blocks')
    )
      throw new Error('Invalid bip68 encoded b value: ' + b);
  }

  if (typeof a !== 'undefined' && typeof b !== 'undefined') {
    if (lockType === ABSOLUTE) {
      // Both a and b must be either below 500000000 or both above or equal 500000000
      if (
        (a < 500000000 && b >= 500000000) ||
        (a >= 500000000 && b < 500000000)
      ) {
        throw new Error(
          'nLockTime values must be either below 500000000 or both above or equal 500000000'
        );
      }
    } else {
      const decodedA = bip68.decode(a);
      const decodedB = bip68.decode(b);

      if (
        decodedA.hasOwnProperty('seconds') !==
        decodedB.hasOwnProperty('seconds')
      ) {
        throw new Error(
          'a and b must both be either represent seconds or block height'
        );
      }
    }
    return Math.max(a, b);
  }

  if (typeof a !== 'undefined') return a;
  if (typeof b !== 'undefined') return b;
  return undefined;
}

// Copyright (c) 2022 Jose-Luis Landabaso - https://bitcoinerlab.com

/**
 * Given a `solutionTemplate`, such as "0 dsat(X) sat(Y) 1 sat(Z)", and given the
 * sat/dissatisfactions for X, Y, Z,... (comprised in `satisfactionsMap`) it
 * computes all the possible combination of solutions returned in an array
 * of {@link Solution}.
 *
 * Terminology:
 *
 * A solution of type {@link Solution} is an object
 * that contains an unlocking witness for a
 * miniscript fragment.
 *
 * When matching an unlocking witness with a locking
 * script, they can produce True or False. These solutions are called sats and
 * dsats, respectively.
 *
 * For example, take this solution: `sol = {asm:"sig key"}`.
 *
 * When matched with `DUP HASH160 <HASH160(key)> EQUALVERIFY CHECKSIG` it
 * produces `True`, that is, a valid sat solution: `<sig> <key> DUP HASH160 <HASH160(key)> EQUALVERIFY CHECKSIG`.
 *
 * A solution object can also contain other associated pieces of information: `solution: {asm, nLockTime, nSequence}`:
 *   -  nLockTime, nSequence: (number/str) interlock attached to this transaction
 *
 * A `solutionTemplate` describes a solution using sats and dsats of subexpressions.
 *
 * F.ex., this is a `solutionTemplate = "0 dsat(X) sat(Y) 1 sat(Z)"`.
 *
 * satisfactions is an object of type {@link Satisfactions}
 * that comprises both sat and dsat solutions for a
 * miniscript fragment:
 *
 *   `satisfactions = {sats: [sol_s1, sol_s2, ...], dsats: [sol_d1, ...]}`
 *
 * satisfactionsMap is a group of satisfactions:
 * ```javascript
 *   satisfactionsMap = { X: satisfactions_X, Y: satisfactions_Y, ...} =
 *   satisfactionsMap = {
 *                     X: {
 *                         sats: [sol_s1, sol_s2, ...],
 *                         dsats:[...]
 *                     },
 *                     Y: {sats: [...], dsats: [...]},
 *                     ...}
 * ```
 *
 * @param {string} solutionTemplate - a string containing sat or dsat expressions such as: "0 dsat(X) sat(Y) 1 sat(Z)"
 * @param {Object} satisfactionsMap - an object mapping the arguments for the sat and dsat expressions
 * in `solutionTemplate` (f.ex: `X, Y, Z`) to their {@link Satisfactions}.
 * @param {Satisfactions} [satisfactionsMap.X] - The satisfactions for `X`
 * @param {Satisfactions} [satisfactionsMap.Y] - The satisfactions for `Y`
 * @param {Satisfactions} [satisfactionsMap.Z] - The satisfactions for `Z`
 * @param {Satisfactions} [satisfactionsMap....] - The satisfactions for `...`
 *
 * @returns {Solution[]} an array of solutions, containing the resulting witness, nSequence and nLockTime values, and whether the solution has a HASSIG marker or should be marked as "DONTUSE".
 */

function combine(solutionTemplate, satisfactionsMap) {
  //First, break solutionTemplate into 3 parts:
  //  pre + curr + post,
  //where curr is the first sat(...)/dsat(...) in solutionTemplate.
  //
  //For example, in "0 dsat(X) sat(Y) 1 sat(Z)":
  //  pre= "0 "; curr = "dsat(X)"; post: " sat(Y) sat(Z)"
  //
  //Recursively call combine(post) until there are no further
  //sat()/dsat() in *post*

  //regExp that matches the first dsat(...) or sat(...):
  const reCurr = /d?sat\(([^\(]*)\)/;
  const currMatch = solutionTemplate.match(reCurr);

  if (currMatch && currMatch.length) {
    //The array of solutions to be computed and returned.
    const solutions = [];

    //curr is the first d?sat() matched in solutionTemplate:
    const curr = currMatch[0];
    //pre is whatever was before the first d?sat():
    const pre = solutionTemplate.split(curr)[0];
    //post is whatever was after the first d?sat():
    const post = solutionTemplate.slice(curr.length + pre.length);

    //the argument for curr: d?sat( -> argument <- ):
    //This will match the string "X" in the example above:
    //currArg = "X" for solutionTemplate "0 dsat(X) sat(Y) 1 sat(Z)"
    const currArg = currMatch[1];
    //currKey = "sats" or "dsats". "dsats" for the example above.
    const currKey = curr[0] === 'd' ? 'dsats' : 'sats';

    if (typeof satisfactionsMap[currArg] !== 'object')
      throw new Error(
        `satisfactionsMap does not provide sats/dsats solutions for argument ${currArg}, evaluating: ${solutionTemplate}`
      );
    const currSolutions = satisfactionsMap[currArg][currKey] || [];
    for (const currSolution of currSolutions) {
      //Does *post* contain further sat() or dsat() expressions?
      if (post.match(reCurr)) {
        //There are more sat/dsat, do a recursive call:
        const postSolutions = combine(post, satisfactionsMap);
        for (const postSolution of postSolutions) {
          //if ((currSolution.nLockTime && postSolution.nLockTime)) return [];
          solutions.push({
            nSequence: maxLock(
              currSolution.nSequence,
              postSolution.nSequence,
              RELATIVE
            ),
            nLockTime: maxLock(
              currSolution.nLockTime,
              postSolution.nLockTime,
              ABSOLUTE
            ),
            asm: `${pre}${currSolution.asm}${postSolution.asm}`
          });
        }
      } else {
        //This was the last instance of combine where there are no *post*
        //sat/dsats
        solutions.push({
          ...currSolution,
          asm: `${pre}${currSolution.asm}${post}`
        });
      }
    }
    //markDontUseSolutions(solutions);

    return solutions;
  }
  throw new Error('Invalid solutionTemplate: ' + solutionTemplate);
}

/**
 * An object containing functions for generating Basic satisfaction and dissatisfaction sets for miniscripts.
 *
 * @see {@link https://bitcoin.sipa.be/miniscript/}
 * @typedef {Object} SatisfactionsMaker
 *
 */
const satisfactionsMaker = {
  0: () => ({
    dsats: [{ asm: `` }]
  }),
  1: () => ({
    sats: [{ asm: `` }]
  }),
  pk_k: key => ({
    dsats: [{ asm: `0` }],
    sats: [{ asm: `<sig(${key})>` }]
  }),
  pk_h: key => ({
    dsats: [{ asm: `0 <${key}>` }],
    sats: [{ asm: `<sig(${key})> <${key}>` }]
  }),
  older: n => ({
    sats: [{ asm: ``, nSequence: n }]
  }),
  after: n => ({
    sats: [{ asm: ``, nLockTime: n }]
  }),
  sha256: h => ({
    sats: [{ asm: `<sha256_preimage(${h})>` }],
    dsats: [{ asm: `<random_preimage()>` }]
  }),
  ripemd160: h => ({
    sats: [{ asm: `<ripemd160_preimage(${h})>` }],
    dsats: [{ asm: `<random_preimage()>` }]
  }),
  hash256: h => ({
    sats: [{ asm: `<hash256_preimage(${h})>` }],
    dsats: [{ asm: `<random_preimage()>` }]
  }),
  hash160: h => ({
    sats: [{ asm: `<hash160_preimage(${h})>` }],
    dsats: [{ asm: `<random_preimage()>` }]
  }),
  andor: (X, Y, Z) => ({
    dsats: [
      ...combine(`dsat(Z) dsat(X)`, { X, Y, Z }),
      ...combine(`dsat(Y) sat(X)`, { X, Y, Z })
    ],
    sats: [
      ...combine('sat(Y) sat(X)', { X, Y, Z }),
      ...combine('sat(Z) dsat(X)', { X, Y, Z })
    ]
  }),
  and_v: (X, Y) => ({
    dsats: [...combine(`dsat(Y) sat(X)`, { X, Y })],
    sats: [...combine(`sat(Y) sat(X)`, { X, Y })]
  }),
  and_b: (X, Y) => ({
    dsats: [
      ...combine(`dsat(Y) dsat(X)`, { X, Y }),
      //https://bitcoin.sipa.be/miniscript/
      //The non-canonical options for and_b, or_b, and thresh are always
      //overcomplete (reason 3), so instead use DONTUSE there
      ...combine(`sat(Y) dsat(X)`, { X, Y }),
      ...combine(`dsat(Y) sat(X)`, { X, Y })
    ],
    sats: [...combine(`sat(Y) sat(X)`, { Y, X })]
  }),
  or_b: (X, Z) => ({
    dsats: [...combine(`dsat(Z) dsat(X)`, { X, Z })],
    sats: [
      ...combine(`dsat(Z) sat(X)`, { X, Z }),
      ...combine(`sat(Z) dsat(X)`, { X, Z }),
      //https://bitcoin.sipa.be/miniscript/
      //The non-canonical options for and_b, or_b, and thresh are always
      //overcomplete (reason 3), so instead use DONTUSE there
      ...combine(`sat(Z) sat(X)`, { X, Z })
    ]
  }),
  or_c: (X, Z) => ({
    sats: [
      ...combine(`sat(X)`, { X, Z }),
      ...combine(`sat(Z) dsat(X)`, { X, Z })
    ]
  }),
  or_d: (X, Z) => ({
    dsats: [...combine(`dsat(Z) dsat(X)`, { X, Z })],
    sats: [
      ...combine(`sat(X)`, { X, Z }),
      ...combine(`sat(Z) dsat(X)`, { X, Z })
    ]
  }),
  or_i: (X, Z) => ({
    dsats: [
      ...combine(`dsat(X) 1`, { X, Z }),
      ...combine(`dsat(Z) 0`, { X, Z })
    ],
    sats: [...combine(`sat(X) 1`, { X, Z }), ...combine(`sat(Z) 0`, { X, Z })]
  }),
  /*
   * This is not entirely trivial from the docs
   * (https://bitcoin.sipa.be/miniscript/),
   *  but solution templates for thresh must be written in reverse order.
   *  For example the first dsat, which is "All dsats", corresponds to:
   *  "<DSAT_N> <DSAT_N-1> ... <DSAT_1>" (note the reverse order in N)
   *  While this is not entirely trivial by reading the document
   *  it can be deduced by analyzing the script:
   *  thresh(k,X1,...,Xn)	[X1] [X2] ADD ... [Xn] ADD ... <k> EQUAL
   */
  thresh: (k, ...satisfactionsArray) => {
    if (Number.isInteger(Number(k)) && Number(k) > 0) k = Number(k);
    else throw new Error(`k must be positive number: ${k}`);

    //First, convert input satisfactions (which are dynamic for thresh
    //and multi) into an object.
    //For example, if input was, thresh(k, X, Y, Z), then
    //create an object like this: satisfactionsMap = {X, Y, Z};
    const satisfactionsMap = {};
    const N = satisfactionsArray.length;
    satisfactionsArray.map((satisfactions, index) => {
      satisfactionsMap[index] = satisfactions;
    });

    const dsats = [];
    const sats = [];
    //Push the canonical dsat (All dsats):
    //"<DSAT_N> <DSAT_N-1> ... <DSAT_1>" (note the reverse order)
    dsats.push(
      ...combine(
        Object.keys(satisfactionsMap)
          .map(mapKeyName => `dsat(${mapKeyName})`)
          .reverse()
          .join(' '),
        satisfactionsMap
      )
    );

    const dsatsNonCanSolutionTemplates = []; //Sats/dsats with 1 ≤ #(sats) ≠ k
    const satsSolutionTemplates = []; //Sats/dsats with #(sats) = k
    for (let i = 1; i < 1 << N; i++) {
      const c = [];
      let totalSatisfactions = 0;
      for (let j = 0; j < N; j++) {
        if (i & (1 << j)) totalSatisfactions++;
        c.push(i & (1 << j) ? `sat(${j})` : `dsat(${j})`);
      }
      if (totalSatisfactions !== k)
        dsatsNonCanSolutionTemplates.push(c.reverse().join(' '));
      else satsSolutionTemplates.push(c.reverse().join(' '));
    }

    //Push the non canonical dsats:
    for (const solutionTemplate of dsatsNonCanSolutionTemplates) {
      //https://bitcoin.sipa.be/miniscript/
      //The non-canonical options for and_b, or_b, and thresh are always
      //overcomplete (reason 3), so instead use DONTUSE there
      dsats.push(...combine(solutionTemplate, satisfactionsMap));
    }

    //Push the sats (which all are canonical):
    for (const solutionTemplate of satsSolutionTemplates) {
      sats.push(...combine(solutionTemplate, satisfactionsMap));
    }

    return { dsats, sats };
  },
  multi: (k, ...keys) => {
    if (Number.isInteger(Number(k)) && Number(k) > 0) k = Number(k);
    else throw new Error(`k must be positive number: ${k}`);

    //Example of a multi-sig locking script:
    //OP_3 <pubKey1> <pubKey2> <pubKey3> <pubKey4> OP_4 OP_CHECKMULTISIG
    //unlockingScript: OP_0 <sig1> <sig2> <sig4>
    //OP_0 is a dummy OP, needed because of a bug in Bitcoin
    if (typeof k !== 'number') throw new Error('k must be a number:' + k);
    if (k === 0) throw new Error('k cannot be 0');
    const dsats = [{ asm: '0 '.repeat(k + 1).trim() }];

    // Create all combinations of k signatures
    function keyCombinations(keys, k) {
      if (k === 0) {
        return [[]];
      }

      const combinations = [];

      for (let i = 0; i < keys.length; i++) {
        const remainingKeys = keys.slice(i + 1);
        const subCombinations = keyCombinations(remainingKeys, k - 1);
        subCombinations.forEach(combination => {
          combinations.push([keys[i], ...combination]);
        });
      }

      return combinations;
    }

    const asms = [];
    // Create asms from keyCombination
    keyCombinations(keys, k).forEach(combination => {
      let asm = '0';
      combination.forEach(key => {
        asm += ` <sig(${key})>`;
      });
      asms.push(asm);
    });

    let asm = '0';
    for (let i = 0; i < k; i++) {
      asm += ` <sig(${keys[i]})>`;
    }
    const sats = asms.map(asm => ({ asm }));

    return { sats, dsats };
  },
  a: X => ({
    dsats: [...combine(`dsat(X)`, { X })],
    sats: [...combine(`sat(X)`, { X })]
  }),
  s: X => ({
    dsats: [...combine(`dsat(X)`, { X })],
    sats: [...combine(`sat(X)`, { X })]
  }),
  c: X => ({
    dsats: [...combine(`dsat(X)`, { X })],
    sats: [...combine(`sat(X)`, { X })]
  }),
  d: X => ({
    dsats: [{ asm: `0` }],
    sats: [...combine(`sat(X) 1`, { X })]
  }),
  v: X => ({
    sats: [...combine(`sat(X)`, { X })]
  }),

  /**
   * j:X corresponds to SIZE 0NOTEQUAL IF [X] ENDIF
   *
   * By definition, this: "dsat(X) X" produces a zero.
   *
   *
   * A dsat needs to make this "dsat(X) X" return zero.

   * The easiest dsat for j:X is using 0:
   * 0 SIZE 0NOTEQUAL IF [X] ENDIF
   * 0 0 0NOTEQUAL IF [X] ENDIF
   * 0 0 IF [X] ENDIF
   * 0

   * Now let's do the case where dsat(X) finishes with a 0: "... 0"
   * ... 0 SIZE 0NOTEQUAL IF [X] ENDIF
   * ... 0 0 0NOTEQUAL IF [X] ENDIF
   * ... 0 0 IF [X] ENDIF 
   * ... 0
   * DSAT(X)
   * The final expression is "DSAT(X)".
   * It should have either been "0" or "DSAT(X) X"
   * Thus, this is not a valid dsat.

   * Now let's do the case where dsat(X) is this: "... <nonzero>"
   * ... <nonzero> SIZE 0NOTEQUAL IF [X] ENDIF
   * ... <nonzero> <length_is_nonzero> 0NOTEQUAL IF [X] ENDIF
   * ... <nonzero> 1 IF [X] ENDIF
   * ... <nonzero> [X]
   * DSAT(X) [X]

   * DSAT(X) X is a good dsat
   */
  j: X => {
    const dsats = [];

    dsats.push({ asm: `0` });

    //Filter the dsats of X with Non Zero Top Stack (nztp).
    const dsats_nzts = X.dsats.filter(
      //The top stack corresponds to the last element pushed to the stack,
      //that is, the last element in the produced witness
      solution => solution.asm.trim().split(' ').pop() !== '0'
    );
    dsats.push(...dsats_nzts);

    return { dsats, sats: [...combine(`sat(X)`, { X })] };
  },
  n: X => ({
    dsats: [...combine(`dsat(X)`, { X })],
    sats: [...combine(`sat(X)`, { X })]
  })
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var bindings = createCommonjsModule(function (module, exports) {
var Module = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  
  return (
function(moduleArg = {}) {

var Module=moduleArg;var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject;});var moduleOverrides=Object.assign({},Module);var thisProgram="./this.program";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}{if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src;}if(_scriptDir){scriptDirectory=_scriptDir;}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1);}else {scriptDirectory="";}}Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];Module["noExitRuntime"]||true;var WebAssembly={Memory:function(opts){this.buffer=new ArrayBuffer(opts["initial"]*65536);},Module:function(binary){},Instance:function(module,info){this.exports=(
// EMSCRIPTEN_START_ASM
function instantiate(_a){function c(d){d.set=function(a,b){this[a]=b;};d.get=function(a){return this[a]};return d}var e;var f=new Uint8Array(123);for(var a=25;a>=0;--a){f[48+a]=52+a;f[65+a]=a;f[97+a]=26+a;}f[43]=62;f[47]=63;function l(m,n,o){var g,h,a=0,i=n,j=o.length,k=n+(j*3>>2)-(o[j-2]=="=")-(o[j-1]=="=");for(;a<j;a+=4){g=f[o.charCodeAt(a+1)];h=f[o.charCodeAt(a+2)];m[i++]=f[o.charCodeAt(a)]<<2|g>>4;if(i<k)m[i++]=g<<4|h>>2;if(i<k)m[i++]=h<<6|f[o.charCodeAt(a+3)];}}function p(q){l(e,1024,"ZG16AFZ6AGluZmluaXR5AGNoYW5nZV9jYXBhY2l0eQBGZWJydWFyeQBKYW51YXJ5AEp1bHkAVGh1cnNkYXkAVHVlc2RheQBXZWRuZXNkYXkAU2F0dXJkYXkAU3VuZGF5AE1vbmRheQBGcmlkYXkATWF5ACVtLyVkLyV5AGR1eABCL3pvbm1zeABWL3Vuem9mbXN4AEsvdW56b2Ztc3gAQi91bnpvZm1zeABCby91ZGZlbXN4AGZ4AG5keAAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AF9fbmV4dF9wcmltZSBvdmVyZmxvdwBOb3YAYW5kX3YAVGh1AFdlbWR1AEJlbWR1AFdkdQBCZHUAQXVndXN0AHN0ZDo6YmFkX2Nhc3QAQ29tcHV0aW5nIENvc3RQYWlyIG9mIHVua25vd24gZnJhZ21lbnQAbmV3X2luZGlyZWN0AF91bmlvbi5pbmRpcmVjdABPY3QAU2F0AHpzAGsgPj0gMSAmJiBrIDw9IG5fa2V5cwB1cwBDYWxjT3BzAG91bXMAVi9uem9tcwBCZHVlL3pvbXMAV2RlL3pvbXMAQmRlL3pvbXMAVi96b21zAFYvbnNvbXMAem9ubXMAVi96Zm1zAFYvem91Zm1zAEsvem91Zm1zAEIvem91Zm1zAEJuL291Zm1zAFYvenVkZmVtcwBLL3p1ZGZlbXMAQi96dWRmZW1zAFYvem91ZGZlbXMASy96b3VkZmVtcwBCL3pvdWRmZW1zAEIvdWRmZW1zAEJ6b25kZmVtcwBXL3pvbmRmZW1zAEIvem9uZGZlbXMAQm1zAFZCS3VmcwB6ZXMAayA+PSAxICYmIGsgPD0gbl9zdWJzAEdldFBRcwBBcHIAdmVjdG9yAHVuc3BlY2lmaWVkIGlvc3RyZWFtX2NhdGVnb3J5IGVycm9yAG1vbmV5X2dldCBlcnJvcgBDYWxjQ29zdFBhaXIAR2V0VHlwZUZpbHRlcgBhZnRlcgBvbGRlcgBPY3RvYmVyAE5vdmVtYmVyAFNlcHRlbWJlcgBEZWNlbWJlcgBpb3NfYmFzZTo6Y2xlYXIATWFyAGl0LT5zZWNvbmQucSA9PSBxAG1pbmlzY3JpcHQvYml0Y29pbi9zY3JpcHQvbWluaXNjcmlwdC5jcHAAbWluaXNjcmlwdC9jb21waWxlci5jcHAAU2VwACVJOiVNOiVTICVwAGl0LT5zZWNvbmQucCA9PSBwAEJvAFN1bgBKdW4Ac3RkOjpleGNlcHRpb24AR2V0Q29tcGlsYXRpb24ATW9uAENvbXB1dGVTY3JpcHRMZW4AbmFuAEphbgBCbgBkem0Ab25kZmVtAGlvc3RyZWFtAEp1bABsbABBcHJpbABVbmtub3duIGNoYXJhY3RlciBpbiBfbXN0IGxpdGVyYWwAQnp1ZGVtc3hrAEtvbnVkZW1zeGsAS251ZGVtc3hrAEJ6Zm14awBCenVmbXhrAEJudWRlbXNrAEJvbnVkbWsAZ2hpamsAZ2hpagBGcmkAYmFkX2FycmF5X25ld19sZW5ndGgAdGhyZXNoAE1hcmNoAG1pbmlzY3JpcHQvYml0Y29pbi9zY3JpcHQvbWluaXNjcmlwdC5oAG1pbmlzY3JpcHQvYml0Y29pbi9wcmV2ZWN0b3IuaABBdWcAYmFzaWNfc3RyaW5nAHNmAGluZgAlLjBMZgAlTGYAJWYAQ2FsY1N0YWNrU2l6ZQB0cnVlAFR1ZQB6c2UAUGFyc2UAZmFsc2UAU2FuaXRpemVUeXBlAENvbXB1dGVUeXBlAEp1bmUAQ29tcGlsZQBDU2NyaXB0OjpvcGVyYXRvcjw8KCk6IGludmFsaWQgb3Bjb2RlAEsvb25kZQBUcmVlRXZhbE1heWJlAGl0Mi5zZWNvbmQAYW5kAHVmZABsb2NhbGUgbm90IHN1cHBvcnRlZABXZWQAQWRkAFdkAEJkAFVua25vd24gZXJyb3IgJWQAc3RkOjpiYWRfYWxsb2MARGVjAEZlYgBhbmRfYgBhAC4tXwBbYW5hbHlzaXMgZXJyb3JdAFtjb21waWxlIGVycm9yXQBhbmRvciBbb3JdAFtpbnZhbGlkXQBPUF9WRVJJRlkAT1BfRVFVQUxWRVJJRlkAT1BfTlVNRVFVQUxWRVJJRlkAT1BfQ0hFQ0tTSUdWRVJJRlkAT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWQBPUF9DSEVDS0xPQ0tUSU1FVkVSSUZZAE9QX0NIRUNLU0VRVUVOQ0VWRVJJRlkAJWEgJWIgJWQgJUg6JU06JVMgJVkAUE9TSVgAT1BfTUFYAFcAQktWAE9QX0RJVgBPUF8yRElWAE9QX0lOVkVSVABPUF9ST1QAT1BfMlJPVABPUF9OT1QAT1BfUklHSFQAT1BfUlNISUZUAE9QX0xTSElGVABPUF9MRUZUAE9QX0NBVABPUF9BQlMAJUg6JU06JVMAT1BfU1VCU1RSAE9QX09SAE9QX1hPUgBPUF9DT0RFU0VQQVJBVE9SAE9QX0JPT0xPUgBPUF9WRVIAT1BfT1ZFUgBPUF8yT1ZFUgBPUF9EVVAAT1BfSUZEVVAAT1BfM0RVUABPUF8yRFVQAE9QX0RST1AAT1BfMkRST1AAT1BfTk9QAE9QX05JUABPUF9TV0FQAE9QXzJTV0FQAE9QX1VOS05PV04AT1BfUkVUVVJOAE9QX01JTgBPUF9XSVRISU4ATkFOAE9QX0xFU1NUSEFOAE9QX0dSRUFURVJUSEFOAFBNAEFNAE9QX01VTABPUF8yTVVMAGsgPj0gMSAmJiBrIDwgMHg4MDAwMDAwMFVMAE9QX1JPTEwATENfQUxMAE9QX0VRVUFMAE9QX05VTU5PVEVRVUFMAE9QXzBOT1RFUVVBTABPUF9MRVNTVEhBTk9SRVFVQUwAT1BfR1JFQVRFUlRIQU5PUkVRVUFMAE9QX05VTUVRVUFMAE9QX1RVQ0sAT1BfUElDSwBPUF9UT0FMVFNUQUNLAE9QX0ZST01BTFRTVEFDSwBPUF9ERVBUSABMQU5HAE9QX0NIRUNLU0lHAE9QX0NIRUNLTVVMVElTSUcASU5GAE9QX0lGAE9QX05PVElGAE9QX1ZFUk5PVElGAE9QX1ZFUklGAE9QX0VORElGAE9QX1NJWkUAT1BfTkVHQVRFAE9QX0VMU0UAc3RyYXQtPm5vZGVfdHlwZSA9PSBTdHJhdDo6VHlwZTo6Q0FDSEUAT1BfSU5WQUxJRE9QQ09ERQBPUF9NT0QAT1BfQU5EAE9QX0JPT0xBTkQAT1BfUkVTRVJWRUQAT1BfQUREAE9QXzFBREQAQwBLVkIAT1BfU1VCAE9QXzFTVUIAPC9zcGFuPgAgV1U8L2xpPjwvdWw+ACBieXRlcyBzY3JpcHQ8dWw+PGxpPgA8L2xpPjwvdWw+PC9saT48bGk+ADx1bCBzdHlsZT0ibGlzdC1zdHlsZS10eXBlOiBkaXNjOyI+PGxpPmFuZG9yIFthbmRdPHVsIHN0eWxlPSJsaXN0LXN0eWxlLXR5cGU6IGRpc2M7Ij48bGk+ADwvbGk+ADxIPgApPgA8dWwgc3R5bGU9Imxpc3Qtc3R5bGUtdHlwZTogZGlzYzsiPgA8ADoAT1BfTk9QOQBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OQBPUF9OT1A4AEMuVVRGLTgAT1BfTk9QNwBPUF9OT1A2AGhhc2gyNTYAc2hhMjU2AE9QX0hBU0gyNTYAT1BfU0hBMjU2ADE2AE9QX05PUDUAMTUAT1BfTk9QNABPUF9QVVNIREFUQTQAMTQAMTMAbl9zdWJzID09IDMAT1BfUkVTRVJWRUQyAE9QX1BVU0hEQVRBMgBkYXRhX3NpemUgPT0gMzIAMTIAbl9zdWJzID09IDIAT1BfTk9QMQBPUF9SRVNFUlZFRDEAT1BfUFVTSERBVEExAE9QX1NIQTEAMTEALTEAbl9rZXlzID09IDEAbnVtX3R5cGVzID09IDEAbl9zdWJzID09IDEAcmVzdWx0cy5zaXplKCkgPT0gMQBjb25zdHJ1Y3RlZC5zaXplKCkgPT0gMQByZXNfVy5zaXplKCkgPT0gMQByZXNfQi5zaXplKCkgPT0gMQBoYXNoMTYwAHJpcGVtZDE2MABPUF9IQVNIMTYwAE9QX1JJUEVNRDE2MABkYXRhX3NpemUgPT0gMjAAbl9rZXlzID49IDEgJiYgbl9rZXlzIDw9IDIwAE9QX05PUDEwAHN0cmF0LT5zdWIuc2l6ZSgpID4gMABuX2tleXMgPT0gMABuX3N1YnMgPT0gMABsID09IDAAayA9PSAwAGRhdGFfc2l6ZSA9PSAwAC4ALAAhKGUgPDwgIm4iX21zdCkgfHwgIShlIDw8ICJ6Il9tc3QpACEoZSA8PCAiViJfbXN0KSB8fCAhKGUgPDwgInUiX21zdCkAIShlIDw8ICJLIl9tc3QpIHx8IChlIDw8ICJ1Il9tc3QpACEoZSA8PCAiSyJfbXN0KSB8fCAoZSA8PCAicyJfbXN0KQAhKGUgPDwgInoiX21zdCkgfHwgIShlIDw8ICJvIl9tc3QpACEoZSA8PCAieiJfbXN0KSB8fCAoZSA8PCAibSJfbXN0KQAhKGUgPDwgImUiX21zdCkgfHwgIShlIDw8ICJmIl9tc3QpACEoZSA8PCAiZCJfbXN0KSB8fCAhKGUgPDwgImYiX21zdCkAIShlIDw8ICJWIl9tc3QpIHx8IChlIDw8ICJmIl9tc3QpACEoZSA8PCAiViJfbXN0KSB8fCAhKGUgPDwgImUiX21zdCkAIShlIDw8ICJWIl9tc3QpIHx8ICEoZSA8PCAiZCJfbXN0KQAhKGUgPDwgImUiX21zdCkgfHwgKGUgPDwgImQiX21zdCkAIShlIDw8ICJuIl9tc3QpIHx8ICEoZSA8PCAiVyJfbXN0KQAobnVsbCkAaGFzaDI1NihIKQBzaGEyNTYoSCkAaGFzaDE2MChIKQByaXBlbWQxNjAoSCkAaGFzaDE2MCg5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5KQByaXBlbWQxNjAoOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSkAaGFzaDI1Nig4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4KQBzaGEyNTYoODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OCkAb3BlcmF0b3IoKQBrIDw9IHNhdHMuc2l6ZSgpAHJlc3VsdHMuc2l6ZSgpID49IG5vZGUuc3Vicy5zaXplKCkAcy5zaXplKCkgPT0gZmlsdGVyW2pdLnNpemUoKQAgLiw7LV8vOj9AKCkAaGFzaDI1NigpAGhhc2gxNjAoKQByaXBlbWQxNjAoKQBhbmRfdigAYW5kb3IoAGFmdGVyKABvbGRlcigAYW5kX24oAHBrKABwa19rKABtdWx0aSgAb3JfaSgAdGhyZXNoKABwa2goAHBrX2goAG9yX2QoAG9yX2MoAG9yX2IoAGFuZF9iKABoYXNoMjU2KABzaGEyNTYoAGhhc2gxNjAoAHJpcGVtZDE2MCgAPEhBU0gxNjAoACEqJygpOzpAJj0rJCwvPyNbXS1fLn4lACBvZiAAIFdVPC9saT48bGk+SW5wdXQ6IAA8dWw+PGxpPlNjcmlwdDogACYjMTM7bWF4IG9wczogAFtleGNlcHRpb246IAAmIzEzO3NjcmlwdGxlbjogACBXVTwvbGk+PGxpPlRvdGFsOiAAJiMxMzttYXggc3RhY2sgc2l6ZTogAFNpemU6IAA8c3BhbiB0aXRsZT0idHlwZTogACAg");l(e,5584,"////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg///////////////////////////////////woLDA0OD/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////4QAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADEDwAAgw8AAFcPAADcDwAAtw0AAFQQAACtDwAAdA8AAGUPAABNDwAAQg8AABMPAAALDwAA+w4AALIQAADZDwAAoA8AAGcPAABkDwAATA8AAEEPAADFCwAAfAsAAB8NAAAlDQAAOg0AAC4NAABeDQAAQw0AADUKAADvCwAA0gwAAOAMAAC8CwAArAsAAKQLAACLCwAA/woAANsLAACbCwAA8AwAALQLAACUCwAAzAsAAIMLAADKDAAAWQwAAPgKAADTCwAAwgwAADMLAABKCwAAKwsAAA4LAABMDQAA7goAAKUNAABUCwAAWgsAAGgMAAA/CgAAtw8AAHYPAADKDQAA3w0AADYMAADmCgAAVA0AADoLAAAHCwAAgAwAAMMNAADYDQAALwwAAN8KAACeDQAAIQsAABcLAACsDQAAcgsAALYMAABOCgAAcQwAAA4MAAAaDAAAjQwAAKAMAAD5CwAA0goAAAAMAABzEAAA0Q8AADcPAABoEAAALA8AAGELAAD+DAAAYAoAAAoNAAByCgAArw8AAIkKAACgCgAATw8AAEQPAAAVDwAADQ8AAP0OAAC2DgAArBAAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAOQLAADkCwAA5AsAAI0NAAAEXwAABF8AAARfAAAEXwAABF8AAARfAAAEXwAABF8AAARfAAAEXwAAFF8AACRfAAA0XwAARF8AAFRfAABkXwAAdF8AAIRfAACUXwAApF8AAMRfAAC0XwAA1F8AAORfAAAEXwAABF8=");l(e,6976,"MDEyMzQ1Njc4OWFiY2RlZgAAAAAAAAAAJAEAACUBAAAmAQAAJwEAACgBAAAAAAAAGQAKABkZGQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAAZABEKGRkZAwoHAAEACQsYAAAJBgsAAAsABhkAAAAZGRk=");l(e,7105,"DgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAO");l(e,7163,"DA==");l(e,7175,"EwAAAAATAAAAAAkMAAAAAAAMAAAM");l(e,7221,"EA==");l(e,7233,"DwAAAAQPAAAAAAkQAAAAAAAQAAAQ");l(e,7279,"Eg==");l(e,7291,"EQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoa");l(e,7346,"GgAAABoaGgAAAAAAAAk=");l(e,7395,"FA==");l(e,7407,"FwAAAAAXAAAAAAkUAAAAAAAUAAAU");l(e,7453,"Fg==");l(e,7465,"FQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVGAAAAAAIAAAADAAAABQAAAAcAAAALAAAADQAAABEAAAATAAAAFwAAAB0AAAAfAAAAJQAAACkAAAArAAAALwAAADUAAAA7AAAAPQAAAEMAAABHAAAASQAAAE8AAABTAAAAWQAAAGEAAABlAAAAZwAAAGsAAABtAAAAcQAAAH8AAACDAAAAiQAAAIsAAACVAAAAlwAAAJ0AAACjAAAApwAAAK0AAACzAAAAtQAAAL8AAADBAAAAxQAAAMcAAADTAAAAAQAAAAsAAAANAAAAEQAAABMAAAAXAAAAHQAAAB8AAAAlAAAAKQAAACsAAAAvAAAANQAAADsAAAA9AAAAQwAAAEcAAABJAAAATwAAAFMAAABZAAAAYQAAAGUAAABnAAAAawAAAG0AAABxAAAAeQAAAH8AAACDAAAAiQAAAIsAAACPAAAAlQAAAJcAAACdAAAAowAAAKcAAACpAAAArQAAALMAAAC1AAAAuwAAAL8AAADBAAAAxQAAAMcAAADRAAAAAAAAALwfAAApAQAAKgEAACsBAAAsAQAALQEAAC4BAAAvAQAAMAEAADEBAAAyAQAAMwEAADQBAAA1AQAANgEAAAAAAABQIAAANwEAADgBAAArAQAALAEAADkBAAA6AQAALwEAADABAAAxAQAAOwEAADMBAAA8AQAANQEAAD0BAABOU3QzX18yOWJhc2ljX2lvc0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQAAACRZAABQHwAAXCEAAE5TdDNfXzIxNWJhc2ljX3N0cmVhbWJ1ZkljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQAAAADkWAAAiB8AAE5TdDNfXzIxM2Jhc2ljX29zdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAABXAADEHwAAAAAAAAEAAAB8HwAAA/T//05TdDNfXzIxNWJhc2ljX3N0cmluZ2J1ZkljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAAAAJFkAAAwgAAC8HwAAOAAAAAAAAAD0IAAAPgEAAD8BAADI////yP////QgAABAAQAAQQEAADgAAAAAAAAA9B8AAEIBAABDAQAAyP///8j////0HwAARAEAAEUBAABOU3QzX18yMTliYXNpY19vc3RyaW5nc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAAAkWQAArCAAAPQfAAAAAAAArCEAAEYBAABHAQAASAEAAEkBAABKAQAASwEAAEwBAAAAAAAAgCEAALEAAABNAQAATgEAAAAAAABcIQAATwEAAFABAABOU3QzX18yOGlvc19iYXNlRQAAAORYAABIIQAATlN0M19fMjhpb3NfYmFzZTdmYWlsdXJlRQAAACRZAABkIQAAlFUAAE5TdDNfXzIxOV9faW9zdHJlYW1fY2F0ZWdvcnlFAAAAJFkAAIwhAADkVQ==");l(e,8640,"/////////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP///////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAQIEBwMGBQAAAAAAAADRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///8AAAAAAAAAAN4SBJUAAAAA////////////////");l(e,9024,"TENfQ1RZUEUAAAAATENfTlVNRVJJQwAATENfVElNRQAAAAAATENfQ09MTEFURQAATENfTU9ORVRBUlkATENfTUVTU0FHRVMAICMAABQAAABDLlVURi04");l(e,9652,"AQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAGEAAABiAAAAYwAAAGQAAABlAAAAZgAAAGcAAABoAAAAaQAAAGoAAABrAAAAbAAAAG0AAABuAAAAbwAAAHAAAABxAAAAcgAAAHMAAAB0AAAAdQAAAHYAAAB3AAAAeAAAAHkAAAB6AAAAWwAAAFwAAABdAAAAXgAAAF8AAABgAAAAYQAAAGIAAABjAAAAZAAAAGUAAABmAAAAZwAAAGgAAABpAAAAagAAAGsAAABsAAAAbQAAAG4AAABvAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAfw==");l(e,11188,"AQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAAQwAAAEQAAABFAAAARgAAAEcAAABIAAAASQAAAEoAAABLAAAATAAAAE0AAABOAAAATwAAAFAAAABRAAAAUgAAAFMAAABUAAAAVQAAAFYAAABXAAAAWAAAAFkAAABaAAAAWwAAAFwAAABdAAAAXgAAAF8AAABgAAAAQQAAAEIAAABDAAAARAAAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAAE4AAABPAAAAUAAAAFEAAABSAAAAUwAAAFQAAABVAAAAVgAAAFcAAABYAAAAWQAAAFoAAAB7AAAAfAAAAH0AAAB+AAAAfw==");l(e,12208,"AgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzbAAAAADAxMjM0NTY3ODlhYmNkZWZBQkNERUZ4WCstcFBpSW5OACVJOiVNOiVTICVwJUg6JU0=");l(e,12480,"JQAAAG0AAAAvAAAAJQAAAGQAAAAvAAAAJQAAAHkAAAAlAAAAWQAAAC0AAAAlAAAAbQAAAC0AAAAlAAAAZAAAACUAAABJAAAAOgAAACUAAABNAAAAOgAAACUAAABTAAAAIAAAACUAAABwAAAAAAAAACUAAABIAAAAOgAAACUAAABN");l(e,12624,"JQAAAEgAAAA6AAAAJQAAAE0AAAA6AAAAJQAAAFMAAAAAAAAAxDoAAFEBAABSAQAAUwEAAAAAAAAkOwAAVAEAAFUBAABTAQAAVgEAAFcBAABYAQAAWQEAAFoBAABbAQAAXAEAAF0B");l(e,12736,"BAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABQIAAAUAAAAFAAAABQAAAAUAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAADAgAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAQgEAAEIBAABCAQAAQgEAAEIBAABCAQAAQgEAAEIBAABCAQAAQgEAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAAAqAQAAKgEAACoBAAAqAQAAKgEAACoBAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAADIBAAAyAQAAMgEAADIBAAAyAQAAMgEAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAggAAAIIAAACCAAAAggAAAAQ=");l(e,13764,"jDoAAF4BAABfAQAAUwEAAGABAABhAQAAYgEAAGMBAABkAQAAZQEAAGYBAAAAAAAAXDsAAGcBAABoAQAAUwEAAGkBAABqAQAAawEAAGwBAABtAQAAAAAAAIA7AABuAQAAbwEAAFMBAABwAQAAcQEAAHIBAABzAQAAdAEAAHQAAAByAAAAdQAAAGUAAAAAAAAAZgAAAGEAAABsAAAAcwAAAGUAAAAAAAAAJQAAAG0AAAAvAAAAJQAAAGQAAAAvAAAAJQAAAHkAAAAAAAAAJQAAAEgAAAA6AAAAJQAAAE0AAAA6AAAAJQAAAFMAAAAAAAAAJQAAAGEAAAAgAAAAJQAAAGIAAAAgAAAAJQAAAGQAAAAgAAAAJQAAAEgAAAA6AAAAJQAAAE0AAAA6AAAAJQAAAFMAAAAgAAAAJQAAAFkAAAAAAAAAJQAAAEkAAAA6AAAAJQAAAE0AAAA6AAAAJQAAAFMAAAAgAAAAJQAAAHA=");l(e,14140,"ZDcAAHUBAAB2AQAAUwEAAE5TdDNfXzI2bG9jYWxlNWZhY2V0RQAAACRZAABMNwAA3FUAAAAAAADkNwAAdQEAAHcBAABTAQAAeAEAAHkBAAB6AQAAewEAAHwBAAB9AQAAfgEAAH8BAACAAQAAgQEAAIIBAACDAQAATlN0M19fMjVjdHlwZUl3RUUATlN0M19fMjEwY3R5cGVfYmFzZUUAAORYAADGNwAAAFcAALQ3AAAAAAAAAgAAAGQ3AAACAAAA3DcAAAIAAAAAAAAAeDgAAHUBAACEAQAAUwEAAIUBAACGAQAAhwEAAIgBAACJAQAAigEAAIsBAABOU3QzX18yN2NvZGVjdnRJY2MxMV9fbWJzdGF0ZV90RUUATlN0M19fMjEyY29kZWN2dF9iYXNlRQAAAADkWAAAVjgAAABXAAA0OAAAAAAAAAIAAABkNwAAAgAAAHA4AAACAAAAAAAAAOw4AAB1AQAAjAEAAFMBAACNAQAAjgEAAI8BAACQAQAAkQEAAJIBAACTAQAATlN0M19fMjdjb2RlY3Z0SURzYzExX19tYnN0YXRlX3RFRQAAAFcAAMg4AAAAAAAAAgAAAGQ3AAACAAAAcDgAAAIAAAAAAAAAYDkAAHUBAACUAQAAUwEAAJUBAACWAQAAlwEAAJgBAACZAQAAmgEAAJsBAABOU3QzX18yN2NvZGVjdnRJRHNEdTExX19tYnN0YXRlX3RFRQAAVwAAPDkAAAAAAAACAAAAZDcAAAIAAABwOAAAAgAAAAAAAADUOQAAdQEAAJwBAABTAQAAnQEAAJ4BAACfAQAAoAEAAKEBAACiAQAAowEAAE5TdDNfXzI3Y29kZWN2dElEaWMxMV9fbWJzdGF0ZV90RUUAAABXAACwOQAAAAAAAAIAAABkNwAAAgAAAHA4AAACAAAAAAAAAEg6AAB1AQAApAEAAFMBAAClAQAApgEAAKcBAACoAQAAqQEAAKoBAACrAQAATlN0M19fMjdjb2RlY3Z0SURpRHUxMV9fbWJzdGF0ZV90RUUAAFcAACQ6AAAAAAAAAgAAAGQ3AAACAAAAcDgAAAIAAABOU3QzX18yN2NvZGVjdnRJd2MxMV9fbWJzdGF0ZV90RUUAAAAAVwAAaDoAAAAAAAACAAAAZDcAAAIAAABwOAAAAgAAAE5TdDNfXzI2bG9jYWxlNV9faW1wRQAAACRZAACsOgAAZDcAAE5TdDNfXzI3Y29sbGF0ZUljRUUAJFkAANA6AABkNwAATlN0M19fMjdjb2xsYXRlSXdFRQAkWQAA8DoAAGQ3AABOU3QzX18yNWN0eXBlSWNFRQAAAABXAAAQOwAAAAAAAAIAAABkNwAAAgAAANw3AAACAAAATlN0M19fMjhudW1wdW5jdEljRUUAAAAAJFkAAEQ7AABkNwAATlN0M19fMjhudW1wdW5jdEl3RUUAAAAAJFkAAGg7AABkNwAAAAAAAOQ6AACsAQAArQEAAFMBAACuAQAArwEAALABAAAAAAAABDsAALEBAACyAQAAUwEAALMBAAC0AQAAtQEAAAAAAACgPAAAdQEAALYBAABTAQAAtwEAALgBAAC5AQAAugEAALsBAAC8AQAAvQEAAL4BAAC/AQAAwAEAAMEBAABOU3QzX18yN251bV9nZXRJY05TXzE5aXN0cmVhbWJ1Zl9pdGVyYXRvckljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRUVFAE5TdDNfXzI5X19udW1fZ2V0SWNFRQBOU3QzX18yMTRfX251bV9nZXRfYmFzZUUAAORYAABmPAAAAFcAAFA8AAAAAAAAAQAAAIA8AAAAAAAAAFcAAAw8AAAAAAAAAgAAAGQ3AAACAAAAiDw=");l(e,15556,"dD0AAHUBAADCAQAAUwEAAMMBAADEAQAAxQEAAMYBAADHAQAAyAEAAMkBAADKAQAAywEAAMwBAADNAQAATlN0M19fMjdudW1fZ2V0SXdOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yOV9fbnVtX2dldEl3RUUAAAAAVwAARD0AAAAAAAABAAAAgDwAAAAAAAAAVwAAAD0AAAAAAAACAAAAZDcAAAIAAABcPQ==");l(e,15768,"XD4AAHUBAADOAQAAUwEAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAANUBAADWAQAATlN0M19fMjdudW1fcHV0SWNOU18xOW9zdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yOV9fbnVtX3B1dEljRUUATlN0M19fMjE0X19udW1fcHV0X2Jhc2VFAADkWAAAIj4AAABXAAAMPgAAAAAAAAEAAAA8PgAAAAAAAABXAADIPQAAAAAAAAIAAABkNwAAAgAAAEQ+");l(e,16e3,"JD8AAHUBAADXAQAAUwEAANgBAADZAQAA2gEAANsBAADcAQAA3QEAAN4BAADfAQAATlN0M19fMjdudW1fcHV0SXdOU18xOW9zdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yOV9fbnVtX3B1dEl3RUUAAAAAVwAA9D4AAAAAAAABAAAAPD4AAAAAAAAAVwAAsD4AAAAAAAACAAAAZDcAAAIAAAAMPw==");l(e,16200,"JEAAAOABAADhAQAAUwEAAOIBAADjAQAA5AEAAOUBAADmAQAA5wEAAOgBAAD4////JEAAAOkBAADqAQAA6wEAAOwBAADtAQAA7gEAAO8BAABOU3QzX18yOHRpbWVfZ2V0SWNOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yOXRpbWVfYmFzZUUA5FgAAN0/AABOU3QzX18yMjBfX3RpbWVfZ2V0X2Nfc3RvcmFnZUljRUUAAADkWAAA+D8AAABXAACYPwAAAAAAAAMAAABkNwAAAgAAAPA/AAACAAAAHEAAAAAIAAAAAAAAEEEAAPABAADxAQAAUwEAAPIBAADzAQAA9AEAAPUBAAD2AQAA9wEAAPgBAAD4////EEEAAPkBAAD6AQAA+wEAAPwBAAD9AQAA/gEAAP8BAABOU3QzX18yOHRpbWVfZ2V0SXdOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yMjBfX3RpbWVfZ2V0X2Nfc3RvcmFnZUl3RUUAAORYAADlQAAAAFcAAKBAAAAAAAAAAwAAAGQ3AAACAAAA8D8AAAIAAAAIQQAAAAgAAAAAAAC0QQAAAAIAAAECAABTAQAAAgIAAE5TdDNfXzI4dGltZV9wdXRJY05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRUVFAE5TdDNfXzIxMF9fdGltZV9wdXRFAAAA5FgAAJVBAAAAVwAAUEEAAAAAAAACAAAAZDcAAAIAAACsQQAAAAgAAAAAAAA0QgAAAwIAAAQCAABTAQAABQIAAE5TdDNfXzI4dGltZV9wdXRJd05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRUVFAAAAAABXAADsQQAAAAAAAAIAAABkNwAAAgAAAKxBAAAACAAAAAAAAMhCAAB1AQAABgIAAFMBAAAHAgAACAIAAAkCAAAKAgAACwIAAAwCAAANAgAADgIAAA8CAABOU3QzX18yMTBtb25leXB1bmN0SWNMYjBFRUUATlN0M19fMjEwbW9uZXlfYmFzZUUAAAAA5FgAAKhCAAAAVwAAjEIAAAAAAAACAAAAZDcAAAIAAADAQgAAAgAAAAAAAAA8QwAAdQEAABACAABTAQAAEQIAABICAAATAgAAFAIAABUCAAAWAgAAFwIAABgCAAAZAgAATlN0M19fMjEwbW9uZXlwdW5jdEljTGIxRUVFAABXAAAgQwAAAAAAAAIAAABkNwAAAgAAAMBCAAACAAAAAAAAALBDAAB1AQAAGgIAAFMBAAAbAgAAHAIAAB0CAAAeAgAAHwIAACACAAAhAgAAIgIAACMCAABOU3QzX18yMTBtb25leXB1bmN0SXdMYjBFRUUAAFcAAJRDAAAAAAAAAgAAAGQ3AAACAAAAwEIAAAIAAAAAAAAAJEQAAHUBAAAkAgAAUwEAACUCAAAmAgAAJwIAACgCAAApAgAAKgIAACsCAAAsAgAALQIAAE5TdDNfXzIxMG1vbmV5cHVuY3RJd0xiMUVFRQAAVwAACEQAAAAAAAACAAAAZDcAAAIAAADAQgAAAgAAAAAAAADIRAAAdQEAAC4CAABTAQAALwIAADACAABOU3QzX18yOW1vbmV5X2dldEljTlNfMTlpc3RyZWFtYnVmX2l0ZXJhdG9ySWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFRUUATlN0M19fMjExX19tb25leV9nZXRJY0VFAADkWAAApkQAAABXAABgRAAAAAAAAAIAAABkNwAAAgAAAMBE");l(e,17644,"bEUAAHUBAAAxAgAAUwEAADICAAAzAgAATlN0M19fMjltb25leV9nZXRJd05TXzE5aXN0cmVhbWJ1Zl9pdGVyYXRvckl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRUVFAE5TdDNfXzIxMV9fbW9uZXlfZ2V0SXdFRQAA5FgAAEpFAAAAVwAABEUAAAAAAAACAAAAZDcAAAIAAABkRQ==");l(e,17808,"EEYAAHUBAAA0AgAAUwEAADUCAAA2AgAATlN0M19fMjltb25leV9wdXRJY05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRUVFAE5TdDNfXzIxMV9fbW9uZXlfcHV0SWNFRQAA5FgAAO5FAAAAVwAAqEUAAAAAAAACAAAAZDcAAAIAAAAIRg==");l(e,17972,"tEYAAHUBAAA3AgAAUwEAADgCAAA5AgAATlN0M19fMjltb25leV9wdXRJd05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRUVFAE5TdDNfXzIxMV9fbW9uZXlfcHV0SXdFRQAA5FgAAJJGAAAAVwAATEYAAAAAAAACAAAAZDcAAAIAAACsRg==");l(e,18136,"LEcAAHUBAAA6AgAAUwEAADsCAAA8AgAAPQIAAE5TdDNfXzI4bWVzc2FnZXNJY0VFAE5TdDNfXzIxM21lc3NhZ2VzX2Jhc2VFAAAAAORYAAAJRwAAAFcAAPRGAAAAAAAAAgAAAGQ3AAACAAAAJEcAAAIAAAAAAAAAhEcAAHUBAAA+AgAAUwEAAD8CAABAAgAAQQIAAE5TdDNfXzI4bWVzc2FnZXNJd0VFAAAAAABXAABsRwAAAAAAAAIAAABkNwAAAgAAACRHAAACAAAAUwAAAHUAAABuAAAAZAAAAGEAAAB5AAAAAAAAAE0AAABvAAAAbgAAAGQAAABhAAAAeQAAAAAAAABUAAAAdQAAAGUAAABzAAAAZAAAAGEAAAB5AAAAAAAAAFcAAABlAAAAZAAAAG4AAABlAAAAcwAAAGQAAABhAAAAeQAAAAAAAABUAAAAaAAAAHUAAAByAAAAcwAAAGQAAABhAAAAeQAAAAAAAABGAAAAcgAAAGkAAABkAAAAYQAAAHkAAAAAAAAAUwAAAGEAAAB0AAAAdQAAAHIAAABkAAAAYQAAAHkAAAAAAAAAUwAAAHUAAABuAAAAAAAAAE0AAABvAAAAbgAAAAAAAABUAAAAdQAAAGUAAAAAAAAAVwAAAGUAAABkAAAAAAAAAFQAAABoAAAAdQAAAAAAAABGAAAAcgAAAGkAAAAAAAAAUwAAAGEAAAB0AAAAAAAAAEoAAABhAAAAbgAAAHUAAABhAAAAcgAAAHkAAAAAAAAARgAAAGUAAABiAAAAcgAAAHUAAABhAAAAcgAAAHkAAAAAAAAATQAAAGEAAAByAAAAYwAAAGgAAAAAAAAAQQAAAHAAAAByAAAAaQAAAGwAAAAAAAAATQAAAGEAAAB5AAAAAAAAAEoAAAB1AAAAbgAAAGUAAAAAAAAASgAAAHUAAABsAAAAeQAAAAAAAABBAAAAdQAAAGcAAAB1AAAAcwAAAHQAAAAAAAAAUwAAAGUAAABwAAAAdAAAAGUAAABtAAAAYgAAAGUAAAByAAAAAAAAAE8AAABjAAAAdAAAAG8AAABiAAAAZQAAAHIAAAAAAAAATgAAAG8AAAB2AAAAZQAAAG0AAABiAAAAZQAAAHIAAAAAAAAARAAAAGUAAABjAAAAZQAAAG0AAABiAAAAZQAAAHIAAAAAAAAASgAAAGEAAABuAAAAAAAAAEYAAABlAAAAYgAAAAAAAABNAAAAYQAAAHIAAAAAAAAAQQAAAHAAAAByAAAAAAAAAEoAAAB1AAAAbgAAAAAAAABKAAAAdQAAAGwAAAAAAAAAQQAAAHUAAABnAAAAAAAAAFMAAABlAAAAcAAAAAAAAABPAAAAYwAAAHQAAAAAAAAATgAAAG8AAAB2AAAAAAAAAEQAAABlAAAAYwAAAAAAAABBAAAATQAAAAAAAABQAAAATQ==");l(e,19228,"HEAAAOkBAADqAQAA6wEAAOwBAADtAQAA7gEAAO8BAAAAAAAACEEAAPkBAAD6AQAA+wEAAPwBAAD9AQAA/gEAAP8BAABOU3QzX18yMTRfX3NoYXJlZF9jb3VudEU=");l(e,19348,"iCM=");l(e,19372,"Tm8gZXJyb3IgaW5mb3JtYXRpb24ASWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATXVsdGlob3AgYXR0ZW1wdGVkAFJlcXVpcmVkIGtleSBub3QgYXZhaWxhYmxlAEtleSBoYXMgZXhwaXJlZABLZXkgaGFzIGJlZW4gcmV2b2tlZABLZXkgd2FzIHJlamVjdGVkIGJ5IHNlcnZpY2U=");l(e,21298,"pQJbAPABtQWMBSUBgwYdA5QE/wDHAzEDCwa8AY8BfwPKBCsA2gavAEIDTgPcAQ4EFQChBg0BlAILAjgGZAK8Av8CXQPnBAsHzwLLBe8F2wXhAh4GRQKFAIICbANvBPEA8wMYBdkA2gNMBlQCewGdA70EAABRABUCuwCzA20A/wGFBC8F+QQ4AGUBRgGfALcGqAFzAlMB");l(e,21496,"IQQAAAAAAAAAAC8C");l(e,21528,"NQRHBFYE");l(e,21550,"oAQ=");l(e,21570,"RgVgBW4FYQYAAM8BAAAAAAAAAADJBukG+QYeBzkHSQdeBw==");l(e,21620,"CgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUAypo7AAAAAAAAAAAwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OQAAAACUVQAAQgIAAEMCAABOAQAATlN0M19fMjEyc3lzdGVtX2Vycm9yRQAAJFkAAHxVAACIWAAATlN0M19fMjE0ZXJyb3JfY2F0ZWdvcnlFAAAAAORYAACgVQAATlN0M19fMjEyX19kb19tZXNzYWdlRQAA5FgAAGBLAAAkWQAAxFUAALxVAAAAAAAA3FUAAEQCAABFAgAARgIAAE4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAAAAACRZAAAEVgAAFFkAAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQAAACRZAAA0VgAAKFYAAE4xMF9fY3h4YWJpdjExN19fcGJhc2VfdHlwZV9pbmZvRQAAACRZAABkVgAAKFYAAE4xMF9fY3h4YWJpdjExOV9fcG9pbnRlcl90eXBlX2luZm9FACRZAACUVgAAiFYAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAAAkWQAAxFYAAFhWAAAAAAAASFcAAEgCAABJAgAASgIAAEsCAABMAgAATQIAAE4CAABPAgAATjEwX19jeHhhYml2MTIxX192bWlfY2xhc3NfdHlwZV9pbmZvRQAAACRZAAAgVwAAWFYAAAAAAACwVwAABQAAAFACAABRAgAAAAAAALxXAAAFAAAAUgIAAFMCAABTdDlleGNlcHRpb24AU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAFN0OWJhZF9hbGxvYwAAJFkAAKJXAABQWQAAJFkAAIlXAACwVwAAAAAAAABYAAAHAAAAVAIAAFUCAAAAAAAAiFgAAFwAAABWAgAATgEAAFN0MTFsb2dpY19lcnJvcgAkWQAA8FcAAFBZAAAAAAAANFgAAAcAAABXAgAAVQIAAFN0MTJsZW5ndGhfZXJyb3IAAAAAJFkAACBYAAAAWAAAAAAAAGhYAAAHAAAAWAIAAFUCAABTdDEyb3V0X29mX3JhbmdlAAAAACRZAABUWAAAAFgAAFN0MTNydW50aW1lX2Vycm9yAAAAJFkAAHRYAABQWQAAAAAAALxYAABcAAAAWQIAAE4BAABTdDE0b3ZlcmZsb3dfZXJyb3IAACRZAACoWAAAiFgAAAAAAABYWQAArQAAAFoCAABbAgAAAAAAAFhWAABIAgAAXAIAAEoCAABLAgAATAIAAF0CAABeAgAAXwIAAFN0OXR5cGVfaW5mbwAAAADkWAAABFkAAAAAAADsVgAASAIAAGACAABKAgAASwIAAEwCAABhAgAAYgIAAGMCAABTdDhiYWRfY2FzdADkWAAAfFcAACRZAABEWQAAUFkAAAAAAABQWQAABQAAAGQCAABlAg==");l(e,22904,"0GoBAAghAABHAg==");}var r=new ArrayBuffer(16);var s=new Int32Array(r);var t=new Float32Array(r);var u=new Float64Array(r);function v(w){return s[w]}function x(w,y){s[w]=y;}function z(){return u[0]}function A(y){u[0]=y;}function B(){throw new Error("abort")}function C(){return t[2]}function D(y){t[2]=y;}function Za(q){var E=q.a;var F=E.a;var G=F.buffer;var H=new Int8Array(G);var I=new Int16Array(G);var J=new Int32Array(G);var K=new Uint8Array(G);var L=new Uint16Array(G);var M=new Uint32Array(G);var N=new Float32Array(G);var O=new Float64Array(G);var P=Math.imul;var Q=Math.fround;var R=Math.abs;var S=Math.clz32;var W=Math.ceil;var Z=E.b;var _=E.c;var $=E.d;var aa=E.e;var ba=E.f;var ca=E.g;var da=E.h;var ea=E.i;var fa=E.j;var ga=E.k;var ha=E.l;var ia=E.m;var ja=E.n;var ka=E.o;var la=E.p;var ma=E.q;var na=E.r;var oa=E.s;var pa=E.t;var qa=E.u;var ra=E.v;var sa=E.w;var ta=E.x;var ua=E.y;var va=E.z;var wa=E.A;var xa=E.B;var ya=E.C;var za=E.D;var Aa=E.E;var Ba=E.F;var Ca=E.G;var Da=E.H;var Ea=E.I;var Fa=E.J;var Ga=E.K;var Ha=E.L;var Ia=E.M;var Ja=E.N;var Ka=E.O;var La=E.P;var Ma=E.Q;var Na=E.R;var Oa=E.S;var Pa=E.T;var Qa=E.U;var Ra=E.V;var Sa=E.W;var Ta=E.X;var Ua=92880;var Va=0;var Wa=0;
// EMSCRIPTEN_START_FUNCS
function Vm(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;e=Ua-352|0;Ua=e;J[e+328>>2]=0;J[e+320>>2]=0;J[e+324>>2]=0;J[5996]=0;J[e+316>>2]=0;J[e+308>>2]=0;J[e+312>>2]=0;f=$(3,24)|0;d=J[5996];J[5996]=0;a:{b:{c:{if((d|0)!=1){J[f+8>>2]=-1;J[f+12>>2]=-1;J[f>>2]=0;J[f+16>>2]=-1;J[f+20>>2]=-1;c=f+24|0;J[e+328>>2]=c;J[e+320>>2]=f;m=e+296|0;d:{e:{f:{g:{h:{i:{j:{k:{l:{while(1){d=c-24|0;g=J[d+20>>2];J[m>>2]=J[d+16>>2];J[m+4>>2]=g;g=J[d+12>>2];J[e+288>>2]=J[d+8>>2];J[e+292>>2]=g;h=J[d+4>>2];g=J[d>>2];J[e+280>>2]=g;J[e+284>>2]=h;J[e+324>>2]=d;l=18;m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{x:{y:{z:{switch(g|0){case 0:c=J[b+4>>2];A:{if((c|0)<2){f=-1;break A}g=J[b>>2];f=1;while(1){h=K[f+g|0];if((h|0)==58){l=0;B:{C:{D:{E:{while(1){F:{G:{switch(K[J[b>>2]+l|0]-97|0){case 0:d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=3;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}H:{I:{J:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;K:{if(c>>>0>=178956971){J[5996]=0;ca(142);a=J[5996];J[5996]=0;if((a|0)==1){break K}break a}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break I}if(h>>>0<178956971){break J}J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break H}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=3;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);break F}b=Z()|0;break b;case 18:d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=2;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}L:{M:{N:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;O:{if(c>>>0>=178956971){J[5996]=0;ca(142);break O}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break M}if(h>>>0<178956971){break N}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break L}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=2;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);break F}b=Z()|0;break b;case 2:d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=4;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}P:{Q:{R:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;S:{if(c>>>0>=178956971){J[5996]=0;ca(142);break S}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break Q}if(h>>>0<178956971){break R}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break P}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=4;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);break F}b=Z()|0;break b;case 3:d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=5;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}T:{U:{V:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;W:{if(c>>>0>=178956971){J[5996]=0;ca(142);break W}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break U}if(h>>>0<178956971){break V}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break T}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=5;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);break F}b=Z()|0;break b;case 9:d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=7;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}X:{Y:{Z:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;_:{if(c>>>0>=178956971){J[5996]=0;ca(142);break _}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break Y}if(h>>>0<178956971){break Z}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break X}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=7;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);break F}b=Z()|0;break b;case 13:d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=8;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}$:{aa:{ba:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;ca:{if(c>>>0>=178956971){J[5996]=0;ca(142);break ca}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break aa}if(h>>>0<178956971){break ba}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break $}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=8;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);break F}b=Z()|0;break b;case 21:d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=6;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}da:{ea:{fa:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;ga:{if(c>>>0>=178956971){J[5996]=0;ca(142);break ga}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break ea}if(h>>>0<178956971){break fa}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break da}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=6;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);break F}b=Z()|0;break b;case 20:d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=9;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}ha:{ia:{ja:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;ka:{if(c>>>0>=178956971){J[5996]=0;ca(142);break ka}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break ia}if(h>>>0<178956971){break ja}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break ha}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=9;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);break F}b=Z()|0;break b;case 19:d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=10;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}la:{ma:{na:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;oa:{if(c>>>0>=178956971){J[5996]=0;ca(142);break oa}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break ma}if(h>>>0<178956971){break na}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break la}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=10;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);break F}b=Z()|0;break b;case 11:break G;default:break B}}J[5996]=0;d=$(3,104)|0;c=J[5996];J[5996]=0;if((c|0)==1){break E}J[d>>2]=7e3;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;g=ba(143,d+12|0,0,0)|0;c=J[5996];J[5996]=0;if((c|0)==1){b=Z()|0;$a(d);break b}J[e+244>>2]=d;J[e+240>>2]=g;c=J[e+312>>2];pa:{if(c>>>0<M[e+316>>2]){J[c+4>>2]=d;J[c>>2]=g;J[e+312>>2]=c+8;break pa}J[5996]=0;aa(144,e+308|0,e+240|0);d=J[5996];J[5996]=0;if((d|0)==1){break D}d=J[e+244>>2];if(!d){break pa}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break pa}Xa[J[J[d>>2]+8>>2]](d);bb(d);}d=J[e+324>>2];h=J[e+328>>2];if(d>>>0<h>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=18;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break F}qa:{ra:{g=J[e+320>>2];j=(d-g|0)/24|0;c=j+1|0;sa:{if(c>>>0>=178956971){J[5996]=0;ca(142);break sa}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break qa}if(h>>>0<178956971){break ra}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break C}}c=P(j,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=18;J[c+16>>2]=-1;J[c+20>>2]=-1;j=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;k=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=k;k=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=k;k=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=k;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=j;J[e+320>>2]=c;if(!d){break F}$a(d);}l=l+1|0;if((l|0)!=(f|0)){continue}break}d=J[e+324>>2];break A}b=Z()|0;break b}b=Z()|0;mb(e+240|0);break b}b=Z()|0;break b}J[a>>2]=0;J[a+4>>2]=0;break l}if((h-97&255)>>>0>25){f=-1;break A}f=f+1|0;if((c|0)>(f|0)){continue}break}f=-1;}ta:{h=J[e+328>>2];ua:{if(h>>>0>d>>>0){J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=1;J[d+16>>2]=-1;J[d+20>>2]=-1;J[e+324>>2]=d+24;break ua}va:{wa:{g=J[e+320>>2];l=(d-g|0)/24|0;c=l+1|0;xa:{if(c>>>0>=178956971){J[5996]=0;ca(142);break xa}h=(h-g|0)/24|0;i=h<<1;h=h>>>0>=89478485?178956970:c>>>0<i>>>0?i:c;if(!h){i=0;break va}if(h>>>0<178956971){break wa}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(h,24)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break ta}}c=P(l,24)+i|0;J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=1;J[c+16>>2]=-1;J[c+20>>2]=-1;l=c+24|0;if((d|0)!=(g|0)){while(1){d=d-24|0;j=J[d+4>>2];c=c-24|0;J[c>>2]=J[d>>2];J[c+4>>2]=j;j=J[d+20>>2];J[c+16>>2]=J[d+16>>2];J[c+20>>2]=j;j=J[d+12>>2];J[c+8>>2]=J[d+8>>2];J[c+12>>2]=j;if((d|0)!=(g|0)){continue}break}d=g;}J[e+328>>2]=P(h,24)+i;J[e+324>>2]=l;J[e+320>>2]=c;if(!d){break ua}$a(d);}d=f+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];break m}b=Z()|0;break b;case 21:ya:{d=J[b+4>>2];if(d){c=J[b>>2];if(K[c|0]==41){break ya}}J[a>>2]=0;J[a+4>>2]=0;break l}J[b+4>>2]=d-1;J[b>>2]=c+1;break m;case 20:za:{d=J[b+4>>2];if(d){c=J[b>>2];if(K[c|0]==44){break za}}J[a>>2]=0;J[a+4>>2]=0;break l}J[b+4>>2]=d-1;J[b>>2]=c+1;break m;case 19:g=J[b+4>>2];if(!g){J[a>>2]=0;J[a+4>>2]=0;break l}Aa:{Ba:{Ca:{Da:{Ea:{Fa:{h=J[b>>2];switch(K[h|0]-41|0){case 0:break Ea;case 3:break Fa;default:break Da}}J[b+4>>2]=g-1;J[b>>2]=h+1;g=J[e+292>>2];h=J[e+288>>2]+1|0;g=h?g:g+1|0;Ga:{Ha:{i=J[e+328>>2];Ia:{if(i>>>0>d>>>0){J[d>>2]=19;J[d+8>>2]=h;J[d+12>>2]=g;f=J[e+300>>2];J[d+16>>2]=J[e+296>>2];J[d+20>>2]=f;J[e+324>>2]=c;break Ia}Ja:{Ka:{l=(d-f|0)/24|0;c=l+1|0;La:{if(c>>>0>=178956971){J[5996]=0;ca(142);break La}i=(i-f|0)/24|0;j=i<<1;c=i>>>0>=89478485?178956970:c>>>0<j>>>0?j:c;if(!c){i=0;break Ja}if(c>>>0<178956971){break Ka}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(c,24)|0)|0;j=J[5996];J[5996]=0;if((j|0)==1){break Ha}}l=P(l,24)+i|0;J[l+8>>2]=h;J[l+12>>2]=g;J[l>>2]=19;g=J[e+300>>2];J[l+16>>2]=J[e+296>>2];J[l+20>>2]=g;i=P(c,24)+i|0;c=l+24|0;Ma:{if((d|0)==(f|0)){J[e+328>>2]=i;J[e+324>>2]=c;J[e+320>>2]=l;break Ma}while(1){d=d-24|0;h=J[d+4>>2];l=l-24|0;g=l;J[g>>2]=J[d>>2];J[g+4>>2]=h;g=J[d+20>>2];J[l+16>>2]=J[d+16>>2];J[l+20>>2]=g;g=J[d+12>>2];J[l+8>>2]=J[d+8>>2];J[l+12>>2]=g;if((d|0)!=(f|0)){continue}break}J[e+328>>2]=i;J[e+324>>2]=c;J[e+320>>2]=l;if(!f){break Ia}}$a(f);i=J[e+328>>2];c=J[e+324>>2];}if(c>>>0<i>>>0){J[c+8>>2]=-1;J[c+12>>2]=-1;J[c>>2]=0;J[c+16>>2]=-1;J[c+20>>2]=-1;J[e+324>>2]=c+24;break m}Na:{Oa:{f=J[e+320>>2];h=(c-f|0)/24|0;d=h+1|0;Pa:{if(d>>>0>=178956971){J[5996]=0;ca(142);break Pa}g=(i-f|0)/24|0;i=g<<1;g=g>>>0>=89478485?178956970:d>>>0<i>>>0?i:d;if(!g){i=0;break Na}if(g>>>0<178956971){break Oa}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[5996]=0;i=$(3,P(g,24)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Ga}}d=P(h,24)+i|0;J[d+8>>2]=-1;J[d+12>>2]=-1;J[d>>2]=0;J[d+16>>2]=-1;J[d+20>>2]=-1;h=d+24|0;if((c|0)!=(f|0)){while(1){c=c-24|0;l=J[c+4>>2];d=d-24|0;J[d>>2]=J[c>>2];J[d+4>>2]=l;l=J[c+20>>2];J[d+16>>2]=J[c+16>>2];J[d+20>>2]=l;l=J[c+12>>2];J[d+8>>2]=J[c+8>>2];J[d+12>>2]=l;if((c|0)!=(f|0)){continue}break}c=f;}J[e+328>>2]=P(g,24)+i;J[e+324>>2]=h;J[e+320>>2]=d;if(!c){break m}$a(c);break m}b=Z()|0;break b}b=Z()|0;break b}d=J[e+288>>2];c=J[e+292>>2];f=J[e+300>>2];if(d>>>0<M[e+296>>2]&(c|0)<=(f|0)|(c|0)<(f|0)){J[a>>2]=0;J[a+4>>2]=0;break l}J[b+4>>2]=g-1;J[b>>2]=h+1;J[e+340>>2]=0;J[e+332>>2]=0;J[e+336>>2]=0;if(!d&(c|0)<=0|(c|0)<0){break Ba}f=0;c=0;d=J[e+312>>2];while(1){Qa:{g=d-8|0;h=J[e+336>>2];Ra:{if(h>>>0<M[e+340>>2]){J[h>>2]=J[g>>2];i=d-4|0;J[h+4>>2]=J[i>>2];J[g>>2]=0;J[i>>2]=0;J[e+336>>2]=h+8;break Ra}J[5996]=0;aa(144,e+332|0,g|0);d=J[5996];J[5996]=0;if((d|0)==1){break Qa}d=J[e+312>>2];g=J[d-4>>2];if(!g){break Ra}h=J[g+4>>2];J[g+4>>2]=h-1;if(h){break Ra}Xa[J[J[g>>2]+8>>2]](g);bb(g);}d=d-8|0;J[e+312>>2]=d;f=f+1|0;c=f?c:c+1|0;g=J[e+292>>2];if(M[e+288>>2]>f>>>0&(g|0)>=(c|0)|(c|0)<(g|0)){continue}break Ca}break}b=Z()|0;break Aa}J[a>>2]=0;J[a+4>>2]=0;break l}d=J[e+332>>2];f=J[e+336>>2];if((d|0)==(f|0)){break Ba}c=f-8|0;if(c>>>0<=d>>>0){break Ba}while(1){g=J[d>>2];J[d>>2]=J[c>>2];J[c>>2]=g;g=J[d+4>>2];f=f-4|0;J[d+4>>2]=J[f>>2];J[f>>2]=g;f=c;d=d+8|0;c=c-8|0;if(d>>>0<c>>>0){continue}break}}J[5996]=0;f=$(3,104)|0;d=J[5996];J[5996]=0;Sa:{Ta:{if((d|0)!=1){J[f>>2]=7e3;J[f+4>>2]=0;J[f+8>>2]=0;J[5996]=0;J[e+240>>2]=J[e+332>>2];d=J[e+336>>2];c=J[e+340>>2];J[e+340>>2]=0;J[e+244>>2]=d;J[e+248>>2]=c;J[e+332>>2]=0;J[e+336>>2]=0;h=ia(64,f+12|0,24,e+240|0,J[e+296>>2])|0;d=J[5996];J[5996]=0;if((d|0)==1){break Sa}c=J[e+240>>2];if(c){d=J[e+244>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;g=J[d+4>>2];Ua:{if(!g){break Ua}i=J[g+4>>2];J[g+4>>2]=i-1;if(i){break Ua}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((c|0)!=(d|0)){continue}break}c=J[e+240>>2];}$a(c);}J[e+348>>2]=f;J[e+344>>2]=h;d=J[e+312>>2];Va:{if(d>>>0<M[e+316>>2]){J[d+4>>2]=f;J[d>>2]=h;J[e+312>>2]=d+8;break Va}J[5996]=0;aa(144,e+308|0,e+344|0);d=J[5996];J[5996]=0;if((d|0)==1){break Ta}d=J[e+348>>2];if(!d){break Va}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break Va}Xa[J[J[d>>2]+8>>2]](d);bb(d);}c=J[e+332>>2];if(!c){break m}d=J[e+336>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;f=J[d+4>>2];Wa:{if(!f){break Wa}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break Wa}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(d|0)){continue}break}c=J[e+332>>2];}$a(c);break m}b=Z()|0;break Aa}b=Z()|0;mb(e+344|0);break Aa}b=Z()|0;lb(e+240|0);$a(f);}lb(e+332|0);break b;case 14:c=J[e+312>>2];d=c-8|0;J[e+332>>2]=J[d>>2];J[e+336>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;d=c-16|0;J[e+344>>2]=J[d>>2];J[e+348>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[e+312>>2]=d;J[5996]=0;f=e+240|0;ga(145,f|0,c-24|0,e+344|0,e+332|0);d=J[5996];J[5996]=0;Xa:{Ya:{Za:{if((d|0)!=1){J[5996]=0;d=$(3,104)|0;c=J[5996];J[5996]=0;if((c|0)==1){break Za}J[5996]=0;c=ba(146,d|0,23,f|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){b=Z()|0;$a(d);break Ya}f=J[e+312>>2]-8|0;J[f>>2]=c+12;d=J[f+4>>2];J[f+4>>2]=c;_a:{if(!d){break _a}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break _a}Xa[J[J[d>>2]+8>>2]](d);bb(d);}f=J[e+240>>2];if(f){d=J[e+244>>2];c=f;if((d|0)!=(c|0)){while(1){d=d-8|0;c=J[d+4>>2];$a:{if(!c){break $a}g=J[c+4>>2];J[c+4>>2]=g-1;if(g){break $a}Xa[J[J[c>>2]+8>>2]](c);bb(c);}if((d|0)!=(f|0)){continue}break}c=J[e+240>>2];}J[e+244>>2]=f;$a(c);}d=J[e+348>>2];ab:{if(!d){break ab}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break ab}Xa[J[J[d>>2]+8>>2]](d);bb(d);}d=J[e+336>>2];if(!d){break m}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break m}Xa[J[J[d>>2]+8>>2]](d);bb(d);break m}b=Z()|0;break Xa}b=Z()|0;}lb(e+240|0);}mb(e+344|0);mb(e+332|0);break b;case 18:l=22;break y;case 17:l=21;break y;case 16:l=20;break y;case 15:l=19;break y;case 1:break n;case 3:break o;case 2:break p;case 4:break q;case 5:break r;case 7:break s;case 8:break t;case 6:break u;case 9:break v;case 10:break w;case 11:break x;case 13:break y;case 12:break z;default:break m}}l=17;}f=J[e+312>>2];c=f-8|0;J[e+344>>2]=J[c>>2];J[e+348>>2]=J[c+4>>2];J[c>>2]=0;J[c+4>>2]=0;J[e+312>>2]=c;J[5996]=0;J[e+340>>2]=0;J[e+332>>2]=0;J[e+336>>2]=0;d=$(3,16)|0;g=J[5996];J[5996]=0;bb:{if((g|0)==1){b=Z()|0;break bb}J[e+332>>2]=d;g=d+16|0;J[e+340>>2]=g;f=f-16|0;J[d>>2]=J[f>>2];J[d+4>>2]=J[f+4>>2];J[f>>2]=0;J[f+4>>2]=0;J[d+8>>2]=J[e+344>>2];J[d+12>>2]=J[e+348>>2];J[e+336>>2]=g;J[e+344>>2]=0;J[e+348>>2]=0;J[5996]=0;f=$(3,104)|0;h=J[5996];J[5996]=0;if((h|0)!=1){J[f>>2]=7e3;J[f+4>>2]=0;J[f+8>>2]=0;J[e+244>>2]=g;J[e+240>>2]=d;J[e+332>>2]=0;J[e+336>>2]=0;J[5996]=0;d=J[e+340>>2];J[e+340>>2]=0;J[e+248>>2]=d;g=ia(64,f+12|0,l|0,e+240|0,0)|0;d=J[5996];J[5996]=0;if((d|0)!=1){l=J[e+240>>2];if(l){d=J[e+244>>2];if((l|0)!=(d|0)){while(1){d=d-8|0;c=J[d+4>>2];cb:{if(!c){break cb}h=J[c+4>>2];J[c+4>>2]=h-1;if(h){break cb}Xa[J[J[c>>2]+8>>2]](c);bb(c);}if((d|0)!=(l|0)){continue}break}l=J[e+240>>2];c=J[e+312>>2];}$a(l);}c=c-8|0;J[c>>2]=g;d=J[c+4>>2];J[c+4>>2]=f;db:{if(!d){break db}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break db}Xa[J[J[d>>2]+8>>2]](d);bb(d);}c=J[e+332>>2];if(c){d=J[e+336>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;f=J[d+4>>2];eb:{if(!f){break eb}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break eb}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(d|0)){continue}break}c=J[e+332>>2];}$a(c);}d=J[e+348>>2];if(!d){break m}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break m}Xa[J[J[d>>2]+8>>2]](d);bb(d);break m}b=Z()|0;lb(e+240|0);$a(f);break bb}b=Z()|0;}lb(e+332|0);mb(e+344|0);break b}c=J[e+312>>2];d=c-8|0;J[e+332>>2]=J[d>>2];J[e+336>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[e+312>>2]=d;J[5996]=0;d=$(3,104)|0;f=J[5996];J[5996]=0;fb:{gb:{hb:{ib:{jb:{if((f|0)!=1){J[d>>2]=7e3;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=ba(143,d+12|0,0,0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(d);break fb}J[e+348>>2]=d;J[e+344>>2]=f;J[5996]=0;f=e+240|0;ga(145,f|0,c-16|0,e+332|0,e+344|0);d=J[5996];J[5996]=0;if((d|0)==1){break jb}J[5996]=0;d=$(3,104)|0;c=J[5996];J[5996]=0;if((c|0)==1){break ib}J[5996]=0;c=ba(146,d|0,23,f|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){b=Z()|0;$a(d);break hb}f=J[e+312>>2]-8|0;J[f>>2]=c+12;d=J[f+4>>2];J[f+4>>2]=c;kb:{if(!d){break kb}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break kb}Xa[J[J[d>>2]+8>>2]](d);bb(d);}f=J[e+240>>2];if(f){d=J[e+244>>2];c=f;if((d|0)!=(c|0)){while(1){d=d-8|0;c=J[d+4>>2];lb:{if(!c){break lb}g=J[c+4>>2];J[c+4>>2]=g-1;if(g){break lb}Xa[J[J[c>>2]+8>>2]](c);bb(c);}if((d|0)!=(f|0)){continue}break}c=J[e+240>>2];}J[e+244>>2]=f;$a(c);}d=J[e+348>>2];mb:{if(!d){break mb}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break mb}Xa[J[J[d>>2]+8>>2]](d);bb(d);}d=J[e+336>>2];if(!d){break m}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break m}Xa[J[J[d>>2]+8>>2]](d);bb(d);break m}b=Z()|0;break fb}b=Z()|0;break gb}b=Z()|0;}lb(e+240|0);}mb(e+344|0);}mb(e+332|0);break b}J[5996]=0;c=J[e+312>>2];d=$(3,104)|0;f=J[5996];J[5996]=0;nb:{ob:{if((f|0)!=1){J[d>>2]=7e3;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=ba(143,d+12|0,1,0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(d);break b}J[e+336>>2]=d;J[e+332>>2]=f;J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;d=$(3,16)|0;f=J[5996];J[5996]=0;if((f|0)==1){b=Z()|0;break nb}J[e+240>>2]=d;g=d+16|0;J[e+248>>2]=g;f=c-8|0;J[d>>2]=J[f>>2];c=c-4|0;J[d+4>>2]=J[c>>2];J[f>>2]=0;J[c>>2]=0;J[d+8>>2]=J[e+332>>2];J[d+12>>2]=J[e+336>>2];J[e+244>>2]=g;J[e+332>>2]=0;J[e+336>>2]=0;J[5996]=0;d=$(3,104)|0;g=J[5996];J[5996]=0;if((g|0)==1){break ob}J[5996]=0;g=ba(146,d|0,17,e+240|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){b=Z()|0;$a(d);break nb}J[f>>2]=g+12;d=J[c>>2];J[c>>2]=g;pb:{if(!d){break pb}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break pb}Xa[J[J[d>>2]+8>>2]](d);bb(d);}f=J[e+240>>2];if(f){d=J[e+244>>2];c=f;if((d|0)!=(c|0)){while(1){d=d-8|0;c=J[d+4>>2];qb:{if(!c){break qb}g=J[c+4>>2];J[c+4>>2]=g-1;if(g){break qb}Xa[J[J[c>>2]+8>>2]](c);bb(c);}if((d|0)!=(f|0)){continue}break}c=J[e+240>>2];}J[e+244>>2]=f;$a(c);}d=J[e+336>>2];if(!d){break m}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break m}Xa[J[J[d>>2]+8>>2]](d);bb(d);break m}b=Z()|0;break b}b=Z()|0;}lb(e+240|0);mb(e+332|0);break b}J[5996]=0;c=J[e+312>>2];d=$(3,104)|0;f=J[5996];J[5996]=0;rb:{sb:{if((f|0)!=1){J[d>>2]=7e3;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=ba(143,d+12|0,0,0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(d);break b}J[e+336>>2]=d;J[e+332>>2]=f;J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;d=$(3,16)|0;f=J[5996];J[5996]=0;if((f|0)==1){b=Z()|0;break rb}J[e+240>>2]=d;g=d+16|0;J[e+248>>2]=g;f=c-8|0;J[d>>2]=J[f>>2];c=c-4|0;J[d+4>>2]=J[c>>2];J[f>>2]=0;J[c>>2]=0;J[d+8>>2]=J[e+332>>2];J[d+12>>2]=J[e+336>>2];J[e+244>>2]=g;J[e+332>>2]=0;J[e+336>>2]=0;J[5996]=0;d=$(3,104)|0;g=J[5996];J[5996]=0;if((g|0)==1){break sb}J[5996]=0;g=ba(146,d|0,22,e+240|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){b=Z()|0;$a(d);break rb}J[f>>2]=g+12;d=J[c>>2];J[c>>2]=g;tb:{if(!d){break tb}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break tb}Xa[J[J[d>>2]+8>>2]](d);bb(d);}f=J[e+240>>2];if(f){d=J[e+244>>2];c=f;if((d|0)!=(c|0)){while(1){d=d-8|0;c=J[d+4>>2];ub:{if(!c){break ub}g=J[c+4>>2];J[c+4>>2]=g-1;if(g){break ub}Xa[J[J[c>>2]+8>>2]](c);bb(c);}if((d|0)!=(f|0)){continue}break}c=J[e+240>>2];}J[e+244>>2]=f;$a(c);}d=J[e+336>>2];if(!d){break m}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break m}Xa[J[J[d>>2]+8>>2]](d);bb(d);break m}b=Z()|0;break b}b=Z()|0;}lb(e+240|0);mb(e+332|0);break b}J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;d=J[e+312>>2];c=$(3,8)|0;f=J[5996];J[5996]=0;vb:{if((f|0)!=1){J[e+240>>2]=c;f=c+8|0;J[e+248>>2]=f;d=d-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[5996]=0;J[e+244>>2]=f;c=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)!=1){J[5996]=0;f=ba(146,c|0,14,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(c);break vb}J[d>>2]=f+12;c=J[d+4>>2];J[d+4>>2]=f;wb:{if(!c){break wb}d=J[c+4>>2];J[c+4>>2]=d-1;if(d){break wb}Xa[J[J[c>>2]+8>>2]](c);bb(c);}c=J[e+240>>2];if(!c){break m}d=J[e+244>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;f=J[d+4>>2];xb:{if(!f){break xb}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break xb}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(d|0)){continue}break}c=J[e+240>>2];}$a(c);break m}b=Z()|0;break vb}b=Z()|0;}lb(e+240|0);break b}J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;d=J[e+312>>2];c=$(3,8)|0;f=J[5996];J[5996]=0;yb:{if((f|0)!=1){J[e+240>>2]=c;f=c+8|0;J[e+248>>2]=f;d=d-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[5996]=0;J[e+244>>2]=f;c=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)!=1){J[5996]=0;f=ba(146,c|0,16,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(c);break yb}J[d>>2]=f+12;c=J[d+4>>2];J[d+4>>2]=f;zb:{if(!c){break zb}d=J[c+4>>2];J[c+4>>2]=d-1;if(d){break zb}Xa[J[J[c>>2]+8>>2]](c);bb(c);}c=J[e+240>>2];if(!c){break m}d=J[e+244>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;f=J[d+4>>2];Ab:{if(!f){break Ab}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break Ab}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(d|0)){continue}break}c=J[e+240>>2];}$a(c);break m}b=Z()|0;break yb}b=Z()|0;}lb(e+240|0);break b}J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;d=J[e+312>>2];c=$(3,8)|0;f=J[5996];J[5996]=0;Bb:{if((f|0)!=1){J[e+240>>2]=c;f=c+8|0;J[e+248>>2]=f;d=d-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[5996]=0;J[e+244>>2]=f;c=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)!=1){J[5996]=0;f=ba(146,c|0,15,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(c);break Bb}J[d>>2]=f+12;c=J[d+4>>2];J[d+4>>2]=f;Cb:{if(!c){break Cb}d=J[c+4>>2];J[c+4>>2]=d-1;if(d){break Cb}Xa[J[J[c>>2]+8>>2]](c);bb(c);}c=J[e+240>>2];if(!c){break m}d=J[e+244>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;f=J[d+4>>2];Db:{if(!f){break Db}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break Db}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(d|0)){continue}break}c=J[e+240>>2];}$a(c);break m}b=Z()|0;break Bb}b=Z()|0;}lb(e+240|0);break b}J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;d=J[e+312>>2];c=$(3,8)|0;f=J[5996];J[5996]=0;Eb:{if((f|0)!=1){J[e+240>>2]=c;f=c+8|0;J[e+248>>2]=f;d=d-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[5996]=0;J[e+244>>2]=f;c=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)!=1){J[5996]=0;f=ba(146,c|0,13,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(c);break Eb}J[d>>2]=f+12;c=J[d+4>>2];J[d+4>>2]=f;Fb:{if(!c){break Fb}d=J[c+4>>2];J[c+4>>2]=d-1;if(d){break Fb}Xa[J[J[c>>2]+8>>2]](c);bb(c);}c=J[e+240>>2];if(!c){break m}d=J[e+244>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;f=J[d+4>>2];Gb:{if(!f){break Gb}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break Gb}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(d|0)){continue}break}c=J[e+240>>2];}$a(c);break m}b=Z()|0;break Eb}b=Z()|0;}lb(e+240|0);break b}J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;d=J[e+312>>2];c=$(3,8)|0;f=J[5996];J[5996]=0;Hb:{if((f|0)!=1){J[e+240>>2]=c;f=c+8|0;J[e+248>>2]=f;d=d-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[5996]=0;J[e+244>>2]=f;c=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)!=1){J[5996]=0;f=ba(146,c|0,12,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(c);break Hb}J[d>>2]=f+12;c=J[d+4>>2];J[d+4>>2]=f;Ib:{if(!c){break Ib}d=J[c+4>>2];J[c+4>>2]=d-1;if(d){break Ib}Xa[J[J[c>>2]+8>>2]](c);bb(c);}c=J[e+240>>2];if(!c){break m}d=J[e+244>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;f=J[d+4>>2];Jb:{if(!f){break Jb}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break Jb}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(d|0)){continue}break}c=J[e+240>>2];}$a(c);break m}b=Z()|0;break Hb}b=Z()|0;}lb(e+240|0);break b}J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;d=J[e+312>>2];c=$(3,8)|0;f=J[5996];J[5996]=0;Kb:{if((f|0)!=1){J[e+240>>2]=c;f=c+8|0;J[e+248>>2]=f;d=d-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[5996]=0;J[e+244>>2]=f;c=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)!=1){J[5996]=0;f=ba(146,c|0,11,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(c);break Kb}J[d>>2]=f+12;c=J[d+4>>2];J[d+4>>2]=f;Lb:{if(!c){break Lb}d=J[c+4>>2];J[c+4>>2]=d-1;if(d){break Lb}Xa[J[J[c>>2]+8>>2]](c);bb(c);}c=J[e+240>>2];if(!c){break m}d=J[e+244>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;f=J[d+4>>2];Mb:{if(!f){break Mb}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break Mb}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(d|0)){continue}break}c=J[e+240>>2];}$a(c);break m}b=Z()|0;break Kb}b=Z()|0;}lb(e+240|0);break b}J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;d=J[e+312>>2];c=$(3,8)|0;f=J[5996];J[5996]=0;Nb:{if((f|0)!=1){J[e+240>>2]=c;f=c+8|0;J[e+248>>2]=f;d=d-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[5996]=0;J[e+244>>2]=f;c=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)!=1){J[5996]=0;f=ba(146,c|0,10,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(c);break Nb}J[d>>2]=f+12;c=J[d+4>>2];J[d+4>>2]=f;Ob:{if(!c){break Ob}d=J[c+4>>2];J[c+4>>2]=d-1;if(d){break Ob}Xa[J[J[c>>2]+8>>2]](c);bb(c);}c=J[e+240>>2];if(!c){break m}d=J[e+244>>2];if((c|0)!=(d|0)){while(1){d=d-8|0;f=J[d+4>>2];Pb:{if(!f){break Pb}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break Pb}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(d|0)){continue}break}c=J[e+240>>2];}$a(c);break m}b=Z()|0;break Nb}b=Z()|0;}lb(e+240|0);break b}I[e+240>>1]=48;H[e+251|0]=1;Qb:{Rb:{Sb:{Tb:{d=J[b+4>>2];if(!d){H[e+251|0]=3;H[e+243|0]=0;I[e+240>>1]=K[5279]|K[5280]<<8;H[e+242|0]=K[5281];break Tb}c=J[b>>2];if(K[e+240|0]==K[c|0]){J[b+4>>2]=d-1;J[b>>2]=c+1;J[5996]=0;d=$(3,104)|0;c=J[5996];J[5996]=0;Ub:{if((c|0)!=1){J[d>>2]=7e3;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=ba(143,d+12|0,0,0)|0;c=J[5996];J[5996]=0;if((c|0)==1){b=Z()|0;$a(d);break b}J[e+244>>2]=d;J[e+240>>2]=f;c=J[e+312>>2];if(c>>>0<M[e+316>>2]){J[c+4>>2]=d;J[c>>2]=f;J[e+312>>2]=c+8;break m}J[5996]=0;aa(144,e+308|0,e+240|0);d=J[5996];J[5996]=0;if((d|0)==1){break Ub}d=J[e+244>>2];if(!d){break m}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break m}Xa[J[J[d>>2]+8>>2]](d);bb(d);break m}b=Z()|0;break b}b=Z()|0;mb(e+240|0);break b}H[e+251|0]=1;I[e+240>>1]=49;c=J[b>>2];if(K[c|0]==49){J[b+4>>2]=d-1;J[b>>2]=c+1;J[5996]=0;d=$(3,104)|0;c=J[5996];J[5996]=0;Vb:{if((c|0)!=1){J[d>>2]=7e3;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=ba(143,d+12|0,1,0)|0;c=J[5996];J[5996]=0;if((c|0)==1){b=Z()|0;$a(d);break b}J[e+244>>2]=d;J[e+240>>2]=f;c=J[e+312>>2];if(c>>>0<M[e+316>>2]){J[c+4>>2]=d;J[c>>2]=f;J[e+312>>2]=c+8;break m}J[5996]=0;aa(144,e+308|0,e+240|0);d=J[5996];J[5996]=0;if((d|0)==1){break Vb}d=J[e+244>>2];if(!d){break m}c=J[d+4>>2];J[d+4>>2]=c-1;if(c){break m}Xa[J[J[d>>2]+8>>2]](d);bb(d);break m}b=Z()|0;break b}b=Z()|0;mb(e+240|0);break b}H[e+243|0]=0;I[e+240>>1]=K[5279]|K[5280]<<8;H[e+242|0]=K[5281];H[e+251|0]=3;if(d>>>0<3){break Tb}Wb:{Xb:{Yb:{Zb:{_b:{$b:{ac:{bc:{cc:{dc:{ec:{fc:{gc:{c=J[b>>2];if(!(K[e+240|0]!=K[c|0]|K[e+241|0]!=K[c+1|0]|K[e+242|0]!=K[c+2|0])){g=d-3|0;J[b+4>>2]=g;J[b>>2]=c+3;if((g|0)<=0){break Wb}f=J[b>>2];c=J[b>>2];d=0;while(1){if(K[c+d|0]!=41){d=d+1|0;if((g|0)!=(d|0)){continue}break Wb}break}if(d-18>>>0<4294967279){break Wb}hc:{if(d>>>0<=10){H[e+251|0]=d;c=e+240|0;break hc}J[5996]=0;g=(d|15)+1|0;c=$(3,g|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break gc}J[e+240>>2]=c;J[e+244>>2]=d;J[e+248>>2]=g|-2147483648;}H[fb(c,f,d)+d|0]=0;J[e+272>>2]=J[e+244>>2];c=K[e+247|0]|K[e+248|0]<<8|(K[e+249|0]<<16|K[e+250|0]<<24);H[e+275|0]=c;H[e+276|0]=c>>>8;H[e+277|0]=c>>>16;H[e+278|0]=c>>>24;J[5996]=0;f=J[e+240>>2];g=H[e+251|0];J[e+340>>2]=0;J[e+332>>2]=0;J[e+336>>2]=0;c=$(3,12)|0;h=J[5996];J[5996]=0;if((h|0)!=1){J[e+332>>2]=c;h=c+12|0;J[e+340>>2]=h;J[c>>2]=f;J[c+4>>2]=J[e+272>>2];f=K[e+275|0]|K[e+276|0]<<8|(K[e+277|0]<<16|K[e+278|0]<<24);H[c+7|0]=f;H[c+8|0]=f>>>8;H[c+9|0]=f>>>16;H[c+10|0]=f>>>24;H[c+11|0]=g;H[e+275|0]=0;H[e+276|0]=0;H[e+277|0]=0;H[e+278|0]=0;J[e+272>>2]=0;J[e+336>>2]=h;J[5996]=0;c=$(3,104)|0;f=J[5996];J[5996]=0;ic:{jc:{if((f|0)!=1){J[5996]=0;f=ba(147,c|0,2,e+332|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(c);break Xb}J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;J[e+268>>2]=f;g=f+12|0;J[e+264>>2]=g;c=$(3,8)|0;h=J[5996];J[5996]=0;if((h|0)==1){break fc}J[e+240>>2]=c;h=c+8|0;J[e+248>>2]=h;J[c+4>>2]=f;J[c>>2]=g;J[e+244>>2]=h;J[e+264>>2]=0;J[e+268>>2]=0;J[5996]=0;f=$(3,104)|0;c=J[5996];J[5996]=0;if((c|0)==1){break jc}J[5996]=0;c=ba(146,f|0,12,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(f);break Yb}J[e+348>>2]=c;g=c+12|0;J[e+344>>2]=g;f=J[e+312>>2];kc:{if(f>>>0<M[e+316>>2]){J[f+4>>2]=c;J[f>>2]=g;J[e+312>>2]=f+8;J[e+344>>2]=0;J[e+348>>2]=0;break kc}J[5996]=0;aa(144,e+308|0,e+344|0);c=J[5996];J[5996]=0;if((c|0)==1){break ic}c=J[e+348>>2];if(!c){break kc}f=J[c+4>>2];J[c+4>>2]=f-1;if(f){break kc}Xa[J[J[c>>2]+8>>2]](c);bb(c);}g=J[e+240>>2];if(g){c=J[e+244>>2];f=g;if((c|0)!=(f|0)){while(1){c=c-8|0;f=J[c+4>>2];lc:{if(!f){break lc}h=J[f+4>>2];J[f+4>>2]=h-1;if(h){break lc}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(g|0)){continue}break}f=J[e+240>>2];}J[e+244>>2]=g;$a(f);}c=J[e+268>>2];mc:{if(!c){break mc}f=J[c+4>>2];J[c+4>>2]=f-1;if(f){break mc}Xa[J[J[c>>2]+8>>2]](c);bb(c);}g=J[e+332>>2];if(g){f=J[e+336>>2];if((g|0)!=(f|0)){while(1){c=f-12|0;if(H[f-1|0]<0){$a(J[c>>2]);}f=c;if((c|0)!=(g|0)){continue}break}}J[e+336>>2]=g;$a(g);}d=d+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];break m}b=Z()|0;break Xb}b=Z()|0;break Yb}b=Z()|0;mb(e+344|0);break Yb}b=Z()|0;rb(e+332|0);if((g|0)>=0){break b}$a(f);break b}H[e+244|0]=0;J[e+240>>2]=677931888;H[e+251|0]=4;if(d>>>0<4){break Sb}c=J[b>>2];if(!(K[e+240|0]!=K[c|0]|K[e+241|0]!=K[c+1|0]|(K[e+242|0]!=K[c+2|0]|K[e+243|0]!=K[c+3|0]))){g=d-4|0;J[b+4>>2]=g;J[b>>2]=c+4;if((g|0)<=0){break Zb}f=J[b>>2];c=J[b>>2];d=0;while(1){if(K[c+d|0]!=41){d=d+1|0;if((g|0)!=(d|0)){continue}break Zb}break}if(d-18>>>0<4294967279){break Zb}nc:{if(d>>>0<=10){H[e+251|0]=d;c=e+240|0;break nc}J[5996]=0;g=(d|15)+1|0;c=$(3,g|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break ec}J[e+240>>2]=c;J[e+244>>2]=d;J[e+248>>2]=g|-2147483648;}H[fb(c,f,d)+d|0]=0;J[e+272>>2]=J[e+244>>2];c=K[e+247|0]|K[e+248|0]<<8|(K[e+249|0]<<16|K[e+250|0]<<24);H[e+275|0]=c;H[e+276|0]=c>>>8;H[e+277|0]=c>>>16;H[e+278|0]=c>>>24;J[5996]=0;f=J[e+240>>2];g=H[e+251|0];J[e+340>>2]=0;J[e+332>>2]=0;J[e+336>>2]=0;c=$(3,12)|0;h=J[5996];J[5996]=0;if((h|0)!=1){J[e+332>>2]=c;h=c+12|0;J[e+340>>2]=h;J[c>>2]=f;J[c+4>>2]=J[e+272>>2];f=K[e+275|0]|K[e+276|0]<<8|(K[e+277|0]<<16|K[e+278|0]<<24);H[c+7|0]=f;H[c+8|0]=f>>>8;H[c+9|0]=f>>>16;H[c+10|0]=f>>>24;H[c+11|0]=g;H[e+275|0]=0;H[e+276|0]=0;H[e+277|0]=0;H[e+278|0]=0;J[e+272>>2]=0;J[e+336>>2]=h;J[5996]=0;c=$(3,104)|0;f=J[5996];J[5996]=0;oc:{pc:{if((f|0)!=1){J[5996]=0;f=ba(147,c|0,3,e+332|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(c);break _b}J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[5996]=0;J[e+268>>2]=f;g=f+12|0;J[e+264>>2]=g;c=$(3,8)|0;h=J[5996];J[5996]=0;if((h|0)==1){break dc}J[e+240>>2]=c;h=c+8|0;J[e+248>>2]=h;J[c+4>>2]=f;J[c>>2]=g;J[e+244>>2]=h;J[e+264>>2]=0;J[e+268>>2]=0;J[5996]=0;f=$(3,104)|0;c=J[5996];J[5996]=0;if((c|0)==1){break pc}J[5996]=0;c=ba(146,f|0,12,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(f);break $b}J[e+348>>2]=c;g=c+12|0;J[e+344>>2]=g;f=J[e+312>>2];qc:{if(f>>>0<M[e+316>>2]){J[f+4>>2]=c;J[f>>2]=g;J[e+312>>2]=f+8;J[e+344>>2]=0;J[e+348>>2]=0;break qc}J[5996]=0;aa(144,e+308|0,e+344|0);c=J[5996];J[5996]=0;if((c|0)==1){break oc}c=J[e+348>>2];if(!c){break qc}f=J[c+4>>2];J[c+4>>2]=f-1;if(f){break qc}Xa[J[J[c>>2]+8>>2]](c);bb(c);}g=J[e+240>>2];if(g){c=J[e+244>>2];f=g;if((c|0)!=(f|0)){while(1){c=c-8|0;f=J[c+4>>2];rc:{if(!f){break rc}h=J[f+4>>2];J[f+4>>2]=h-1;if(h){break rc}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((c|0)!=(g|0)){continue}break}f=J[e+240>>2];}J[e+244>>2]=g;$a(f);}c=J[e+268>>2];sc:{if(!c){break sc}f=J[c+4>>2];J[c+4>>2]=f-1;if(f){break sc}Xa[J[J[c>>2]+8>>2]](c);bb(c);}g=J[e+332>>2];if(g){f=J[e+336>>2];if((g|0)!=(f|0)){while(1){c=f-12|0;if(H[f-1|0]<0){$a(J[c>>2]);}f=c;if((c|0)!=(g|0)){continue}break}}J[e+336>>2]=g;$a(g);}d=d+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];break m}b=Z()|0;break _b}b=Z()|0;break $b}b=Z()|0;mb(e+344|0);break $b}b=Z()|0;rb(e+332|0);if((g|0)>=0){break b}$a(f);break b}H[e+245|0]=0;H[e+244|0]=K[5287];J[e+240>>2]=K[5283]|K[5284]<<8|(K[5285]<<16|K[5286]<<24);H[e+251|0]=5;if(d>>>0<5){break Rb}tc:{c=J[b>>2];if(K[e+240|0]!=K[c|0]|K[e+241|0]!=K[c+1|0]|(K[e+242|0]!=K[c+2|0]|K[e+243|0]!=K[c+3|0])){break tc}if(K[e+244|0]!=K[c+4|0]){break tc}g=d-5|0;J[b+4>>2]=g;J[b>>2]=c+5;if((g|0)<=0){break ac}f=J[b>>2];c=J[b>>2];d=0;while(1){if(K[c+d|0]!=41){d=d+1|0;if((g|0)!=(d|0)){continue}break ac}break}if(d-18>>>0<4294967279){break ac}uc:{if(d>>>0<=10){H[e+251|0]=d;c=e+240|0;break uc}J[5996]=0;g=(d|15)+1|0;c=$(3,g|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break cc}J[e+240>>2]=c;J[e+244>>2]=d;J[e+248>>2]=g|-2147483648;}H[fb(c,f,d)+d|0]=0;J[e+344>>2]=J[e+244>>2];c=K[e+247|0]|K[e+248|0]<<8|(K[e+249|0]<<16|K[e+250|0]<<24);H[e+347|0]=c;H[e+348|0]=c>>>8;H[e+349|0]=c>>>16;H[e+350|0]=c>>>24;J[5996]=0;f=J[e+240>>2];g=H[e+251|0];J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;c=$(3,12)|0;h=J[5996];J[5996]=0;if((h|0)!=1){J[e+240>>2]=c;h=c+12|0;J[e+248>>2]=h;J[c>>2]=f;J[c+4>>2]=J[e+344>>2];f=K[e+347|0]|K[e+348|0]<<8|(K[e+349|0]<<16|K[e+350|0]<<24);H[c+7|0]=f;H[c+8|0]=f>>>8;H[c+9|0]=f>>>16;H[c+10|0]=f>>>24;H[c+11|0]=g;H[e+347|0]=0;H[e+348|0]=0;H[e+349|0]=0;H[e+350|0]=0;J[e+344>>2]=0;J[e+244>>2]=h;J[5996]=0;f=$(3,104)|0;c=J[5996];J[5996]=0;vc:{wc:{if((c|0)!=1){J[5996]=0;c=ba(147,f|0,2,e+240|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){b=Z()|0;$a(f);break vc}J[e+336>>2]=c;g=c+12|0;J[e+332>>2]=g;f=J[e+312>>2];xc:{if(f>>>0<M[e+316>>2]){J[f+4>>2]=c;J[f>>2]=g;J[e+312>>2]=f+8;J[e+332>>2]=0;J[e+336>>2]=0;break xc}J[5996]=0;aa(144,e+308|0,e+332|0);c=J[5996];J[5996]=0;if((c|0)==1){break wc}c=J[e+336>>2];if(!c){break xc}f=J[c+4>>2];J[c+4>>2]=f-1;if(f){break xc}Xa[J[J[c>>2]+8>>2]](c);bb(c);}g=J[e+240>>2];if(g){f=J[e+244>>2];if((g|0)!=(f|0)){while(1){c=f-12|0;if(H[f-1|0]<0){$a(J[c>>2]);}f=c;if((c|0)!=(g|0)){continue}break}}J[e+244>>2]=g;$a(g);}d=d+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];break m}b=Z()|0;break vc}b=Z()|0;mb(e+332|0);}rb(e+240|0);break b}b=Z()|0;rb(e+240|0);if((g|0)>=0){break b}$a(f);break b}H[e+245|0]=0;H[e+244|0]=K[5319];H[e+251|0]=5;f=K[5315]|K[5316]<<8|(K[5317]<<16|K[5318]<<24);J[e+240>>2]=f;c=J[b>>2];if(K[c|0]!=(f&255)|K[e+241|0]!=K[c+1|0]|(K[e+242|0]!=K[c+2|0]|K[e+243|0]!=K[c+3|0])){break Qb}if(K[e+244|0]!=K[c+4|0]){break Qb}J[b+4>>2]=d-5;J[b>>2]=c+5;d=J[b>>2];c=J[b+4>>2];J[5996]=0;f=e+240|0;Na(148,f|0,d|0,c|0);d=J[5996];J[5996]=0;if((d|0)==1){break bc}yc:{zc:{Ac:{Bc:{Cc:{if(K[e+256|0]){J[5996]=0;d=e+332|0;aa(149,d|0,f|0);c=J[5996];J[5996]=0;if((c|0)==1){break Cc}J[5996]=0;c=e+344|0;ea(150,c|0,3,d|0);f=J[5996];J[5996]=0;if((f|0)==1){break Bc}J[5996]=0;aa(151,e+308|0,c|0);f=J[5996];J[5996]=0;if((f|0)==1){break Ac}mb(c);rb(d);d=J[e+252>>2]+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];if(!K[e+256|0]|H[e+251|0]>=0){break m}$a(J[e+240>>2]);break m}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break yc}b=Z()|0;break zc}b=Z()|0;mb(e+344|0);}rb(e+332|0);}if(!K[e+256|0]|H[e+251|0]>=0){break b}$a(J[e+240>>2]);break b}b=Z()|0;break b}b=Z()|0;break Yb}b=Z()|0;break b}b=Z()|0;break $b}b=Z()|0;break b}b=Z()|0;break b}J[a>>2]=0;J[a+4>>2]=0;break l}lb(e+240|0);mb(e+264|0);}rb(e+332|0);break b}J[a>>2]=0;J[a+4>>2]=0;break l}lb(e+240|0);mb(e+264|0);}rb(e+332|0);break b}J[a>>2]=0;J[a+4>>2]=0;break l}H[e+244|0]=0;J[e+240>>2]=677931888;H[e+251|0]=4;}H[e+245|0]=0;H[e+244|0]=K[5287];H[e+251|0]=5;J[e+240>>2]=K[5283]|K[5284]<<8|(K[5285]<<16|K[5286]<<24);}H[e+245|0]=0;H[e+244|0]=K[5319];H[e+251|0]=5;J[e+240>>2]=K[5315]|K[5316]<<8|(K[5317]<<16|K[5318]<<24);}J[5996]=0;d=_(30,e+228|0,5355)|0;c=J[5996];J[5996]=0;Dc:{Ec:{Fc:{if((c|0)!=1){c=vb(d,b);if(H[e+239|0]<0){$a(J[d>>2]);}if(!c){break Dc}d=J[b>>2];c=J[b+4>>2];J[5996]=0;bd(e+240|0,d,c,32);d=J[5996];J[5996]=0;if((d|0)==1){break Fc}if(K[e+256|0]){break Ec}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}b=Z()|0;break b}J[5996]=0;d=e+332|0;ea(153,d|0,6,e+240|0);c=J[5996];J[5996]=0;Gc:{Hc:{if((c|0)!=1){J[5996]=0;aa(151,e+308|0,d|0);c=J[5996];J[5996]=0;if((c|0)==1){break Hc}mb(d);d=J[e+252>>2]+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];if(!K[e+256|0]){break m}d=J[e+240>>2];if(!d){break m}$a(d);break m}b=Z()|0;break Gc}b=Z()|0;mb(e+332|0);}if(!K[e+256|0]){break b}a=J[e+240>>2];if(!a){break b}$a(a);break b}J[5996]=0;d=_(30,e+216|0,5372)|0;c=J[5996];J[5996]=0;Ic:{Jc:{Kc:{if((c|0)!=1){c=vb(d,b);if(H[e+227|0]<0){$a(J[d>>2]);}if(!c){break Ic}d=J[b>>2];c=J[b+4>>2];J[5996]=0;bd(e+240|0,d,c,20);d=J[5996];J[5996]=0;if((d|0)==1){break Kc}if(K[e+256|0]){break Jc}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}b=Z()|0;break b}J[5996]=0;d=e+332|0;ea(153,d|0,8,e+240|0);c=J[5996];J[5996]=0;Lc:{Mc:{if((c|0)!=1){J[5996]=0;aa(151,e+308|0,d|0);c=J[5996];J[5996]=0;if((c|0)==1){break Mc}mb(d);d=J[e+252>>2]+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];if(!K[e+256|0]){break m}d=J[e+240>>2];if(!d){break m}$a(d);break m}b=Z()|0;break Lc}b=Z()|0;mb(e+332|0);}if(!K[e+256|0]){break b}a=J[e+240>>2];if(!a){break b}$a(a);break b}J[5996]=0;d=_(30,e+204|0,5346)|0;c=J[5996];J[5996]=0;Nc:{Oc:{Pc:{if((c|0)!=1){c=vb(d,b);if(H[e+215|0]<0){$a(J[d>>2]);}if(!c){break Nc}d=J[b>>2];c=J[b+4>>2];J[5996]=0;bd(e+240|0,d,c,32);d=J[5996];J[5996]=0;if((d|0)==1){break Pc}if(K[e+256|0]){break Oc}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}b=Z()|0;break b}J[5996]=0;d=e+332|0;ea(153,d|0,7,e+240|0);c=J[5996];J[5996]=0;Qc:{Rc:{if((c|0)!=1){J[5996]=0;aa(151,e+308|0,d|0);c=J[5996];J[5996]=0;if((c|0)==1){break Rc}mb(d);d=J[e+252>>2]+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];if(!K[e+256|0]){break m}d=J[e+240>>2];if(!d){break m}$a(d);break m}b=Z()|0;break Qc}b=Z()|0;mb(e+332|0);}if(!K[e+256|0]){break b}a=J[e+240>>2];if(!a){break b}$a(a);break b}J[5996]=0;d=_(30,e+192|0,5363)|0;c=J[5996];J[5996]=0;Sc:{Tc:{Uc:{if((c|0)!=1){c=vb(d,b);if(H[e+203|0]<0){$a(J[d>>2]);}if(!c){break Sc}d=J[b>>2];c=J[b+4>>2];J[5996]=0;bd(e+240|0,d,c,20);d=J[5996];J[5996]=0;if((d|0)==1){break Uc}if(K[e+256|0]){break Tc}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}b=Z()|0;break b}J[5996]=0;d=e+332|0;ea(153,d|0,9,e+240|0);c=J[5996];J[5996]=0;Vc:{Wc:{if((c|0)!=1){J[5996]=0;aa(151,e+308|0,d|0);c=J[5996];J[5996]=0;if((c|0)==1){break Wc}mb(d);d=J[e+252>>2]+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];if(!K[e+256|0]){break m}d=J[e+240>>2];if(!d){break m}$a(d);break m}b=Z()|0;break Vc}b=Z()|0;mb(e+332|0);}if(!K[e+256|0]){break b}a=J[e+240>>2];if(!a){break b}$a(a);break b}J[5996]=0;d=_(30,e+180|0,5258)|0;c=J[5996];J[5996]=0;Xc:{Yc:{Zc:{_c:{$c:{if((c|0)!=1){c=vb(d,b);if(H[e+191|0]<0){$a(J[d>>2]);}if(!c){break _c}f=J[b+4>>2];ad:{if((f|0)<=0){break ad}c=J[b>>2];d=0;while(1){g=c+d|0;if(K[g|0]!=41){d=d+1|0;if((f|0)!=(d|0)){continue}break ad}break}if(d){break $c}}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}J[5996]=0;c=ba(154,e+168|0,c|0,g|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Yc}f=hd(c,e+240|0);if(H[e+179|0]<0){$a(J[c>>2]);}if(!f){break Zc}f=J[e+244>>2];g=f;c=J[e+240>>2];h=c- -2147483648|0;f=f-(c>>>0<2147483648)|0;if((f|0)==-1&h>>>0<2147483649|(f|0)!=-1){break Zc}J[5996]=0;f=e+332|0;Ae(f,5,c,g);c=J[5996];J[5996]=0;bd:{if((c|0)!=1){J[5996]=0;aa(151,e+308|0,f|0);c=J[5996];J[5996]=0;if((c|0)==1){break bd}mb(f);d=d+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];break m}b=Z()|0;break b}b=Z()|0;mb(e+332|0);break b}J[5996]=0;d=_(30,e+156|0,5265)|0;c=J[5996];J[5996]=0;cd:{dd:{ed:{fd:{if((c|0)!=1){c=vb(d,b);if(H[e+167|0]<0){$a(J[d>>2]);}if(!c){break ed}f=J[b+4>>2];gd:{if((f|0)<=0){break gd}c=J[b>>2];d=0;while(1){g=c+d|0;if(K[g|0]!=41){d=d+1|0;if((f|0)!=(d|0)){continue}break gd}break}if(d){break fd}}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}J[5996]=0;c=ba(154,e+144|0,c|0,g|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break cd}f=hd(c,e+240|0);if(H[e+155|0]<0){$a(J[c>>2]);}if(!f){break dd}f=J[e+244>>2];g=f;c=J[e+240>>2];h=c- -2147483648|0;f=f-(c>>>0<2147483648)|0;if((f|0)==-1&h>>>0<2147483649|(f|0)!=-1){break dd}J[5996]=0;f=e+332|0;Ae(f,4,c,g);c=J[5996];J[5996]=0;hd:{if((c|0)!=1){J[5996]=0;aa(151,e+308|0,f|0);c=J[5996];J[5996]=0;if((c|0)==1){break hd}mb(f);d=d+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];break m}b=Z()|0;break b}b=Z()|0;mb(e+332|0);break b}J[5996]=0;d=_(30,e+132|0,5289)|0;c=J[5996];J[5996]=0;id:{if((c|0)!=1){c=vb(d,b);if(H[e+143|0]<0){$a(J[d>>2]);}if(!c){break Xc}f=J[b+4>>2];jd:{if((f|0)<=0){break jd}c=J[b>>2];d=0;while(1){g=c+d|0;h=K[g|0];if((h|0)!=44){if((h|0)==41){break jd}d=d+1|0;if((f|0)>(d|0)){continue}break jd}break}if(d){break id}}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}J[5996]=0;c=ba(154,e+120|0,c|0,g|0)|0;f=J[5996];J[5996]=0;kd:{if((f|0)!=1){f=hd(c,m);if(H[e+131|0]<0){$a(J[c>>2]);}if(f){break kd}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}d=d+1|0;l=J[b+4>>2]-d|0;J[b+4>>2]=l;f=d+J[b>>2]|0;J[b>>2]=f;J[e+340>>2]=0;J[e+332>>2]=0;J[e+336>>2]=0;ld:{md:{nd:{od:{pd:{qd:{while(1){d=0;g=(l|0)<=0;if(g){break od}rd:{while(1){c=K[d+f|0];if((c|0)==44){c=d;break rd}if((c|0)!=41){d=d+1|0;if((l|0)>(d|0)){continue}}break}c=0;if(g){break od}while(1){if(K[c+f|0]==41){d=-1;break rd}c=c+1|0;if((l|0)!=(c|0)){continue}break}break od}if((c|0)<=0){break od}J[5996]=0;ea(156,e+240|0,f|0,c+f|0);f=J[5996];J[5996]=0;if((f|0)==1){break ld}if(!K[e+252|0]){break od}f=J[e+336>>2];sd:{if(f>>>0<M[e+340>>2]){g=J[e+244>>2];J[f>>2]=J[e+240>>2];J[f+4>>2]=g;J[f+8>>2]=J[e+248>>2];J[e+248>>2]=0;J[e+240>>2]=0;J[e+244>>2]=0;J[e+336>>2]=f+12;l=1;g=0;break sd}J[5996]=0;aa(157,e+332|0,e+240|0);f=J[5996];J[5996]=0;if((f|0)==1){break qd}l=K[e+252|0];g=K[e+251|0];}c=c+1|0;J[b+4>>2]=J[b+4>>2]-c;f=c+J[b>>2]|0;J[b>>2]=f;if(!(!(l&255)|g<<24>>24>=0)){$a(J[e+240>>2]);f=J[b>>2];}if((d|0)!=-1){l=J[b+4>>2];continue}break}d=J[e+336>>2];c=J[e+332>>2];f=(d-c|0)/12|0;if((c|0)!=(d|0)&f>>>0<21){break pd}break od}b=Z()|0;if(!K[e+252|0]|H[e+251|0]>=0){break c}$a(J[e+240>>2]);break c}d=J[e+296>>2];c=J[e+300>>2];if(!((!!d&(c|0)>=0|(c|0)>0)&(!c&d>>>0<=f>>>0))){break od}J[5996]=0;f=e+240|0;g=e+332|0;Ka(158,f|0,25,g|0,d|0,c|0);d=J[5996];J[5996]=0;if((d|0)==1){break nd}J[5996]=0;aa(151,e+308|0,f|0);d=J[5996];J[5996]=0;if((d|0)==1){break md}mb(f);rb(g);break m}J[a>>2]=0;J[a+4>>2]=0;rb(e+332|0);break l}b=Z()|0;break c}b=Z()|0;mb(e+240|0);break c}b=Z()|0;break c}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}J[5996]=0;d=_(30,e+108|0,5302)|0;c=J[5996];J[5996]=0;td:{ud:{if((c|0)!=1){c=vb(d,b);if(H[e+119|0]<0){$a(J[d>>2]);}if(!c){break td}f=J[b+4>>2];vd:{if((f|0)<=0){break vd}c=J[b>>2];d=0;while(1){g=c+d|0;h=K[g|0];if((h|0)!=44){if((h|0)==41){break vd}d=d+1|0;if((f|0)>(d|0)){continue}break vd}break}if(d){break ud}}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}J[5996]=0;c=ba(154,e+96|0,c|0,g|0)|0;f=J[5996];J[5996]=0;wd:{if((f|0)!=1){f=hd(c,m);if(H[e+107|0]<0){$a(J[c>>2]);}if(f){break wd}J[a>>2]=0;J[a+4>>2]=0;break l}b=Z()|0;break b}c=J[e+300>>2];if(!J[e+296>>2]&(c|0)<=0|(c|0)<0){J[a>>2]=0;J[a+4>>2]=0;break l}d=d+1|0;J[b+4>>2]=J[b+4>>2]-d;J[b>>2]=d+J[b>>2];J[5996]=0;d=e+320|0;ga(159,d|0,19,1,m|0);c=J[5996];J[5996]=0;if((c|0)==1){break k}J[5996]=0;ga(160,d|0,0,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break m}b=Z()|0;break b}J[5996]=0;d=_(30,e+84|0,5251)|0;c=J[5996];J[5996]=0;xd:{yd:{zd:{Ad:{Bd:{Cd:{Dd:{if((c|0)!=1){c=vb(d,b);if(H[e+95|0]<0){$a(J[d>>2]);}if(!c){break xd}J[5996]=0;d=e+320|0;ga(160,d|0,14,-1,-1);c=J[5996];J[5996]=0;if((c|0)==1){break Dd}J[5996]=0;ga(160,d|0,21,-1,-1);c=J[5996];J[5996]=0;if((c|0)==1){break Cd}J[5996]=0;ga(160,d|0,0,-1,-1);c=J[5996];J[5996]=0;if((c|0)==1){break Bd}J[5996]=0;ga(160,d|0,20,-1,-1);c=J[5996];J[5996]=0;if((c|0)==1){break Ad}J[5996]=0;ga(160,d|0,0,-1,-1);c=J[5996];J[5996]=0;if((c|0)==1){break zd}J[5996]=0;ga(160,d|0,20,-1,-1);c=J[5996];J[5996]=0;if((c|0)==1){break yd}J[5996]=0;ga(160,d|0,0,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break m}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}J[5996]=0;d=_(30,e+72|0,5272)|0;c=J[5996];J[5996]=0;if((c|0)==1){break j}c=vb(d,b);if(H[e+83|0]<0){$a(J[d>>2]);}Ed:{if(c){J[5996]=0;ga(160,e+320|0,11,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break Ed}b=Z()|0;break b}J[5996]=0;d=_(30,e+60|0,5339)|0;c=J[5996];J[5996]=0;if((c|0)==1){break i}c=vb(d,b);if(H[e+71|0]<0){$a(J[d>>2]);}if(c){J[5996]=0;ga(160,e+320|0,13,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break Ed}b=Z()|0;break b}J[5996]=0;d=_(30,e+48|0,5244)|0;c=J[5996];J[5996]=0;if((c|0)==1){break h}c=vb(d,b);if(H[e+59|0]<0){$a(J[d>>2]);}if(c){J[5996]=0;ga(160,e+320|0,12,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break Ed}b=Z()|0;break b}J[5996]=0;d=_(30,e+36|0,5333)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}c=vb(d,b);if(H[e+47|0]<0){$a(J[d>>2]);}if(c){J[5996]=0;ga(160,e+320|0,15,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break Ed}b=Z()|0;break b}J[5996]=0;d=_(30,e+24|0,5327)|0;c=J[5996];J[5996]=0;if((c|0)==1){break f}c=vb(d,b);if(H[e+35|0]<0){$a(J[d>>2]);}if(c){J[5996]=0;ga(160,e+320|0,16,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break Ed}b=Z()|0;break b}J[5996]=0;d=_(30,e+12|0,5321)|0;c=J[5996];J[5996]=0;if((c|0)==1){break e}c=vb(d,b);if(H[e+23|0]<0){$a(J[d>>2]);}if(c){J[5996]=0;ga(160,e+320|0,17,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break Ed}b=Z()|0;break b}J[5996]=0;d=_(30,e|0,5296)|0;c=J[5996];J[5996]=0;if((c|0)==1){break d}c=vb(d,b);if(H[e+11|0]<0){$a(J[d>>2]);}if(c){J[5996]=0;ga(160,e+320|0,18,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break Ed}b=Z()|0;break b}J[a>>2]=0;J[a+4>>2]=0;break l}J[5996]=0;d=e+320|0;ga(160,d|0,21,-1,-1);c=J[5996];J[5996]=0;Fd:{Gd:{if((c|0)!=1){J[5996]=0;ga(160,d|0,0,-1,-1);c=J[5996];J[5996]=0;if((c|0)==1){break Gd}J[5996]=0;ga(160,d|0,20,-1,-1);c=J[5996];J[5996]=0;if((c|0)==1){break Fd}J[5996]=0;ga(160,d|0,0,-1,-1);d=J[5996];J[5996]=0;if((d|0)!=1){break m}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}c=J[e+324>>2];f=J[e+320>>2];if((c|0)!=(f|0)){continue}break}d=J[e+308>>2];if((J[e+312>>2]-d|0)!=8){J[5996]=0;ga(44,4122,2210,1561,2344);a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}if(J[b+4>>2]){J[a>>2]=0;J[a+4>>2]=0;break l}J[a>>2]=J[d>>2];J[a+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;}a=J[e+308>>2];if(a){d=J[e+312>>2];if((a|0)!=(d|0)){while(1){d=d-8|0;b=J[d+4>>2];Hd:{if(!b){break Hd}c=J[b+4>>2];J[b+4>>2]=c-1;if(c){break Hd}Xa[J[J[b>>2]+8>>2]](b);bb(b);}if((a|0)!=(d|0)){continue}break}a=J[e+308>>2];}$a(a);}a=J[e+320>>2];if(a){J[e+324>>2]=a;$a(a);}Ua=e+352|0;return}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}b=Z()|0;break b}rb(e+332|0);}lb(e+308|0);a=J[e+320>>2];if(a){J[e+324>>2]=a;$a(a);}da(b|0);B();}B();}function hn(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0;f=Ua-128|0;Ua=f;H[f+127|0]=b;g=f+116|0;fb(g,b?3764:5575,b);H[b|g]=0;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{x:{y:{z:{A:{B:{C:{D:{switch(J[c>>2]){case 10:J[5996]=0;b=ba(99,d|0,0,2553)|0;c=J[5996];J[5996]=0;if((c|0)==1){break u}d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b;case 11:J[5996]=0;b=ba(99,d|0,0,1681)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a;case 12:E:{F:{G:{b=J[J[c+32>>2]>>2];switch(J[b>>2]-2|0){case 1:break F;case 0:break G;default:break E}}b=J[b+8>>2];if(H[b+11|0]>=0){J[f+104>>2]=J[b+8>>2];c=J[b+4>>2];J[f+96>>2]=J[b>>2];J[f+100>>2]=c;break c}c=J[b+4>>2];b=J[b>>2];J[5996]=0;ea(40,f+96|0,b|0,c|0);b=J[5996];J[5996]=0;if((b|0)!=1){break c}a=Z()|0;break a}b=J[b+8>>2];if(H[b+11|0]>=0){J[f+104>>2]=J[b+8>>2];c=J[b+4>>2];J[f+96>>2]=J[b>>2];J[f+100>>2]=c;break d}c=J[b+4>>2];b=J[b>>2];J[5996]=0;ea(40,f+96|0,b|0,c|0);b=J[5996];J[5996]=0;if((b|0)!=1){break d}a=Z()|0;break a}J[5996]=0;b=ba(99,d|0,0,2541)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a;case 13:J[5996]=0;b=ba(99,d|0,0,2522)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a;case 14:J[5996]=0;b=ba(99,d|0,0,1271)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a;case 15:J[5996]=0;b=ba(99,d|0,0,2170)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a;case 16:J[5996]=0;b=ba(99,d|0,0,2029)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a;case 17:if(J[J[J[c+32>>2]+8>>2]>>2]!=1){break C}J[5996]=0;b=ba(99,d|0,0,1392)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a;case 22:b=J[c+32>>2];if(!J[J[b>>2]>>2]){J[5996]=0;b=ba(99,d+12|0,0,2096)|0;c=J[5996];J[5996]=0;if((c|0)!=1){e=J[b>>2];c=K[d+19|0]|K[d+20|0]<<8|(K[d+21|0]<<16|K[d+22|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[f+96>>2]=J[d+16>>2];c=K[d+23|0];J[b+8>>2]=0;J[b>>2]=0;J[b+4>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a}if(J[J[b+8>>2]>>2]){break x}J[5996]=0;b=ba(99,d|0,0,1295)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a;case 2:b=J[c+8>>2];if(H[b+11|0]>=0){J[f+104>>2]=J[b+8>>2];c=J[b+4>>2];J[f+96>>2]=J[b>>2];J[f+100>>2]=c;break e}c=J[b+4>>2];b=J[b>>2];J[5996]=0;ea(40,f+96|0,b|0,c|0);b=J[5996];J[5996]=0;if((b|0)!=1){break e}a=Z()|0;break a;case 3:b=J[c+8>>2];if(H[b+11|0]>=0){J[f+104>>2]=J[b+8>>2];c=J[b+4>>2];J[f+96>>2]=J[b>>2];J[f+100>>2]=c;break f}c=J[b+4>>2];b=J[b>>2];J[5996]=0;ea(40,f+96|0,b|0,c|0);b=J[5996];J[5996]=0;if((b|0)!=1){break f}a=Z()|0;break a;case 5:J[5996]=0;b=_(97,f+116|0,5258)|0;d=J[5996];J[5996]=0;H:{I:{J:{K:{L:{if((d|0)!=1){J[f+88>>2]=J[b+8>>2];d=J[b+4>>2];J[f+80>>2]=J[b>>2];J[f+84>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;b=f- -64|0;aa(119,b|0,c+4|0);c=J[5996];J[5996]=0;if((c|0)==1){break L}J[5996]=0;d=b;b=K[f+75|0];c=b<<24>>24<0;c=ba(100,f+80|0,(c?J[f+64>>2]:d)|0,(c?J[f+68>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break K}J[f+104>>2]=J[c+8>>2];b=J[c+4>>2];J[f+96>>2]=J[c>>2];J[f+100>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break J}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break H}a=Z()|0;break I}a=Z()|0;if(H[f+107|0]>=0){break I}$a(J[f+96>>2]);}if(H[f+75|0]>=0){break H}$a(J[f+64>>2]);}if(H[f+91|0]>=0){break a}$a(J[f+80>>2]);break a;case 4:J[5996]=0;b=_(97,f+116|0,5265)|0;d=J[5996];J[5996]=0;M:{N:{O:{P:{Q:{if((d|0)!=1){J[f+88>>2]=J[b+8>>2];d=J[b+4>>2];J[f+80>>2]=J[b>>2];J[f+84>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;b=f- -64|0;aa(119,b|0,c+4|0);c=J[5996];J[5996]=0;if((c|0)==1){break Q}J[5996]=0;d=b;b=K[f+75|0];c=b<<24>>24<0;c=ba(100,f+80|0,(c?J[f+64>>2]:d)|0,(c?J[f+68>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break P}J[f+104>>2]=J[c+8>>2];b=J[c+4>>2];J[f+96>>2]=J[c>>2];J[f+100>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break O}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break M}a=Z()|0;break N}a=Z()|0;if(H[f+107|0]>=0){break N}$a(J[f+96>>2]);}if(H[f+75|0]>=0){break M}$a(J[f+64>>2]);}if(H[f+91|0]>=0){break a}$a(J[f+80>>2]);break a;case 7:J[5996]=0;b=_(97,f+116|0,5346)|0;d=J[5996];J[5996]=0;R:{S:{T:{if((d|0)!=1){J[f+88>>2]=J[b+8>>2];d=J[b+4>>2];J[f+80>>2]=J[b>>2];J[f+84>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;d=J[c+24>>2];b=J[c+20>>2];J[f+72>>2]=0;J[f+64>>2]=0;J[f+68>>2]=0;J[5996]=0;c=d-b|0;aa(101,f- -64|0,c<<1);e=J[5996];J[5996]=0;if((e|0)==1){break h}U:{if(b>>>0<d>>>0){d=b+c|0;while(1){c=K[b|0];J[5996]=0;e=f- -64|0;aa(98,e|0,H[(c>>>4|0)+6976|0]);g=J[5996];J[5996]=0;if((g|0)==1){break U}J[5996]=0;aa(98,e|0,H[(c&15)+6976|0]);c=J[5996];J[5996]=0;if((c|0)==1){break U}b=b+1|0;if((d|0)!=(b|0)){continue}break}}J[5996]=0;b=K[f+75|0];c=b<<24>>24<0;c=ba(100,f+80|0,(c?J[f+64>>2]:f- -64|0)|0,(c?J[f+68>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break T}J[f+104>>2]=J[c+8>>2];b=J[c+4>>2];J[f+96>>2]=J[c>>2];J[f+100>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break S}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}break h}a=Z()|0;break a}a=Z()|0;break R}a=Z()|0;if(H[f+107|0]>=0){break R}$a(J[f+96>>2]);}break g;case 9:J[5996]=0;b=_(97,f+116|0,5363)|0;d=J[5996];J[5996]=0;V:{W:{X:{if((d|0)!=1){J[f+88>>2]=J[b+8>>2];d=J[b+4>>2];J[f+80>>2]=J[b>>2];J[f+84>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;d=J[c+24>>2];b=J[c+20>>2];J[f+72>>2]=0;J[f+64>>2]=0;J[f+68>>2]=0;J[5996]=0;c=d-b|0;aa(101,f- -64|0,c<<1);e=J[5996];J[5996]=0;if((e|0)==1){break j}Y:{if(b>>>0<d>>>0){d=b+c|0;while(1){c=K[b|0];J[5996]=0;e=f- -64|0;aa(98,e|0,H[(c>>>4|0)+6976|0]);g=J[5996];J[5996]=0;if((g|0)==1){break Y}J[5996]=0;aa(98,e|0,H[(c&15)+6976|0]);c=J[5996];J[5996]=0;if((c|0)==1){break Y}b=b+1|0;if((d|0)!=(b|0)){continue}break}}J[5996]=0;b=K[f+75|0];c=b<<24>>24<0;c=ba(100,f+80|0,(c?J[f+64>>2]:f- -64|0)|0,(c?J[f+68>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break X}J[f+104>>2]=J[c+8>>2];b=J[c+4>>2];J[f+96>>2]=J[c>>2];J[f+100>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break W}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}break j}a=Z()|0;break a}a=Z()|0;break V}a=Z()|0;if(H[f+107|0]>=0){break V}$a(J[f+96>>2]);}break i;case 6:J[5996]=0;b=_(97,f+116|0,5355)|0;d=J[5996];J[5996]=0;Z:{_:{$:{if((d|0)!=1){J[f+88>>2]=J[b+8>>2];d=J[b+4>>2];J[f+80>>2]=J[b>>2];J[f+84>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;d=J[c+24>>2];b=J[c+20>>2];J[f+72>>2]=0;J[f+64>>2]=0;J[f+68>>2]=0;J[5996]=0;c=d-b|0;aa(101,f- -64|0,c<<1);e=J[5996];J[5996]=0;if((e|0)==1){break l}aa:{if(b>>>0<d>>>0){d=b+c|0;while(1){c=K[b|0];J[5996]=0;e=f- -64|0;aa(98,e|0,H[(c>>>4|0)+6976|0]);g=J[5996];J[5996]=0;if((g|0)==1){break aa}J[5996]=0;aa(98,e|0,H[(c&15)+6976|0]);c=J[5996];J[5996]=0;if((c|0)==1){break aa}b=b+1|0;if((d|0)!=(b|0)){continue}break}}J[5996]=0;b=K[f+75|0];c=b<<24>>24<0;c=ba(100,f+80|0,(c?J[f+64>>2]:f- -64|0)|0,(c?J[f+68>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break $}J[f+104>>2]=J[c+8>>2];b=J[c+4>>2];J[f+96>>2]=J[c>>2];J[f+100>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break _}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}break l}a=Z()|0;break a}a=Z()|0;break Z}a=Z()|0;if(H[f+107|0]>=0){break Z}$a(J[f+96>>2]);}break k;case 8:J[5996]=0;b=_(97,f+116|0,5372)|0;d=J[5996];J[5996]=0;ba:{ca:{da:{if((d|0)!=1){J[f+88>>2]=J[b+8>>2];d=J[b+4>>2];J[f+80>>2]=J[b>>2];J[f+84>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;d=J[c+24>>2];b=J[c+20>>2];J[f+72>>2]=0;J[f+64>>2]=0;J[f+68>>2]=0;J[5996]=0;c=d-b|0;aa(101,f- -64|0,c<<1);e=J[5996];J[5996]=0;if((e|0)==1){break n}ea:{if(b>>>0<d>>>0){d=b+c|0;while(1){c=K[b|0];J[5996]=0;e=f- -64|0;aa(98,e|0,H[(c>>>4|0)+6976|0]);g=J[5996];J[5996]=0;if((g|0)==1){break ea}J[5996]=0;aa(98,e|0,H[(c&15)+6976|0]);c=J[5996];J[5996]=0;if((c|0)==1){break ea}b=b+1|0;if((d|0)!=(b|0)){continue}break}}J[5996]=0;b=K[f+75|0];c=b<<24>>24<0;c=ba(100,f+80|0,(c?J[f+64>>2]:f- -64|0)|0,(c?J[f+68>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break da}J[f+104>>2]=J[c+8>>2];b=J[c+4>>2];J[f+96>>2]=J[c>>2];J[f+100>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break ca}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}break n}a=Z()|0;break a}a=Z()|0;break ba}a=Z()|0;if(H[f+107|0]>=0){break ba}$a(J[f+96>>2]);}break m;case 1:J[5996]=0;b=_(97,f+116|0,4180)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;c=K[f+127|0];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a;case 24:break s;case 25:break v;case 23:break w;case 20:break y;case 21:break z;case 19:break A;case 18:break B;case 0:break D;default:break t}}J[5996]=0;b=_(97,f+116|0,4350)|0;c=J[5996];J[5996]=0;if((c|0)!=1){d=J[b>>2];J[f+96>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+99|0]=c;H[f+100|0]=c>>>8;H[f+101|0]=c>>>16;H[f+102|0]=c>>>24;c=K[f+127|0];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+96>>2];b=K[f+99|0]|K[f+100|0]<<8|(K[f+101|0]<<16|K[f+102|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a}J[5996]=0;b=_(97,f+116|0,5244)|0;c=J[5996];J[5996]=0;fa:{ga:{ha:{ia:{ja:{ka:{la:{if((c|0)!=1){J[f+56>>2]=J[b+8>>2];c=J[b+4>>2];J[f+48>>2]=J[b>>2];J[f+52>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;c=J[d>>2];e=J[d+4>>2];b=K[d+11|0];J[5996]=0;h=c;c=b<<24>>24<0;c=ba(100,f+48|0,(c?h:d)|0,(c?e:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break la}J[f+72>>2]=J[c+8>>2];b=J[c+4>>2];J[f+64>>2]=J[c>>2];J[f+68>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;e=_(97,f- -64|0,4354)|0;b=J[5996];J[5996]=0;if((b|0)==1){break ka}J[f+88>>2]=J[e+8>>2];b=J[e+4>>2];J[f+80>>2]=J[e>>2];J[f+84>>2]=b;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;g=J[d+16>>2];h=J[d+12>>2];b=K[d+23|0];J[5996]=0;i=d+12|0;d=b<<24>>24<0;d=ba(100,f+80|0,(d?h:i)|0,(d?g:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break ja}J[f+104>>2]=J[d+8>>2];b=J[d+4>>2];J[f+96>>2]=J[d>>2];J[f+100>>2]=b;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;g=J[5996];J[5996]=0;if((g|0)==1){break ia}h=J[b>>2];J[f+24>>2]=J[b+4>>2];g=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+27|0]=g;H[f+28|0]=g>>>8;H[f+29|0]=g>>>16;H[f+30|0]=g>>>24;J[b>>2]=0;J[b+4>>2]=0;g=K[b+11|0];J[b+8>>2]=0;J[a>>2]=h;J[a+4>>2]=J[f+24>>2];b=K[f+27|0]|K[f+28|0]<<8|(K[f+29|0]<<16|K[f+30|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=g;if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break fa}a=Z()|0;break ga}a=Z()|0;break ha}a=Z()|0;if(H[f+107|0]>=0){break ha}$a(J[f+96>>2]);}if(H[f+91|0]>=0){break ga}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break fa}$a(J[f+64>>2]);}if(H[f+59|0]>=0){break a}$a(J[f+48>>2]);break a}J[5996]=0;b=_(97,f+116|0,5339)|0;c=J[5996];J[5996]=0;ma:{na:{oa:{pa:{qa:{ra:{sa:{if((c|0)!=1){J[f+56>>2]=J[b+8>>2];c=J[b+4>>2];J[f+48>>2]=J[b>>2];J[f+52>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;c=J[d>>2];e=J[d+4>>2];b=K[d+11|0];J[5996]=0;h=c;c=b<<24>>24<0;c=ba(100,f+48|0,(c?h:d)|0,(c?e:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break sa}J[f+72>>2]=J[c+8>>2];b=J[c+4>>2];J[f+64>>2]=J[c>>2];J[f+68>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;e=_(97,f- -64|0,4354)|0;b=J[5996];J[5996]=0;if((b|0)==1){break ra}J[f+88>>2]=J[e+8>>2];b=J[e+4>>2];J[f+80>>2]=J[e>>2];J[f+84>>2]=b;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;g=J[d+16>>2];h=J[d+12>>2];b=K[d+23|0];J[5996]=0;i=d+12|0;d=b<<24>>24<0;d=ba(100,f+80|0,(d?h:i)|0,(d?g:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break qa}J[f+104>>2]=J[d+8>>2];b=J[d+4>>2];J[f+96>>2]=J[d>>2];J[f+100>>2]=b;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;g=J[5996];J[5996]=0;if((g|0)==1){break pa}h=J[b>>2];J[f+24>>2]=J[b+4>>2];g=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+27|0]=g;H[f+28|0]=g>>>8;H[f+29|0]=g>>>16;H[f+30|0]=g>>>24;J[b>>2]=0;J[b+4>>2]=0;g=K[b+11|0];J[b+8>>2]=0;J[a>>2]=h;J[a+4>>2]=J[f+24>>2];b=K[f+27|0]|K[f+28|0]<<8|(K[f+29|0]<<16|K[f+30|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=g;if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break ma}a=Z()|0;break na}a=Z()|0;break oa}a=Z()|0;if(H[f+107|0]>=0){break oa}$a(J[f+96>>2]);}if(H[f+91|0]>=0){break na}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break ma}$a(J[f+64>>2]);}if(H[f+59|0]>=0){break a}$a(J[f+48>>2]);break a}J[5996]=0;b=_(97,f+116|0,5333)|0;c=J[5996];J[5996]=0;ta:{ua:{va:{wa:{xa:{ya:{za:{if((c|0)!=1){J[f+56>>2]=J[b+8>>2];c=J[b+4>>2];J[f+48>>2]=J[b>>2];J[f+52>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;c=J[d>>2];e=J[d+4>>2];b=K[d+11|0];J[5996]=0;h=c;c=b<<24>>24<0;c=ba(100,f+48|0,(c?h:d)|0,(c?e:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break za}J[f+72>>2]=J[c+8>>2];b=J[c+4>>2];J[f+64>>2]=J[c>>2];J[f+68>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;e=_(97,f- -64|0,4354)|0;b=J[5996];J[5996]=0;if((b|0)==1){break ya}J[f+88>>2]=J[e+8>>2];b=J[e+4>>2];J[f+80>>2]=J[e>>2];J[f+84>>2]=b;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;g=J[d+16>>2];h=J[d+12>>2];b=K[d+23|0];J[5996]=0;i=d+12|0;d=b<<24>>24<0;d=ba(100,f+80|0,(d?h:i)|0,(d?g:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break xa}J[f+104>>2]=J[d+8>>2];b=J[d+4>>2];J[f+96>>2]=J[d>>2];J[f+100>>2]=b;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;g=J[5996];J[5996]=0;if((g|0)==1){break wa}h=J[b>>2];J[f+24>>2]=J[b+4>>2];g=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+27|0]=g;H[f+28|0]=g>>>8;H[f+29|0]=g>>>16;H[f+30|0]=g>>>24;J[b>>2]=0;J[b+4>>2]=0;g=K[b+11|0];J[b+8>>2]=0;J[a>>2]=h;J[a+4>>2]=J[f+24>>2];b=K[f+27|0]|K[f+28|0]<<8|(K[f+29|0]<<16|K[f+30|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=g;if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break ta}a=Z()|0;break ua}a=Z()|0;break va}a=Z()|0;if(H[f+107|0]>=0){break va}$a(J[f+96>>2]);}if(H[f+91|0]>=0){break ua}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break ta}$a(J[f+64>>2]);}if(H[f+59|0]>=0){break a}$a(J[f+48>>2]);break a}J[5996]=0;b=_(97,f+116|0,5321)|0;c=J[5996];J[5996]=0;Aa:{Ba:{Ca:{Da:{Ea:{Fa:{Ga:{if((c|0)!=1){J[f+56>>2]=J[b+8>>2];c=J[b+4>>2];J[f+48>>2]=J[b>>2];J[f+52>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;c=J[d>>2];e=J[d+4>>2];b=K[d+11|0];J[5996]=0;h=c;c=b<<24>>24<0;c=ba(100,f+48|0,(c?h:d)|0,(c?e:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Ga}J[f+72>>2]=J[c+8>>2];b=J[c+4>>2];J[f+64>>2]=J[c>>2];J[f+68>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;e=_(97,f- -64|0,4354)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Fa}J[f+88>>2]=J[e+8>>2];b=J[e+4>>2];J[f+80>>2]=J[e>>2];J[f+84>>2]=b;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;g=J[d+16>>2];h=J[d+12>>2];b=K[d+23|0];J[5996]=0;i=d+12|0;d=b<<24>>24<0;d=ba(100,f+80|0,(d?h:i)|0,(d?g:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Ea}J[f+104>>2]=J[d+8>>2];b=J[d+4>>2];J[f+96>>2]=J[d>>2];J[f+100>>2]=b;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Da}h=J[b>>2];J[f+24>>2]=J[b+4>>2];g=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+27|0]=g;H[f+28|0]=g>>>8;H[f+29|0]=g>>>16;H[f+30|0]=g>>>24;J[b>>2]=0;J[b+4>>2]=0;g=K[b+11|0];J[b+8>>2]=0;J[a>>2]=h;J[a+4>>2]=J[f+24>>2];b=K[f+27|0]|K[f+28|0]<<8|(K[f+29|0]<<16|K[f+30|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=g;if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break Aa}a=Z()|0;break Ba}a=Z()|0;break Ca}a=Z()|0;if(H[f+107|0]>=0){break Ca}$a(J[f+96>>2]);}if(H[f+91|0]>=0){break Ba}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break Aa}$a(J[f+64>>2]);}if(H[f+59|0]>=0){break a}$a(J[f+48>>2]);break a}J[5996]=0;b=_(97,f+116|0,5327)|0;c=J[5996];J[5996]=0;Ha:{Ia:{Ja:{Ka:{La:{Ma:{Na:{if((c|0)!=1){J[f+56>>2]=J[b+8>>2];c=J[b+4>>2];J[f+48>>2]=J[b>>2];J[f+52>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;c=J[d>>2];e=J[d+4>>2];b=K[d+11|0];J[5996]=0;h=c;c=b<<24>>24<0;c=ba(100,f+48|0,(c?h:d)|0,(c?e:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Na}J[f+72>>2]=J[c+8>>2];b=J[c+4>>2];J[f+64>>2]=J[c>>2];J[f+68>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;e=_(97,f- -64|0,4354)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Ma}J[f+88>>2]=J[e+8>>2];b=J[e+4>>2];J[f+80>>2]=J[e>>2];J[f+84>>2]=b;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;g=J[d+16>>2];h=J[d+12>>2];b=K[d+23|0];J[5996]=0;i=d+12|0;d=b<<24>>24<0;d=ba(100,f+80|0,(d?h:i)|0,(d?g:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break La}J[f+104>>2]=J[d+8>>2];b=J[d+4>>2];J[f+96>>2]=J[d>>2];J[f+100>>2]=b;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Ka}h=J[b>>2];J[f+24>>2]=J[b+4>>2];g=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+27|0]=g;H[f+28|0]=g>>>8;H[f+29|0]=g>>>16;H[f+30|0]=g>>>24;J[b>>2]=0;J[b+4>>2]=0;g=K[b+11|0];J[b+8>>2]=0;J[a>>2]=h;J[a+4>>2]=J[f+24>>2];b=K[f+27|0]|K[f+28|0]<<8|(K[f+29|0]<<16|K[f+30|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=g;if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break Ha}a=Z()|0;break Ia}a=Z()|0;break Ja}a=Z()|0;if(H[f+107|0]>=0){break Ja}$a(J[f+96>>2]);}if(H[f+91|0]>=0){break Ia}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break Ha}$a(J[f+64>>2]);}if(H[f+59|0]>=0){break a}$a(J[f+48>>2]);break a}J[5996]=0;b=_(97,f+116|0,5296)|0;c=J[5996];J[5996]=0;Oa:{Pa:{Qa:{Ra:{Sa:{Ta:{Ua:{if((c|0)!=1){J[f+56>>2]=J[b+8>>2];c=J[b+4>>2];J[f+48>>2]=J[b>>2];J[f+52>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;c=J[d>>2];e=J[d+4>>2];b=K[d+11|0];J[5996]=0;h=c;c=b<<24>>24<0;c=ba(100,f+48|0,(c?h:d)|0,(c?e:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Ua}J[f+72>>2]=J[c+8>>2];b=J[c+4>>2];J[f+64>>2]=J[c>>2];J[f+68>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;e=_(97,f- -64|0,4354)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Ta}J[f+88>>2]=J[e+8>>2];b=J[e+4>>2];J[f+80>>2]=J[e>>2];J[f+84>>2]=b;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;g=J[d+16>>2];h=J[d+12>>2];b=K[d+23|0];J[5996]=0;i=d+12|0;d=b<<24>>24<0;d=ba(100,f+80|0,(d?h:i)|0,(d?g:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Sa}J[f+104>>2]=J[d+8>>2];b=J[d+4>>2];J[f+96>>2]=J[d>>2];J[f+100>>2]=b;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Ra}h=J[b>>2];J[f+24>>2]=J[b+4>>2];g=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+27|0]=g;H[f+28|0]=g>>>8;H[f+29|0]=g>>>16;H[f+30|0]=g>>>24;J[b>>2]=0;J[b+4>>2]=0;g=K[b+11|0];J[b+8>>2]=0;J[a>>2]=h;J[a+4>>2]=J[f+24>>2];b=K[f+27|0]|K[f+28|0]<<8|(K[f+29|0]<<16|K[f+30|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=g;if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break Oa}a=Z()|0;break Pa}a=Z()|0;break Qa}a=Z()|0;if(H[f+107|0]>=0){break Qa}$a(J[f+96>>2]);}if(H[f+91|0]>=0){break Pa}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break Oa}$a(J[f+64>>2]);}if(H[f+59|0]>=0){break a}$a(J[f+48>>2]);break a}if(!J[J[J[c+32>>2]+16>>2]>>2]){J[5996]=0;b=_(97,f+116|0,5272)|0;c=J[5996];J[5996]=0;Va:{Wa:{Xa:{Ya:{Za:{_a:{$a:{if((c|0)!=1){J[f+56>>2]=J[b+8>>2];c=J[b+4>>2];J[f+48>>2]=J[b>>2];J[f+52>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;c=J[d>>2];e=J[d+4>>2];b=K[d+11|0];J[5996]=0;h=c;c=b<<24>>24<0;c=ba(100,f+48|0,(c?h:d)|0,(c?e:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break $a}J[f+72>>2]=J[c+8>>2];b=J[c+4>>2];J[f+64>>2]=J[c>>2];J[f+68>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;e=_(97,f- -64|0,4354)|0;b=J[5996];J[5996]=0;if((b|0)==1){break _a}J[f+88>>2]=J[e+8>>2];b=J[e+4>>2];J[f+80>>2]=J[e>>2];J[f+84>>2]=b;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;g=J[d+16>>2];h=J[d+12>>2];b=K[d+23|0];J[5996]=0;i=d+12|0;d=b<<24>>24<0;d=ba(100,f+80|0,(d?h:i)|0,(d?g:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Za}J[f+104>>2]=J[d+8>>2];b=J[d+4>>2];J[f+96>>2]=J[d>>2];J[f+100>>2]=b;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Ya}h=J[b>>2];J[f+24>>2]=J[b+4>>2];g=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+27|0]=g;H[f+28|0]=g>>>8;H[f+29|0]=g>>>16;H[f+30|0]=g>>>24;J[b>>2]=0;J[b+4>>2]=0;g=K[b+11|0];J[b+8>>2]=0;J[a>>2]=h;J[a+4>>2]=J[f+24>>2];b=K[f+27|0]|K[f+28|0]<<8|(K[f+29|0]<<16|K[f+30|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=g;if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break Va}a=Z()|0;break Wa}a=Z()|0;break Xa}a=Z()|0;if(H[f+107|0]>=0){break Xa}$a(J[f+96>>2]);}if(H[f+91|0]>=0){break Wa}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break Va}$a(J[f+64>>2]);}if(H[f+59|0]>=0){break a}$a(J[f+48>>2]);break a}J[5996]=0;b=_(97,f+116|0,5251)|0;c=J[5996];J[5996]=0;ab:{bb:{cb:{db:{eb:{fb:{gb:{hb:{ib:{jb:{kb:{if((c|0)!=1){J[f+16>>2]=J[b+8>>2];c=J[b+4>>2];J[f+8>>2]=J[b>>2];J[f+12>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;c=J[d>>2];e=J[d+4>>2];b=K[d+11|0];J[5996]=0;h=c;c=b<<24>>24<0;c=ba(100,f+8|0,(c?h:d)|0,(c?e:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break kb}J[f+32>>2]=J[c+8>>2];b=J[c+4>>2];J[f+24>>2]=J[c>>2];J[f+28>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;e=_(97,f+24|0,4354)|0;b=J[5996];J[5996]=0;if((b|0)==1){break jb}J[f+56>>2]=J[e+8>>2];b=J[e+4>>2];J[f+48>>2]=J[e>>2];J[f+52>>2]=b;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;g=J[d+16>>2];h=J[d+12>>2];b=K[d+23|0];J[5996]=0;i=h;h=b<<24>>24<0;g=ba(100,f+48|0,(h?i:d+12|0)|0,(h?g:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break ib}J[f+72>>2]=J[g+8>>2];b=J[g+4>>2];J[f+64>>2]=J[g>>2];J[f+68>>2]=b;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;h=_(97,f- -64|0,4354)|0;b=J[5996];J[5996]=0;if((b|0)==1){break hb}J[f+88>>2]=J[h+8>>2];b=J[h+4>>2];J[f+80>>2]=J[h>>2];J[f+84>>2]=b;J[h>>2]=0;J[h+4>>2]=0;J[h+8>>2]=0;i=J[d+28>>2];j=J[d+24>>2];b=K[d+35|0];J[5996]=0;k=d+24|0;d=b<<24>>24<0;d=ba(100,f+80|0,(d?j:k)|0,(d?i:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break gb}J[f+104>>2]=J[d+8>>2];b=J[d+4>>2];J[f+96>>2]=J[d>>2];J[f+100>>2]=b;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;b=_(97,f+96|0,5242)|0;i=J[5996];J[5996]=0;if((i|0)==1){break fb}j=J[b>>2];J[f+40>>2]=J[b+4>>2];i=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+43|0]=i;H[f+44|0]=i>>>8;H[f+45|0]=i>>>16;H[f+46|0]=i>>>24;J[b>>2]=0;J[b+4>>2]=0;i=K[b+11|0];J[b+8>>2]=0;J[a>>2]=j;J[a+4>>2]=J[f+40>>2];b=K[f+43|0]|K[f+44|0]<<8|(K[f+45|0]<<16|K[f+46|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=i;if(H[d+11|0]<0){$a(J[d>>2]);}if(H[h+11|0]<0){$a(J[h>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+11|0]>=0){break b}$a(J[c>>2]);break b}a=Z()|0;break a}a=Z()|0;break ab}a=Z()|0;break bb}a=Z()|0;break cb}a=Z()|0;break db}a=Z()|0;break eb}a=Z()|0;if(H[f+107|0]>=0){break eb}$a(J[f+96>>2]);}if(H[f+91|0]>=0){break db}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break cb}$a(J[f+64>>2]);}if(H[f+59|0]>=0){break bb}$a(J[f+48>>2]);}if(H[f+35|0]>=0){break ab}$a(J[f+24>>2]);}if(H[f+19|0]>=0){break a}$a(J[f+8>>2]);break a}J[5996]=0;b=_(97,f+116|0,5289)|0;d=J[5996];J[5996]=0;if((d|0)==1){break o}J[f+72>>2]=J[b+8>>2];d=J[b+4>>2];J[f+64>>2]=J[b>>2];J[f+68>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;b=f+96|0;aa(119,b|0,c+4|0);d=J[5996];J[5996]=0;if((d|0)==1){break q}J[5996]=0;e=b;b=K[f+107|0];d=b<<24>>24<0;b=ba(100,f- -64|0,(d?J[f+96>>2]:e)|0,(d?J[f+100>>2]:b)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break r}J[f+88>>2]=J[b+8>>2];d=J[b+4>>2];J[f+80>>2]=J[b>>2];J[f+84>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;lb:{if(H[f+107|0]>=0){break lb}$a(J[f+96>>2]);if(H[b+11|0]>=0){break lb}$a(J[b>>2]);}mb:{nb:{ob:{pb:{qb:{b=J[c+8>>2];d=J[c+12>>2];if((b|0)!=(d|0)){while(1){rb:{if(H[b+11|0]>=0){J[f+104>>2]=J[b+8>>2];c=J[b+4>>2];J[f+96>>2]=J[b>>2];J[f+100>>2]=c;break rb}c=J[b+4>>2];e=J[b>>2];J[5996]=0;ea(40,f+96|0,e|0,c|0);c=J[5996];J[5996]=0;if((c|0)!=1){break rb}a=Z()|0;break nb}J[5996]=0;H[f+108|0]=1;c=ba(99,f+96|0,0,4354)|0;e=J[5996];J[5996]=0;if((e|0)==1){break qb}J[f+56>>2]=J[c+8>>2];e=J[c+4>>2];J[f+48>>2]=J[c>>2];J[f+52>>2]=e;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;e=K[f+59|0];g=e<<24>>24<0;ba(100,f+80|0,(g?J[f+48>>2]:f+48|0)|0,(g?J[f+52>>2]:e)|0)|0;e=J[5996];J[5996]=0;if((e|0)==1){break pb}if(H[f+59|0]<0){$a(J[f+48>>2]);}if(!(!K[f+108|0]|H[f+107|0]>=0)){$a(J[c>>2]);}b=b+12|0;if((d|0)!=(b|0)){continue}break}}J[5996]=0;b=_(97,f+80|0,5242)|0;c=J[5996];J[5996]=0;if((c|0)!=1){break mb}a=Z()|0;break nb}a=Z()|0;break ob}a=Z()|0;if(H[f+59|0]>=0){break ob}$a(J[f+48>>2]);}if(!K[f+108|0]|H[f+107|0]>=0){break nb}$a(J[f+96>>2]);}if(H[f+91|0]>=0){break a}$a(J[f+80>>2]);break a}d=J[b>>2];J[f+48>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=c;H[f+52|0]=c>>>8;H[f+53|0]=c>>>16;H[f+54|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a}J[5996]=0;ga(44,2350,2210,725,5107);a=J[5996];J[5996]=0;if((a|0)==1){a=Z()|0;break a}B();}J[5996]=0;b=_(97,f+116|0,5302)|0;g=J[5996];J[5996]=0;sb:{tb:{ub:{vb:{wb:{xb:{yb:{if((g|0)!=1){J[f+88>>2]=J[b+8>>2];g=J[b+4>>2];J[f+80>>2]=J[b>>2];J[f+84>>2]=g;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;b=f- -64|0;aa(119,b|0,c+4|0);c=J[5996];J[5996]=0;if((c|0)==1){break yb}J[5996]=0;h=b;b=K[f+75|0];c=b<<24>>24<0;b=ba(100,f+80|0,(c?J[f+64>>2]:h)|0,(c?J[f+68>>2]:b)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break xb}J[f+104>>2]=J[b+8>>2];c=J[b+4>>2];J[f+96>>2]=J[b>>2];J[f+100>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;zb:{if(H[f+75|0]>=0){break zb}$a(J[f+64>>2]);if(H[b+11|0]>=0){break zb}$a(J[b>>2]);}if(e){c=P(e,12)+d|0;while(1){J[5996]=0;b=ba(99,d|0,0,4354)|0;d=J[5996];J[5996]=0;if((d|0)==1){break vb}J[f+72>>2]=J[b+8>>2];d=J[b+4>>2];J[f+64>>2]=J[b>>2];J[f+68>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;d=K[f+75|0];e=d<<24>>24<0;ba(100,f+96|0,(e?J[f+64>>2]:f- -64|0)|0,(e?J[f+68>>2]:d)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break ub}if(H[f+75|0]<0){$a(J[f+64>>2]);}d=b+12|0;if((c|0)!=(d|0)){continue}break}}J[5996]=0;b=_(97,f+96|0,5242)|0;c=J[5996];J[5996]=0;if((c|0)==1){break tb}d=J[b>>2];J[f+64>>2]=J[b+4>>2];c=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+67|0]=c;H[f+68|0]=c>>>8;H[f+69|0]=c>>>16;H[f+70|0]=c>>>24;J[b>>2]=0;J[b+4>>2]=0;c=K[b+11|0];J[b+8>>2]=0;J[a>>2]=d;J[a+4>>2]=J[f+64>>2];b=K[f+67|0]|K[f+68|0]<<8|(K[f+69|0]<<16|K[f+70|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=c;break b}a=Z()|0;break a}a=Z()|0;break wb}a=Z()|0;if(H[f+75|0]>=0){break wb}$a(J[f+64>>2]);}if(H[f+91|0]>=0){break a}$a(J[f+80>>2]);break a}a=Z()|0;break sb}a=Z()|0;if(H[f+75|0]>=0){break sb}$a(J[f+64>>2]);break sb}a=Z()|0;}if(H[f+107|0]>=0){break a}$a(J[f+96>>2]);break a}a=Z()|0;if(H[f+107|0]>=0){break p}$a(J[f+96>>2]);break p}a=Z()|0;}if(H[f+75|0]>=0){break a}$a(J[f+64>>2]);break a}a=Z()|0;break a}a=Z()|0;}if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[f+91|0]>=0){break a}$a(J[f+80>>2]);break a}a=Z()|0;}if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[f+91|0]>=0){break a}$a(J[f+80>>2]);break a}a=Z()|0;}if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[f+91|0]>=0){break a}$a(J[f+80>>2]);break a}a=Z()|0;}if(H[f+75|0]<0){$a(J[f+64>>2]);}if(H[f+91|0]>=0){break a}$a(J[f+80>>2]);break a}J[5996]=0;H[f+108|0]=1;b=_(97,f+116|0,5315)|0;c=J[5996];J[5996]=0;Ab:{Bb:{Cb:{Db:{if((c|0)!=1){J[f+72>>2]=J[b+8>>2];c=J[b+4>>2];J[f+64>>2]=J[b>>2];J[f+68>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;b=K[f+107|0];c=b<<24>>24<0;c=ba(100,f- -64|0,(c?J[f+96>>2]:f+96|0)|0,(c?J[f+100>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Db}J[f+88>>2]=J[c+8>>2];b=J[c+4>>2];J[f+80>>2]=J[c>>2];J[f+84>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+80|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Cb}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[c+11|0]<0){$a(J[c>>2]);}if(!K[f+108|0]|H[f+107|0]>=0){break b}$a(J[f+96>>2]);break b}a=Z()|0;break Ab}a=Z()|0;break Bb}a=Z()|0;if(H[f+91|0]>=0){break Bb}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break Ab}$a(J[f+64>>2]);}if(!K[f+108|0]|H[f+107|0]>=0){break a}$a(J[f+96>>2]);break a}J[5996]=0;H[f+108|0]=1;b=_(97,f+116|0,5283)|0;c=J[5996];J[5996]=0;Eb:{Fb:{Gb:{Hb:{if((c|0)!=1){J[f+72>>2]=J[b+8>>2];c=J[b+4>>2];J[f+64>>2]=J[b>>2];J[f+68>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;b=K[f+107|0];c=b<<24>>24<0;c=ba(100,f- -64|0,(c?J[f+96>>2]:f+96|0)|0,(c?J[f+100>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Hb}J[f+88>>2]=J[c+8>>2];b=J[c+4>>2];J[f+80>>2]=J[c>>2];J[f+84>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+80|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Gb}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[c+11|0]<0){$a(J[c>>2]);}if(!K[f+108|0]|H[f+107|0]>=0){break b}$a(J[f+96>>2]);break b}a=Z()|0;break Eb}a=Z()|0;break Fb}a=Z()|0;if(H[f+91|0]>=0){break Fb}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break Eb}$a(J[f+64>>2]);}if(!K[f+108|0]|H[f+107|0]>=0){break a}$a(J[f+96>>2]);break a}J[5996]=0;H[f+108|0]=1;b=_(97,f+116|0,5310)|0;c=J[5996];J[5996]=0;Ib:{Jb:{Kb:{Lb:{if((c|0)!=1){J[f+72>>2]=J[b+8>>2];c=J[b+4>>2];J[f+64>>2]=J[b>>2];J[f+68>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;b=K[f+107|0];c=b<<24>>24<0;c=ba(100,f- -64|0,(c?J[f+96>>2]:f+96|0)|0,(c?J[f+100>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Lb}J[f+88>>2]=J[c+8>>2];b=J[c+4>>2];J[f+80>>2]=J[c>>2];J[f+84>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+80|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Kb}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[c+11|0]<0){$a(J[c>>2]);}if(!K[f+108|0]|H[f+107|0]>=0){break b}$a(J[f+96>>2]);break b}a=Z()|0;break Ib}a=Z()|0;break Jb}a=Z()|0;if(H[f+91|0]>=0){break Jb}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break Ib}$a(J[f+64>>2]);}if(!K[f+108|0]|H[f+107|0]>=0){break a}$a(J[f+96>>2]);break a}J[5996]=0;H[f+108|0]=1;b=_(97,f+116|0,5279)|0;c=J[5996];J[5996]=0;Mb:{Nb:{Ob:{Pb:{if((c|0)!=1){J[f+72>>2]=J[b+8>>2];c=J[b+4>>2];J[f+64>>2]=J[b>>2];J[f+68>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;b=K[f+107|0];c=b<<24>>24<0;c=ba(100,f- -64|0,(c?J[f+96>>2]:f+96|0)|0,(c?J[f+100>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Pb}J[f+88>>2]=J[c+8>>2];b=J[c+4>>2];J[f+80>>2]=J[c>>2];J[f+84>>2]=b;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[5996]=0;b=_(97,f+80|0,5242)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Ob}e=J[b>>2];J[f+48>>2]=J[b+4>>2];d=K[b+7|0]|K[b+8|0]<<8|(K[b+9|0]<<16|K[b+10|0]<<24);H[f+51|0]=d;H[f+52|0]=d>>>8;H[f+53|0]=d>>>16;H[f+54|0]=d>>>24;J[b>>2]=0;J[b+4>>2]=0;d=K[b+11|0];J[b+8>>2]=0;J[a>>2]=e;J[a+4>>2]=J[f+48>>2];b=K[f+51|0]|K[f+52|0]<<8|(K[f+53|0]<<16|K[f+54|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+12|0]=1;H[a+11|0]=d;if(H[c+11|0]<0){$a(J[c>>2]);}if(!K[f+108|0]|H[f+107|0]>=0){break b}$a(J[f+96>>2]);break b}a=Z()|0;break Mb}a=Z()|0;break Nb}a=Z()|0;if(H[f+91|0]>=0){break Nb}$a(J[f+80>>2]);}if(H[f+75|0]>=0){break Mb}$a(J[f+64>>2]);}if(!K[f+108|0]|H[f+107|0]>=0){break a}$a(J[f+96>>2]);break a}if(H[f+127|0]<0){$a(J[f+116>>2]);}Ua=f+128|0;return}if(H[f+127|0]<0){$a(J[f+116>>2]);}da(a|0);B();}function dn(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=Ua-112|0;Ua=h;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{switch(J[c>>2]){case 2:f=J[c+8>>2];c=cb(4);J[h+48>>2]=c;b=c+4|0;J[h+56>>2]=b;H[c|0]=2;H[c+1|0]=80;H[c+2|0]=75;H[c+3|0]=98;J[h+52>>2]=b;J[5996]=0;H[h+16|0]=0;d=h+48|0;ea(126,d|0,29,h+16|0);b=J[5996];J[5996]=0;if((b|0)==1){break c}e=J[h+48>>2];c=K[f+11|0];b=c<<24>>24<0;eb(e+4|0,b?J[f>>2]:f,b?J[f+4>>2]:c);H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;J[5996]=0;_(19,a|0,d|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){g=Z()|0;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0>=29){$a(K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24));H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;}if(!e){break a}$a(e);break a}if(!e){break d}$a(e);break d;case 3:d=J[c+8>>2];c=cb(3);J[h+48>>2]=c;b=c+3|0;J[h+56>>2]=b;H[c+2|0]=104;H[c|0]=80;H[c+1|0]=75;J[h+52>>2]=b;J[5996]=0;H[h+16|0]=0;ea(126,h+48|0,17,h+16|0);b=J[5996];J[5996]=0;if((b|0)==1){g=Z()|0;a=J[h+48>>2];if(!a){break a}$a(a);break a}f=J[h+48>>2];c=K[d+11|0];b=c<<24>>24<0;eb(f+3|0,b?J[d>>2]:d,b?J[d+4>>2]:c);H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a|0]=2;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=118;H[a+5|0]=169;J[5996]=0;i=_(19,a|0,h+48|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){k:{g=K[i|0]|K[i+1|0]<<8|(K[i+2|0]<<16|K[i+3|0]<<24);e=g-29|0;c=g>>>0<29?g:e;b=c+1|0;d=a+4|0;if(b>>>0>(g>>>0<=28?28:K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24))>>>0){J[5996]=0;aa(124,i|0,b+(b>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break k}g=K[i|0]|K[i+1|0]<<8|(K[i+2|0]<<16|K[i+3|0]<<24);e=g-29|0;}b=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);a=g>>>0<29;b=c+(a?d:b)|0;eb(b+1|0,b,(a?g:e)-c|0);a=(K[i|0]|K[i+1|0]<<8|(K[i+2|0]<<16|K[i+3|0]<<24))+1|0;H[i|0]=a;H[i+1|0]=a>>>8;H[i+2|0]=a>>>16;H[i+3|0]=a>>>24;H[b|0]=136;if(!f){break d}$a(f);break d}}g=Z()|0;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0>=29){$a(K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24));H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;}if(!f){break a}$a(f);break a;case 4:H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;b=J[c+4>>2];J[5996]=0;e=nc(a,b,0);b=J[5996];J[5996]=0;if((b|0)!=1){l:{f=K[e|0]|K[e+1|0]<<8|(K[e+2|0]<<16|K[e+3|0]<<24);b=f-29|0;d=f>>>0<29?f:b;c=d+1|0;if(c>>>0>(f>>>0<=28?28:K[e+4|0]|K[e+5|0]<<8|(K[e+6|0]<<16|K[e+7|0]<<24))>>>0){J[5996]=0;aa(124,e|0,c+(c>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break l}f=K[e|0]|K[e+1|0]<<8|(K[e+2|0]<<16|K[e+3|0]<<24);b=f-29|0;}a=f>>>0<29;c=d+(a?e+4|0:K[e+8|0]|K[e+9|0]<<8|(K[e+10|0]<<16|K[e+11|0]<<24))|0;eb(c+1|0,c,(a?f:b)-d|0);a=(K[e|0]|K[e+1|0]<<8|(K[e+2|0]<<16|K[e+3|0]<<24))+1|0;H[e|0]=a;H[e+1|0]=a>>>8;H[e+2|0]=a>>>16;H[e+3|0]=a>>>24;H[c|0]=178;break d}}break b;case 5:H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;b=J[c+4>>2];J[5996]=0;e=nc(a,b,0);b=J[5996];J[5996]=0;if((b|0)!=1){m:{f=K[e|0]|K[e+1|0]<<8|(K[e+2|0]<<16|K[e+3|0]<<24);b=f-29|0;d=f>>>0<29?f:b;c=d+1|0;if(c>>>0>(f>>>0<=28?28:K[e+4|0]|K[e+5|0]<<8|(K[e+6|0]<<16|K[e+7|0]<<24))>>>0){J[5996]=0;aa(124,e|0,c+(c>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break m}f=K[e|0]|K[e+1|0]<<8|(K[e+2|0]<<16|K[e+3|0]<<24);b=f-29|0;}a=f>>>0<29;c=d+(a?e+4|0:K[e+8|0]|K[e+9|0]<<8|(K[e+10|0]<<16|K[e+11|0]<<24))|0;eb(c+1|0,c,(a?f:b)-d|0);a=(K[e|0]|K[e+1|0]<<8|(K[e+2|0]<<16|K[e+3|0]<<24))+1|0;H[e|0]=a;H[e+1|0]=a>>>8;H[e+2|0]=a>>>16;H[e+3|0]=a>>>24;H[c|0]=177;break d}}break b;case 8:J[h+48>>2]=32;J[h+16>>2]=136;J[h+80>>2]=166;J[h+4>>2]=b?136:135;vd(a,h+48|0,h+16|0,h+80|0,c+20|0,h+4|0);break d;case 7:J[h+48>>2]=32;J[h+16>>2]=136;J[h+80>>2]=170;J[h+4>>2]=b?136:135;vd(a,h+48|0,h+16|0,h+80|0,c+20|0,h+4|0);break d;case 9:J[h+48>>2]=32;J[h+16>>2]=136;J[h+80>>2]=169;J[h+4>>2]=b?136:135;vd(a,h+48|0,h+16|0,h+80|0,c+20|0,h+4|0);break d;case 10:H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+4|0]=107;H[a|0]=1;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;c=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);e=-28;f=1;b=K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24);l=b>>>0<29;n:{j=l?b:b-29|0;b=j+1|0;if(b>>>0>=29){J[5996]=0;aa(124,a|0,b+(b>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break n}n=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=f-29|0;}i=a+4|0;b=f>>>0<29;g=(b?i:n)+1|0;eb(j+g|0,g,(b?f:e)-1|0);b=j+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;o:{if(!j){break o}b=l?d+4|0:c;c=j&7;p:{if(!c){f=b;break p}d=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((c|0)!=(d|0)){continue}break}}if(j>>>0<8){break o}b=b+j|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}g=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);n=g-29|0;d=g>>>0<29?g:n;b=d+1|0;if(b>>>0>(g>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){J[5996]=0;aa(124,a|0,b+(b>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break n}g=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);n=g-29|0;}b=g>>>0<29;c=d+(b?i:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(c+1|0,c,(b?g:n)-d|0);b=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;H[c|0]=108;break d}break b;case 11:H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+4|0]=124;H[a|0]=1;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;c=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);e=-28;f=1;b=K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24);i=b>>>0<29;q:{l=i?b:b-29|0;b=l+1|0;if(b>>>0>=29){J[5996]=0;aa(124,a|0,b+(b>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break q}n=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=f-29|0;}b=f>>>0<29;g=(b?a+4|0:n)+1|0;eb(l+g|0,g,(b?f:e)-1|0);b=l+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;if(!l){break d}a=i?d+4|0:c;b=l&7;r:{if(!b){f=a;break r}d=0;f=a;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((b|0)!=(d|0)){continue}break}}if(l>>>0<8){break d}a=a+l|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((a|0)!=(f|0)){continue}break}break d}break b;case 12:J[h+48>>2]=b?173:172;te(a,d,h+48|0);break d;case 13:H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a|0]=2;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=118;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+5|0]=99;c=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);e=-27;f=2;b=K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24);l=b>>>0<29;s:{j=l?b:b-29|0;b=j+2|0;if(b>>>0>=29){J[5996]=0;aa(124,a|0,b+(b>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break s}n=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=f-29|0;}i=a+4|0;b=f>>>0<29;g=(b?i:n)+2|0;eb(j+g|0,g,(b?f:e)-2|0);b=j+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;t:{if(!j){break t}b=l?d+4|0:c;c=j&7;u:{if(!c){f=b;break u}d=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((c|0)!=(d|0)){continue}break}}if(j>>>0<8){break t}b=b+j|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}g=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);n=g-29|0;d=g>>>0<29?g:n;b=d+1|0;if(b>>>0>(g>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){J[5996]=0;aa(124,a|0,b+(b>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break s}g=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);n=g-29|0;}b=g>>>0<29;c=d+(b?i:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(c+1|0,c,(b?g:n)-d|0);b=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;H[c|0]=104;break d}break b;case 14:b=J[J[J[c+32>>2]>>2]+80>>2];if(!(Wb(1239,1)&(b^-1))){J[h+48>>2]=105;te(a,d,h+48|0);break d}H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;J[h+72>>2]=K[a+28|0]|K[a+29|0]<<8|(K[a+30|0]<<16|K[a+31|0]<<24);b=K[a+24|0]|K[a+25|0]<<8|(K[a+26|0]<<16|K[a+27|0]<<24);c=h- -64|0;J[c>>2]=K[a+20|0]|K[a+21|0]<<8|(K[a+22|0]<<16|K[a+23|0]<<24);J[c+4>>2]=b;b=K[a+16|0]|K[a+17|0]<<8|(K[a+18|0]<<16|K[a+19|0]<<24);J[h+56>>2]=K[a+12|0]|K[a+13|0]<<8|(K[a+14|0]<<16|K[a+15|0]<<24);J[h+60>>2]=b;b=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);J[h+48>>2]=K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24);J[h+52>>2]=b;b=K[d+28|0]|K[d+29|0]<<8|(K[d+30|0]<<16|K[d+31|0]<<24);H[a+28|0]=b;H[a+29|0]=b>>>8;H[a+30|0]=b>>>16;H[a+31|0]=b>>>24;e=K[d+24|0]|K[d+25|0]<<8|(K[d+26|0]<<16|K[d+27|0]<<24);b=K[d+20|0]|K[d+21|0]<<8|(K[d+22|0]<<16|K[d+23|0]<<24);H[a+20|0]=b;H[a+21|0]=b>>>8;H[a+22|0]=b>>>16;H[a+23|0]=b>>>24;H[a+24|0]=e;H[a+25|0]=e>>>8;H[a+26|0]=e>>>16;H[a+27|0]=e>>>24;e=K[d+16|0]|K[d+17|0]<<8|(K[d+18|0]<<16|K[d+19|0]<<24);b=K[d+12|0]|K[d+13|0]<<8|(K[d+14|0]<<16|K[d+15|0]<<24);H[a+12|0]=b;H[a+13|0]=b>>>8;H[a+14|0]=b>>>16;H[a+15|0]=b>>>24;H[a+16|0]=e;H[a+17|0]=e>>>8;H[a+18|0]=e>>>16;H[a+19|0]=e>>>24;e=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);b=K[d+4|0]|K[d+5|0]<<8|(K[d+6|0]<<16|K[d+7|0]<<24);H[a+4|0]=b;H[a+5|0]=b>>>8;H[a+6|0]=b>>>16;H[a+7|0]=b>>>24;H[a+8|0]=e;H[a+9|0]=e>>>8;H[a+10|0]=e>>>16;H[a+11|0]=e>>>24;b=J[h+72>>2];H[d+28|0]=b;H[d+29|0]=b>>>8;H[d+30|0]=b>>>16;H[d+31|0]=b>>>24;e=J[c+4>>2];b=J[c>>2];H[d+20|0]=b;H[d+21|0]=b>>>8;H[d+22|0]=b>>>16;H[d+23|0]=b>>>24;H[d+24|0]=e;H[d+25|0]=e>>>8;H[d+26|0]=e>>>16;H[d+27|0]=e>>>24;c=J[h+60>>2];b=J[h+56>>2];H[d+12|0]=b;H[d+13|0]=b>>>8;H[d+14|0]=b>>>16;H[d+15|0]=b>>>24;H[d+16|0]=c;H[d+17|0]=c>>>8;H[d+18|0]=c>>>16;H[d+19|0]=c>>>24;c=J[h+52>>2];b=J[h+48>>2];H[d+4|0]=b;H[d+5|0]=b>>>8;H[d+6|0]=b>>>16;H[d+7|0]=b>>>24;H[d+8|0]=c;H[d+9|0]=c>>>8;H[d+10|0]=c>>>16;H[d+11|0]=c>>>24;J[a>>2]=J[d>>2];J[d>>2]=0;break d;case 15:H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;J[5996]=0;c=_(127,a|0,130)|0;b=J[5996];J[5996]=0;if((b|0)!=1){v:{J[5996]=0;c=_(127,c|0,146)|0;b=J[5996];J[5996]=0;if((b|0)==1){break v}J[5996]=0;k=_(127,c|0,99)|0;b=J[5996];J[5996]=0;if((b|0)==1){break v}e=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);c=K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24);l=c>>>0<29;f=K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24);b=f-29|0;j=l?c:c-29|0;i=f>>>0<29?f:b;c=j+i|0;if(c>>>0>(f>>>0<=28?28:K[k+4|0]|K[k+5|0]<<8|(K[k+6|0]<<16|K[k+7|0]<<24))>>>0){J[5996]=0;aa(124,k|0,c+(c>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break v}f=K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24);b=f-29|0;}c=f>>>0<29;g=i+(c?k+4|0:K[k+8|0]|K[k+9|0]<<8|(K[k+10|0]<<16|K[k+11|0]<<24))|0;eb(j+g|0,g,(c?f:b)-i|0);b=j+(K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24))|0;H[k|0]=b;H[k+1|0]=b>>>8;H[k+2|0]=b>>>16;H[k+3|0]=b>>>24;w:{if(!j){break w}b=l?d+4|0:e;c=j&7;x:{if(!c){f=b;break x}d=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((c|0)!=(d|0)){continue}break}}if(j>>>0<8){break w}b=b+j|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;_(127,k|0,104)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break d}}}break b;case 16:J[h+48>>2]=146;te(a,d,h+48|0);break d;case 1:H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+4|0]=81;H[a|0]=1;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;break d;case 0:H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+4|0]=0;H[a|0]=1;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;break d;case 17:H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;c=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);n=-29;b=0;i=K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24);e=i>>>0<29;y:{l=e?i:i-29|0;if(l>>>0>=29){J[5996]=0;aa(124,a|0,l+(l>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break y}f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);n=f-29|0;b=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);}i=a+4|0;k=b;b=f>>>0<29;g=b?i:k;eb(l+g|0,g,b?f:n);b=l+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;z:{if(!l){break z}b=e?d+4|0:c;c=l&7;A:{if(!c){f=b;break A}n=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;n=n+1|0;if((c|0)!=(n|0)){continue}break}}if(l>>>0<8){break z}b=b+l|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}c=K[d+40|0]|K[d+41|0]<<8|(K[d+42|0]<<16|K[d+43|0]<<24);b=K[d+32|0]|K[d+33|0]<<8|(K[d+34|0]<<16|K[d+35|0]<<24);j=b>>>0<29;f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=f-29|0;k=j?b:b-29|0;l=f>>>0<29?f:e;b=k+l|0;if(b>>>0>(f>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){J[5996]=0;aa(124,a|0,b+(b>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break y}f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=f-29|0;}b=f>>>0<29;g=l+(b?i:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(k+g|0,g,(b?f:e)-l|0);b=k+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;if(!k){break d}a=j?d+36|0:c;b=k&7;B:{if(!b){f=a;break B}d=0;f=a;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((b|0)!=(d|0)){continue}break}}if(k>>>0<8){break d}a=a+k|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((a|0)!=(f|0)){continue}break}break d}break b;case 18:J[h+48>>2]=154;se(a,d,d+32|0,h+48|0);break d;case 19:J[h+48>>2]=155;se(a,d,d+32|0,h+48|0);break d;case 21:H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;c=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);n=-29;b=0;i=K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24);e=i>>>0<29;i=e?i:i-29|0;C:{if(i>>>0>=29){J[5996]=0;aa(124,a|0,i+(i>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break C}f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);n=f-29|0;b=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);}j=a+4|0;k=b;b=f>>>0<29;g=b?j:k;eb(i+g|0,g,b?f:n);b=i+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;D:{if(!i){break D}b=e?d+4|0:c;c=i&7;E:{if(!c){f=b;break E}n=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;n=n+1|0;if((c|0)!=(n|0)){continue}break}}if(i>>>0<8){break D}b=b+i|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;c=_(127,a|0,115)|0;b=J[5996];J[5996]=0;if((b|0)==1){break C}J[5996]=0;m=_(127,c|0,100)|0;b=J[5996];J[5996]=0;if((b|0)==1){break C}e=K[d+40|0]|K[d+41|0]<<8|(K[d+42|0]<<16|K[d+43|0]<<24);c=K[d+32|0]|K[d+33|0]<<8|(K[d+34|0]<<16|K[d+35|0]<<24);l=c>>>0<29;f=K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24);b=f-29|0;k=l?c:c-29|0;i=f>>>0<29?f:b;c=k+i|0;if(c>>>0>(f>>>0<=28?28:K[j|0]|K[j+1|0]<<8|(K[j+2|0]<<16|K[j+3|0]<<24))>>>0){J[5996]=0;aa(124,m|0,c+(c>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break C}f=K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24);b=f-29|0;}c=f>>>0<29;g=i+(c?j:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(k+g|0,g,(c?f:b)-i|0);b=k+(K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24))|0;H[m|0]=b;H[m+1|0]=b>>>8;H[m+2|0]=b>>>16;H[m+3|0]=b>>>24;F:{if(!k){break F}b=l?d+36|0:e;c=k&7;G:{if(!c){f=b;break G}d=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((c|0)!=(d|0)){continue}break}}if(k>>>0<8){break F}b=b+k|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;_(127,m|0,104)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break d}}break b;case 20:H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;c=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);n=-29;b=0;i=K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24);e=i>>>0<29;i=e?i:i-29|0;H:{if(i>>>0>=29){J[5996]=0;aa(124,a|0,i+(i>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break H}f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);n=f-29|0;b=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);}j=a+4|0;k=b;b=f>>>0<29;g=b?j:k;eb(i+g|0,g,b?f:n);b=i+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;I:{if(!i){break I}b=e?d+4|0:c;c=i&7;J:{if(!c){f=b;break J}n=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;n=n+1|0;if((c|0)!=(n|0)){continue}break}}if(i>>>0<8){break I}b=b+i|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;m=_(127,a|0,100)|0;b=J[5996];J[5996]=0;if((b|0)==1){break H}e=K[d+40|0]|K[d+41|0]<<8|(K[d+42|0]<<16|K[d+43|0]<<24);c=K[d+32|0]|K[d+33|0]<<8|(K[d+34|0]<<16|K[d+35|0]<<24);l=c>>>0<29;f=K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24);b=f-29|0;k=l?c:c-29|0;i=f>>>0<29?f:b;c=k+i|0;if(c>>>0>(f>>>0<=28?28:K[j|0]|K[j+1|0]<<8|(K[j+2|0]<<16|K[j+3|0]<<24))>>>0){J[5996]=0;aa(124,m|0,c+(c>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break H}f=K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24);b=f-29|0;}c=f>>>0<29;g=i+(c?j:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(k+g|0,g,(c?f:b)-i|0);b=k+(K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24))|0;H[m|0]=b;H[m+1|0]=b>>>8;H[m+2|0]=b>>>16;H[m+3|0]=b>>>24;K:{if(!k){break K}b=l?d+36|0:e;c=k&7;L:{if(!c){f=b;break L}d=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((c|0)!=(d|0)){continue}break}}if(k>>>0<8){break K}b=b+k|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;_(127,m|0,104)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break d}}break b;case 22:H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;J[5996]=0;k=_(127,a|0,99)|0;b=J[5996];J[5996]=0;if((b|0)!=1){M:{e=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);c=K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24);l=c>>>0<29;f=K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24);b=f-29|0;j=l?c:c-29|0;i=f>>>0<29?f:b;c=j+i|0;if(c>>>0>(f>>>0<=28?28:K[k+4|0]|K[k+5|0]<<8|(K[k+6|0]<<16|K[k+7|0]<<24))>>>0){J[5996]=0;aa(124,k|0,c+(c>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break M}f=K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24);b=f-29|0;}c=f>>>0<29;g=i+(c?k+4|0:K[k+8|0]|K[k+9|0]<<8|(K[k+10|0]<<16|K[k+11|0]<<24))|0;eb(j+g|0,g,(c?f:b)-i|0);b=j+(K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24))|0;H[k|0]=b;H[k+1|0]=b>>>8;H[k+2|0]=b>>>16;H[k+3|0]=b>>>24;N:{if(!j){break N}b=l?d+4|0:e;c=j&7;O:{if(!c){f=b;break O}f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;n=n+1|0;if((c|0)!=(n|0)){continue}break}}if(j>>>0<8){break N}b=b+j|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;k=_(127,k|0,103)|0;b=J[5996];J[5996]=0;if((b|0)==1){break M}e=K[d+40|0]|K[d+41|0]<<8|(K[d+42|0]<<16|K[d+43|0]<<24);c=K[d+32|0]|K[d+33|0]<<8|(K[d+34|0]<<16|K[d+35|0]<<24);l=c>>>0<29;f=K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24);b=f-29|0;j=l?c:c-29|0;i=f>>>0<29?f:b;c=j+i|0;if(c>>>0>(f>>>0<=28?28:K[k+4|0]|K[k+5|0]<<8|(K[k+6|0]<<16|K[k+7|0]<<24))>>>0){J[5996]=0;aa(124,k|0,c+(c>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break M}f=K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24);b=f-29|0;}c=f>>>0<29;g=i+(c?k+4|0:K[k+8|0]|K[k+9|0]<<8|(K[k+10|0]<<16|K[k+11|0]<<24))|0;eb(j+g|0,g,(c?f:b)-i|0);b=j+(K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24))|0;H[k|0]=b;H[k+1|0]=b>>>8;H[k+2|0]=b>>>16;H[k+3|0]=b>>>24;P:{if(!j){break P}b=l?d+36|0:e;c=j&7;Q:{if(!c){f=b;break Q}d=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((c|0)!=(d|0)){continue}break}}if(j>>>0<8){break P}b=b+j|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;_(127,k|0,104)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break d}}}break b;case 23:H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;c=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);n=-29;b=0;i=K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24);e=i>>>0<29;i=e?i:i-29|0;R:{if(i>>>0>=29){J[5996]=0;aa(124,a|0,i+(i>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break R}f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);n=f-29|0;b=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);}k=a+4|0;m=b;b=f>>>0<29;g=b?k:m;eb(i+g|0,g,b?f:n);b=i+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;S:{if(!i){break S}b=e?d+4|0:c;c=i&7;T:{if(!c){f=b;break T}n=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;n=n+1|0;if((c|0)!=(n|0)){continue}break}}if(i>>>0<8){break S}b=b+i|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;m=_(127,a|0,100)|0;b=J[5996];J[5996]=0;if((b|0)==1){break R}e=K[d+72|0]|K[d+73|0]<<8|(K[d+74|0]<<16|K[d+75|0]<<24);c=K[d+64|0]|K[d+65|0]<<8|(K[d+66|0]<<16|K[d+67|0]<<24);l=c>>>0<29;f=K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24);b=f-29|0;j=l?c:c-29|0;i=f>>>0<29?f:b;c=j+i|0;if(c>>>0>(f>>>0<=28?28:K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24))>>>0){J[5996]=0;aa(124,m|0,c+(c>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break R}f=K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24);b=f-29|0;}c=f>>>0<29;g=i+(c?k:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(j+g|0,g,(c?f:b)-i|0);b=j+(K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24))|0;H[m|0]=b;H[m+1|0]=b>>>8;H[m+2|0]=b>>>16;H[m+3|0]=b>>>24;U:{if(!j){break U}b=l?d+68|0:e;c=j&7;V:{if(!c){f=b;break V}n=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;n=n+1|0;if((c|0)!=(n|0)){continue}break}}if(j>>>0<8){break U}b=b+j|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;m=_(127,m|0,103)|0;b=J[5996];J[5996]=0;if((b|0)==1){break R}e=K[d+40|0]|K[d+41|0]<<8|(K[d+42|0]<<16|K[d+43|0]<<24);c=K[d+32|0]|K[d+33|0]<<8|(K[d+34|0]<<16|K[d+35|0]<<24);l=c>>>0<29;f=K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24);b=f-29|0;j=l?c:c-29|0;i=f>>>0<29?f:b;c=j+i|0;if(c>>>0>(f>>>0<=28?28:K[k|0]|K[k+1|0]<<8|(K[k+2|0]<<16|K[k+3|0]<<24))>>>0){J[5996]=0;aa(124,m|0,c+(c>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break R}f=K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24);b=f-29|0;}c=f>>>0<29;g=i+(c?k:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(j+g|0,g,(c?f:b)-i|0);b=j+(K[m|0]|K[m+1|0]<<8|(K[m+2|0]<<16|K[m+3|0]<<24))|0;H[m|0]=b;H[m+1|0]=b>>>8;H[m+2|0]=b>>>16;H[m+3|0]=b>>>24;W:{if(!j){break W}b=l?d+36|0:e;c=j&7;X:{if(!c){f=b;break X}d=0;f=b;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((c|0)!=(d|0)){continue}break}}if(j>>>0<8){break W}b=b+j|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((b|0)!=(f|0)){continue}break}}J[5996]=0;_(127,m|0,104)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break d}}break b;case 25:J[h+72>>2]=0;J[h+76>>2]=0;d=h- -64|0;J[d>>2]=0;J[d+4>>2]=0;J[h+56>>2]=0;J[h+60>>2]=0;J[h+48>>2]=0;J[h+52>>2]=0;d=J[c+4>>2];J[5996]=0;o=nc(h+48|0,d,0);d=J[5996];J[5996]=0;if((d|0)==1){g=Z()|0;if(M[h+48>>2]<29){break a}$a(J[h+56>>2]);break a}e=J[c+8>>2];m=J[c+12>>2];if((e|0)==(m|0)){c=e;break g}l=o+4|0;i=h+20|0;while(1){Y:{J[5996]=0;f=$(3,4)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Y}J[h+4>>2]=f;d=f+4|0;J[h+12>>2]=d;H[f|0]=2;H[f+1|0]=80;H[f+2|0]=75;H[f+3|0]=98;J[h+8>>2]=d;J[5996]=0;H[h+80|0]=0;ea(126,h+4|0,29,h+80|0);d=J[5996];J[5996]=0;if((d|0)==1){g=Z()|0;a=J[h+4>>2];if(!a){break f}$a(a);break f}d=0;j=K[e+11|0];f=j<<24>>24<0;eb(J[h+4>>2]+4|0,f?J[e>>2]:e,f?J[e+4>>2]:j);J[h+40>>2]=0;J[h+44>>2]=0;J[h+32>>2]=0;J[h+36>>2]=0;J[h+24>>2]=0;J[h+28>>2]=0;J[h+16>>2]=0;J[h+20>>2]=0;n=-29;j=J[o+8>>2];f=0;p=J[o>>2];k=p>>>0<29;p=k?p:p-29|0;if(p>>>0>=29){J[5996]=0;aa(124,h+16|0,p+(p>>>1|0)|0);d=J[5996];J[5996]=0;if((d|0)==1){break i}f=J[h+16>>2];n=f-29|0;g=J[h+24>>2];}else {g=d;}d=f>>>0<29;g=d?i:g;eb(g+p|0,g,d?f:n);J[h+16>>2]=p+J[h+16>>2];Z:{if(!p){break Z}d=0;k=k?l:j;f=k;j=p&7;if(j){while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((j|0)!=(d|0)){continue}break}}if(p>>>0<8){break Z}d=k+p|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((d|0)!=(f|0)){continue}break}}J[5996]=0;f=_(19,h+16|0,h+4|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break i}J[h+104>>2]=K[l+24|0]|K[l+25|0]<<8|(K[l+26|0]<<16|K[l+27|0]<<24);d=K[l+20|0]|K[l+21|0]<<8|(K[l+22|0]<<16|K[l+23|0]<<24);J[h+96>>2]=K[l+16|0]|K[l+17|0]<<8|(K[l+18|0]<<16|K[l+19|0]<<24);J[h+100>>2]=d;d=K[l+12|0]|K[l+13|0]<<8|(K[l+14|0]<<16|K[l+15|0]<<24);J[h+88>>2]=K[l+8|0]|K[l+9|0]<<8|(K[l+10|0]<<16|K[l+11|0]<<24);J[h+92>>2]=d;d=K[l+4|0]|K[l+5|0]<<8|(K[l+6|0]<<16|K[l+7|0]<<24);J[h+80>>2]=K[l|0]|K[l+1|0]<<8|(K[l+2|0]<<16|K[l+3|0]<<24);J[h+84>>2]=d;J[l+24>>2]=J[i+24>>2];d=J[i+20>>2];J[l+16>>2]=J[i+16>>2];J[l+20>>2]=d;d=J[i+12>>2];J[l+8>>2]=J[i+8>>2];J[l+12>>2]=d;d=J[i+4>>2];J[l>>2]=J[i>>2];J[l+4>>2]=d;d=J[h+104>>2];H[i+24|0]=d;H[i+25|0]=d>>>8;H[i+26|0]=d>>>16;H[i+27|0]=d>>>24;j=J[h+100>>2];d=J[h+96>>2];H[i+16|0]=d;H[i+17|0]=d>>>8;H[i+18|0]=d>>>16;H[i+19|0]=d>>>24;H[i+20|0]=j;H[i+21|0]=j>>>8;H[i+22|0]=j>>>16;H[i+23|0]=j>>>24;j=J[h+92>>2];d=J[h+88>>2];H[i+8|0]=d;H[i+9|0]=d>>>8;H[i+10|0]=d>>>16;H[i+11|0]=d>>>24;H[i+12|0]=j;H[i+13|0]=j>>>8;H[i+14|0]=j>>>16;H[i+15|0]=j>>>24;j=J[h+84>>2];d=J[h+80>>2];H[i|0]=d;H[i+1|0]=d>>>8;H[i+2|0]=d>>>16;H[i+3|0]=d>>>24;H[i+4|0]=j;H[i+5|0]=j>>>8;H[i+6|0]=j>>>16;H[i+7|0]=j>>>24;d=J[o>>2];J[o>>2]=J[f>>2];J[f>>2]=d;if(d>>>0>=29){$a(J[h+24>>2]);J[h+24>>2]=0;}d=J[h+4>>2];if(d){$a(d);}e=e+12|0;if((m|0)!=(e|0)){continue}break h}break}g=Z()|0;break f;case 24:J[h+72>>2]=0;J[h+76>>2]=0;f=h- -64|0;J[f>>2]=0;J[f+4>>2]=0;J[h+56>>2]=0;J[h+60>>2]=0;J[h+48>>2]=0;J[h+52>>2]=0;n=J[h+76>>2];J[h+40>>2]=n;k=J[h+72>>2];f=J[h+68>>2];m=f;J[h+32>>2]=f;J[h+36>>2]=k;j=J[h+64>>2];i=J[h+60>>2];J[h+24>>2]=i;J[h+28>>2]=j;l=J[h+56>>2];f=J[h+52>>2];J[h+16>>2]=f;J[h+20>>2]=l;J[h+76>>2]=K[d+28|0]|K[d+29|0]<<8|(K[d+30|0]<<16|K[d+31|0]<<24);o=K[d+24|0]|K[d+25|0]<<8|(K[d+26|0]<<16|K[d+27|0]<<24);J[h+68>>2]=K[d+20|0]|K[d+21|0]<<8|(K[d+22|0]<<16|K[d+23|0]<<24);J[h+72>>2]=o;o=K[d+16|0]|K[d+17|0]<<8|(K[d+18|0]<<16|K[d+19|0]<<24);J[h+60>>2]=K[d+12|0]|K[d+13|0]<<8|(K[d+14|0]<<16|K[d+15|0]<<24);J[h+64>>2]=o;o=K[d+8|0]|K[d+9|0]<<8|(K[d+10|0]<<16|K[d+11|0]<<24);J[h+52>>2]=K[d+4|0]|K[d+5|0]<<8|(K[d+6|0]<<16|K[d+7|0]<<24);J[h+56>>2]=o;H[d+28|0]=n;H[d+29|0]=n>>>8;H[d+30|0]=n>>>16;H[d+31|0]=n>>>24;H[d+20|0]=m;H[d+21|0]=m>>>8;H[d+22|0]=m>>>16;H[d+23|0]=m>>>24;H[d+24|0]=k;H[d+25|0]=k>>>8;H[d+26|0]=k>>>16;H[d+27|0]=k>>>24;H[d+12|0]=i;H[d+13|0]=i>>>8;H[d+14|0]=i>>>16;H[d+15|0]=i>>>24;H[d+16|0]=j;H[d+17|0]=j>>>8;H[d+18|0]=j>>>16;H[d+19|0]=j>>>24;H[d+4|0]=f;H[d+5|0]=f>>>8;H[d+6|0]=f>>>16;H[d+7|0]=f>>>24;H[d+8|0]=l;H[d+9|0]=l>>>8;H[d+10|0]=l>>>16;H[d+11|0]=l>>>24;g=J[d>>2];J[h+48>>2]=g;J[d>>2]=0;j=h+48|4;_:{$:{if(e>>>0>=2){n=1;while(1){J[5996]=0;J[h+4>>2]=147;ga(128,h+16|0,h+48|0,(n<<5)+d|0,h+4|0);f=J[5996];J[5996]=0;if((f|0)==1){break $}J[h+104>>2]=K[j+24|0]|K[j+25|0]<<8|(K[j+26|0]<<16|K[j+27|0]<<24);f=K[j+20|0]|K[j+21|0]<<8|(K[j+22|0]<<16|K[j+23|0]<<24);J[h+96>>2]=K[j+16|0]|K[j+17|0]<<8|(K[j+18|0]<<16|K[j+19|0]<<24);J[h+100>>2]=f;f=K[j+12|0]|K[j+13|0]<<8|(K[j+14|0]<<16|K[j+15|0]<<24);J[h+88>>2]=K[j+8|0]|K[j+9|0]<<8|(K[j+10|0]<<16|K[j+11|0]<<24);J[h+92>>2]=f;f=K[j+4|0]|K[j+5|0]<<8|(K[j+6|0]<<16|K[j+7|0]<<24);J[h+80>>2]=K[j|0]|K[j+1|0]<<8|(K[j+2|0]<<16|K[j+3|0]<<24);J[h+84>>2]=f;J[j+24>>2]=J[h+44>>2];f=J[h+40>>2];J[j+16>>2]=J[h+36>>2];J[j+20>>2]=f;f=J[h+32>>2];J[j+8>>2]=J[h+28>>2];J[j+12>>2]=f;f=J[h+24>>2];J[j>>2]=J[h+20>>2];J[j+4>>2]=f;f=J[h+104>>2];H[h+44|0]=f;H[h+45|0]=f>>>8;H[h+46|0]=f>>>16;H[h+47|0]=f>>>24;i=J[h+100>>2];f=J[h+96>>2];H[h+36|0]=f;H[h+37|0]=f>>>8;H[h+38|0]=f>>>16;H[h+39|0]=f>>>24;H[h+40|0]=i;H[h+41|0]=i>>>8;H[h+42|0]=i>>>16;H[h+43|0]=i>>>24;i=J[h+92>>2];f=J[h+88>>2];H[h+28|0]=f;H[h+29|0]=f>>>8;H[h+30|0]=f>>>16;H[h+31|0]=f>>>24;H[h+32|0]=i;H[h+33|0]=i>>>8;H[h+34|0]=i>>>16;H[h+35|0]=i>>>24;i=J[h+84>>2];f=J[h+80>>2];H[h+20|0]=f;H[h+21|0]=f>>>8;H[h+22|0]=f>>>16;H[h+23|0]=f>>>24;H[h+24|0]=i;H[h+25|0]=i>>>8;H[h+26|0]=i>>>16;H[h+27|0]=i>>>24;f=J[h+48>>2];J[h+48>>2]=J[h+16>>2];J[h+16>>2]=f;if(f>>>0>=29){$a(J[h+24>>2]);}n=n+1|0;if((n|0)!=(e|0)){continue}break}g=J[h+48>>2];}H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;n=-29;i=J[h+56>>2];d=0;aa:{k=a+4|0;f=g>>>0<29;l=f?g:g-29|0;ba:{if(l>>>0>=29){J[5996]=0;aa(124,a|0,l+(l>>>1|0)|0);d=J[5996];J[5996]=0;if((d|0)==1){break ba}d=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);n=d-29|0;p=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);}e=d>>>0<29;g=e?k:p;eb(g+l|0,g,e?d:n);d=l+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=d;H[a+1|0]=d>>>8;H[a+2|0]=d>>>16;H[a+3|0]=d>>>24;ca:{if(!l){break ca}e=f?j:i;i=l&7;da:{if(!i){f=e;break da}d=0;f=e;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((i|0)!=(d|0)){continue}break}}if(l>>>0<8){break ca}d=e+l|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((d|0)!=(f|0)){continue}break}}c=J[c+4>>2];J[5996]=0;d=nc(a,c,0);c=J[5996];J[5996]=0;if((c|0)==1){break ba}J[5996]=0;_(127,d|0,(b?136:135)|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break aa}}g=Z()|0;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0<29){break _}$a(K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24));H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;break _}if(M[h+48>>2]<29){break d}$a(J[h+56>>2]);break d}g=Z()|0;}if(M[h+48>>2]<29){break a}$a(J[h+56>>2]);break a;default:la(2350,2210,624,5107);B();case 6:break j}}J[h+48>>2]=32;J[h+16>>2]=136;J[h+80>>2]=168;J[h+4>>2]=b?136:135;vd(a,h+48|0,h+16|0,h+80|0,c+20|0,h+4|0);break d}g=Z()|0;if(M[h+16>>2]>=29){$a(J[h+24>>2]);J[h+24>>2]=0;}a=J[h+4>>2];if(!a){break f}$a(a);break f}e=J[c+8>>2];c=J[c+12>>2];}H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;l=J[o+8>>2];d=-29;i=(c-e|0)/12|0;n=0;f=0;c=J[o>>2];e=c>>>0<29;j=e?c:c-29|0;ea:{if(j>>>0>=29){J[5996]=0;aa(124,a|0,j+(j>>>1|0)|0);c=J[5996];J[5996]=0;if((c|0)==1){break ea}n=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);f=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=f-29|0;}c=f>>>0<29;g=c?a+4|0:n;eb(j+g|0,g,c?f:d);c=j+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;fa:{if(!j){break fa}c=e?o+4|0:l;e=j&7;ga:{if(!e){f=c;break ga}d=0;f=c;while(1){H[g|0]=K[f|0];f=f+1|0;g=g+1|0;d=d+1|0;if((e|0)!=(d|0)){continue}break}}if(j>>>0<8){break fa}c=c+j|0;while(1){H[g|0]=K[f|0];H[g+1|0]=K[f+1|0];H[g+2|0]=K[f+2|0];H[g+3|0]=K[f+3|0];H[g+4|0]=K[f+4|0];H[g+5|0]=K[f+5|0];H[g+6|0]=K[f+6|0];H[g+7|0]=K[f+7|0];g=g+8|0;f=f+8|0;if((c|0)!=(f|0)){continue}break}}J[5996]=0;d=nc(a,i,0);c=J[5996];J[5996]=0;if((c|0)==1){break ea}J[5996]=0;_(127,d|0,(b?175:174)|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break e}}g=Z()|0;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0<29){break f}$a(K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24));H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;}if(M[o>>2]<29){break a}$a(J[o+8>>2]);break a}if(M[o>>2]<29){break d}$a(J[o+8>>2]);}Ua=h+112|0;return}g=Z()|0;a=J[h+48>>2];if(!a){break a}$a(a);break a}g=Z()|0;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0<29){break a}$a(K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24));H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;}da(g|0);B();}function Um(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;c=Ua-496|0;Ua=c;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{x:{y:{z:{A:{B:{C:{D:{E:{F:{G:{H:{I:{J:{K:{L:{M:{N:{O:{P:{Q:{R:{S:{T:{U:{V:{W:{X:{Y:{e=J[b>>2];switch(J[e>>2]-1|0){case 23:break z;case 22:break A;case 21:break B;case 20:break C;case 19:break D;case 18:break E;case 17:break F;case 16:break G;case 14:break H;case 15:break I;case 13:break J;case 12:break K;case 11:break L;case 10:break M;case 9:break N;case 0:break O;case 8:break Q;case 6:break R;case 7:break S;case 5:break T;case 3:break U;case 4:break V;case 24:break W;case 2:break X;case 1:break Y;default:break P}}e=J[e+8>>2];Z:{if(H[e+11|0]>=0){J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;break Z}Zc(c+448|0,J[e>>2],J[e+4>>2]);}J[5996]=0;H[c+460|0]=1;e=ba(99,c+448|0,0,5283)|0;d=J[5996];J[5996]=0;_:{$:{aa:{ba:{if((d|0)!=1){J[c+472>>2]=J[e+8>>2];d=J[e+4>>2];J[c+464>>2]=J[e>>2];J[c+468>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;d=_(97,c+464|0,5242)|0;f=J[5996];J[5996]=0;if((f|0)==1){break ba}J[c+488>>2]=J[d+8>>2];f=J[d+4>>2];J[c+480>>2]=J[d>>2];J[c+484>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;ea(161,a|0,b|0,c+480|0);a=J[5996];J[5996]=0;if((a|0)==1){break aa}if(H[c+491|0]<0){$a(J[c+480>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(!K[c+460|0]|H[e+11|0]>=0){break y}$a(J[e>>2]);break y}b=Z()|0;break _}b=Z()|0;break $}b=Z()|0;if(H[c+491|0]>=0){break $}$a(J[c+480>>2]);}if(H[c+475|0]>=0){break _}$a(J[c+464>>2]);}break c}e=J[e+8>>2];ca:{if(H[e+11|0]>=0){J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;break ca}Zc(c+448|0,J[e>>2],J[e+4>>2]);}J[5996]=0;H[c+460|0]=1;e=ba(99,c+448|0,0,5315)|0;d=J[5996];J[5996]=0;da:{ea:{fa:{ga:{if((d|0)!=1){J[c+472>>2]=J[e+8>>2];d=J[e+4>>2];J[c+464>>2]=J[e>>2];J[c+468>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;d=_(97,c+464|0,5242)|0;f=J[5996];J[5996]=0;if((f|0)==1){break ga}J[c+440>>2]=J[d+8>>2];f=J[d+4>>2];J[c+432>>2]=J[d>>2];J[c+436>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;ea(161,a|0,b|0,c+432|0);a=J[5996];J[5996]=0;if((a|0)==1){break fa}if(H[c+443|0]<0){$a(J[c+432>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(!K[c+460|0]|H[e+11|0]>=0){break y}$a(J[e>>2]);break y}b=Z()|0;break da}b=Z()|0;break ea}b=Z()|0;if(H[c+443|0]>=0){break ea}$a(J[c+432>>2]);}if(H[c+475|0]>=0){break da}$a(J[c+464>>2]);}break c}d=c+384|0;Kc(d,J[e+4>>2]);J[5996]=0;e=ba(99,d|0,0,5289)|0;d=J[5996];J[5996]=0;ha:{ia:{ja:{ka:{la:{ma:{na:{oa:{pa:{qa:{if((d|0)!=1){J[c+408>>2]=J[e+8>>2];d=J[e+4>>2];J[c+400>>2]=J[e>>2];J[c+404>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;d=_(97,c+400|0,5417)|0;f=J[5996];J[5996]=0;if((f|0)==1){break qa}J[c+472>>2]=J[d+8>>2];f=J[d+4>>2];J[c+464>>2]=J[d>>2];J[c+468>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;f=J[b>>2];g=J[f+12>>2];f=J[f+8>>2];J[5996]=0;h=c+368|0;aa(115,h|0,(g-f|0)/12|0);f=J[5996];J[5996]=0;if((f|0)==1){break pa}J[5996]=0;f=K[c+379|0];g=f<<24>>24<0;f=ba(100,c+464|0,(g?J[c+368>>2]:h)|0,(g?J[c+372>>2]:f)|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break oa}J[c+456>>2]=J[f+8>>2];g=J[f+4>>2];J[c+448>>2]=J[f>>2];J[c+452>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;J[5996]=0;g=_(97,c+448|0,5242)|0;h=J[5996];J[5996]=0;if((h|0)==1){break na}J[c+424>>2]=J[g+8>>2];h=J[g+4>>2];J[c+416>>2]=J[g>>2];J[c+420>>2]=h;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;ea(161,a|0,b|0,c+416|0);a=J[5996];J[5996]=0;if((a|0)==1){break ma}if(H[c+427|0]<0){$a(J[c+416>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[c+379|0]<0){$a(J[c+368>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]>=0){break y}$a(J[e>>2]);break y}b=Z()|0;break ha}b=Z()|0;break ia}b=Z()|0;break ja}b=Z()|0;break ka}b=Z()|0;break la}b=Z()|0;if(H[c+427|0]>=0){break la}$a(J[c+416>>2]);}if(H[c+459|0]>=0){break ka}$a(J[c+448>>2]);}if(H[c+379|0]>=0){break ja}$a(J[c+368>>2]);}if(H[c+475|0]>=0){break ia}$a(J[c+464>>2]);}if(H[c+411|0]>=0){break ha}$a(J[c+400>>2]);}if(H[c+395|0]>=0){break a}$a(J[c+384>>2]);break a}d=c+464|0;Kc(d,J[e+4>>2]);J[5996]=0;e=ba(99,d|0,0,5258)|0;d=J[5996];J[5996]=0;ra:{sa:{ta:{ua:{if((d|0)!=1){J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;d=_(97,c+448|0,5242)|0;f=J[5996];J[5996]=0;if((f|0)==1){break ua}J[c+360>>2]=J[d+8>>2];f=J[d+4>>2];J[c+352>>2]=J[d>>2];J[c+356>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;ea(161,a|0,b|0,c+352|0);a=J[5996];J[5996]=0;if((a|0)==1){break ta}if(H[c+363|0]<0){$a(J[c+352>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]>=0){break y}$a(J[e>>2]);break y}b=Z()|0;break ra}b=Z()|0;break sa}b=Z()|0;if(H[c+363|0]>=0){break sa}$a(J[c+352>>2]);}if(H[c+459|0]>=0){break ra}$a(J[c+448>>2]);}break b}d=c+464|0;Kc(d,J[e+4>>2]);J[5996]=0;e=ba(99,d|0,0,5265)|0;d=J[5996];J[5996]=0;va:{wa:{xa:{ya:{if((d|0)!=1){J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;d=_(97,c+448|0,5242)|0;f=J[5996];J[5996]=0;if((f|0)==1){break ya}J[c+344>>2]=J[d+8>>2];f=J[d+4>>2];J[c+336>>2]=J[d>>2];J[c+340>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;ea(161,a|0,b|0,c+336|0);a=J[5996];J[5996]=0;if((a|0)==1){break xa}if(H[c+347|0]<0){$a(J[c+336>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]>=0){break y}$a(J[e>>2]);break y}b=Z()|0;break va}b=Z()|0;break wa}b=Z()|0;if(H[c+347|0]>=0){break wa}$a(J[c+336>>2]);}if(H[c+459|0]>=0){break va}$a(J[c+448>>2]);}break b}H[c+328|0]=0;J[c+320>>2]=845244531;J[c+324>>2]=690501173;H[c+331|0]=8;J[5996]=0;ea(161,a|0,b|0,c+320|0);a=J[5996];J[5996]=0;if((a|0)!=1){if(H[c+331|0]>=0){break y}$a(J[c+320>>2]);break y}b=Z()|0;if(H[c+331|0]>=0){break a}$a(J[c+320>>2]);break a}e=cb(16);J[c+308>>2]=e;J[c+312>>2]=11;J[c+316>>2]=-2147483632;d=K[5239]|K[5240]<<8|(K[5241]<<16|K[5242]<<24);H[e+7|0]=d;H[e+8|0]=d>>>8;H[e+9|0]=d>>>16;H[e+10|0]=d>>>24;d=K[5236]|K[5237]<<8|(K[5238]<<16|K[5239]<<24);f=K[5232]|K[5233]<<8|(K[5234]<<16|K[5235]<<24);H[e|0]=f;H[e+1|0]=f>>>8;H[e+2|0]=f>>>16;H[e+3|0]=f>>>24;H[e+4|0]=d;H[e+5|0]=d>>>8;H[e+6|0]=d>>>16;H[e+7|0]=d>>>24;H[e+11|0]=0;J[5996]=0;ea(161,a|0,b|0,c+308|0);a=J[5996];J[5996]=0;if((a|0)!=1){if(H[c+319|0]>=0){break y}$a(J[c+308>>2]);break y}b=Z()|0;if(H[c+319|0]>=0){break a}$a(J[c+308>>2]);break a}H[c+304|0]=K[5220];H[c+307|0]=9;H[c+305|0]=0;J[5996]=0;e=K[5216]|K[5217]<<8|(K[5218]<<16|K[5219]<<24);J[c+296>>2]=K[5212]|K[5213]<<8|(K[5214]<<16|K[5215]<<24);J[c+300>>2]=e;ea(161,a|0,b|0,c+296|0);a=J[5996];J[5996]=0;if((a|0)!=1){if(H[c+307|0]>=0){break y}$a(J[c+296>>2]);break y}b=Z()|0;if(H[c+307|0]>=0){break a}$a(J[c+296>>2]);break a}H[c+288|0]=K[5230];H[c+291|0]=9;H[c+289|0]=0;J[5996]=0;e=K[5226]|K[5227]<<8|(K[5228]<<16|K[5229]<<24);J[c+280>>2]=K[5222]|K[5223]<<8|(K[5224]<<16|K[5225]<<24);J[c+284>>2]=e;ea(161,a|0,b|0,c+280|0);a=J[5996];J[5996]=0;if((a|0)!=1){if(H[c+291|0]>=0){break y}$a(J[c+280>>2]);break y}b=Z()|0;if(H[c+291|0]>=0){break a}$a(J[c+280>>2]);break a}H[c+272|0]=K[2354];H[c+279|0]=5;H[c+273|0]=0;J[5996]=0;J[c+268>>2]=K[2350]|K[2351]<<8|(K[2352]<<16|K[2353]<<24);ea(161,a|0,b|0,c+268|0);a=J[5996];J[5996]=0;if((a|0)!=1){if(H[c+279|0]>=0){break y}$a(J[c+268>>2]);break y}b=Z()|0;if(H[c+279|0]>=0){break a}$a(J[c+268>>2]);break a}H[c+260|0]=0;J[c+256>>2]=1702195828;H[c+267|0]=4;J[5996]=0;ea(161,a|0,b|0,c+256|0);a=J[5996];J[5996]=0;if((a|0)!=1){if(H[c+267|0]>=0){break y}$a(J[c+256>>2]);break y}b=Z()|0;if(H[c+267|0]>=0){break a}$a(J[c+256>>2]);break a}H[c+255|0]=2;H[c+246|0]=0;I[c+244>>1]=14945;J[5996]=0;e=c+464|0;ea(161,e|0,b|0,c+244|0);d=J[5996];J[5996]=0;za:{Aa:{Ba:{Ca:{Da:{Ea:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,5574)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Ea}J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;d=c+400|0;aa(141,d|0,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break Da}J[5996]=0;f=d;b=K[c+411|0];d=b<<24>>24<0;b=ba(100,c+448|0,(d?J[c+400>>2]:f)|0,(d?J[c+404>>2]:b)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Ca}d=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=d;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;Fa:{if(H[c+411|0]>=0){break Fa}$a(J[c+400>>2]);if(H[b+11|0]>=0){break Fa}$a(J[b>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+255|0]>=0){break y}$a(J[c+244>>2]);break y}b=Z()|0;break za}b=Z()|0;break Aa}b=Z()|0;break Ba}b=Z()|0;if(H[c+411|0]>=0){break Ba}$a(J[c+400>>2]);}if(H[c+459|0]>=0){break Aa}$a(J[c+448>>2]);}if(H[c+475|0]>=0){break za}$a(J[c+464>>2]);}if(H[c+255|0]>=0){break a}$a(J[c+244>>2]);break a}H[c+243|0]=2;H[c+234|0]=0;I[c+232>>1]=14963;J[5996]=0;e=c+464|0;ea(161,e|0,b|0,c+232|0);d=J[5996];J[5996]=0;Ga:{Ha:{Ia:{Ja:{Ka:{La:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,5574)|0;d=J[5996];J[5996]=0;if((d|0)==1){break La}J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;d=c+400|0;aa(141,d|0,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break Ka}J[5996]=0;f=d;b=K[c+411|0];d=b<<24>>24<0;b=ba(100,c+448|0,(d?J[c+400>>2]:f)|0,(d?J[c+404>>2]:b)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Ja}d=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=d;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;Ma:{if(H[c+411|0]>=0){break Ma}$a(J[c+400>>2]);if(H[b+11|0]>=0){break Ma}$a(J[b>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+243|0]>=0){break y}$a(J[c+232>>2]);break y}b=Z()|0;break Ga}b=Z()|0;break Ha}b=Z()|0;break Ia}b=Z()|0;if(H[c+411|0]>=0){break Ia}$a(J[c+400>>2]);}if(H[c+459|0]>=0){break Ha}$a(J[c+448>>2]);}if(H[c+475|0]>=0){break Ga}$a(J[c+464>>2]);}if(H[c+243|0]>=0){break a}$a(J[c+232>>2]);break a}H[c+231|0]=2;H[c+222|0]=0;I[c+220>>1]=14947;J[5996]=0;e=c+464|0;ea(161,e|0,b|0,c+220|0);d=J[5996];J[5996]=0;Na:{Oa:{Pa:{Qa:{Ra:{Sa:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,5574)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Sa}J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;d=c+400|0;aa(141,d|0,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break Ra}J[5996]=0;f=d;b=K[c+411|0];d=b<<24>>24<0;b=ba(100,c+448|0,(d?J[c+400>>2]:f)|0,(d?J[c+404>>2]:b)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Qa}d=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=d;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;Ta:{if(H[c+411|0]>=0){break Ta}$a(J[c+400>>2]);if(H[b+11|0]>=0){break Ta}$a(J[b>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+231|0]>=0){break y}$a(J[c+220>>2]);break y}b=Z()|0;break Na}b=Z()|0;break Oa}b=Z()|0;break Pa}b=Z()|0;if(H[c+411|0]>=0){break Pa}$a(J[c+400>>2]);}if(H[c+459|0]>=0){break Oa}$a(J[c+448>>2]);}if(H[c+475|0]>=0){break Na}$a(J[c+464>>2]);}if(H[c+231|0]>=0){break a}$a(J[c+220>>2]);break a}H[c+219|0]=2;H[c+210|0]=0;I[c+208>>1]=14948;J[5996]=0;e=c+464|0;ea(161,e|0,b|0,c+208|0);d=J[5996];J[5996]=0;Ua:{Va:{Wa:{Xa:{Ya:{Za:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,5574)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Za}J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;d=c+400|0;aa(141,d|0,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break Ya}J[5996]=0;f=d;b=K[c+411|0];d=b<<24>>24<0;b=ba(100,c+448|0,(d?J[c+400>>2]:f)|0,(d?J[c+404>>2]:b)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Xa}d=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=d;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;_a:{if(H[c+411|0]>=0){break _a}$a(J[c+400>>2]);if(H[b+11|0]>=0){break _a}$a(J[b>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+219|0]>=0){break y}$a(J[c+208>>2]);break y}b=Z()|0;break Ua}b=Z()|0;break Va}b=Z()|0;break Wa}b=Z()|0;if(H[c+411|0]>=0){break Wa}$a(J[c+400>>2]);}if(H[c+459|0]>=0){break Va}$a(J[c+448>>2]);}if(H[c+475|0]>=0){break Ua}$a(J[c+464>>2]);}if(H[c+219|0]>=0){break a}$a(J[c+208>>2]);break a}H[c+207|0]=2;H[c+198|0]=0;I[c+196>>1]=14966;J[5996]=0;e=c+464|0;ea(161,e|0,b|0,c+196|0);d=J[5996];J[5996]=0;$a:{ab:{bb:{cb:{db:{eb:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,5574)|0;d=J[5996];J[5996]=0;if((d|0)==1){break eb}J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;d=c+400|0;aa(141,d|0,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break db}J[5996]=0;f=d;b=K[c+411|0];d=b<<24>>24<0;b=ba(100,c+448|0,(d?J[c+400>>2]:f)|0,(d?J[c+404>>2]:b)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break cb}d=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=d;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;fb:{if(H[c+411|0]>=0){break fb}$a(J[c+400>>2]);if(H[b+11|0]>=0){break fb}$a(J[b>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+207|0]>=0){break y}$a(J[c+196>>2]);break y}b=Z()|0;break $a}b=Z()|0;break ab}b=Z()|0;break bb}b=Z()|0;if(H[c+411|0]>=0){break bb}$a(J[c+400>>2]);}if(H[c+459|0]>=0){break ab}$a(J[c+448>>2]);}if(H[c+475|0]>=0){break $a}$a(J[c+464>>2]);}if(H[c+207|0]>=0){break a}$a(J[c+196>>2]);break a}H[c+195|0]=2;H[c+186|0]=0;I[c+184>>1]=14958;J[5996]=0;e=c+464|0;ea(161,e|0,b|0,c+184|0);d=J[5996];J[5996]=0;gb:{hb:{ib:{jb:{kb:{lb:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,5574)|0;d=J[5996];J[5996]=0;if((d|0)==1){break lb}J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;d=c+400|0;aa(141,d|0,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break kb}J[5996]=0;f=d;b=K[c+411|0];d=b<<24>>24<0;b=ba(100,c+448|0,(d?J[c+400>>2]:f)|0,(d?J[c+404>>2]:b)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break jb}d=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=d;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;mb:{if(H[c+411|0]>=0){break mb}$a(J[c+400>>2]);if(H[b+11|0]>=0){break mb}$a(J[b>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+195|0]>=0){break y}$a(J[c+184>>2]);break y}b=Z()|0;break gb}b=Z()|0;break hb}b=Z()|0;break ib}b=Z()|0;if(H[c+411|0]>=0){break ib}$a(J[c+400>>2]);}if(H[c+459|0]>=0){break hb}$a(J[c+448>>2]);}if(H[c+475|0]>=0){break gb}$a(J[c+464>>2]);}if(H[c+195|0]>=0){break a}$a(J[c+184>>2]);break a}H[c+183|0]=2;H[c+174|0]=0;I[c+172>>1]=14954;J[5996]=0;e=c+464|0;ea(161,e|0,b|0,c+172|0);d=J[5996];J[5996]=0;nb:{ob:{pb:{qb:{rb:{sb:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,5574)|0;d=J[5996];J[5996]=0;if((d|0)==1){break sb}J[c+456>>2]=J[e+8>>2];d=J[e+4>>2];J[c+448>>2]=J[e>>2];J[c+452>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;d=c+400|0;aa(141,d|0,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break rb}J[5996]=0;f=d;b=K[c+411|0];d=b<<24>>24<0;b=ba(100,c+448|0,(d?J[c+400>>2]:f)|0,(d?J[c+404>>2]:b)|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break qb}d=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=d;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;tb:{if(H[c+411|0]>=0){break tb}$a(J[c+400>>2]);if(H[b+11|0]>=0){break tb}$a(J[b>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+183|0]>=0){break y}$a(J[c+172>>2]);break y}b=Z()|0;break nb}b=Z()|0;break ob}b=Z()|0;break pb}b=Z()|0;if(H[c+411|0]>=0){break pb}$a(J[c+400>>2]);}if(H[c+459|0]>=0){break ob}$a(J[c+448>>2]);}if(H[c+475|0]>=0){break nb}$a(J[c+464>>2]);}if(H[c+183|0]>=0){break a}$a(J[c+172>>2]);break a}H[c+164|0]=K[1271];H[c+171|0]=5;H[c+165|0]=0;J[5996]=0;J[c+160>>2]=K[1267]|K[1268]<<8|(K[1269]<<16|K[1270]<<24);e=c+368|0;ea(161,e|0,b|0,c+160|0);d=J[5996];J[5996]=0;ub:{vb:{wb:{xb:{yb:{zb:{Ab:{Bb:{Cb:{Db:{Eb:{Fb:{Gb:{Hb:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,3673)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Hb}J[c+392>>2]=J[e+8>>2];d=J[e+4>>2];J[c+384>>2]=J[e>>2];J[c+388>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;d=J[J[b>>2]+32>>2];J[5996]=0;f=c+144|0;aa(141,f|0,d|0);d=J[5996];J[5996]=0;if((d|0)==1){break Gb}J[5996]=0;g=f;d=K[c+155|0];f=d<<24>>24<0;d=ba(100,c+384|0,(f?J[c+144>>2]:g)|0,(f?J[c+148>>2]:d)|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Fb}J[c+408>>2]=J[d+8>>2];f=J[d+4>>2];J[c+400>>2]=J[d>>2];J[c+404>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=_(97,c+400|0,3613)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Eb}J[c+472>>2]=J[f+8>>2];g=J[f+4>>2];J[c+464>>2]=J[f>>2];J[c+468>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;g=c+128|0;aa(141,g|0,b+8|0);b=J[5996];J[5996]=0;if((b|0)==1){break Db}J[5996]=0;h=g;b=K[c+139|0];g=b<<24>>24<0;g=ba(100,c+464|0,(g?J[c+128>>2]:h)|0,(g?J[c+132>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Cb}J[c+456>>2]=J[g+8>>2];b=J[g+4>>2];J[c+448>>2]=J[g>>2];J[c+452>>2]=b;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;b=_(97,c+448|0,3570)|0;h=J[5996];J[5996]=0;if((h|0)==1){break Bb}h=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=h;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;if(H[c+139|0]<0){$a(J[c+128>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}if(H[c+155|0]<0){$a(J[c+144>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+171|0]>=0){break y}$a(J[c+160>>2]);break y}b=Z()|0;break ub}b=Z()|0;break vb}b=Z()|0;break wb}b=Z()|0;break xb}b=Z()|0;break yb}b=Z()|0;break zb}b=Z()|0;break Ab}b=Z()|0;if(H[c+459|0]>=0){break Ab}$a(J[c+448>>2]);}if(H[c+139|0]>=0){break zb}$a(J[c+128>>2]);}if(H[c+475|0]>=0){break yb}$a(J[c+464>>2]);}if(H[c+411|0]>=0){break xb}$a(J[c+400>>2]);}if(H[c+155|0]>=0){break wb}$a(J[c+144>>2]);}if(H[c+395|0]>=0){break vb}$a(J[c+384>>2]);}if(H[c+379|0]>=0){break ub}$a(J[c+368>>2]);}if(H[c+171|0]>=0){break a}$a(J[c+160>>2]);break a}H[c+120|0]=K[2551];H[c+127|0]=5;H[c+121|0]=0;J[5996]=0;J[c+116>>2]=K[2547]|K[2548]<<8|(K[2549]<<16|K[2550]<<24);e=c+368|0;ea(161,e|0,b|0,c+116|0);d=J[5996];J[5996]=0;Ib:{Jb:{Kb:{Lb:{Mb:{Nb:{Ob:{Pb:{Qb:{Rb:{Sb:{Tb:{Ub:{Vb:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,3673)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Vb}J[c+392>>2]=J[e+8>>2];d=J[e+4>>2];J[c+384>>2]=J[e>>2];J[c+388>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;d=J[J[b>>2]+32>>2];J[5996]=0;f=c+144|0;aa(141,f|0,d|0);d=J[5996];J[5996]=0;if((d|0)==1){break Ub}J[5996]=0;g=f;d=K[c+155|0];f=d<<24>>24<0;d=ba(100,c+384|0,(f?J[c+144>>2]:g)|0,(f?J[c+148>>2]:d)|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Tb}J[c+408>>2]=J[d+8>>2];f=J[d+4>>2];J[c+400>>2]=J[d>>2];J[c+404>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=_(97,c+400|0,3613)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Sb}J[c+472>>2]=J[f+8>>2];g=J[f+4>>2];J[c+464>>2]=J[f>>2];J[c+468>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;g=c+128|0;aa(141,g|0,b+8|0);b=J[5996];J[5996]=0;if((b|0)==1){break Rb}J[5996]=0;h=g;b=K[c+139|0];g=b<<24>>24<0;g=ba(100,c+464|0,(g?J[c+128>>2]:h)|0,(g?J[c+132>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Qb}J[c+456>>2]=J[g+8>>2];b=J[g+4>>2];J[c+448>>2]=J[g>>2];J[c+452>>2]=b;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;b=_(97,c+448|0,3570)|0;h=J[5996];J[5996]=0;if((h|0)==1){break Pb}h=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=h;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;if(H[c+139|0]<0){$a(J[c+128>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}if(H[c+155|0]<0){$a(J[c+144>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+127|0]>=0){break y}$a(J[c+116>>2]);break y}b=Z()|0;break Ib}b=Z()|0;break Jb}b=Z()|0;break Kb}b=Z()|0;break Lb}b=Z()|0;break Mb}b=Z()|0;break Nb}b=Z()|0;break Ob}b=Z()|0;if(H[c+459|0]>=0){break Ob}$a(J[c+448>>2]);}if(H[c+139|0]>=0){break Nb}$a(J[c+128>>2]);}if(H[c+475|0]>=0){break Mb}$a(J[c+464>>2]);}if(H[c+411|0]>=0){break Lb}$a(J[c+400>>2]);}if(H[c+155|0]>=0){break Kb}$a(J[c+144>>2]);}if(H[c+395|0]>=0){break Jb}$a(J[c+384>>2]);}if(H[c+379|0]>=0){break Ib}$a(J[c+368>>2]);}if(H[c+127|0]>=0){break a}$a(J[c+116>>2]);break a}H[c+115|0]=4;H[c+108|0]=0;J[c+104>>2]=1650422383;J[5996]=0;e=c+368|0;ea(161,e|0,b|0,c+104|0);d=J[5996];J[5996]=0;Wb:{Xb:{Yb:{Zb:{_b:{$b:{ac:{bc:{cc:{dc:{ec:{fc:{gc:{hc:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,3673)|0;d=J[5996];J[5996]=0;if((d|0)==1){break hc}J[c+392>>2]=J[e+8>>2];d=J[e+4>>2];J[c+384>>2]=J[e>>2];J[c+388>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;d=J[J[b>>2]+32>>2];J[5996]=0;f=c+144|0;aa(141,f|0,d|0);d=J[5996];J[5996]=0;if((d|0)==1){break gc}J[5996]=0;g=f;d=K[c+155|0];f=d<<24>>24<0;d=ba(100,c+384|0,(f?J[c+144>>2]:g)|0,(f?J[c+148>>2]:d)|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break fc}J[c+408>>2]=J[d+8>>2];f=J[d+4>>2];J[c+400>>2]=J[d>>2];J[c+404>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=_(97,c+400|0,3613)|0;g=J[5996];J[5996]=0;if((g|0)==1){break ec}J[c+472>>2]=J[f+8>>2];g=J[f+4>>2];J[c+464>>2]=J[f>>2];J[c+468>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;g=c+128|0;aa(141,g|0,b+8|0);b=J[5996];J[5996]=0;if((b|0)==1){break dc}J[5996]=0;h=g;b=K[c+139|0];g=b<<24>>24<0;g=ba(100,c+464|0,(g?J[c+128>>2]:h)|0,(g?J[c+132>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break cc}J[c+456>>2]=J[g+8>>2];b=J[g+4>>2];J[c+448>>2]=J[g>>2];J[c+452>>2]=b;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;b=_(97,c+448|0,3570)|0;h=J[5996];J[5996]=0;if((h|0)==1){break bc}h=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=h;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;if(H[c+139|0]<0){$a(J[c+128>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}if(H[c+155|0]<0){$a(J[c+144>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+115|0]>=0){break y}$a(J[c+104>>2]);break y}b=Z()|0;break Wb}b=Z()|0;break Xb}b=Z()|0;break Yb}b=Z()|0;break Zb}b=Z()|0;break _b}b=Z()|0;break $b}b=Z()|0;break ac}b=Z()|0;if(H[c+459|0]>=0){break ac}$a(J[c+448>>2]);}if(H[c+139|0]>=0){break $b}$a(J[c+128>>2]);}if(H[c+475|0]>=0){break _b}$a(J[c+464>>2]);}if(H[c+411|0]>=0){break Zb}$a(J[c+400>>2]);}if(H[c+155|0]>=0){break Yb}$a(J[c+144>>2]);}if(H[c+395|0]>=0){break Xb}$a(J[c+384>>2]);}if(H[c+379|0]>=0){break Wb}$a(J[c+368>>2]);}if(H[c+115|0]>=0){break a}$a(J[c+104>>2]);break a}H[c+103|0]=4;H[c+96|0]=0;J[c+92>>2]=1667199599;J[5996]=0;e=c+368|0;ea(161,e|0,b|0,c+92|0);d=J[5996];J[5996]=0;ic:{jc:{kc:{lc:{mc:{nc:{oc:{pc:{qc:{rc:{sc:{tc:{uc:{vc:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,3673)|0;d=J[5996];J[5996]=0;if((d|0)==1){break vc}J[c+392>>2]=J[e+8>>2];d=J[e+4>>2];J[c+384>>2]=J[e>>2];J[c+388>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;d=J[J[b>>2]+32>>2];J[5996]=0;f=c+144|0;aa(141,f|0,d|0);d=J[5996];J[5996]=0;if((d|0)==1){break uc}J[5996]=0;g=f;d=K[c+155|0];f=d<<24>>24<0;d=ba(100,c+384|0,(f?J[c+144>>2]:g)|0,(f?J[c+148>>2]:d)|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break tc}J[c+408>>2]=J[d+8>>2];f=J[d+4>>2];J[c+400>>2]=J[d>>2];J[c+404>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=_(97,c+400|0,3613)|0;g=J[5996];J[5996]=0;if((g|0)==1){break sc}J[c+472>>2]=J[f+8>>2];g=J[f+4>>2];J[c+464>>2]=J[f>>2];J[c+468>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;g=c+128|0;aa(141,g|0,b+8|0);b=J[5996];J[5996]=0;if((b|0)==1){break rc}J[5996]=0;h=g;b=K[c+139|0];g=b<<24>>24<0;g=ba(100,c+464|0,(g?J[c+128>>2]:h)|0,(g?J[c+132>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break qc}J[c+456>>2]=J[g+8>>2];b=J[g+4>>2];J[c+448>>2]=J[g>>2];J[c+452>>2]=b;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;b=_(97,c+448|0,3570)|0;h=J[5996];J[5996]=0;if((h|0)==1){break pc}h=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=h;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;if(H[c+139|0]<0){$a(J[c+128>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}if(H[c+155|0]<0){$a(J[c+144>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+103|0]>=0){break y}$a(J[c+92>>2]);break y}b=Z()|0;break ic}b=Z()|0;break jc}b=Z()|0;break kc}b=Z()|0;break lc}b=Z()|0;break mc}b=Z()|0;break nc}b=Z()|0;break oc}b=Z()|0;if(H[c+459|0]>=0){break oc}$a(J[c+448>>2]);}if(H[c+139|0]>=0){break nc}$a(J[c+128>>2]);}if(H[c+475|0]>=0){break mc}$a(J[c+464>>2]);}if(H[c+411|0]>=0){break lc}$a(J[c+400>>2]);}if(H[c+155|0]>=0){break kc}$a(J[c+144>>2]);}if(H[c+395|0]>=0){break jc}$a(J[c+384>>2]);}if(H[c+379|0]>=0){break ic}$a(J[c+368>>2]);}if(H[c+103|0]>=0){break a}$a(J[c+92>>2]);break a}H[c+91|0]=4;H[c+84|0]=0;J[c+80>>2]=1683976815;J[5996]=0;e=c+368|0;ea(161,e|0,b|0,c+80|0);d=J[5996];J[5996]=0;wc:{xc:{yc:{zc:{Ac:{Bc:{Cc:{Dc:{Ec:{Fc:{Gc:{Hc:{Ic:{Jc:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,3673)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Jc}J[c+392>>2]=J[e+8>>2];d=J[e+4>>2];J[c+384>>2]=J[e>>2];J[c+388>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;d=J[J[b>>2]+32>>2];J[5996]=0;f=c+144|0;aa(141,f|0,d|0);d=J[5996];J[5996]=0;if((d|0)==1){break Ic}J[5996]=0;g=f;d=K[c+155|0];f=d<<24>>24<0;d=ba(100,c+384|0,(f?J[c+144>>2]:g)|0,(f?J[c+148>>2]:d)|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Hc}J[c+408>>2]=J[d+8>>2];f=J[d+4>>2];J[c+400>>2]=J[d>>2];J[c+404>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=_(97,c+400|0,3613)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Gc}J[c+472>>2]=J[f+8>>2];g=J[f+4>>2];J[c+464>>2]=J[f>>2];J[c+468>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;g=c+128|0;aa(141,g|0,b+8|0);b=J[5996];J[5996]=0;if((b|0)==1){break Fc}J[5996]=0;h=g;b=K[c+139|0];g=b<<24>>24<0;g=ba(100,c+464|0,(g?J[c+128>>2]:h)|0,(g?J[c+132>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Ec}J[c+456>>2]=J[g+8>>2];b=J[g+4>>2];J[c+448>>2]=J[g>>2];J[c+452>>2]=b;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;b=_(97,c+448|0,3570)|0;h=J[5996];J[5996]=0;if((h|0)==1){break Dc}h=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=h;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;if(H[c+139|0]<0){$a(J[c+128>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}if(H[c+155|0]<0){$a(J[c+144>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+91|0]>=0){break y}$a(J[c+80>>2]);break y}b=Z()|0;break wc}b=Z()|0;break xc}b=Z()|0;break yc}b=Z()|0;break zc}b=Z()|0;break Ac}b=Z()|0;break Bc}b=Z()|0;break Cc}b=Z()|0;if(H[c+459|0]>=0){break Cc}$a(J[c+448>>2]);}if(H[c+139|0]>=0){break Bc}$a(J[c+128>>2]);}if(H[c+475|0]>=0){break Ac}$a(J[c+464>>2]);}if(H[c+411|0]>=0){break zc}$a(J[c+400>>2]);}if(H[c+155|0]>=0){break yc}$a(J[c+144>>2]);}if(H[c+395|0]>=0){break xc}$a(J[c+384>>2]);}if(H[c+379|0]>=0){break wc}$a(J[c+368>>2]);}if(H[c+91|0]>=0){break a}$a(J[c+80>>2]);break a}H[c+79|0]=4;H[c+72|0]=0;J[c+68>>2]=1767862895;J[5996]=0;e=c+368|0;ea(161,e|0,b|0,c+68|0);d=J[5996];J[5996]=0;Kc:{Lc:{Mc:{Nc:{Oc:{Pc:{Qc:{Rc:{Sc:{Tc:{Uc:{Vc:{Wc:{Xc:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,3673)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Xc}J[c+392>>2]=J[e+8>>2];d=J[e+4>>2];J[c+384>>2]=J[e>>2];J[c+388>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;d=J[J[b>>2]+32>>2];J[5996]=0;f=c+144|0;aa(141,f|0,d|0);d=J[5996];J[5996]=0;if((d|0)==1){break Wc}J[5996]=0;g=f;d=K[c+155|0];f=d<<24>>24<0;d=ba(100,c+384|0,(f?J[c+144>>2]:g)|0,(f?J[c+148>>2]:d)|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Vc}J[c+408>>2]=J[d+8>>2];f=J[d+4>>2];J[c+400>>2]=J[d>>2];J[c+404>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=_(97,c+400|0,3613)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Uc}J[c+472>>2]=J[f+8>>2];g=J[f+4>>2];J[c+464>>2]=J[f>>2];J[c+468>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;g=c+128|0;aa(141,g|0,b+8|0);b=J[5996];J[5996]=0;if((b|0)==1){break Tc}J[5996]=0;h=g;b=K[c+139|0];g=b<<24>>24<0;g=ba(100,c+464|0,(g?J[c+128>>2]:h)|0,(g?J[c+132>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break Sc}J[c+456>>2]=J[g+8>>2];b=J[g+4>>2];J[c+448>>2]=J[g>>2];J[c+452>>2]=b;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;b=_(97,c+448|0,3570)|0;h=J[5996];J[5996]=0;if((h|0)==1){break Rc}h=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=h;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;if(H[c+139|0]<0){$a(J[c+128>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}if(H[c+155|0]<0){$a(J[c+144>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+79|0]>=0){break y}$a(J[c+68>>2]);break y}b=Z()|0;break Kc}b=Z()|0;break Lc}b=Z()|0;break Mc}b=Z()|0;break Nc}b=Z()|0;break Oc}b=Z()|0;break Pc}b=Z()|0;break Qc}b=Z()|0;if(H[c+459|0]>=0){break Qc}$a(J[c+448>>2]);}if(H[c+139|0]>=0){break Pc}$a(J[c+128>>2]);}if(H[c+475|0]>=0){break Oc}$a(J[c+464>>2]);}if(H[c+411|0]>=0){break Nc}$a(J[c+400>>2]);}if(H[c+155|0]>=0){break Mc}$a(J[c+144>>2]);}if(H[c+395|0]>=0){break Lc}$a(J[c+384>>2]);}if(H[c+379|0]>=0){break Kc}$a(J[c+368>>2]);}if(H[c+79|0]>=0){break a}$a(J[c+68>>2]);break a}I[c- -64>>1]=K[2600]|K[2601]<<8;I[c+66>>1]=2560;J[5996]=0;e=K[2596]|K[2597]<<8|(K[2598]<<16|K[2599]<<24);J[c+56>>2]=K[2592]|K[2593]<<8|(K[2594]<<16|K[2595]<<24);J[c+60>>2]=e;e=c+128|0;ea(161,e|0,b|0,c+56|0);d=J[5996];J[5996]=0;Yc:{Zc:{_c:{$c:{ad:{bd:{cd:{dd:{ed:{fd:{gd:{hd:{id:{jd:{kd:{ld:{md:{nd:{od:{pd:{if((d|0)!=1){J[5996]=0;e=_(97,e|0,3623)|0;d=J[5996];J[5996]=0;if((d|0)==1){break pd}J[c+152>>2]=J[e+8>>2];d=J[e+4>>2];J[c+144>>2]=J[e>>2];J[c+148>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;d=J[J[b>>2]+32>>2];J[5996]=0;f=c+40|0;aa(141,f|0,d|0);d=J[5996];J[5996]=0;if((d|0)==1){break od}J[5996]=0;g=f;d=K[c+51|0];f=d<<24>>24<0;d=ba(100,c+144|0,(f?J[c+40>>2]:g)|0,(f?J[c+44>>2]:d)|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break nd}J[c+376>>2]=J[d+8>>2];f=J[d+4>>2];J[c+368>>2]=J[d>>2];J[c+372>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=_(97,c+368|0,3613)|0;g=J[5996];J[5996]=0;if((g|0)==1){break md}J[c+392>>2]=J[f+8>>2];g=J[f+4>>2];J[c+384>>2]=J[f>>2];J[c+388>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;g=J[J[b>>2]+32>>2];J[5996]=0;h=c+28|0;aa(141,h|0,g+8|0);g=J[5996];J[5996]=0;if((g|0)==1){break ld}J[5996]=0;i=h;g=K[c+39|0];h=g<<24>>24<0;g=ba(100,c+384|0,(h?J[c+28>>2]:i)|0,(h?J[c+32>>2]:g)|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break kd}J[c+408>>2]=J[g+8>>2];h=J[g+4>>2];J[c+400>>2]=J[g>>2];J[c+404>>2]=h;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;h=_(97,c+400|0,3603)|0;i=J[5996];J[5996]=0;if((i|0)==1){break jd}J[c+472>>2]=J[h+8>>2];i=J[h+4>>2];J[c+464>>2]=J[h>>2];J[c+468>>2]=i;J[h>>2]=0;J[h+4>>2]=0;J[h+8>>2]=0;b=J[J[b>>2]+32>>2];J[5996]=0;i=c+16|0;aa(141,i|0,b+16|0);b=J[5996];J[5996]=0;if((b|0)==1){break id}J[5996]=0;j=i;b=K[c+27|0];i=b<<24>>24<0;i=ba(100,c+464|0,(i?J[c+16>>2]:j)|0,(i?J[c+20>>2]:b)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break hd}J[c+456>>2]=J[i+8>>2];b=J[i+4>>2];J[c+448>>2]=J[i>>2];J[c+452>>2]=b;J[i>>2]=0;J[i+4>>2]=0;J[i+8>>2]=0;J[5996]=0;b=_(97,c+448|0,3570)|0;j=J[5996];J[5996]=0;if((j|0)==1){break gd}j=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=j;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;if(H[c+27|0]<0){$a(J[c+16>>2]);}if(H[i+11|0]<0){$a(J[i>>2]);}if(H[h+11|0]<0){$a(J[h>>2]);}if(H[c+39|0]<0){$a(J[c+28>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}if(H[c+51|0]<0){$a(J[c+40>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}if(H[c+67|0]>=0){break y}$a(J[c+56>>2]);break y}b=Z()|0;break Yc}b=Z()|0;break Zc}b=Z()|0;break _c}b=Z()|0;break $c}b=Z()|0;break ad}b=Z()|0;break bd}b=Z()|0;break cd}b=Z()|0;break dd}b=Z()|0;break ed}b=Z()|0;break fd}b=Z()|0;if(H[c+459|0]>=0){break fd}$a(J[c+448>>2]);}if(H[c+27|0]>=0){break ed}$a(J[c+16>>2]);}if(H[c+475|0]>=0){break dd}$a(J[c+464>>2]);}if(H[c+411|0]>=0){break cd}$a(J[c+400>>2]);}if(H[c+39|0]>=0){break bd}$a(J[c+28>>2]);}if(H[c+395|0]>=0){break ad}$a(J[c+384>>2]);}if(H[c+379|0]>=0){break $c}$a(J[c+368>>2]);}if(H[c+51|0]>=0){break _c}$a(J[c+40>>2]);}if(H[c+155|0]>=0){break Zc}$a(J[c+144>>2]);}if(H[c+139|0]>=0){break Yc}$a(J[c+128>>2]);}if(H[c+67|0]>=0){break a}$a(J[c+56>>2]);break a}d=c+144|0;Kc(d,J[e+4>>2]);J[5996]=0;e=ba(99,d|0,0,5302)|0;d=J[5996];J[5996]=0;if((d|0)==1){break x}J[c+376>>2]=J[e+8>>2];d=J[e+4>>2];J[c+368>>2]=J[e>>2];J[c+372>>2]=d;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;d=_(97,c+368|0,5417)|0;f=J[5996];J[5996]=0;if((f|0)==1){break w}J[c+392>>2]=J[d+8>>2];f=J[d+4>>2];J[c+384>>2]=J[d>>2];J[c+388>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;f=J[b>>2];g=J[f+36>>2];f=J[f+32>>2];J[5996]=0;h=c+128|0;aa(115,h|0,g-f>>3);f=J[5996];J[5996]=0;if((f|0)==1){break v}J[5996]=0;f=K[c+139|0];g=f<<24>>24<0;f=ba(100,c+384|0,(g?J[c+128>>2]:h)|0,(g?J[c+132>>2]:f)|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break u}J[c+408>>2]=J[f+8>>2];g=J[f+4>>2];J[c+400>>2]=J[f>>2];J[c+404>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;J[5996]=0;g=_(97,c+400|0,5242)|0;h=J[5996];J[5996]=0;if((h|0)==1){break t}J[c+8>>2]=J[g+8>>2];h=J[g+4>>2];J[c>>2]=J[g>>2];J[c+4>>2]=h;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;h=c+464|0;ea(161,h|0,b|0,c|0);i=J[5996];J[5996]=0;if((i|0)==1){break s}J[5996]=0;h=_(97,h|0,3726)|0;i=J[5996];J[5996]=0;if((i|0)==1){break r}J[c+456>>2]=J[h+8>>2];i=J[h+4>>2];J[c+448>>2]=J[h>>2];J[c+452>>2]=i;J[h>>2]=0;J[h+4>>2]=0;J[h+8>>2]=0;if(H[c+11|0]<0){$a(J[c>>2]);}if(H[g+11|0]<0){$a(J[g>>2]);}if(H[c+139|0]<0){$a(J[c+128>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}if(H[e+11|0]<0){$a(J[e>>2]);}b=J[b>>2];d=J[b+32>>2];f=J[b+36>>2];if((d|0)!=(f|0)){while(1){J[5996]=0;b=c+28|0;aa(141,b|0,d|0);e=J[5996];J[5996]=0;if((e|0)==1){break k}J[5996]=0;b=ba(99,b|0,0,3708)|0;e=J[5996];J[5996]=0;if((e|0)==1){break j}J[c+48>>2]=J[b+8>>2];e=J[b+4>>2];J[c+40>>2]=J[b>>2];J[c+44>>2]=e;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;e=_(97,c+40|0,3713)|0;g=J[5996];J[5996]=0;if((g|0)==1){break i}J[c+136>>2]=J[e+8>>2];g=J[e+4>>2];J[c+128>>2]=J[e>>2];J[c+132>>2]=g;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;g=K[c+139|0];h=g<<24>>24<0;ba(100,c+448|0,(h?J[c+128>>2]:c+128|0)|0,(h?J[c+132>>2]:g)|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break h}if(H[c+139|0]<0){$a(J[c+128>>2]);}if(H[c+51|0]<0){$a(J[e>>2]);}if(H[c+39|0]<0){$a(J[b>>2]);}d=d+8|0;if((f|0)!=(d|0)){continue}break}}J[5996]=0;b=_(97,c+448|0,3575)|0;e=J[5996];J[5996]=0;if((e|0)==1){break e}e=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=e;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;}Ua=c+496|0;return}b=Z()|0;break l}b=Z()|0;break m}b=Z()|0;break n}b=Z()|0;break o}b=Z()|0;break p}b=Z()|0;break q}b=Z()|0;if(H[c+475|0]>=0){break q}$a(J[c+464>>2]);}if(H[c+11|0]>=0){break p}$a(J[c>>2]);}if(H[c+411|0]>=0){break o}$a(J[c+400>>2]);}if(H[c+139|0]>=0){break n}$a(J[c+128>>2]);}if(H[c+395|0]>=0){break m}$a(J[c+384>>2]);}if(H[c+379|0]>=0){break l}$a(J[c+368>>2]);}if(H[c+155|0]>=0){break a}$a(J[c+144>>2]);break a}b=Z()|0;break d}b=Z()|0;break f}b=Z()|0;break g}b=Z()|0;if(H[c+139|0]>=0){break g}$a(J[c+128>>2]);}if(H[c+51|0]>=0){break f}$a(J[c+40>>2]);}if(H[c+39|0]>=0){break d}$a(J[c+28>>2]);break d}b=Z()|0;}if(H[c+459|0]>=0){break a}$a(J[c+448>>2]);break a}if(!K[c+460|0]|H[c+459|0]>=0){break a}$a(J[c+448>>2]);break a}if(H[c+475|0]>=0){break a}$a(J[c+464>>2]);}da(b|0);B();}function ze(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;h=Ua-48|0;Ua=h;J[h+24>>2]=0;J[h+16>>2]=0;J[h+20>>2]=0;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{switch(J[a>>2]){case 1:J[5996]=0;b=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break d}J[5996]=0;a=_(32,h+28|0,a+28|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break u}J[b+4>>2]=0;J[b+8>>2]=0;J[b>>2]=2;J[b+12>>2]=0;J[b+16>>2]=J[a>>2];J[b+20>>2]=J[a+4>>2];J[b+24>>2]=J[a+8>>2];J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;J[b+44>>2]=0;J[b+36>>2]=0;J[b+40>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[5996]=0;aa(33,c|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break d}d=J[h+20>>2];f=J[h+24>>2];if(d>>>0<f>>>0){J[d>>2]=b;J[h+20>>2]=d+4;break o}a=J[h+16>>2];e=d-a>>2;g=e+1|0;if(g>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)==1){break d}break a}f=f-a|0;i=f>>1;g=f>>>0>=2147483644?1073741823:g>>>0<i>>>0?i:g;if(g){if(g>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break d}J[5996]=0;j=$(3,g<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break d}}e=(e<<2)+j|0;J[e>>2]=b;f=e+4|0;if((a|0)!=(d|0)){while(1){e=e-4|0;d=d-4|0;J[e>>2]=J[d>>2];if((a|0)!=(d|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(g<<2)+j;J[h+20>>2]=f;J[h+16>>2]=e;if(!d){break n}$a(d);break o;case 2:a=J[a+52>>2];J[5996]=0;b=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break e}J[b+4>>2]=0;J[b+8>>2]=0;J[b>>2]=4;J[b+40>>2]=a;J[b+44>>2]=0;J[b+12>>2]=0;J[b+16>>2]=0;J[b+20>>2]=0;J[b+24>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[b+36>>2]=0;J[5996]=0;aa(33,c|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break e}d=J[h+20>>2];f=J[h+24>>2];if(d>>>0<f>>>0){J[d>>2]=b;J[h+20>>2]=d+4;break o}a=J[h+16>>2];e=d-a>>2;g=e+1|0;if(g>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break e}f=f-a|0;i=f>>1;g=f>>>0>=2147483644?1073741823:g>>>0<i>>>0?i:g;if(g){if(g>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break e}J[5996]=0;j=$(3,g<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break e}}e=(e<<2)+j|0;J[e>>2]=b;f=e+4|0;if((a|0)!=(d|0)){while(1){e=e-4|0;d=d-4|0;J[e>>2]=J[d>>2];if((a|0)!=(d|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(g<<2)+j;J[h+20>>2]=f;J[h+16>>2]=e;if(!d){break n}$a(d);break o;case 3:a=J[a+52>>2];J[5996]=0;b=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break f}J[b+4>>2]=0;J[b+8>>2]=0;J[b>>2]=5;J[b+40>>2]=a;J[b+44>>2]=0;J[b+12>>2]=0;J[b+16>>2]=0;J[b+20>>2]=0;J[b+24>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[b+36>>2]=0;J[5996]=0;aa(33,c|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break f}d=J[h+20>>2];f=J[h+24>>2];if(d>>>0<f>>>0){J[d>>2]=b;J[h+20>>2]=d+4;break o}a=J[h+16>>2];e=d-a>>2;g=e+1|0;if(g>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break f}f=f-a|0;i=f>>1;g=f>>>0>=2147483644?1073741823:g>>>0<i>>>0?i:g;if(g){if(g>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break f}J[5996]=0;j=$(3,g<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break f}}e=(e<<2)+j|0;J[e>>2]=b;f=e+4|0;if((a|0)!=(d|0)){while(1){e=e-4|0;d=d-4|0;J[e>>2]=J[d>>2];if((a|0)!=(d|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(g<<2)+j;J[h+20>>2]=f;J[h+16>>2]=e;if(!d){break n}$a(d);break o;case 5:b=J[a+20>>2];a=J[a+16>>2];J[5996]=0;g=ia(36,c|0,7,a|0,b|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}d=J[h+20>>2];f=J[h+24>>2];if(d>>>0<f>>>0){J[d>>2]=g;J[h+20>>2]=d+4;break o}a=J[h+16>>2];e=d-a>>2;b=e+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break g}f=f-a|0;i=f>>1;b=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;if(b){if(b>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break g}J[5996]=0;j=$(3,b<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}}e=(e<<2)+j|0;J[e>>2]=g;f=e+4|0;if((a|0)!=(d|0)){while(1){e=e-4|0;d=d-4|0;J[e>>2]=J[d>>2];if((a|0)!=(d|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(b<<2)+j;J[h+20>>2]=f;J[h+16>>2]=e;if(!d){break n}$a(d);break o;case 4:b=J[a+20>>2];a=J[a+16>>2];J[5996]=0;g=ia(36,c|0,6,a|0,b|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break h}d=J[h+20>>2];f=J[h+24>>2];if(d>>>0<f>>>0){J[d>>2]=g;J[h+20>>2]=d+4;break o}a=J[h+16>>2];e=d-a>>2;b=e+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break h}f=f-a|0;i=f>>1;b=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;if(b){if(b>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break h}J[5996]=0;j=$(3,b<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break h}}e=(e<<2)+j|0;J[e>>2]=g;f=e+4|0;if((a|0)!=(d|0)){while(1){e=e-4|0;d=d-4|0;J[e>>2]=J[d>>2];if((a|0)!=(d|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(b<<2)+j;J[h+20>>2]=f;J[h+16>>2]=e;if(!d){break n}$a(d);break o;case 7:b=J[a+20>>2];a=J[a+16>>2];J[5996]=0;g=ia(36,c|0,8,a|0,b|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break i}d=J[h+20>>2];f=J[h+24>>2];if(d>>>0<f>>>0){J[d>>2]=g;J[h+20>>2]=d+4;break o}a=J[h+16>>2];e=d-a>>2;b=e+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break i}f=f-a|0;i=f>>1;b=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;if(b){if(b>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break i}J[5996]=0;j=$(3,b<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break i}}e=(e<<2)+j|0;J[e>>2]=g;f=e+4|0;if((a|0)!=(d|0)){while(1){e=e-4|0;d=d-4|0;J[e>>2]=J[d>>2];if((a|0)!=(d|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(b<<2)+j;J[h+20>>2]=f;J[h+16>>2]=e;if(!d){break n}$a(d);break o;case 6:b=J[a+20>>2];a=J[a+16>>2];J[5996]=0;g=ia(36,c|0,9,a|0,b|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break j}d=J[h+20>>2];f=J[h+24>>2];if(d>>>0<f>>>0){J[d>>2]=g;J[h+20>>2]=d+4;break o}a=J[h+16>>2];e=d-a>>2;b=e+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break j}f=f-a|0;i=f>>1;b=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;if(b){if(b>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break j}J[5996]=0;j=$(3,b<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break j}}e=(e<<2)+j|0;J[e>>2]=g;f=e+4|0;if((a|0)!=(d|0)){while(1){e=e-4|0;d=d-4|0;J[e>>2]=J[d>>2];if((a|0)!=(d|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(b<<2)+j;J[h+20>>2]=f;J[h+16>>2]=e;if(!d){break n}$a(d);break o;case 8:d=J[a+4>>2];if((J[a+8>>2]-d|0)!=112){break m}J[5996]=0;g=ba(37,d|0,b|0,c|0)|0;d=J[5996];J[5996]=0;w:{x:{y:{z:{A:{B:{C:{if((d|0)!=1){a=J[a+4>>2];J[5996]=0;f=ba(37,a+56|0,b|0,c|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break C}if(!g|!f){break m}J[5996]=0;a=$(3,8)|0;b=J[5996];J[5996]=0;if((b|0)==1){break z}J[a+4>>2]=f;J[a>>2]=g;J[5996]=0;b=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break y}J[b+16>>2]=0;J[b+20>>2]=0;J[b+4>>2]=a;J[b>>2]=10;a=a+8|0;J[b+12>>2]=a;J[b+8>>2]=a;J[b+24>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[b+36>>2]=0;J[b+40>>2]=0;J[b+44>>2]=0;J[5996]=0;aa(33,c|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break k}e=J[h+20>>2];d=J[h+24>>2];if(e>>>0>=d>>>0){break B}J[e>>2]=b;J[h+20>>2]=e+4;break A}c=Z()|0;break c}c=Z()|0;break c}i=J[h+16>>2];k=e-i>>2;a=k+1|0;if(a>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break k}d=d-i|0;j=d>>1;j=d>>>0>=2147483644?1073741823:a>>>0<j>>>0?j:a;D:{if(!j){a=0;break D}if(j>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break k}J[5996]=0;a=$(3,j<<2)|0;d=J[5996];J[5996]=0;if((d|0)==1){break k}}d=(k<<2)+a|0;J[d>>2]=b;b=d+4|0;if((e|0)!=(i|0)){while(1){d=d-4|0;e=e-4|0;J[d>>2]=J[e>>2];if((e|0)!=(i|0)){continue}break}e=J[h+16>>2];}J[h+24>>2]=(j<<2)+a;J[h+20>>2]=b;J[h+16>>2]=d;if(!e){break A}$a(e);}J[5996]=0;b=$(3,12)|0;a=J[5996];J[5996]=0;if((a|0)==1){break x}J[b+4>>2]=f;J[b>>2]=g;J[b+8>>2]=J[6079];J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break w}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=b;J[a>>2]=12;J[a+48>>2]=0;J[a+52>>2]=1072693248;b=b+12|0;J[a+12>>2]=b;J[a+8>>2]=b;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break l}d=J[h+20>>2];f=J[h+24>>2];if(d>>>0<f>>>0){J[d>>2]=a;J[h+20>>2]=d+4;break o}b=J[h+16>>2];e=d-b>>2;g=e+1|0;if(g>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break l}f=f-b|0;i=f>>1;g=f>>>0>=2147483644?1073741823:g>>>0<i>>>0?i:g;E:{if(!g){j=0;break E}if(g>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break l}J[5996]=0;j=$(3,g<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break l}}e=(e<<2)+j|0;J[e>>2]=a;f=e+4|0;if((b|0)!=(d|0)){while(1){e=e-4|0;d=d-4|0;J[e>>2]=J[d>>2];if((b|0)!=(d|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(g<<2)+j;J[h+20>>2]=f;J[h+16>>2]=e;if(!d){break n}$a(d);break o}c=Z()|0;break c}c=Z()|0;$a(a);break c}c=Z()|0;break c}c=Z()|0;$a(b);break c;case 9:d=J[a+4>>2];if((J[a+8>>2]-d|0)!=112){break m}g=J[a+40>>2];f=J[g+4>>2];i=J[g>>2];j=i+f|0;if(f>>>0>j>>>0){break m}J[5996]=0;g=ba(37,d|0,b|0,c|0)|0;d=J[5996];J[5996]=0;F:{G:{if((d|0)!=1){d=J[a+4>>2];J[5996]=0;f=ba(37,d+56|0,b|0,c|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break G}if(!g|!f){break m}o=+(i>>>0)/+(j>>>0);e=J[a+4>>2];if(J[e>>2]!=8){break p}d=J[e+4>>2];if((J[e+8>>2]-d|0)==112){break F}break p}c=Z()|0;break c}c=Z()|0;break c}J[5996]=0;i=ba(37,d|0,b|0,c|0)|0;d=J[5996];J[5996]=0;H:{I:{J:{if((d|0)!=1){d=J[J[a+4>>2]+4>>2];J[5996]=0;j=ba(37,d+56|0,b|0,c|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break J}e=0;if(!i|!j){break m}J[5996]=0;d=$(3,12)|0;e=J[5996];J[5996]=0;if((e|0)==1){break I}J[h+28>>2]=d;e=d+12|0;J[h+36>>2]=e;J[d+8>>2]=f;J[d+4>>2]=j;J[d>>2]=i;J[5996]=0;J[h+32>>2]=e;d=ya(38,c|0,12,h+28|0,+o)|0;e=J[5996];J[5996]=0;if((e|0)==1){break H}J[5996]=0;aa(39,h+16|0,d|0);d=J[5996];J[5996]=0;if((d|0)==1){break H}d=J[h+28>>2];if(d){$a(d);}e=J[a+4>>2];break p}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;a=J[h+28>>2];if(!a){break c}$a(a);break c;case 0:break m;case 10:break v;default:break o}}g=J[a+4>>2];l=J[a+8>>2];if((g|0)==(l|0)){break s}while(1){K:{J[5996]=0;d=ba(37,g|0,b|0,c|0)|0;i=J[5996];J[5996]=0;if((i|0)==1){break K}L:{if(e>>>0<j>>>0){J[e>>2]=d;e=e+4|0;break L}n=e-f>>2;i=n+1|0;if(i>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break r}j=j-f|0;k=j>>1;k=j>>>0>=2147483644?1073741823:i>>>0<k>>>0?k:i;M:{if(!k){j=0;break M}if(k>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break r}J[5996]=0;j=$(3,k<<2)|0;i=J[5996];J[5996]=0;if((i|0)==1){break K}}i=(n<<2)+j|0;J[i>>2]=d;d=i;if((e|0)!=(f|0)){while(1){d=d-4|0;e=e-4|0;J[d>>2]=J[e>>2];if((e|0)!=(f|0)){continue}break}}j=(k<<2)+j|0;e=i+4|0;if(f){$a(f);}f=d;}g=g+56|0;if((l|0)!=(g|0)){continue}break t}break}c=Z()|0;break q}c=Z()|0;$a(b);break c}if((e|0)==(f|0)){f=e;break s}d=f;while(1){if(J[d>>2]){d=d+4|0;if((e|0)!=(d|0)){continue}break s}break}e=0;if(!f){break m}$a(f);break m}N:{O:{n=J[a+8>>2];i=J[a+4>>2];P:{if((n-i|0)/56>>>0>20){break P}Q:{R:{if((i|0)!=(n|0)){d=i;while(1){if(J[d>>2]!=1){break P}d=d+56|0;if((n|0)!=(d|0)){continue}break}break R}J[h+12>>2]=0;J[h+4>>2]=0;J[h+8>>2]=0;break Q}J[h+12>>2]=0;J[h+4>>2]=0;J[h+8>>2]=0;q=h+12|0;while(1){b=J[i+28>>2];S:{T:{d=J[h+8>>2];if((d|0)!=J[h+12>>2]){if(H[b+11|0]>=0){g=J[b+4>>2];J[d>>2]=J[b>>2];J[d+4>>2]=g;J[d+8>>2]=J[b+8>>2];break T}g=J[b+4>>2];b=J[b>>2];J[5996]=0;ea(40,d|0,b|0,g|0);b=J[5996];J[5996]=0;if((b|0)!=1){break T}c=Z()|0;J[h+8>>2]=d;break N}U:{V:{W:{X:{g=J[h+4>>2];k=(d-g|0)/12|0;l=k+1|0;Y:{if(l>>>0>=357913942){J[5996]=0;ca(41);break Y}J[h+44>>2]=q;m=k<<1;m=k>>>0>=178956970?357913941:l>>>0<m>>>0?m:l;if(!m){l=0;break W}if(m>>>0<357913942){break X}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}c=Z()|0;break N}J[5996]=0;l=$(3,P(m,12)|0)|0;p=J[5996];J[5996]=0;if((p|0)==1){break V}}J[h+28>>2]=l;k=P(k,12)+l|0;J[h+36>>2]=k;l=P(m,12)+l|0;J[h+40>>2]=l;J[h+32>>2]=k;Z:{if(H[b+11|0]>=0){m=J[b+4>>2];J[k>>2]=J[b>>2];J[k+4>>2]=m;J[k+8>>2]=J[b+8>>2];break Z}d=J[b+4>>2];b=J[b>>2];J[5996]=0;ea(40,k|0,b|0,d|0);b=J[5996];J[5996]=0;if((b|0)==1){break U}g=J[h+4>>2];d=J[h+8>>2];}m=k+12|0;if((d|0)==(g|0)){b=g;}else {while(1){d=d-12|0;p=J[d+4>>2];k=k-12|0;b=k;J[b>>2]=J[d>>2];J[b+4>>2]=p;J[b+8>>2]=J[d+8>>2];J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;if((d|0)!=(g|0)){continue}break}g=J[h+8>>2];b=J[h+4>>2];}J[h+32>>2]=b;J[h+4>>2]=k;J[h+8>>2]=m;d=J[h+12>>2];J[h+12>>2]=l;J[h+40>>2]=d;J[h+28>>2]=b;if((b|0)!=(g|0)){while(1){d=g-12|0;J[h+36>>2]=d;if(H[g-1|0]<0){$a(J[d>>2]);}g=d;if((d|0)!=(b|0)){continue}break}g=b;}if(!g){break S}$a(g);break S}c=Z()|0;break N}c=Z()|0;a=J[h+36>>2];d=J[h+32>>2];if((a|0)!=(d|0)){while(1){b=a-12|0;J[h+36>>2]=b;if(H[a-1|0]>=0){a=b;}else {$a(J[b>>2]);a=J[h+36>>2];}if((d|0)!=(a|0)){continue}break}}a=J[h+28>>2];if(a){$a(a);}break N}J[h+8>>2]=d+12;}i=i+56|0;if((n|0)!=(i|0)){continue}break}}b=J[a+52>>2];J[5996]=0;i=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break O}d=J[h+12>>2];J[h+12>>2]=0;g=J[h+4>>2];k=J[h+8>>2];J[h+4>>2]=0;J[h+8>>2]=0;J[i+4>>2]=0;J[i+8>>2]=0;J[i>>2]=3;J[i+12>>2]=0;J[i+40>>2]=b;J[i+44>>2]=0;J[i+36>>2]=0;J[i+28>>2]=0;J[i+32>>2]=0;J[i+24>>2]=d;J[i+16>>2]=g;J[i+20>>2]=k;J[5996]=0;aa(33,c|0,i|0);b=J[5996];J[5996]=0;if((b|0)==1){break O}d=J[h+20>>2];k=J[h+24>>2];_:{if(d>>>0<k>>>0){J[d>>2]=i;J[h+20>>2]=d+4;break _}b=J[h+16>>2];n=d-b>>2;g=n+1|0;if(g>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break O}k=k-b|0;l=k>>1;k=k>>>0>=2147483644?1073741823:g>>>0<l>>>0?l:g;$:{if(!k){l=0;break $}if(k>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break O}J[5996]=0;l=$(3,k<<2)|0;g=J[5996];J[5996]=0;if((g|0)==1){break O}}g=(n<<2)+l|0;J[g>>2]=i;i=g+4|0;if((b|0)!=(d|0)){while(1){g=g-4|0;d=d-4|0;J[g>>2]=J[d>>2];if((b|0)!=(d|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(k<<2)+l;J[h+20>>2]=i;J[h+16>>2]=g;if(!d){break _}$a(d);}b=J[h+4>>2];if(!b){break P}d=b;g=J[h+8>>2];if((d|0)!=(g|0)){while(1){d=g-12|0;if(H[g-1|0]<0){$a(J[d>>2]);}g=d;if((d|0)!=(b|0)){continue}break}d=J[h+4>>2];}J[h+8>>2]=b;$a(d);}b=J[a+52>>2];aa:{if((b|0)!=1&(b|0)!=((J[a+8>>2]-J[a+4>>2]|0)/56|0)){break aa}ba:{ca:{da:{ea:{fa:{ga:{b=e-f|0;if(b>>>0>=5){while(1){k=J[a+52>>2];J[5996]=0;i=$(3,8)|0;d=J[5996];J[5996]=0;if((d|0)==1){break ga}d=e-8|0;J[i>>2]=J[d>>2];e=e-4|0;J[i+4>>2]=J[e>>2];J[5996]=0;g=$(3,56)|0;l=J[5996];J[5996]=0;if((l|0)==1){break fa}J[g+16>>2]=0;J[g+20>>2]=0;J[g+4>>2]=i;J[g>>2]=(k|0)==1?11:10;i=i+8|0;J[g+12>>2]=i;J[g+8>>2]=i;J[g+24>>2]=0;J[g+28>>2]=0;J[g+32>>2]=0;J[g+36>>2]=0;J[g+40>>2]=0;J[g+44>>2]=0;O[g+48>>3]=1/+(b>>2>>>0);J[5996]=0;aa(33,c|0,g|0);b=J[5996];J[5996]=0;if((b|0)==1){c=Z()|0;break q}J[5996]=0;i=$(3,4)|0;b=J[5996];J[5996]=0;if((b|0)==1){break ea}J[i>>2]=g;J[5996]=0;b=$(3,56)|0;g=J[5996];J[5996]=0;if((g|0)==1){break ca}J[b+16>>2]=0;J[b+20>>2]=0;J[b+4>>2]=i;J[b>>2]=21;g=i+4|0;J[b+12>>2]=g;J[b+8>>2]=g;J[b+24>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[b+36>>2]=0;J[b+40>>2]=0;J[b+44>>2]=0;J[5996]=0;aa(33,c|0,b|0);g=J[5996];J[5996]=0;if((g|0)==1){break da}ha:{if(d>>>0<j>>>0){J[d>>2]=b;break ha}ia:{ja:{i=d-f>>2;g=i+1|0;ka:{if(g>>>0>=1073741824){J[5996]=0;ca(34);break ka}e=j-f|0;j=e>>1;e=e>>>0>=2147483644?1073741823:g>>>0<j>>>0?j:g;if(!e){j=0;break ia}if(e>>>0<1073741824){break ja}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}c=Z()|0;break q}J[5996]=0;j=$(3,e<<2)|0;g=J[5996];J[5996]=0;if((g|0)==1){break da}}g=(i<<2)+j|0;J[g>>2]=b;j=(e<<2)+j|0;e=g+4|0;la:{if((d|0)!=(f|0)){while(1){g=g-4|0;d=d-4|0;J[g>>2]=J[d>>2];if((d|0)!=(f|0)){continue}break}if(!f){break la}}$a(f);}f=g;}b=e-f|0;if(b>>>0>4){continue}break}}j=J[f>>2];d=J[h+20>>2];if((d|0)==J[h+24>>2]){break ba}J[d>>2]=j;J[h+20>>2]=d+4;break aa}c=Z()|0;break q}c=Z()|0;$a(i);break q}c=Z()|0;break q}c=Z()|0;break q}c=Z()|0;$a(i);break q}k=J[h+16>>2];b=d-k|0;l=b>>2;g=l+1|0;if(g>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break r}i=b>>1;b=b>>>0>=2147483644?1073741823:g>>>0<i>>>0?i:g;ma:{if(!b){i=0;break ma}if(b>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break r}J[5996]=0;i=$(3,b<<2)|0;g=J[5996];J[5996]=0;if((g|0)==1){break r}}g=(l<<2)+i|0;J[g>>2]=j;j=g+4|0;if((d|0)!=(k|0)){while(1){g=g-4|0;d=d-4|0;J[g>>2]=J[d>>2];if((d|0)!=(k|0)){continue}break}d=J[h+16>>2];}J[h+24>>2]=(b<<2)+i;J[h+20>>2]=j;J[h+16>>2]=g;if(!d){break aa}$a(d);}j=J[a+52>>2];b=0;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;na:{oa:{if((d|0)==1){break oa}g=e-f|0;k=g>>2;i=0;d=0;if((e|0)!=(f|0)){if((g|0)<0){J[5996]=0;ca(34);b=J[5996];J[5996]=0;if((b|0)!=1){break a}break na}J[5996]=0;d=$(3,g|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break na}g=(g-4&-4)+4|0;e=fb(d,f,g);b=e+(k<<2)|0;i=e+g|0;}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=d;J[a>>2]=13;O[a+48>>3]=+(j>>>0)/+(k>>>0);J[a+12>>2]=b;J[a+8>>2]=i;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=j;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break oa}e=J[h+20>>2];d=J[h+24>>2];pa:{if(e>>>0<d>>>0){J[e>>2]=a;J[h+20>>2]=e+4;break pa}g=J[h+16>>2];j=e-g>>2;b=j+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break oa}d=d-g|0;i=d>>1;i=d>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;qa:{if(!i){b=0;break qa}if(i>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break oa}J[5996]=0;b=$(3,i<<2)|0;d=J[5996];J[5996]=0;if((d|0)==1){break oa}}d=(j<<2)+b|0;J[d>>2]=a;a=d+4|0;if((e|0)!=(g|0)){while(1){d=d-4|0;e=e-4|0;J[d>>2]=J[e>>2];if((e|0)!=(g|0)){continue}break}e=J[h+16>>2];}J[h+24>>2]=(i<<2)+b;J[h+20>>2]=a;J[h+16>>2]=d;if(!e){break pa}$a(e);}if(!f){break o}$a(f);break o}c=Z()|0;break q}c=Z()|0;$a(a);break q}c=Z()|0;}rb(h+4|0);break q}c=Z()|0;}if(!f){break c}$a(f);break c}ra:{sa:{ta:{ua:{va:{wa:{xa:{ya:{za:{if(J[e+56>>2]!=8){break za}d=J[e+60>>2];if((J[e- -64>>2]-d|0)!=112){break za}J[5996]=0;d=ba(37,d|0,b|0,c|0)|0;e=J[5996];J[5996]=0;if((e|0)==1){break ya}a=J[J[a+4>>2]+60>>2];J[5996]=0;b=ba(37,a+56|0,b|0,c|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break xa}e=0;if(!d|!b){break m}J[5996]=0;a=$(3,12)|0;e=J[5996];J[5996]=0;if((e|0)==1){break wa}J[h+28>>2]=a;e=a+12|0;J[h+36>>2]=e;J[a+8>>2]=g;J[a+4>>2]=b;J[a>>2]=d;J[5996]=0;J[h+32>>2]=e;a=Sa(42,c|0,h+28|0,+(1-o))|0;b=J[5996];J[5996]=0;if((b|0)==1){break va}J[5996]=0;aa(39,h+16|0,a|0);a=J[5996];J[5996]=0;if((a|0)==1){break va}a=J[h+28>>2];if(!a){break za}$a(a);}J[5996]=0;a=$(3,12)|0;b=J[5996];J[5996]=0;if((b|0)==1){break ua}J[h+28>>2]=a;b=a+12|0;J[h+36>>2]=b;J[a>>2]=g;d=J[6080];J[a+8>>2]=f;J[a+4>>2]=d;J[5996]=0;J[h+32>>2]=b;a=ya(38,c|0,12,h+28|0,+o)|0;b=J[5996];J[5996]=0;if((b|0)==1){break ta}J[5996]=0;aa(39,h+16|0,a|0);a=J[5996];J[5996]=0;if((a|0)==1){break ta}a=J[h+28>>2];if(a){$a(a);}J[5996]=0;a=$(3,8)|0;b=J[5996];J[5996]=0;if((b|0)==1){break sa}J[h+28>>2]=a;b=a+8|0;J[h+36>>2]=b;J[a+4>>2]=f;J[a>>2]=g;J[5996]=0;J[h+32>>2]=b;a=ya(38,c|0,11,h+28|0,+o)|0;b=J[5996];J[5996]=0;if((b|0)==1){break ra}J[5996]=0;aa(39,h+16|0,a|0);a=J[5996];J[5996]=0;if((a|0)==1){break ra}a=J[h+28>>2];if(!a){break o}$a(a);break o}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;a=J[h+28>>2];if(!a){break c}$a(a);break c}c=Z()|0;break c}c=Z()|0;a=J[h+28>>2];if(!a){break c}$a(a);break c}c=Z()|0;break c}c=Z()|0;a=J[h+28>>2];if(!a){break c}$a(a);break c}f=J[h+20>>2];e=J[h+16>>2];}Aa:{Ba:{Ca:{Da:{if((f-e|0)==4){break Da}b=J[h+24>>2];J[h+24>>2]=0;J[h+16>>2]=0;J[h+20>>2]=0;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Ca}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=e;J[a>>2]=20;J[a+12>>2]=b;J[a+8>>2]=f;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break Aa}e=J[h+20>>2];g=J[h+24>>2];if(e>>>0<g>>>0){J[e>>2]=a;J[h+20>>2]=e+4;break Da}b=J[h+16>>2];f=e-b>>2;d=f+1|0;if(d>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Aa}g=g-b|0;i=g>>1;g=g>>>0>=2147483644?1073741823:d>>>0<i>>>0?i:d;Ea:{if(!g){j=0;break Ea}if(g>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Aa}J[5996]=0;j=$(3,g<<2)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Aa}}d=(f<<2)+j|0;J[d>>2]=a;a=d+4|0;if((b|0)!=(e|0)){while(1){d=d-4|0;e=e-4|0;J[d>>2]=J[e>>2];if((b|0)!=(e|0)){continue}break}e=J[h+16>>2];}J[h+24>>2]=(g<<2)+j;J[h+20>>2]=a;J[h+16>>2]=d;if(!e){break Da}$a(e);}J[5996]=0;e=$(3,56)|0;a=J[5996];J[5996]=0;if((a|0)!=1){a=J[h+24>>2];J[h+24>>2]=0;b=J[h+16>>2];d=J[h+20>>2];J[h+16>>2]=0;J[h+20>>2]=0;J[e+16>>2]=0;J[e+20>>2]=0;J[e+12>>2]=a;J[e+4>>2]=b;J[e+8>>2]=d;J[e>>2]=21;J[e+24>>2]=0;J[e+28>>2]=0;J[e+32>>2]=0;J[e+36>>2]=0;J[e+40>>2]=0;J[e+44>>2]=0;J[5996]=0;aa(33,c|0,e|0);a=J[5996];J[5996]=0;if((a|0)!=1){break Ba}}c=Z()|0;break c}c=Z()|0;if(!e){break b}$a(e);break c}J[5996]=0;b=$(3,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){c=Z()|0;break c}J[b>>2]=e;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;Fa:{Ga:{Ha:{Ia:{Ja:{Ka:{La:{Ma:{Na:{Oa:{Pa:{Qa:{Ra:{Sa:{Ta:{if((d|0)!=1){J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=b;J[a>>2]=15;b=b+4|0;J[a+12>>2]=b;J[a+8>>2]=b;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break Fa}d=J[e+8>>2];f=J[e+12>>2];Ua:{if(d>>>0<f>>>0){J[d>>2]=a;J[e+8>>2]=d+4;break Ua}g=J[e+4>>2];j=d-g>>2;b=j+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Fa}f=f-g|0;i=f>>1;i=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;Va:{if(!i){b=0;break Va}if(i>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Fa}J[5996]=0;b=$(3,i<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Fa}}f=(j<<2)+b|0;J[f>>2]=a;a=f+4|0;if((d|0)!=(g|0)){while(1){f=f-4|0;d=d-4|0;J[f>>2]=J[d>>2];if((d|0)!=(g|0)){continue}break}d=J[e+4>>2];}J[e+12>>2]=(i<<2)+b;J[e+8>>2]=a;J[e+4>>2]=f;if(!d){break Ua}$a(d);}J[5996]=0;b=$(3,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){c=Z()|0;break c}J[b>>2]=e;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Ta}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=b;J[a>>2]=17;b=b+4|0;J[a+12>>2]=b;J[a+8>>2]=b;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break Ga}d=J[e+8>>2];f=J[e+12>>2];Wa:{if(d>>>0<f>>>0){J[d>>2]=a;J[e+8>>2]=d+4;break Wa}g=J[e+4>>2];j=d-g>>2;b=j+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ga}f=f-g|0;i=f>>1;i=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;Xa:{if(!i){b=0;break Xa}if(i>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ga}J[5996]=0;b=$(3,i<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Ga}}f=(j<<2)+b|0;J[f>>2]=a;a=f+4|0;if((d|0)!=(g|0)){while(1){f=f-4|0;d=d-4|0;J[f>>2]=J[d>>2];if((d|0)!=(g|0)){continue}break}d=J[e+4>>2];}J[e+12>>2]=(i<<2)+b;J[e+8>>2]=a;J[e+4>>2]=f;if(!d){break Wa}$a(d);}J[5996]=0;a=J[6080];b=$(3,8)|0;d=J[5996];J[5996]=0;if((d|0)==1){c=Z()|0;break c}J[b+4>>2]=a;J[b>>2]=e;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Sa}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=b;J[a>>2]=10;b=b+8|0;J[a+12>>2]=b;J[a+8>>2]=b;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break Ha}d=J[e+8>>2];f=J[e+12>>2];Ya:{if(d>>>0<f>>>0){J[d>>2]=a;J[e+8>>2]=d+4;break Ya}g=J[e+4>>2];j=d-g>>2;b=j+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ha}f=f-g|0;i=f>>1;i=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;Za:{if(!i){b=0;break Za}if(i>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ha}J[5996]=0;b=$(3,i<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Ha}}f=(j<<2)+b|0;J[f>>2]=a;a=f+4|0;if((d|0)!=(g|0)){while(1){f=f-4|0;d=d-4|0;J[f>>2]=J[d>>2];if((d|0)!=(g|0)){continue}break}d=J[e+4>>2];}J[e+12>>2]=(i<<2)+b;J[e+8>>2]=a;J[e+4>>2]=f;if(!d){break Ya}$a(d);}J[5996]=0;b=$(3,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){c=Z()|0;break c}J[b>>2]=e;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Ra}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=b;J[a>>2]=19;b=b+4|0;J[a+12>>2]=b;J[a+8>>2]=b;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break Ia}d=J[e+8>>2];f=J[e+12>>2];_a:{if(d>>>0<f>>>0){J[d>>2]=a;J[e+8>>2]=d+4;break _a}g=J[e+4>>2];j=d-g>>2;b=j+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ia}f=f-g|0;i=f>>1;i=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;$a:{if(!i){b=0;break $a}if(i>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ia}J[5996]=0;b=$(3,i<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Ia}}f=(j<<2)+b|0;J[f>>2]=a;a=f+4|0;if((d|0)!=(g|0)){while(1){f=f-4|0;d=d-4|0;J[f>>2]=J[d>>2];if((d|0)!=(g|0)){continue}break}d=J[e+4>>2];}J[e+12>>2]=(i<<2)+b;J[e+8>>2]=a;J[e+4>>2]=f;if(!d){break _a}$a(d);}J[5996]=0;b=$(3,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){c=Z()|0;break c}J[b>>2]=e;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Qa}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=b;J[a>>2]=16;b=b+4|0;J[a+12>>2]=b;J[a+8>>2]=b;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break Ja}d=J[e+8>>2];f=J[e+12>>2];ab:{if(d>>>0<f>>>0){J[d>>2]=a;J[e+8>>2]=d+4;break ab}g=J[e+4>>2];j=d-g>>2;b=j+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ja}f=f-g|0;i=f>>1;i=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;bb:{if(!i){b=0;break bb}if(i>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ja}J[5996]=0;b=$(3,i<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Ja}}f=(j<<2)+b|0;J[f>>2]=a;a=f+4|0;if((d|0)!=(g|0)){while(1){f=f-4|0;d=d-4|0;J[f>>2]=J[d>>2];if((d|0)!=(g|0)){continue}break}d=J[e+4>>2];}J[e+12>>2]=(i<<2)+b;J[e+8>>2]=a;J[e+4>>2]=f;if(!d){break ab}$a(d);}J[5996]=0;b=$(3,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){c=Z()|0;break c}J[b>>2]=e;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Pa}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=b;J[a>>2]=18;b=b+4|0;J[a+12>>2]=b;J[a+8>>2]=b;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break Ka}d=J[e+8>>2];f=J[e+12>>2];cb:{if(d>>>0<f>>>0){J[d>>2]=a;J[e+8>>2]=d+4;break cb}g=J[e+4>>2];j=d-g>>2;b=j+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ka}f=f-g|0;i=f>>1;i=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;db:{if(!i){b=0;break db}if(i>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ka}J[5996]=0;b=$(3,i<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break Ka}}f=(j<<2)+b|0;J[f>>2]=a;a=f+4|0;if((d|0)!=(g|0)){while(1){f=f-4|0;d=d-4|0;J[f>>2]=J[d>>2];if((d|0)!=(g|0)){continue}break}d=J[e+4>>2];}J[e+12>>2]=(i<<2)+b;J[e+8>>2]=a;J[e+4>>2]=f;if(!d){break cb}$a(d);}J[5996]=0;a=J[6079];b=$(3,8)|0;d=J[5996];J[5996]=0;if((d|0)==1){c=Z()|0;break c}J[b+4>>2]=a;J[b>>2]=e;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Oa}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=b;J[a>>2]=11;J[a+48>>2]=0;J[a+52>>2]=1072693248;b=b+8|0;J[a+12>>2]=b;J[a+8>>2]=b;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break La}d=J[e+8>>2];f=J[e+12>>2];eb:{if(d>>>0<f>>>0){J[d>>2]=a;J[e+8>>2]=d+4;break eb}g=J[e+4>>2];j=d-g>>2;b=j+1|0;if(b>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break La}f=f-g|0;i=f>>1;i=f>>>0>=2147483644?1073741823:b>>>0<i>>>0?i:b;fb:{if(!i){b=0;break fb}if(i>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break La}J[5996]=0;b=$(3,i<<2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break La}}f=(j<<2)+b|0;J[f>>2]=a;a=f+4|0;if((d|0)!=(g|0)){while(1){f=f-4|0;d=d-4|0;J[f>>2]=J[d>>2];if((d|0)!=(g|0)){continue}break}d=J[e+4>>2];}J[e+12>>2]=(i<<2)+b;J[e+8>>2]=a;J[e+4>>2]=f;if(!d){break eb}$a(d);}J[5996]=0;b=$(3,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){c=Z()|0;break c}J[b>>2]=e;J[5996]=0;a=$(3,56)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Na}J[a+16>>2]=0;J[a+20>>2]=0;J[a+4>>2]=b;J[a>>2]=14;b=b+4|0;J[a+12>>2]=b;J[a+8>>2]=b;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[5996]=0;aa(33,c|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break Ma}d=J[e+8>>2];g=J[e+12>>2];if(d>>>0<g>>>0){J[d>>2]=a;J[e+8>>2]=d+4;break m}b=J[e+4>>2];f=d-b>>2;c=f+1|0;if(c>>>0>=1073741824){J[5996]=0;ca(34);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ma}g=g-b|0;i=g>>1;c=g>>>0>=2147483644?1073741823:c>>>0<i>>>0?i:c;gb:{if(!c){j=0;break gb}if(c>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break Ma}J[5996]=0;j=$(3,c<<2)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Ma}}f=(f<<2)+j|0;J[f>>2]=a;a=f+4|0;if((b|0)!=(d|0)){while(1){f=f-4|0;d=d-4|0;J[f>>2]=J[d>>2];if((b|0)!=(d|0)){continue}break}d=J[e+4>>2];}J[e+12>>2]=(c<<2)+j;J[e+8>>2]=a;J[e+4>>2]=f;if(!d){break m}$a(d);break m}c=Z()|0;$a(b);break c}c=Z()|0;$a(b);break c}c=Z()|0;$a(b);break c}c=Z()|0;$a(b);break c}c=Z()|0;$a(b);break c}c=Z()|0;$a(b);break c}c=Z()|0;$a(b);break c}c=Z()|0;$a(b);break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}a=J[h+16>>2];if(a){J[h+20>>2]=a;$a(a);}Ua=h+48|0;return e|0}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;break c}c=Z()|0;}a=J[h+16>>2];if(!a){break b}J[h+20>>2]=a;$a(a);}da(c|0);B();}B();}function yn(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;a:{b:{c:{if(J[a>>2]!=24){break c}c=J[a+32>>2];g=J[a+36>>2];if((c|0)==(g|0)){break c}while(1){j=J[J[c>>2]+80>>2];d:{if(f>>>0>i>>>0){J[i>>2]=j;i=i+4|0;break d}h=i-b>>2;d=h+1|0;if(d>>>0>=1073741824){J[5996]=0;ca(94);a=J[5996];J[5996]=0;if((a|0)==1){break b}break a}e=f-b|0;f=e>>1;f=e>>>0>=2147483644?1073741823:d>>>0<f>>>0?f:d;e:{if(!f){e=0;break e}if(f>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break b}J[5996]=0;e=$(3,f<<2)|0;d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=(h<<2)+e|0;J[d>>2]=j;v=d;if((b|0)!=(i|0)){while(1){v=v-4|0;i=i-4|0;J[v>>2]=J[i>>2];if((b|0)!=(i|0)){continue}break}}f=(f<<2)+e|0;i=d+4|0;if(b){$a(b);}b=v;}c=c+8|0;if((g|0)!=(c|0)){continue}break}}j=J[a+36>>2];f=J[a+32>>2];c=j-f|0;f:{if((f|0)==(j|0)){d=0;h=0;break f}h=J[J[f>>2]+80>>2];if(c>>>0<9){d=0;break f}d=J[J[f+8>>2]+80>>2];if(c>>>0<17){break f}m=J[J[f+16>>2]+80>>2];}s=c>>3;k=J[a+24>>2];o=J[a+20>>2];e=k-o|0;u=J[a+12>>2];w=J[a+8>>2];x=u-w|0;g=(x|0)/12|0;n=J[a+4>>2];g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{b=J[a>>2];a=b&-2;switch(a-6|0){case 2:break t;case 0:break u;default:break s}}if((e|0)==32){break r}e=2369;a=39;g=3984;break h}if((e|0)==20){break r}e=2369;a=41;g=4224;break h}e=2369;if((k|0)!=(o|0)){a=43;g=4337;break h}if((a|0)!=4){break r}if((n|0)>0){break q}a=47;g=3134;break h}v:{switch(b-24|0){case 1:if(g>>>0>n-1>>>0){break p}e=2369;a=49;g=1397;break h;case 0:if(s>>>0>n-1>>>0){break n}e=2369;a=51;g=1654;break h;default:break v}}e=2369;if(n){a=53;g=4330;break h}if(b-17>>>0>5){break q}if((c|0)==16){break o}a=58;g=4003;break h}if(b-10>>>0>=7){if((b|0)!=23){break p}if((c|0)==24){break n}a=60;g=3946;break h}if((c|0)==8){break n}a=64;g=4090;break h}if((b|0)==24|(f|0)==(j|0)){break o}e=2369;a=66;g=4311;break h}if((a|0)==2){if((x|0)==12){break m}e=2369;a=70;g=4063;break h}if((b|0)!=25){break n}if(g-1>>>0<20){break l}e=2369;a=72;g=4240;break h}if((u|0)==(w|0)){break m}e=2369;a=74;g=4299;break h}c=10;f=2108;e=2369;a=247;g=2350;w:{switch(b|0){case 3:c=9;f=2119;break k;case 4:J[5996]=0;a=_(54,2295,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,2278,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}J[5996]=0;c=_(54,2129,6)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}b=c|(n&4194304?a:b);break i;case 5:J[5996]=0;a=_(54,2174,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,2170,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}J[5996]=0;c=_(54,2129,6)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}b=c|((n>>>0<5e8?b:0)|(n>>>0>499999999?a:0));break i;case 6:case 7:case 8:case 9:c=7;f=2153;break k;case 1:c=7;f=2136;break k;case 0:c=9;f=2098;break k;case 10:J[5996]=0;a=_(54,2777,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,3557,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}J[5996]=0;c=_(54,2161,5)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}J[5996]=0;d=_(54,1600,6)|0;e=J[5996];J[5996]=0;if((e|0)==1){break g}J[5996]=0;e=_(54,1239,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}b=(c|d)&h|(e|(b&(h^-1)?0:a));break i;case 11:J[5996]=0;a=_(54,2777,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,1958,2)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}J[5996]=0;c=_(54,2161,5)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}J[5996]=0;d=_(54,1197,7)|0;e=J[5996];J[5996]=0;if((e|0)==1){break g}b=(c|d)&h|(b&(h^-1)?0:a);break i;case 12:J[5996]=0;a=_(54,3557,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,3310,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}J[5996]=0;c=_(54,2161,5)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}J[5996]=0;d=_(54,2035,6)|0;e=J[5996];J[5996]=0;if((e|0)==1){break g}J[5996]=0;e=_(54,1419,2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}b=(c|d)&h|(e|(b&(h^-1)?0:a));break i;case 13:J[5996]=0;b=_(54,3557,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;c=_(54,1028,2)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,1959,1)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}J[5996]=0;d=_(54,1029,1)|0;e=J[5996];J[5996]=0;if((e|0)==1){break g}J[5996]=0;e=_(54,2451,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}J[5996]=0;f=_(54,2315,1)|0;j=J[5996];J[5996]=0;if((j|0)==1){break g}J[5996]=0;j=_(54,2161,5)|0;g=J[5996];J[5996]=0;if((g|0)==1){break g}J[5996]=0;g=_(54,1640,2)|0;i=J[5996];J[5996]=0;if((i|0)==1){break g}J[5996]=0;i=_(54,1208,3)|0;n=J[5996];J[5996]=0;if((n|0)==1){break g}k=a;a=h^-1;b=(g|j)&h|(i|((a&d?0:k)|(a&c?0:b)|(a&f?0:e)));break i;case 14:J[5996]=0;a=_(54,2796,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,3557,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}J[5996]=0;c=_(54,2161,5)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}J[5996]=0;d=_(54,1486,5)|0;e=J[5996];J[5996]=0;if((e|0)==1){break g}J[5996]=0;e=_(54,1205,2)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}b=(c|d)&h|(e|(b&(h^-1)?0:a));break i;case 15:J[5996]=0;a=_(54,3557,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,2028,2)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}J[5996]=0;c=_(54,2451,1)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}J[5996]=0;d=_(54,2315,1)|0;e=J[5996];J[5996]=0;if((e|0)==1){break g}J[5996]=0;e=_(54,2161,5)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}J[5996]=0;f=_(54,1430,4)|0;j=J[5996];J[5996]=0;if((j|0)==1){break g}J[5996]=0;j=_(54,1208,3)|0;g=J[5996];J[5996]=0;if((g|0)==1){break g}g=c;c=h^-1;b=(e|f)&h|(j|((c&d?0:g)|(b&c?0:a)));break i;case 16:J[5996]=0;a=_(54,2161,5)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,1607,9)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}J[5996]=0;c=_(54,1149,2)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}b=c|(a|b)&h;break i;case 17:J[5996]=0;j=_(54,3540,3)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;g=_(54,2796,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;i=_(54,2029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;n=_(54,2029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;m=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;s=_(54,1959,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;k=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;o=_(54,1024,3)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;u=_(54,1681,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,2315,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,2315,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}e=h^-1;f=d^-1;x:{if(f&b){c=0;J[5996]=0;b=_(54,1681,1)|0;w=J[5996];J[5996]=0;if((w|0)==1){break g}if(b&e){break x}}c=a;}J[5996]=0;w=_(54,1149,2)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;x=_(54,2167,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,2165,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;q=_(54,2165,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}b=0;p=d&h;y:{if(q&(p^-1)){break y}J[5996]=0;b=_(54,2295,1)|0;q=J[5996];J[5996]=0;if((q|0)==1){break g}if(!(b&e)){b=0;J[5996]=0;q=_(54,2278,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break g}if(!(f&q)){break y}}J[5996]=0;b=_(54,2278,1)|0;q=J[5996];J[5996]=0;if((q|0)==1){break g}if(!(b&e)){b=0;J[5996]=0;q=_(54,2295,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break g}if(!(f&q)){break y}}J[5996]=0;b=_(54,2174,1)|0;q=J[5996];J[5996]=0;if((q|0)==1){break g}if(!(b&e)){b=0;J[5996]=0;q=_(54,2170,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break g}if(!(f&q)){break y}}J[5996]=0;b=_(54,2170,1)|0;q=J[5996];J[5996]=0;if((q|0)==1){break g}if(!(b&e)){b=0;J[5996]=0;q=_(54,2174,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break g}if(!(f&q)){break y}}b=a;}a=d|h;b=d&w|(o&p|(h&i|(e&g?0:d&j)|(e&m?0:d&n))|(k&(a^-1)?0:a&s)|a&u|c)|a&x|b;break i;case 18:J[5996]=0;i=_(54,3557,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;n=_(54,2777,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;m=_(54,1959,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;s=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;k=_(54,2029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;o=_(54,2029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;u=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;w=_(54,2451,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;x=_(54,1681,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;q=_(54,2031,3)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,2315,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;e=_(54,2315,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}b=d^-1;c=h^-1;f=d&h;g=f^-1;z:{A:{if(!(g&e)){break A}J[5996]=0;e=_(54,2297,2)|0;j=J[5996];J[5996]=0;if((j|0)==1){break g}if(!(c&e)){break A}j=0;J[5996]=0;e=_(54,2297,2)|0;p=J[5996];J[5996]=0;if((p|0)==1){break g}if(b&e){break z}}j=a;}J[5996]=0;p=_(54,1681,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;r=_(54,1149,2)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;y=_(54,2167,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,2165,1)|0;e=J[5996];J[5996]=0;if((e|0)==1){break g}e=0;J[5996]=0;l=_(54,2165,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}B:{if(g&l){break B}J[5996]=0;e=_(54,2295,1)|0;l=J[5996];J[5996]=0;if((l|0)==1){break g}if(!(c&e)){e=0;J[5996]=0;l=_(54,2278,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}if(!(b&l)){break B}}J[5996]=0;e=_(54,2278,1)|0;l=J[5996];J[5996]=0;if((l|0)==1){break g}if(!(c&e)){e=0;J[5996]=0;l=_(54,2295,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}if(!(b&l)){break B}}J[5996]=0;e=_(54,2174,1)|0;l=J[5996];J[5996]=0;if((l|0)==1){break g}if(!(c&e)){e=0;J[5996]=0;l=_(54,2170,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}if(!(b&l)){break B}}J[5996]=0;e=_(54,2170,1)|0;l=J[5996];J[5996]=0;if((l|0)==1){break g}if(!(c&e)){e=0;J[5996]=0;l=_(54,2174,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}if(!(b&l)){break B}}e=a;}a=d|h;b=r|(f&q|(h&k|(b&n?0:h&i)|(s&(a^-1)?0:a&m)|(c&u?0:d&o))|(g&x?0:f&w)|j|a&p)|a&y|e;break i;case 19:J[5996]=0;a=_(54,3557,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,2504,2)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}c=0;if(!((h^-1)&b)){J[5996]=0;b=_(54,2501,2)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}c=b&(d^-1)?0:a;}J[5996]=0;e=_(54,1959,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;j=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;g=_(54,2049,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}f=0;J[5996]=0;b=_(54,1681,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}a=d&h;k=b;b=d|h;d=b^-1;if(!(k&d)){J[5996]=0;f=_(54,2451,1)|0;h=J[5996];J[5996]=0;if((h|0)==1){break g}f=f&(a^-1)?0:a&g;}J[5996]=0;g=_(54,2340,3)|0;h=J[5996];J[5996]=0;if((h|0)==1){break g}J[5996]=0;h=_(54,1148,3)|0;i=J[5996];J[5996]=0;if((i|0)==1){break g}J[5996]=0;i=_(54,2167,4)|0;n=J[5996];J[5996]=0;if((n|0)==1){break g}J[5996]=0;n=_(54,2165,1)|0;m=J[5996];J[5996]=0;if((m|0)==1){break g}b=a&n|(b&i|(h|(a&g|((d&j?0:b&e)|c|f))));break i;case 21:J[5996]=0;e=_(54,3557,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;f=_(54,1293,3)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;j=_(54,1959,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;g=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,2049,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;c=_(54,2451,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}b=d&h;i=h^-1;C:{if(i&c){a=d|h;c=0;break C}J[5996]=0;c=_(54,1681,1)|0;n=J[5996];J[5996]=0;if((n|0)==1){break g}k=a&b;a=d|h;c=c&(a^-1)?0:k;}J[5996]=0;n=_(54,1650,3)|0;m=J[5996];J[5996]=0;if((m|0)==1){break g}J[5996]=0;m=_(54,2468,3)|0;s=J[5996];J[5996]=0;if((s|0)==1){break g}J[5996]=0;s=_(54,1239,1)|0;k=J[5996];J[5996]=0;if((k|0)==1){break g}J[5996]=0;k=_(54,2167,4)|0;o=J[5996];J[5996]=0;if((o|0)==1){break g}J[5996]=0;o=_(54,2165,1)|0;u=J[5996];J[5996]=0;if((u|0)==1){break g}b=b&o|(a&k|(s|(d&m|(b&n|(c|((g&(d^-1)?0:h&j)|(f&i?0:d&e)))))));break i;case 20:J[5996]=0;e=_(54,2796,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;f=_(54,1293,3)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;j=_(54,1959,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;g=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,2049,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;c=_(54,2451,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}b=d&h;i=h^-1;D:{if(i&c){a=d|h;c=0;break D}J[5996]=0;c=_(54,1681,1)|0;n=J[5996];J[5996]=0;if((n|0)==1){break g}k=a&b;a=d|h;c=c&(a^-1)?0:k;}J[5996]=0;n=_(54,1394,2)|0;m=J[5996];J[5996]=0;if((m|0)==1){break g}J[5996]=0;m=_(54,1205,2)|0;s=J[5996];J[5996]=0;if((s|0)==1){break g}J[5996]=0;s=_(54,2167,4)|0;k=J[5996];J[5996]=0;if((k|0)==1){break g}J[5996]=0;k=_(54,2165,1)|0;o=J[5996];J[5996]=0;if((o|0)==1){break g}b=b&k|(a&s|(m|(b&n|(c|((g&(d^-1)?0:h&j)|(f&i?0:d&e))))));break i;case 22:J[5996]=0;e=_(54,1643,6)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;b=_(54,1959,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;f=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;j=_(54,2451,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;g=_(54,2315,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;i=_(54,2049,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;n=_(54,1681,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;m=_(54,2522,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;s=_(54,1239,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;k=_(54,2167,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;o=_(54,2165,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}a=d|h;c=a^-1;l=b;b=d&h;b=a&k|(s|(a&m|((f&(b^-1)?0:l)|b&e|(c&g?0:a&j)))|(c&n?0:b&i))|b&o;break i;case 24:break j;case 2:break k;case 25:break l;case 23:break w;default:break h}}J[5996]=0;s=_(54,2779,3)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;k=_(54,1293,3)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;o=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;u=_(54,1959,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;w=_(54,1029,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;x=_(54,1295,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,2315,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,1681,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}c=h^-1;E:{if(c&b){e=0;J[5996]=0;b=_(54,2315,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}if((d^-1)&b){break E}}e=a&m;}J[5996]=0;q=_(54,2522,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,2451,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,1681,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}F:{if(b&c){j=0;J[5996]=0;b=_(54,2315,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}if((d^-1)&b){break F}}j=a&h&m;}J[5996]=0;a=_(54,2049,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,2451,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}n=d&h&m;G:{if(b&c){g=d|h;i=m|g;a=0;break G}J[5996]=0;b=_(54,1681,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}g=d|h;i=m|g;a=b&(i^-1)?0:a&n;}J[5996]=0;p=_(54,1681,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;r=_(54,1239,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;y=_(54,2167,4)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;b=_(54,2165,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break g}f=0;J[5996]=0;l=_(54,2165,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}H:{if(l&(n^-1)){break H}J[5996]=0;f=_(54,2295,1)|0;l=J[5996];J[5996]=0;if((l|0)==1){break g}if(!(c&f)){f=0;J[5996]=0;l=_(54,2278,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}if(!((d^-1)&l)){break H}}J[5996]=0;f=_(54,2278,1)|0;l=J[5996];J[5996]=0;if((l|0)==1){break g}if(!(c&f)){f=0;J[5996]=0;l=_(54,2295,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}if(!((d^-1)&l)){break H}}J[5996]=0;f=_(54,2174,1)|0;l=J[5996];J[5996]=0;if((l|0)==1){break g}if(!(c&f)){f=0;J[5996]=0;l=_(54,2170,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}if(!((d^-1)&l)){break H}}J[5996]=0;f=_(54,2170,1)|0;l=J[5996];J[5996]=0;if((l|0)==1){break g}if(!(c&f)){f=0;J[5996]=0;l=_(54,2174,1)|0;t=J[5996];J[5996]=0;if((t|0)==1){break g}if(!((d^-1)&l)){break H}}f=b;}b=d&m;d=b|h;b=i&y|(g&p&m|(r|(a|(m&q|(b&x|(n&o|(c&k?0:b&s))|(w&(d^-1)?0:d&u)|e)|j))))|f;break i}c=8;f=2144;}J[5996]=0;b=_(54,f|0,c|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){break i}break g}f=0;J[5996]=0;j=1;c=_(54,2165,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}I:{if((i|0)==(v|0)){a=1;h=0;break I}e=J[v>>2];b=0;J[5996]=0;a=_(54,1293,3)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}d=e^-1;if(d&a){break i}J[5996]=0;g=_(54,2451,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;h=_(54,2049,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;m=_(54,1681,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,1029,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}if(a&d){J[5996]=0;a=_(54,1959,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}f=a&d?2:1;}J[5996]=0;k=_(54,2167,4)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;a=_(54,2165,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}J[5996]=0;j=_(54,2165,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}b=0;J:{if(j&(c&e^-1)){break J}K:{if(n>>>0<2){break K}J[5996]=0;b=_(54,2295,1)|0;j=J[5996];J[5996]=0;if((j|0)==1){break g}j=c^-1;if(!(j&b)){b=0;J[5996]=0;o=_(54,2278,1)|0;u=J[5996];J[5996]=0;if((u|0)==1){break g}if(!(d&o)){break J}}J[5996]=0;b=_(54,2278,1)|0;o=J[5996];J[5996]=0;if((o|0)==1){break g}if(!(b&j)){b=0;J[5996]=0;o=_(54,2295,1)|0;u=J[5996];J[5996]=0;if((u|0)==1){break g}if(!(d&o)){break J}}J[5996]=0;b=_(54,2174,1)|0;o=J[5996];J[5996]=0;if((o|0)==1){break g}if(!(b&j)){b=0;J[5996]=0;o=_(54,2170,1)|0;u=J[5996];J[5996]=0;if((u|0)==1){break g}if(!(d&o)){break J}}J[5996]=0;b=_(54,2170,1)|0;o=J[5996];J[5996]=0;if((o|0)==1){break g}if(b&j){break K}b=0;J[5996]=0;j=_(54,2174,1)|0;o=J[5996];J[5996]=0;if((o|0)==1){break g}if(!(d&j)){break J}}b=a;}a=!(d&g);j=!(d&h);h=!(d&m);c=k&(c|e)|b;b=i-v|0;if(b>>>0<5){break I}b=b>>2;o=b>>>0<=2?2:b;e=1;while(1){m=J[(e<<2)+v>>2];J[5996]=0;b=_(54,1289,3)|0;d=J[5996];J[5996]=0;if((d|0)==1){break b}i=m^-1;if(i&b){b=0;break i}J[5996]=0;u=_(54,2451,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break b}J[5996]=0;w=_(54,2049,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break b}J[5996]=0;x=_(54,1681,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break b}J[5996]=0;b=_(54,1029,1)|0;d=J[5996];J[5996]=0;if((d|0)==1){break b}if(b&i){J[5996]=0;b=_(54,1959,1)|0;d=J[5996];J[5996]=0;if((d|0)==1){break b}b=b&i?2:1;}else {b=0;}J[5996]=0;q=_(54,2167,4)|0;d=J[5996];J[5996]=0;if((d|0)==1){break b}J[5996]=0;g=_(54,2165,1)|0;d=J[5996];J[5996]=0;if((d|0)==1){break b}J[5996]=0;k=_(54,2165,1)|0;d=J[5996];J[5996]=0;if((d|0)==1){break b}d=0;L:{if(k&(c&m^-1)){break L}M:{if(n>>>0<2){break M}J[5996]=0;k=_(54,2295,1)|0;p=J[5996];J[5996]=0;if((p|0)==1){break b}l=k;k=c^-1;if(!(l&k)){J[5996]=0;p=_(54,2278,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break b}if(!(i&p)){break L}}J[5996]=0;p=_(54,2278,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break b}if(!(k&p)){J[5996]=0;p=_(54,2295,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break b}if(!(i&p)){break L}}J[5996]=0;p=_(54,2174,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break b}if(!(k&p)){J[5996]=0;p=_(54,2170,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break b}if(!(i&p)){break L}}J[5996]=0;p=_(54,2170,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break b}if(k&p){break M}J[5996]=0;k=_(54,2174,1)|0;p=J[5996];J[5996]=0;if((p|0)==1){break b}if(!(i&k)){break L}}d=g;}a=!(i&u)&a;j=!(i&w)&j;h=!(i&x)+h|0;f=b+f|0;c=q&(c|m)|d;e=e+1|0;if((o|0)!=(e|0)){continue}break}}J[5996]=0;b=_(54,1293,3)|0;d=J[5996];J[5996]=0;if((d|0)==1){break g}J[5996]=0;d=_(54,1029,1)|0;e=J[5996];J[5996]=0;if((e|0)==1){break g}J[5996]=0;e=_(54,1959,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break g}J[5996]=0;g=_(54,2451,1)|0;i=J[5996];J[5996]=0;if((i|0)==1){break g}J[5996]=0;i=_(54,2049,1)|0;m=J[5996];J[5996]=0;if((m|0)==1){break g}J[5996]=0;m=_(54,1681,1)|0;k=J[5996];J[5996]=0;if((k|0)==1){break g}b=b|c|(f?0:d)|((f|0)==1?e:0)|(a?(h|0)==(s|0)?g:0:0);c=a&j?i:0;a=s-n|0;b=b|(a>>>0<=h>>>0?c:0)|(a+1>>>0<=h>>>0?m:0);}J[5996]=0;c=_(54,3310,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;d=_(54,2796,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;f=_(54,3557,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}J[5996]=0;j=_(54,2777,1)|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}e=2356;a=19;g=4075;N:{O:{k=d;d=b^-1;c=((!(k&d)+!(c&d)|0)+!(d&f)|0)+!(d&j)|0;switch(c|0){case 0:break N;case 1:break O;default:break h}}J[5996]=0;a=_(54,1029,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}P:{if(a&d){break P}J[5996]=0;a=_(54,1959,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(a&d){break P}a=20;g=4494;break h}J[5996]=0;a=_(54,2029,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}Q:{if(a&d){break Q}J[5996]=0;a=_(54,1029,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(a&d){break Q}a=21;g=4356;break h}J[5996]=0;a=_(54,2029,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}R:{if(a&d){break R}J[5996]=0;a=_(54,2777,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(a&d){break R}a=22;g=4771;break h}J[5996]=0;a=_(54,2796,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}S:{if(a&d){break S}J[5996]=0;a=_(54,2522,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(a&d){break S}a=23;g=4702;break h}J[5996]=0;a=_(54,3310,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}T:{if(a&d){break T}J[5996]=0;a=_(54,1295,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(!(a&d)){break T}a=24;g=4426;break h}J[5996]=0;a=_(54,2796,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}U:{if(a&d){break U}J[5996]=0;a=_(54,1295,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(a&d){break U}a=25;g=4391;break h}J[5996]=0;a=_(54,2451,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}V:{if(a&d){break V}J[5996]=0;a=_(54,2315,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(a&d){break V}a=26;g=4563;break h}J[5996]=0;a=_(54,2451,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}W:{if(a&d){break W}J[5996]=0;a=_(54,2522,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(!(a&d)){break W}a=27;g=4737;break h}J[5996]=0;a=_(54,2796,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}X:{if(a&d){break X}J[5996]=0;a=_(54,2451,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(a&d){break X}a=28;g=4667;break h}J[5996]=0;a=_(54,2522,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}Y:{if(a&d){break Y}J[5996]=0;a=_(54,2315,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(a&d){break Y}a=29;g=4598;break h}J[5996]=0;a=_(54,2796,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}Z:{if(a&d){break Z}J[5996]=0;a=_(54,2315,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(!(a&d)){break Z}a=30;g=4633;break h}J[5996]=0;a=_(54,3310,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}_:{if(a&d){break _}J[5996]=0;a=_(54,1681,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(!(a&d)){break _}a=31;g=4460;break h}J[5996]=0;a=_(54,1029,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}if(a&d){c=b;break N}J[5996]=0;a=_(54,2049,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break g}c=b;if(!(a&d)){break N}a=32;g=4529;break h}if(v){$a(v);}return c|0}J[5996]=0;ga(44,g|0,1859,a|0,e|0);a=J[5996];J[5996]=0;if((a|0)!=1){break a}}}a=Z()|0;if(v){$a(v);}da(a|0);B();}B();}function jn(a,b,c,d,e,f,g,h,i,j,k){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;l=Ua-304|0;Ua=l;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{m=Gb(a);if(m>>>0>=2147483632){J[5996]=0;ca(2);a=J[5996];J[5996]=0;if((a|0)==1){break s}break a}t:{if(m>>>0<=10){H[l+155|0]=m;n=l+144|0;break t}J[5996]=0;o=(m|15)+1|0;n=$(3,o|0)|0;p=J[5996];J[5996]=0;if((p|0)==1){break s}J[l+144>>2]=n;J[l+148>>2]=m;J[l+152>>2]=o|-2147483648;}H[fb(n,a,m)+m|0]=0;q=J[l+144>>2];a=K[l+155|0];r=a<<24>>24;m=(r|0)<0;p=m?q:l+144|0;s=m?J[l+148>>2]:a;m=p+s|0;n=-1;u:{while(1){if((m|0)==(p|0)){break u}m=m-1|0;o=K[m|0];v=o>>>0<=63;a=o&31;if((o&63)>>>0>=32){o=1<<a;t=0;}else {t=1<<a;o=t-1&1>>>32-a;}a=t&9728;if(v&(o&1|(a|0)!=0)){continue}break}n=m-p|0;}a=n+1|0;if(a>>>0>s>>>0){J[5996]=0;ca(108);a=J[5996];J[5996]=0;if((a|0)!=1){break a}m=fa(22864)|0;a=Va;break m}v:{if((r|0)<0){J[l+148>>2]=a;break v}H[l+155|0]=a;q=l+144|0;}H[a+q|0]=0;J[l+12>>2]=0;J[l+16>>2]=0;w:{if(H[l+155|0]>=0){J[l+120>>2]=J[l+152>>2];a=J[l+148>>2];J[l+112>>2]=J[l+144>>2];J[l+116>>2]=a;break w}J[5996]=0;ea(40,l+112|0,J[l+144>>2],J[l+148>>2]);a=J[5996];J[5996]=0;if((a|0)==1){break r}}J[5996]=0;m=l+128|0;aa(109,m|0,l+112|0);a=J[5996];J[5996]=0;if((a|0)==1){break q}n=H[l+139|0];a=(n|0)<0;J[l+180>>2]=a?J[l+132>>2]:n&255;J[l+176>>2]=a?J[l+128>>2]:m;J[5996]=0;aa(29,l+248|0,l+176|0);a=J[5996];J[5996]=0;x:{y:{z:{A:{if((a|0)!=1){if(!J[l+180>>2]){break A}J[l+240>>2]=0;J[l+244>>2]=0;J[l+232>>2]=0;J[l+236>>2]=0;J[l+224>>2]=0;J[l+228>>2]=0;J[l+216>>2]=0;J[l+220>>2]=0;J[l+208>>2]=0;J[l+212>>2]=0;J[l+200>>2]=0;J[l+204>>2]=0;J[l+192>>2]=0;J[l+196>>2]=0;break z}m=Ra(22528,22864)|0;a=Va;if((a|0)!=(wa(22528)|0)){break x}pa(m|0)|0;J[l+240>>2]=0;J[l+244>>2]=0;J[l+232>>2]=0;J[l+236>>2]=0;J[l+224>>2]=0;J[l+228>>2]=0;J[l+216>>2]=0;J[l+220>>2]=0;J[l+208>>2]=0;J[l+212>>2]=0;J[l+200>>2]=0;J[l+204>>2]=0;J[l+192>>2]=0;J[l+196>>2]=0;J[5996]=0;ca(110);a=J[5996];J[5996]=0;if((a|0)!=1){break y}m=fa(22864)|0;a=Va;break x}a=J[l+260>>2];m=J[l+264>>2];J[l+260>>2]=0;J[l+264>>2]=0;J[l+204>>2]=a;J[l+208>>2]=m;a=J[l+268>>2];m=J[l+272>>2];J[l+268>>2]=0;J[l+272>>2]=0;J[l+212>>2]=a;J[l+216>>2]=m;J[l+228>>2]=J[l+284>>2];a=J[l+288>>2];J[l+284>>2]=0;J[l+288>>2]=0;J[l+192>>2]=J[l+248>>2];m=J[l+252>>2];n=J[l+256>>2];J[l+252>>2]=0;J[l+256>>2]=0;J[l+196>>2]=m;J[l+200>>2]=n;m=J[l+280>>2];J[l+220>>2]=J[l+276>>2];J[l+224>>2]=m;J[l+276>>2]=0;J[l+280>>2]=0;J[l+232>>2]=a;J[l+236>>2]=J[l+292>>2];J[l+292>>2]=0;a=J[l+296>>2];J[l+296>>2]=0;J[l+240>>2]=a;J[l+244>>2]=J[l+300>>2];}Fb(l+248|0);}if(!J[l+192>>2]){n=0;break o}J[l+184>>2]=0;J[l+176>>2]=0;J[l+180>>2]=0;J[l+256>>2]=0;J[l+260>>2]=0;J[5996]=0;J[l+248>>2]=0;J[l+252>>2]=0;J[l+264>>2]=1065353216;o=ba(111,l+192|0,l+248|0,l+176|0)|0;a=J[5996];J[5996]=0;B:{if((a|0)!=1){m=J[l+256>>2];if(m){while(1){a=J[m>>2];$a(m);m=a;if(a){continue}break}}a=J[l+248>>2];n=0;J[l+248>>2]=0;if(a){$a(a);}C:{D:{if(o){J[l+252>>2]=0;J[l+256>>2]=0;J[5996]=0;J[l+248>>2]=l+252;a=qa(50,o|0,1,0,l+248|0)|0;m=J[5996];J[5996]=0;if((m|0)==1){break D}J[5996]=0;m=_(54,1639,3)|0;n=J[5996];J[5996]=0;E:{F:{G:{H:{if((n|0)==1){break H}n=J[a>>2];a=J[a+4>>2];J[5996]=0;oa(51,l+160|0,n|0,a|0,m|0,0);a=J[5996];J[5996]=0;if((a|0)==1){break H}m=J[l+164>>2];n=J[l+160>>2];o=m-n|0;if((o|0)!=32){break G}m=J[n>>2];p=J[n+4>>2];J[n>>2]=0;J[n+4>>2]=0;a=J[l+16>>2];J[l+12>>2]=m;J[l+16>>2]=p;I:{if(!a){break I}m=J[a+4>>2];J[a+4>>2]=m-1;if(m){break I}Xa[J[J[a>>2]+8>>2]](a);bb(a);}n=J[l+160>>2];u=O[n+8>>3];m=J[l+164>>2];break F}m=fa(22864)|0;break C}if(!n){break E}}if((m|0)!=(n|0)){while(1){m=m-32|0;a=J[m+4>>2];J:{if(!a){break J}p=J[a+4>>2];J[a+4>>2]=p-1;if(p){break J}Xa[J[J[a>>2]+8>>2]](a);bb(a);}if((m|0)!=(n|0)){continue}break}m=J[l+160>>2];}J[l+164>>2]=n;$a(m);}xd(J[l+252>>2]);n=(o|0)==32;}a=J[l+176>>2];if(!a){break o}m=J[l+180>>2];if((a|0)!=(m|0)){while(1){m=m-4|0;ad(m);if((a|0)!=(m|0)){continue}break}a=J[l+176>>2];}$a(a);break o}m=fa(22864)|0;}a=Va;xd(J[l+252>>2]);break B}m=fa(22864)|0;a=Va;h=J[l+256>>2];if(h){while(1){i=J[h>>2];$a(h);h=i;if(h){continue}break}}h=J[l+248>>2];J[l+248>>2]=0;if(h){$a(h);}}h=J[l+176>>2];if(h){j=J[l+180>>2];i=h;if((j|0)!=(h|0)){while(1){j=j-4|0;ad(j);if((h|0)!=(j|0)){continue}break}i=J[l+176>>2];}J[l+180>>2]=h;$a(i);}Fb(l+192|0);}if(H[l+139|0]>=0){break p}$a(J[l+128>>2]);break p}m=fa(22864)|0;a=Va;break l}m=fa(22864)|0;a=Va;break n}m=fa(22864)|0;a=Va;}if(H[l+123|0]>=0){break n}$a(J[l+112>>2]);break n}Fb(l+192|0);if(H[l+139|0]<0){$a(J[l+128>>2]);}if(H[l+123|0]<0){$a(J[l+112>>2]);}K:{L:{M:{N:{O:{P:{Q:{R:{if(!n){J[5996]=0;a=$(3,16)|0;h=J[5996];J[5996]=0;S:{T:{if((h|0)!=1){H[a+15|0]=0;h=K[2587]|K[2588]<<8|(K[2589]<<16|K[2590]<<24);i=K[2583]|K[2584]<<8|(K[2585]<<16|K[2586]<<24);H[a+7|0]=i;H[a+8|0]=i>>>8;H[a+9|0]=i>>>16;H[a+10|0]=i>>>24;H[a+11|0]=h;H[a+12|0]=h>>>8;H[a+13|0]=h>>>16;H[a+14|0]=h>>>24;h=K[2580]|K[2581]<<8|(K[2582]<<16|K[2583]<<24);i=K[2576]|K[2577]<<8|(K[2578]<<16|K[2579]<<24);H[a|0]=i;H[a+1|0]=i>>>8;H[a+2|0]=i>>>16;H[a+3|0]=i>>>24;H[a+4|0]=h;H[a+5|0]=h>>>8;H[a+6|0]=h>>>16;H[a+7|0]=h>>>24;h=((c|0)>=16?16:c)-1|0;H[fb(b,a,h)+h|0]=0;$a(a);J[5996]=0;k=$(3,16)|0;a=J[5996];J[5996]=0;if((a|0)==1){break T}H[k+15|0]=0;h=K[2587]|K[2588]<<8|(K[2589]<<16|K[2590]<<24);i=h;a=K[2583]|K[2584]<<8|(K[2585]<<16|K[2586]<<24);H[k+7|0]=a;n=a>>>8|0;H[k+8|0]=n;o=a>>>16|0;H[k+9|0]=o;p=a>>>24|0;H[k+10|0]=p;H[k+11|0]=h;H[k+12|0]=h>>>8;H[k+13|0]=h>>>16;H[k+14|0]=h>>>24;j=K[2580]|K[2581]<<8|(K[2582]<<16|K[2583]<<24);h=K[2576]|K[2577]<<8|(K[2578]<<16|K[2579]<<24);H[k|0]=h;H[k+1|0]=h>>>8;H[k+2|0]=h>>>16;H[k+3|0]=h>>>24;H[k+4|0]=j;H[k+5|0]=j>>>8;H[k+6|0]=j>>>16;H[k+7|0]=j>>>24;m=((e|0)>=16?16:e)-1|0;H[fb(d,k,m)+m|0]=0;$a(k);J[5996]=0;k=$(3,16)|0;m=J[5996];J[5996]=0;if((m|0)==1){break S}H[k+15|0]=0;H[k+7|0]=a;H[k+8|0]=n;H[k+9|0]=o;H[k+10|0]=p;a=i;H[k+11|0]=a;H[k+12|0]=a>>>8;H[k+13|0]=a>>>16;H[k+14|0]=a>>>24;H[k|0]=h;H[k+1|0]=h>>>8;H[k+2|0]=h>>>16;H[k+3|0]=h>>>24;a=j;H[k+4|0]=a;H[k+5|0]=a>>>8;H[k+6|0]=a>>>16;H[k+7|0]=a>>>24;a=((g|0)>=16?16:g)-1|0;H[fb(f,k,a)+a|0]=0;$a(k);break R}m=fa(22864)|0;a=Va;break n}m=fa(22864)|0;a=Va;break n}m=fa(22864)|0;a=Va;break n}J[5996]=0;a=J[l+12>>2];J[l+200>>2]=0;J[l+192>>2]=0;J[l+196>>2]=0;p=$(3,12)|0;m=J[5996];J[5996]=0;if((m|0)==1){break K}H[p+8|0]=0;J[p+4>>2]=0;J[p>>2]=a;m=p+12|0;t=m;U:{V:{W:{while(1){X:{r=m-12|0;o=J[r+4>>2];a=J[r>>2];n=J[a+32>>2];s=J[a+36>>2]-n>>3;Y:{if(s>>>0>o>>>0){s=1;J[r+4>>2]=o+1;a=J[a>>2];Z:{if(a-10>>>0<7){break Z}_:{switch(a-17|0){case 0:s=J[J[n+8>>2]>>2]==1;break Z;case 5:if(!J[J[n>>2]>>2]){break Z}s=!J[J[n+8>>2]>>2];break Z;default:break _}}s=0;}a=J[n+(o<<3)>>2];if(m>>>0<t>>>0){H[m+8|0]=s;J[m+4>>2]=0;J[m>>2]=a;m=m+12|0;break Y}$:{r=(m-p|0)/12|0;n=r+1|0;aa:{if(n>>>0>=357913942){J[5996]=0;ca(112);break aa}o=(t-p|0)/12|0;q=o<<1;n=o>>>0>=178956970?357913941:n>>>0<q>>>0?q:n;if(n>>>0<357913942){break $}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}m=fa(22864)|0;break M}J[5996]=0;q=P(n,12);o=$(3,q|0)|0;n=J[5996];J[5996]=0;if((n|0)==1){break N}n=o+P(r,12)|0;H[n+8|0]=s;J[n+4>>2]=0;J[n>>2]=a;a=n;if((m|0)!=(p|0)){while(1){m=m-12|0;r=J[m+4>>2];a=a-12|0;J[a>>2]=J[m>>2];J[a+4>>2]=r;J[a+8>>2]=J[m+8>>2];if((m|0)!=(p|0)){continue}break}}t=o+q|0;m=n+12|0;if(p){$a(p);}p=a;break Y}q=J[l+192>>2];n=(J[l+196>>2]-q|0)/12|0;if(n>>>0<s>>>0){J[5996]=0;ga(44,5135,2210,439,2439);a=J[5996];J[5996]=0;if((a|0)!=1){break a}m=fa(22864)|0;break M}m=K[m-4|0];J[5996]=0;oa(113,l+248|0,m|0,a|0,(P(n,12)+q|0)+P(s,-12)|0,s|0);m=J[5996];J[5996]=0;ba:{if((m|0)!=1){if(K[l+260|0]){break ba}s=0;break U}m=fa(22864)|0;break M}n=J[l+196>>2];m=J[a+36>>2]-J[a+32>>2]>>3;a=J[l+192>>2];o=((n+P(m,-12)|0)-a|0)/12|0;ca:{if(!P(m,-12)){m=n;break ca}o=a+P(o,12)|0;a=o;m=a+P((P(m,12)|0)/12|0,12)|0;if((n|0)!=(m|0)){while(1){if(H[a+11|0]<0){$a(J[a>>2]);}q=J[m+4>>2];J[a>>2]=J[m>>2];J[a+4>>2]=q;J[a+8>>2]=J[m+8>>2];H[m+11|0]=0;H[m|0]=0;a=a+12|0;m=m+12|0;if((n|0)!=(m|0)){continue}break}n=J[l+196>>2];}m=o+P((a-o|0)/12|0,12)|0;if((n|0)!=(m|0)){while(1){a=n-12|0;if(H[n-1|0]<0){$a(J[a>>2]);}n=a;if((a|0)!=(m|0)){continue}break}}J[l+196>>2]=m;}o=J[l+200>>2];da:{if(o>>>0>m>>>0){a=J[l+252>>2];J[m>>2]=J[l+248>>2];J[m+4>>2]=a;J[m+8>>2]=J[l+256>>2];J[l+256>>2]=0;J[l+248>>2]=0;J[l+252>>2]=0;J[l+196>>2]=m+12;break da}ea:{fa:{n=J[l+192>>2];s=(m-n|0)/12|0;a=s+1|0;ga:{if(a>>>0>=357913942){J[5996]=0;ca(41);break ga}o=(o-n|0)/12|0;q=o<<1;q=o>>>0>=178956970?357913941:a>>>0<q>>>0?q:a;if(!q){o=0;break ea}if(q>>>0<357913942){break fa}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}m=fa(22864)|0;break W}J[5996]=0;o=$(3,P(q,12)|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break X}}a=P(s,12)+o|0;s=J[l+252>>2];J[a>>2]=J[l+248>>2];J[a+4>>2]=s;J[a+8>>2]=J[l+256>>2];J[l+256>>2]=0;J[l+248>>2]=0;J[l+252>>2]=0;o=P(q,12)+o|0;q=a+12|0;ha:{if((m|0)==(n|0)){J[l+200>>2]=o;J[l+196>>2]=q;J[l+192>>2]=a;break ha}while(1){m=m-12|0;s=J[m+4>>2];a=a-12|0;J[a>>2]=J[m>>2];J[a+4>>2]=s;J[a+8>>2]=J[m+8>>2];J[m>>2]=0;J[m+4>>2]=0;J[m+8>>2]=0;if((m|0)!=(n|0)){continue}break}J[l+200>>2]=o;n=J[l+196>>2];J[l+196>>2]=q;m=J[l+192>>2];J[l+192>>2]=a;if((m|0)==(n|0)){break ha}while(1){a=n-12|0;if(H[n-1|0]<0){$a(J[a>>2]);}n=a;if((a|0)!=(m|0)){continue}break}}if(!m){break da}$a(m);}if(!(!K[l+260|0]|H[l+259|0]>=0)){$a(J[l+248>>2]);}m=r;}if((m|0)!=(p|0)){continue}break V}break}m=fa(22864)|0;}a=Va;if(!K[l+260|0]|H[l+259|0]>=0){break L}$a(J[l+248>>2]);break L}a=J[l+192>>2];if((J[l+196>>2]-a|0)!=12){J[5996]=0;ga(44,4102,2210,450,2439);a=J[5996];J[5996]=0;if((a|0)!=1){break a}m=fa(22864)|0;break M}s=J[a>>2];J[l+160>>2]=J[a+4>>2];m=K[a+7|0]|K[a+8|0]<<8|(K[a+9|0]<<16|K[a+10|0]<<24);H[l+163|0]=m;H[l+164|0]=m>>>8;H[l+165|0]=m>>>16;H[l+166|0]=m>>>24;J[a>>2]=0;J[a+4>>2]=0;q=K[a+11|0];J[a+8>>2]=0;}n=J[l+192>>2];if(n){a=J[l+196>>2];m=n;if((a|0)!=(m|0)){while(1){m=a-12|0;if(H[a-1|0]<0){$a(J[m>>2]);}a=m;if((n|0)!=(a|0)){continue}break}m=J[l+192>>2];}J[l+196>>2]=n;$a(m);}if(p){$a(p);}a=K[l+163|0]|K[l+164|0]<<8|(K[l+165|0]<<16|K[l+166|0]<<24);H[l+103|0]=a;H[l+104|0]=a>>>8;H[l+105|0]=a>>>16;H[l+106|0]=a>>>24;J[l+100>>2]=J[l+160>>2];J[l+96>>2]=s;J[l+160>>2]=0;H[l+163|0]=0;H[l+164|0]=0;H[l+165|0]=0;H[l+166|0]=0;H[l+107|0]=q;ia:{ja:{ka:{la:{ma:{na:{oa:{pa:{qa:{ra:{sa:{ta:{ua:{va:{wa:{xa:{ya:{za:{Aa:{Ba:{Ca:{Da:{p=J[l+100>>2];a=q<<24>>24<0;m=a?p:q&255;Ea:{if((m|0)<72){break Ea}o=a?s:l+96|0;n=o+m|0;while(1){a=o;while(1){a=Zb(a,115,m-71|0);if(!a){break Ea}if(Eb(a,5034,72)){a=a+1|0;m=n-a|0;if((m|0)>=72){continue}break Ea}break}if((a|0)==(n|0)){break Ea}a=a-o|0;if((a|0)==-1){break Ea}J[5996]=0;m=l+96|0;ga(114,m|0,a|0,72,4824);a=J[5996];J[5996]=0;if((a|0)==1){break Da}s=J[l+96>>2];n=m;a=K[l+107|0];q=a<<24>>24;m=(q|0)<0;o=m?s:n;p=J[l+100>>2];m=m?p:a;n=o+m|0;if((m|0)>71){continue}break}}Fa:{a=q<<24>>24;m=(a|0)<0?p:q&255;Ga:{if((m|0)<73){break Ga}o=(a|0)<0?s:l+96|0;n=o+m|0;while(1){a=o;while(1){a=Zb(a,104,m-72|0);if(!a){break Ga}if(Eb(a,4960,73)){a=a+1|0;m=n-a|0;if((m|0)>=73){continue}break Ga}break}if((a|0)==(n|0)){break Ga}a=a-o|0;if((a|0)==-1){break Ga}J[5996]=0;m=l+96|0;ga(114,m|0,a|0,73,4813);a=J[5996];J[5996]=0;if((a|0)==1){break Fa}s=J[l+96>>2];n=m;a=K[l+107|0];q=a<<24>>24;m=(q|0)<0;o=m?s:n;p=J[l+100>>2];m=m?p:a;n=o+m|0;if((m|0)>72){continue}break}}Ha:{a=q<<24>>24<0;m=a?p:q&255;Ia:{if((m|0)<51){break Ia}o=a?s:l+96|0;n=o+m|0;while(1){a=o;while(1){a=Zb(a,114,m-50|0);if(!a){break Ia}if(Eb(a,4908,51)){a=a+1|0;m=n-a|0;if((m|0)>=51){continue}break Ia}break}if((a|0)==(n|0)){break Ia}a=a-o|0;if((a|0)==-1){break Ia}J[5996]=0;m=l+96|0;ga(114,m|0,a|0,51,4845);a=J[5996];J[5996]=0;if((a|0)==1){break Ha}s=J[l+96>>2];n=m;a=K[l+107|0];q=a<<24>>24;m=(q|0)<0;o=m?s:n;p=J[l+100>>2];m=m?p:a;n=o+m|0;if((m|0)>50){continue}break}}Ja:{a=q<<24>>24;m=(a|0)<0?p:q&255;Ka:{if((m|0)<49){break Ka}p=(a|0)<0?s:l+96|0;n=p+m|0;while(1){a=p;while(1){a=Zb(a,104,m-48|0);if(!a){break Ka}if(Eb(a,4858,49)){a=a+1|0;m=n-a|0;if((m|0)>=49){continue}break Ka}break}if((a|0)==(n|0)){break Ka}a=a-p|0;if((a|0)==-1){break Ka}J[5996]=0;m=l+96|0;ga(114,m|0,a|0,49,4834);a=J[5996];J[5996]=0;if((a|0)==1){break Ja}n=m;a=K[l+107|0];m=a<<24>>24<0;p=m?J[l+96>>2]:n;m=m?J[l+100>>2]:a;n=p+m|0;if((m|0)>48){continue}break}}J[l+184>>2]=J[l+104>>2];J[l+104>>2]=0;m=J[l+100>>2];a=J[l+96>>2];J[l+176>>2]=a;J[l+180>>2]=m;J[l+96>>2]=0;J[l+100>>2]=0;m=K[l+187|0];n=m<<24>>24;o=(n|0)<0;p=o?a:l+176|0;m=o?J[l+180>>2]:m;o=c-1|0;m=(m|0)<(o|0)?m:o;H[fb(b,p,m)+m|0]=0;La:{if((n|0)>=0){break La}$a(a);if(H[l+107|0]>=0){break La}$a(J[l+96>>2]);}a=J[J[l+12>>2]+84>>2];J[5996]=0;m=l+36|0;aa(115,m|0,a|0);a=J[5996];J[5996]=0;if((a|0)==1){break Ba}J[5996]=0;a=ba(99,m|0,0,5442)|0;m=J[5996];J[5996]=0;if((m|0)==1){break Aa}J[l+56>>2]=J[a+8>>2];m=J[a+4>>2];J[l+48>>2]=J[a>>2];J[l+52>>2]=m;J[a>>2]=0;J[a+4>>2]=0;J[a+8>>2]=0;J[5996]=0;m=_(97,l+48|0,5422)|0;n=J[5996];J[5996]=0;if((n|0)==1){break za}J[l+72>>2]=J[m+8>>2];n=J[m+4>>2];J[l+64>>2]=J[m>>2];J[l+68>>2]=n;J[m>>2]=0;J[m+4>>2]=0;J[m+8>>2]=0;J[5996]=0;n=l+248|0;Da(116,n|0,+u);o=J[5996];J[5996]=0;if((o|0)==1){break ya}J[5996]=0;p=n;n=K[l+259|0];o=n<<24>>24<0;n=ba(100,l- -64|0,(o?J[l+248>>2]:p)|0,(o?J[l+252>>2]:n)|0)|0;o=J[5996];J[5996]=0;if((o|0)==1){break xa}J[l+88>>2]=J[n+8>>2];o=J[n+4>>2];J[l+80>>2]=J[n>>2];J[l+84>>2]=o;J[n>>2]=0;J[n+4>>2]=0;J[n+8>>2]=0;J[5996]=0;o=_(97,l+80|0,5504)|0;p=J[5996];J[5996]=0;if((p|0)==1){break wa}J[l+136>>2]=J[o+8>>2];p=J[o+4>>2];J[l+128>>2]=J[o>>2];J[l+132>>2]=p;J[o>>2]=0;J[o+4>>2]=0;J[o+8>>2]=0;p=J[J[l+12>>2]+84>>2];J[5996]=0;r=l+192|0;Da(116,r|0,+(u+ +(p>>>0)));p=J[5996];J[5996]=0;if((p|0)==1){break va}J[5996]=0;t=r;p=K[l+203|0];r=p<<24>>24<0;p=ba(100,l+128|0,(r?J[l+192>>2]:t)|0,(r?J[l+196>>2]:p)|0)|0;r=J[5996];J[5996]=0;if((r|0)==1){break ua}J[l+168>>2]=J[p+8>>2];r=J[p+4>>2];J[l+160>>2]=J[p>>2];J[l+164>>2]=r;J[p>>2]=0;J[p+4>>2]=0;J[p+8>>2]=0;J[5996]=0;r=_(97,l+160|0,3567)|0;q=J[5996];J[5996]=0;if((q|0)==1){break ta}J[l+184>>2]=J[r+8>>2];q=J[r+4>>2];J[l+176>>2]=J[r>>2];J[l+180>>2]=q;J[r>>2]=0;J[r+4>>2]=0;J[r+8>>2]=0;if(H[l+203|0]<0){$a(J[l+192>>2]);}if(H[p+11|0]<0){$a(J[p>>2]);}if(H[o+11|0]<0){$a(J[o>>2]);}if(H[l+259|0]<0){$a(J[l+248>>2]);}if(H[n+11|0]<0){$a(J[n>>2]);}if(H[m+11|0]<0){$a(J[m>>2]);}if(H[a+11|0]<0){$a(J[a>>2]);}n=J[l+176>>2];a=K[l+187|0];o=a<<24>>24;m=(o|0)<0;p=m?n:l+176|0;a=m?J[l+180>>2]:a;m=e-1|0;a=(a|0)<(m|0)?a:m;H[fb(d,p,a)+a|0]=0;J[5996]=0;m=l+248|0;aa(117,m|0,J[l+12>>2]);a=J[5996];J[5996]=0;if((a|0)==1){break la}J[l+220>>2]=J[l+276>>2];a=J[l+272>>2];J[l+212>>2]=J[l+268>>2];J[l+216>>2]=a;a=J[l+264>>2];J[l+204>>2]=J[l+260>>2];J[l+208>>2]=a;a=J[l+256>>2];J[l+196>>2]=J[l+252>>2];J[l+200>>2]=a;a=J[l+248>>2];J[l+192>>2]=a;J[5996]=0;p=a>>>0<29;r=p?l+196|0:J[l+200>>2];J[l+248>>2]=r;q=l+24|0;ga(102,q|0,m|0,r+(p?a:a-29|0)|0,0);a=J[5996];J[5996]=0;if((a|0)==1){break ka}a=J[l+24>>2];m=K[l+35|0];p=m<<24>>24;r=(p|0)<0;t=r?a:q;m=r?J[l+28>>2]:m;r=g-1|0;m=(m|0)<(r|0)?m:r;H[fb(f,t,m)+m|0]=0;if((p|0)<0){$a(a);}if(M[l+192>>2]>=29){$a(J[l+200>>2]);}a=J[l+12>>2];m=J[a+80>>2];if(!m|M[a+84>>2]>3600|(J[a+52>>2]+J[a+44>>2]>>>0>201|M[a+68>>2]>100)){break ja}J[5996]=0;p=_(54,2049,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break Q}if((m^-1)&p){break ja}m=J[a+80>>2];J[5996]=0;p=_(54,2165,1)|0;r=J[5996];J[5996]=0;if((r|0)==1){break Q}if(K[a+88|0]|(m^-1)&p){break ja}H[l+252|0]=0;J[l+248>>2]=1702195828;H[l+259|0]=4;a=((k|0)>=5?5:k)-1|0;H[fb(j,l+248|0,a)+a|0]=0;break ia}m=fa(22864)|0;break Ca}m=fa(22864)|0;break Ca}m=fa(22864)|0;break Ca}m=fa(22864)|0;}a=Va;if(H[l+107|0]>=0){break n}$a(J[l+96>>2]);break n}m=fa(22864)|0;a=Va;break n}m=fa(22864)|0;a=Va;break ma}m=fa(22864)|0;a=Va;break na}m=fa(22864)|0;a=Va;break oa}m=fa(22864)|0;a=Va;break pa}m=fa(22864)|0;a=Va;break qa}m=fa(22864)|0;a=Va;break ra}m=fa(22864)|0;a=Va;break sa}m=fa(22864)|0;a=Va;if(H[l+171|0]>=0){break sa}$a(J[l+160>>2]);}if(H[l+203|0]>=0){break ra}$a(J[l+192>>2]);}if(H[l+139|0]>=0){break qa}$a(J[l+128>>2]);}if(H[l+91|0]>=0){break pa}$a(J[l+80>>2]);}if(H[l+259|0]>=0){break oa}$a(J[l+248>>2]);}if(H[l+75|0]>=0){break na}$a(J[l+64>>2]);}if(H[l+59|0]>=0){break ma}$a(J[l+48>>2]);}if(H[l+47|0]>=0){break n}$a(J[l+36>>2]);break n}m=fa(22864)|0;break P}m=fa(22864)|0;a=Va;if(M[l+192>>2]<29){break O}$a(J[l+200>>2]);break O}H[l+252|0]=K[2354];H[l+259|0]=5;H[l+253|0]=0;J[l+248>>2]=K[2350]|K[2351]<<8|(K[2352]<<16|K[2353]<<24);a=((k|0)>=6?6:k)-1|0;H[fb(j,l+248|0,a)+a|0]=0;}J[5996]=0;a=$(118,J[l+12>>2])|0;j=J[5996];J[5996]=0;if((j|0)==1){break Q}Ma:{if(a){H[l+252|0]=0;J[l+248>>2]=1702195828;H[l+259|0]=4;a=((i|0)>=5?5:i)-1|0;H[fb(h,l+248|0,a)+a|0]=0;break Ma}H[l+252|0]=K[2354];H[l+259|0]=5;H[l+253|0]=0;J[l+248>>2]=K[2350]|K[2351]<<8|(K[2352]<<16|K[2353]<<24);a=((i|0)>=6?6:i)-1|0;H[fb(h,l+248|0,a)+a|0]=0;}if((o|0)>=0){break R}$a(n);}a=J[l+16>>2];Na:{if(!a){break Na}b=J[a+4>>2];J[a+4>>2]=b-1;if(b){break Na}Xa[J[J[a>>2]+8>>2]](a);bb(a);}if(H[l+155|0]>=0){break k}$a(J[l+144>>2]);break k}m=fa(22864)|0;}a=Va;}if((o|0)>=0){break n}$a(n);break n}m=fa(22864)|0;}a=Va;}rb(l+192|0);if(!p){break n}$a(p);break n}m=fa(22864)|0;a=Va;rb(l+192|0);}mb(l+12|0);}if(H[l+155|0]>=0){break l}$a(J[l+144>>2]);}if((wa(22864)|0)!=(a|0)){break c}a=pa(m|0)|0;a=Xa[J[J[a>>2]+8>>2]](a)|0;J[5996]=0;i=_(30,l+24|0,a|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break j}J[5996]=0;a=ba(99,i|0,0,5474)|0;h=J[5996];J[5996]=0;if((h|0)==1){break i}J[l+152>>2]=J[a+8>>2];h=J[a+4>>2];J[l+144>>2]=J[a>>2];J[l+148>>2]=h;J[a>>2]=0;J[a+4>>2]=0;J[a+8>>2]=0;J[5996]=0;h=_(97,l+144|0,2611)|0;j=J[5996];J[5996]=0;if((j|0)==1){break h}J[l+184>>2]=J[h+8>>2];i=J[h+4>>2];J[l+176>>2]=J[h>>2];J[l+180>>2]=i;J[h>>2]=0;J[h+4>>2]=0;J[h+8>>2]=0;m=b;b=J[l+176>>2];i=K[l+187|0];j=i<<24>>24;k=(j|0)<0;i=k?J[l+180>>2]:i;c=c-1|0;c=(c|0)>(i|0)?i:c;H[fb(m,k?b:l+176|0,c)+c|0]=0;Oa:{if((j|0)>=0){break Oa}$a(b);if(H[h+11|0]>=0){break Oa}$a(J[h>>2]);}if(H[a+11|0]<0){$a(J[a>>2]);}J[5996]=0;a=_(30,l+176|0,5575)|0;b=J[5996];J[5996]=0;if((b|0)==1){break f}i=d;b=J[a>>2];c=K[a+11|0];d=c<<24>>24;h=(d|0)<0;j=h?b:a;a=h?J[a+4>>2]:c;c=e-1|0;a=(a|0)<(c|0)?a:c;H[fb(i,j,a)+a|0]=0;if((d|0)<0){$a(b);}J[5996]=0;a=_(30,l+12|0,5575)|0;b=J[5996];J[5996]=0;if((b|0)==1){break e}b=J[a>>2];c=K[a+11|0];d=c<<24>>24;e=(d|0)<0;h=e?b:a;a=e?J[a+4>>2]:c;c=g-1|0;a=(a|0)<(c|0)?a:c;H[fb(f,h,a)+a|0]=0;if((d|0)<0){$a(b);}ra();}Ua=l+304|0;return}m=Z()|0;break d}m=Z()|0;break g}m=Z()|0;if(H[l+155|0]>=0){break g}$a(J[l+144>>2]);}if(H[i+11|0]>=0){break d}$a(J[i>>2]);break d}m=Z()|0;break d}m=Z()|0;}J[5996]=0;ca(110);a=J[5996];J[5996]=0;if((a|0)==1){break b}}da(m|0);B();}fa(0)|0;Vb();B();}B();}function _g(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;f=Ua-144|0;Ua=f;l=O[b+24>>3];m=O[b+16>>3];a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{x:{y:{z:{A:{B:{e=J[a>>2];switch(e|0){case 9:break j;case 8:break k;case 2:break l;case 3:break m;case 14:break n;case 15:break o;case 16:break p;case 19:break q;case 18:break r;case 17:break s;case 10:break t;case 11:break u;case 12:break v;case 13:break w;case 0:break x;case 4:case 5:break y;case 1:break z;case 21:break A;case 20:break B;case 6:break h;case 7:break i;default:break g}}d=J[a+4>>2];a=J[a+8>>2];if((d|0)==(a|0)){break g}while(1){_g(J[d>>2],b,c);d=d+4|0;if((a|0)!=(d|0)){continue}break}break g}a=$g(a,m,l,c);d=J[a>>2];c=J[a+4>>2];if((d|0)==(c|0)){break g}while(1){J[f+56>>2]=J[d>>2];a=J[d+4>>2];J[f+60>>2]=a;if(a){J[a+4>>2]=J[a+4>>2]+1;}a=J[f+60>>2];J[f>>2]=J[f+56>>2];J[f+4>>2]=a;Zg(b,d+8|0,f);d=d+32|0;if((c|0)!=(d|0)){continue}break}break g}hc(b,c,1,a+4|0,0,0);break g}n=(e|0)==4?4:5;Yc(f+56|0,n,m,l,0,0);J[5996]=0;d=$(46,n|0)|0;e=J[5996];J[5996]=0;if((e|0)==1){break f}J[f+88>>2]=0;J[f+80>>2]=0;J[f+84>>2]=0;H[f+136|0]=0;J[f+132>>2]=f+80;e=J[d+4>>2];h=J[d>>2];k=e-h|0;g=(k|0)/12|0;if((e|0)!=(h|0)){C:{D:{E:{if(g>>>0>=357913942){J[5996]=0;ca(47);a=J[5996];J[5996]=0;if((a|0)==1){break E}break d}J[5996]=0;e=$(3,k|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break E}J[f+84>>2]=e;J[f+80>>2]=e;J[f+88>>2]=e+P(g,12);g=J[d+4>>2];d=J[d>>2];J[5996]=0;d=ia(48,f+88|0,d|0,g|0,e|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){break C}d=Z()|0;J[f+84>>2]=e;break D}d=Z()|0;}Nc(f+132|0);break c}J[f+84>>2]=d;}J[f+140>>2]=0;J[f+132>>2]=0;J[f+136>>2]=0;e=J[a+8>>2];d=J[a+4>>2];J[5996]=0;aa(49,f+132|0,e-d>>2);e=J[5996];J[5996]=0;if((e|0)!=1){d=J[f+84>>2];e=J[f+80>>2];if((d|0)!=(e|0)){u=a+40|0;d=e;while(1){J[f+128>>2]=0;J[f+120>>2]=0;J[f+124>>2]=0;F:{G:{H:{I:{g=J[a+8>>2];e=J[a+4>>2];q=P(s,12);d=q+d|0;if(g-e>>2==J[d+4>>2]-J[d>>2]>>3){h=0;o=1;j=0;if((e|0)!=(g|0)){break I}break H}J[5996]=0;ga(44,5170,1900,642,2497);a=J[5996];J[5996]=0;if((a|0)!=1){break d}d=Z()|0;break G}J:{K:{while(1){L:{d=j<<3;l=O[d+J[f+68>>2]>>3];m=O[d+J[f+56>>2]>>3];e=J[(j<<2)+e>>2];J[5996]=0;e=qa(50,e|0,+m,+l,c|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break L}d=d+J[q+J[f+80>>2]>>2]|0;g=J[d>>2];d=J[d+4>>2];k=J[e+4>>2];e=J[e>>2];J[5996]=0;oa(51,f+100|0,e|0,k|0,g|0,d|0);e=J[5996];J[5996]=0;if((e|0)==1){break K}g=J[f+128>>2];M:{if(g>>>0>h>>>0){J[h+8>>2]=0;J[h>>2]=0;J[h+4>>2]=0;J[h>>2]=J[f+100>>2];J[h+4>>2]=J[f+104>>2];J[h+8>>2]=J[f+108>>2];J[f+124>>2]=h+12;break M}N:{e=J[f+120>>2];k=(h-e|0)/12|0;d=k+1|0;O:{if(d>>>0>=357913942){J[5996]=0;ca(52);break O}g=(g-e|0)/12|0;i=g<<1;d=g>>>0>=178956970?357913941:d>>>0<i>>>0?i:d;if(d>>>0<357913942){break N}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break d}break J}J[5996]=0;i=P(d,12);g=$(3,i|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break J}d=g+P(k,12)|0;J[d>>2]=J[f+100>>2];J[d+4>>2]=J[f+104>>2];J[d+8>>2]=J[f+108>>2];J[f+108>>2]=0;J[f+100>>2]=0;J[f+104>>2]=0;g=g+i|0;k=d+12|0;P:{if((e|0)==(h|0)){J[f+128>>2]=g;J[f+124>>2]=k;J[f+120>>2]=d;break P}while(1){d=d-12|0;h=h-12|0;J[d>>2]=J[h>>2];J[d+4>>2]=J[h+4>>2];J[d+8>>2]=J[h+8>>2];J[h+8>>2]=0;J[h>>2]=0;J[h+4>>2]=0;if((e|0)!=(h|0)){continue}break}J[f+128>>2]=g;e=J[f+124>>2];J[f+124>>2]=k;h=J[f+120>>2];J[f+120>>2]=d;if((e|0)==(h|0)){break P}while(1){i=e-12|0;k=J[i>>2];if(k){r=e-8|0;d=J[r>>2];g=k;if((d|0)!=(g|0)){while(1){d=d-32|0;e=J[d+4>>2];Q:{if(!e){break Q}g=J[e+4>>2];J[e+4>>2]=g-1;if(g){break Q}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((d|0)!=(k|0)){continue}break}g=J[i>>2];}J[r>>2]=k;$a(g);}e=i;if((h|0)!=(e|0)){continue}break}}if(h){$a(h);}g=J[f+100>>2];if(!g){break M}e=g;d=J[f+104>>2];if((e|0)!=(d|0)){while(1){d=d-32|0;e=J[d+4>>2];R:{if(!e){break R}h=J[e+4>>2];J[e+4>>2]=h-1;if(h){break R}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((d|0)!=(g|0)){continue}break}e=J[f+100>>2];}J[f+104>>2]=g;$a(e);}h=J[f+124>>2];e=h-12|0;o=P(J[e+4>>2]-J[e>>2]>>5,o);j=j+1|0;e=J[a+4>>2];if(j>>>0<J[a+8>>2]-e>>2>>>0){continue}break H}break}d=Z()|0;break G}d=Z()|0;break G}d=Z()|0;_b(f+100|0);break G}h=0;k=J[f+132>>2];while(1){if((h|0)==(o|0)){break F}if(J[a+8>>2]!=J[a+4>>2]){d=0;g=J[f+120>>2];e=h;while(1){i=P(d,12);j=i+g|0;g=J[j>>2];J[k+(d<<2)>>2]=g+((e>>>0)%(J[j+4>>2]-g>>5>>>0)<<5);j=e;g=J[f+120>>2];e=i+g|0;e=(j>>>0)/(J[e+4>>2]-J[e>>2]>>5>>>0)|0;d=d+1|0;if(d>>>0<J[a+8>>2]-J[a+4>>2]>>2>>>0){continue}break}}J[5996]=0;Ea(53,b|0,n|0,f+132|0,0,u|0);e=J[5996];J[5996]=0;h=h+1|0;if((e|0)!=1){continue}break}d=Z()|0;}Xc(f+120|0);break e}g=J[f+120>>2];if(g){d=J[f+124>>2];if((g|0)!=(d|0)){while(1){k=d-12|0;h=J[k>>2];if(h){e=h;i=d-8|0;d=J[i>>2];if((e|0)!=(d|0)){while(1){d=d-32|0;e=J[d+4>>2];S:{if(!e){break S}j=J[e+4>>2];J[e+4>>2]=j-1;if(j){break S}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((d|0)!=(h|0)){continue}break}e=J[k>>2];}J[i>>2]=h;$a(e);}d=k;if((g|0)!=(d|0)){continue}break}g=J[f+120>>2];}$a(g);}s=s+1|0;d=J[f+80>>2];if(s>>>0<(J[f+84>>2]-d|0)/12>>>0){continue}break}}a=J[f+132>>2];if(a){$a(a);d=J[f+80>>2];}if(d){e=d;g=J[f+84>>2];if((e|0)!=(g|0)){while(1){a=g-12|0;b=J[a>>2];if(b){J[g-8>>2]=b;$a(b);}g=a;if((a|0)!=(d|0)){continue}break}e=J[f+80>>2];}J[f+84>>2]=d;$a(e);}a=J[f+68>>2];if(a){J[f+72>>2]=a;$a(a);}a=J[f+56>>2];if(!a){break g}J[f+60>>2]=a;$a(a);break g}d=Z()|0;break e}hc(b,c,0,a+4|0,0,0);break g}Yc(f+56|0,24,m,l,O[a+48>>3],J[a+8>>2]-J[a+4>>2]>>2);J[f+88>>2]=0;J[f+80>>2]=0;J[f+84>>2]=0;J[f+140>>2]=0;J[f+132>>2]=0;J[f+136>>2]=0;T:{U:{V:{W:{X:{Y:{Z:{_:{$:{g=J[a+4>>2];aa:{if((g|0)==J[a+8>>2]){k=-1;e=g;d=0;break aa}l=-1;e=g;k=-1;ba:{while(1){d=h<<3;m=O[d+J[f+68>>2]>>3];p=O[d+J[f+56>>2]>>3];e=J[(h<<2)+e>>2];J[5996]=0;e=qa(50,e|0,+p,+m,c|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break $}J[5996]=0;d=_(54,1283,5)|0;g=J[5996];J[5996]=0;ca:{da:{ea:{fa:{ga:{if((g|0)==1){break ga}g=J[e>>2];i=J[e+4>>2];J[5996]=0;oa(51,f+120|0,g|0,i|0,d|0,0);d=J[5996];J[5996]=0;if((d|0)==1){break ga}i=1;g=J[f+120>>2];switch(J[f+124>>2]-g>>5){case 0:break da;case 1:break ea;default:break fa}}d=Z()|0;break T}J[5996]=0;ga(44,4164,1900,807,2386);a=J[5996];J[5996]=0;if((a|0)!=1){break d}d=Z()|0;break U}J[5996]=0;aa(55,f+80|0,g|0);d=J[5996];J[5996]=0;if((d|0)==1){break _}J[5996]=0;d=_(54,1277,5)|0;g=J[5996];J[5996]=0;if((g|0)==1){break ca}g=J[e>>2];e=J[e+4>>2];J[5996]=0;oa(51,f+100|0,g|0,e|0,d|0,0);e=J[5996];J[5996]=0;if((e|0)==1){break ca}ha:{ia:{ja:{e=J[f+100>>2];switch(J[f+104>>2]-e>>5){case 0:break ha;case 1:break ia;default:break ja}}J[5996]=0;ga(44,4146,1900,811,2386);a=J[5996];J[5996]=0;if((a|0)!=1){break d}break V}J[5996]=0;aa(55,f+132|0,e|0);e=J[5996];J[5996]=0;if((e|0)==1){break V}i=0;m=O[J[f+136>>2]-8>>3]-O[J[f+84>>2]-8>>3];if(!(m>l)){break ha}k=h;l=m;}g=J[f+100>>2];if(g){e=g;d=J[f+104>>2];if((e|0)!=(d|0)){while(1){d=d-32|0;e=J[d+4>>2];ka:{if(!e){break ka}j=J[e+4>>2];J[e+4>>2]=j-1;if(j){break ka}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((d|0)!=(g|0)){continue}break}e=J[f+100>>2];}J[f+104>>2]=g;$a(e);}g=J[f+120>>2];}if(g){e=g;d=J[f+124>>2];if((e|0)!=(d|0)){while(1){d=d-32|0;e=J[d+4>>2];la:{if(!e){break la}j=J[e+4>>2];J[e+4>>2]=j-1;if(j){break la}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((d|0)!=(g|0)){continue}break}e=J[f+120>>2];}J[f+124>>2]=g;$a(e);}if(i){break W}h=h+1|0;g=J[a+8>>2];e=J[a+4>>2];if(h>>>0>=g-e>>2>>>0){break ba}continue}break}d=Z()|0;break U}d=J[f+80>>2];}J[5996]=0;c=$(3,4)|0;h=J[5996];J[5996]=0;if((h|0)==1){break Z}J[c>>2]=d+(k<<5);d=c+4|0;J[f+128>>2]=d;J[f+124>>2]=d;J[f+120>>2]=c;if((e|0)!=(g|0)){h=0;while(1){ma:{if((h|0)==(k|0)){break ma}c=J[f+132>>2]+(h<<5)|0;i=J[f+128>>2];if(i>>>0>d>>>0){J[d>>2]=c;d=d+4|0;J[f+124>>2]=d;break ma}na:{oa:{g=J[f+120>>2];o=d-g>>2;e=o+1|0;pa:{if(e>>>0>=1073741824){J[5996]=0;ca(56);break pa}i=i-g|0;j=i>>1;i=i>>>0>=2147483644?1073741823:e>>>0<j>>>0?j:e;if(!i){j=0;break na}if(i>>>0<1073741824){break oa}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break d}d=Z()|0;break X}J[5996]=0;j=$(3,i<<2)|0;e=J[5996];J[5996]=0;if((e|0)==1){break Y}}e=(o<<2)+j|0;J[e>>2]=c;c=e+4|0;if((d|0)!=(g|0)){while(1){e=e-4|0;d=d-4|0;J[e>>2]=J[d>>2];if((d|0)!=(g|0)){continue}break}d=J[f+120>>2];}J[f+128>>2]=(i<<2)+j;J[f+124>>2]=c;J[f+120>>2]=e;if(d){$a(d);}d=c;}h=h+1|0;if(h>>>0<J[a+8>>2]-J[a+4>>2]>>2>>>0){continue}break}}l=O[a+48>>3];J[5996]=0;Ea(53,b|0,24,f+120|0,+l,a+40|0);a=J[5996];J[5996]=0;if((a|0)!=1){a=J[f+120>>2];if(!a){break W}$a(a);break W}d=Z()|0;g=J[f+120>>2];break X}d=Z()|0;break T}d=Z()|0;break U}d=Z()|0;break T}d=Z()|0;}if(!g){break T}$a(g);break T}a=J[f+132>>2];if(a){d=J[f+136>>2];if((a|0)!=(d|0)){while(1){d=d-32|0;b=J[d+4>>2];qa:{if(!b){break qa}c=J[b+4>>2];J[b+4>>2]=c-1;if(c){break qa}Xa[J[J[b>>2]+8>>2]](b);bb(b);}if((a|0)!=(d|0)){continue}break}a=J[f+132>>2];}$a(a);}a=J[f+80>>2];if(a){d=J[f+84>>2];if((a|0)!=(d|0)){while(1){d=d-32|0;b=J[d+4>>2];ra:{if(!b){break ra}c=J[b+4>>2];J[b+4>>2]=c-1;if(c){break ra}Xa[J[J[b>>2]+8>>2]](b);bb(b);}if((a|0)!=(d|0)){continue}break}a=J[f+80>>2];}$a(a);}a=J[f+68>>2];if(a){J[f+72>>2]=a;$a(a);}a=J[f+56>>2];if(!a){break g}J[f+60>>2]=a;$a(a);break g}d=Z()|0;_b(f+100|0);}_b(f+120|0);}_b(f+132|0);_b(f+80|0);break c}e=J[a+4>>2];d=J[e+4>>2];g=J[e>>2];h=J[e+8>>2];e=cb(12);J[f+56>>2]=e;k=e+12|0;J[f+64>>2]=k;J[e+8>>2]=h;J[e+4>>2]=g;J[e>>2]=d;J[f+60>>2]=k;l=O[a+48>>3];J[5996]=0;ja(57,b|0,c|0,23,a+4|0,+l,0);a=J[5996];J[5996]=0;sa:{if((a|0)==1){break sa}J[5996]=0;ja(57,b|0,c|0,23,f+56|0,+l,0);a=J[5996];J[5996]=0;if((a|0)==1){break sa}$a(e);break g}break a}e=J[a+4>>2];d=J[e>>2];g=J[e+4>>2];e=cb(8);J[f+56>>2]=e;h=e+8|0;J[f+64>>2]=h;J[e>>2]=go(d,g,32);J[e+4>>2]=Wa;J[f+60>>2]=h;d=a+4|0;m=O[a+48>>3];p=1-m;ta:{if(l==0){J[5996]=0;ja(57,b|0,c|0,20,d|0,+m,0);a=J[5996];J[5996]=0;if((a|0)==1){break ta}J[5996]=0;ja(57,b|0,c|0,20,f+56|0,+p,0);a=J[5996];J[5996]=0;if((a|0)==1){break ta}}J[5996]=0;ja(57,b|0,c|0,19,d|0,+m,0);a=J[5996];J[5996]=0;if((a|0)==1){break ta}J[5996]=0;a=f+56|0;ja(57,b|0,c|0,19,a|0,+p,0);g=J[5996];J[5996]=0;if((g|0)==1){break ta}J[5996]=0;ja(57,b|0,c|0,21,d|0,+m,0);g=J[5996];J[5996]=0;if((g|0)==1){break ta}J[5996]=0;ja(57,b|0,c|0,21,a|0,+p,0);g=J[5996];J[5996]=0;if((g|0)==1){break ta}J[5996]=0;ja(57,b|0,c|0,22,d|0,+m,0);g=J[5996];J[5996]=0;if((g|0)==1){break ta}J[5996]=0;ja(57,b|0,c|0,22,a|0,+p,0);g=J[5996];J[5996]=0;if((g|0)==1){break ta}J[5996]=0;ja(57,b|0,c|0,22,d|0,+m,1);d=J[5996];J[5996]=0;if((d|0)==1){break ta}J[5996]=0;ja(57,b|0,c|0,22,a|0,+p,1);a=J[5996];J[5996]=0;if((a|0)==1){break ta}$a(e);break g}break a}e=J[a+4>>2];d=J[e>>2];g=J[e+4>>2];e=cb(8);J[f+56>>2]=e;h=e+8|0;J[f+64>>2]=h;J[e>>2]=go(d,g,32);J[e+4>>2]=Wa;J[f+60>>2]=h;a=a+4|0;ua:{if(l==0){J[5996]=0;ja(57,b|0,c|0,17,a|0,0,0);d=J[5996];J[5996]=0;if((d|0)==1){break ua}J[5996]=0;ja(57,b|0,c|0,17,f+56|0,0,0);d=J[5996];J[5996]=0;if((d|0)==1){break ua}}J[5996]=0;ja(57,b|0,c|0,18,a|0,0,0);a=J[5996];J[5996]=0;if((a|0)==1){break ua}J[5996]=0;ja(57,b|0,c|0,18,f+56|0,0,0);a=J[5996];J[5996]=0;if((a|0)==1){break ua}$a(e);break g}break a}hc(b,c,14,a+4|0,0,0);break g}hc(b,c,15,a+4|0,0,0);break g}hc(b,c,16,a+4|0,0,0);break g}hc(b,c,13,a+4|0,0,0);break g}hc(b,c,12,a+4|0,0,0);break g}a=a+4|0;hc(b,c,10,a,0,0);hc(b,c,11,a,0,0);break g}e=J[a+40>>2];k=J[a+44>>2];if(!K[24588]){J[6145]=0;J[6146]=0;J[6143]=0;J[6144]=0;J[6141]=0;J[6142]=0;H[24588]=1;}n=Yg(f+56|0);J[5996]=0;d=$(46,25)|0;g=J[5996];J[5996]=0;va:{wa:{if((g|0)!=1){J[f+52>>2]=0;J[f+44>>2]=0;J[f+48>>2]=0;H[f+84|0]=0;J[f+80>>2]=f+44;g=J[d+4>>2];i=J[d>>2];j=g-i|0;h=(j|0)/12|0;if((g|0)!=(i|0)){if(h>>>0>=357913942){J[5996]=0;ca(47);a=J[5996];J[5996]=0;if((a|0)!=1){break d}break wa}J[5996]=0;g=$(3,j|0)|0;i=J[5996];J[5996]=0;if((i|0)==1){break wa}J[f+48>>2]=g;J[f+44>>2]=g;J[f+52>>2]=g+P(h,12);h=J[d+4>>2];d=J[d>>2];J[5996]=0;d=ia(48,f+52|0,d|0,h|0,g|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){d=Z()|0;J[f+48>>2]=g;break va}J[f+48>>2]=d;}J[f+40>>2]=0;J[f+32>>2]=0;J[f+36>>2]=0;d=J[a+8>>2];g=J[a+4>>2];J[5996]=0;aa(49,f+32|0,d-g>>2);d=J[5996];J[5996]=0;xa:{if((d|0)!=1){ya:{za:{d=J[f+48>>2];g=J[f+44>>2];if((d|0)!=(g|0)){u=a+16|0;l=+(e>>>0)+ +(k|0)*4294967296;m=l+1;l=l*73+1;d=g;while(1){J[f+28>>2]=0;J[f+20>>2]=0;J[f+24>>2]=0;g=J[a+8>>2];e=J[a+4>>2];q=P(s,12);d=q+d|0;if(g-e>>2!=J[d+4>>2]-J[d>>2]>>3){break za}h=0;o=1;j=0;Aa:{if((e|0)!=(g|0)){Ba:{Ca:{Da:{while(1){d=j<<3;p=O[d+J[n+12>>2]>>3];v=O[d+J[n>>2]>>3];e=J[(j<<2)+e>>2];J[5996]=0;e=qa(50,e|0,+v,+p,c|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break Ca}d=d+J[q+J[f+44>>2]>>2]|0;g=J[d>>2];d=J[d+4>>2];k=J[e+4>>2];e=J[e>>2];J[5996]=0;oa(51,f+80|0,e|0,k|0,g|0,d|0);e=J[5996];J[5996]=0;if((e|0)!=1){g=J[f+28>>2];Ea:{if(g>>>0>h>>>0){J[h+8>>2]=0;J[h>>2]=0;J[h+4>>2]=0;J[h>>2]=J[f+80>>2];J[h+4>>2]=J[f+84>>2];J[h+8>>2]=J[f+88>>2];J[f+24>>2]=h+12;break Ea}Fa:{e=J[f+20>>2];k=(h-e|0)/12|0;d=k+1|0;Ga:{if(d>>>0>=357913942){J[5996]=0;ca(52);break Ga}g=(g-e|0)/12|0;i=g<<1;d=g>>>0>=178956970?357913941:d>>>0<i>>>0?i:d;if(d>>>0<357913942){break Fa}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break d}break Da}J[5996]=0;i=P(d,12);g=$(3,i|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break Da}d=g+P(k,12)|0;J[d>>2]=J[f+80>>2];J[d+4>>2]=J[f+84>>2];J[d+8>>2]=J[f+88>>2];J[f+88>>2]=0;J[f+80>>2]=0;J[f+84>>2]=0;g=g+i|0;k=d+12|0;Ha:{if((e|0)==(h|0)){J[f+28>>2]=g;J[f+24>>2]=k;J[f+20>>2]=d;break Ha}while(1){d=d-12|0;h=h-12|0;J[d>>2]=J[h>>2];J[d+4>>2]=J[h+4>>2];J[d+8>>2]=J[h+8>>2];J[h+8>>2]=0;J[h>>2]=0;J[h+4>>2]=0;if((e|0)!=(h|0)){continue}break}J[f+28>>2]=g;e=J[f+24>>2];J[f+24>>2]=k;h=J[f+20>>2];J[f+20>>2]=d;if((e|0)==(h|0)){break Ha}while(1){i=e-12|0;k=J[i>>2];if(k){r=e-8|0;d=J[r>>2];g=k;if((d|0)!=(g|0)){while(1){d=d-32|0;e=J[d+4>>2];Ia:{if(!e){break Ia}g=J[e+4>>2];J[e+4>>2]=g-1;if(g){break Ia}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((d|0)!=(k|0)){continue}break}g=J[i>>2];}J[r>>2]=k;$a(g);}e=i;if((h|0)!=(e|0)){continue}break}}if(h){$a(h);}g=J[f+80>>2];if(!g){break Ea}e=g;d=J[f+84>>2];if((e|0)!=(d|0)){while(1){d=d-32|0;e=J[d+4>>2];Ja:{if(!e){break Ja}h=J[e+4>>2];J[e+4>>2]=h-1;if(h){break Ja}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((d|0)!=(g|0)){continue}break}e=J[f+80>>2];}J[f+84>>2]=g;$a(e);}h=J[f+24>>2];e=h-12|0;o=P(J[e+4>>2]-J[e>>2]>>5,o);j=j+1|0;e=J[a+4>>2];if(j>>>0>=J[a+8>>2]-e>>2>>>0){break Ba}continue}break}d=Z()|0;break ya}d=Z()|0;_b(f+80|0);break ya}d=Z()|0;break ya}if(!o){break Aa}}k=0;Ka:{La:{Ma:{Na:{while(1){h=J[f+32>>2];if(J[a+8>>2]!=J[a+4>>2]){d=0;g=J[f+20>>2];e=k;while(1){i=P(d,12);j=i+g|0;g=J[j>>2];J[(d<<2)+h>>2]=g+((e>>>0)%(J[j+4>>2]-g>>5>>>0)<<5);j=e;g=J[f+20>>2];e=i+g|0;e=(j>>>0)/(J[e+4>>2]-J[e>>2]>>5>>>0)|0;d=d+1|0;if(d>>>0<J[a+8>>2]-J[a+4>>2]>>2>>>0){continue}break}}J[f+108>>2]=0;J[f+100>>2]=0;J[f+104>>2]=0;Oa:{Pa:{q=J[f+36>>2];if((q|0)!=(h|0)){while(1){i=J[h>>2];d=J[f+104>>2];Qa:{if((d|0)!=J[f+108>>2]){J[d>>2]=J[i>>2];e=J[i+4>>2];J[d+4>>2]=e;if(e){J[e+4>>2]=J[e+4>>2]+1;}J[f+104>>2]=d+8;break Qa}Ra:{g=J[f+100>>2];e=d-g|0;r=e>>3;j=r+1|0;Sa:{if(j>>>0>=536870912){J[5996]=0;ca(59);break Sa}t=e>>2;e=e>>>0>=2147483640?536870911:j>>>0<t>>>0?t:j;if(e>>>0<536870912){break Ra}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break d}d=Z()|0;break Ka}J[5996]=0;t=e<<3;j=$(3,t|0)|0;e=J[5996];J[5996]=0;if((e|0)==1){break Pa}e=j+(r<<3)|0;J[e>>2]=J[i>>2];i=J[i+4>>2];J[e+4>>2]=i;if(i){J[i+4>>2]=J[i+4>>2]+1;d=J[f+104>>2];}i=j+t|0;j=e+8|0;Ta:{if((d|0)==(g|0)){J[f+108>>2]=i;J[f+104>>2]=j;J[f+100>>2]=e;break Ta}while(1){e=e-8|0;d=d-8|0;J[e>>2]=J[d>>2];J[e+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;if((d|0)!=(g|0)){continue}break}J[f+108>>2]=i;d=J[f+104>>2];J[f+104>>2]=j;g=J[f+100>>2];J[f+100>>2]=e;if((d|0)==(g|0)){break Ta}while(1){d=d-8|0;e=J[d+4>>2];Ua:{if(!e){break Ua}i=J[e+4>>2];J[e+4>>2]=i-1;if(i){break Ua}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((d|0)!=(g|0)){continue}break}}if(!g){break Qa}$a(g);}h=h+4|0;if((q|0)!=(h|0)){continue}break}}O[f+88>>3]=m;O[f+80>>3]=l;J[5996]=0;h=$(3,104)|0;e=J[5996];J[5996]=0;if((e|0)!=1){break Oa}break La}d=Z()|0;break Ka}J[h>>2]=7e3;J[h+4>>2]=0;J[h+8>>2]=0;J[5996]=0;J[f+132>>2]=J[f+100>>2];e=J[f+104>>2];d=J[f+108>>2];J[f+108>>2]=0;J[f+136>>2]=e;J[f+140>>2]=d;J[f+100>>2]=0;J[f+104>>2]=0;i=_(32,f+120|0,u|0)|0;e=J[5996];J[5996]=0;if((e|0)!=1){e=J[a+40>>2];J[5996]=0;j=xa(60,h+12|0,25,f+132|0,i|0,e|0)|0;e=J[5996];J[5996]=0;if((e|0)==1){break Na}g=J[i>>2];if(g){e=J[f+124>>2];d=g;if((e|0)!=(d|0)){while(1){d=e-12|0;if(H[e-1|0]<0){$a(J[d>>2]);}e=d;if((e|0)!=(g|0)){continue}break}d=J[i>>2];}J[f+124>>2]=g;$a(d);}e=J[f+132>>2];if(e){d=J[f+136>>2];if((e|0)!=(d|0)){while(1){d=d-8|0;g=J[d+4>>2];Va:{if(!g){break Va}i=J[g+4>>2];J[g+4>>2]=i-1;if(i){break Va}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((d|0)!=(e|0)){continue}break}e=J[f+132>>2];}$a(e);}J[f+116>>2]=h;J[f+112>>2]=j;J[5996]=0;e=J[f+116>>2];J[f+8>>2]=J[f+112>>2];J[f+12>>2]=e;ea(61,b|0,f+80|0,f+8|0);e=J[5996];J[5996]=0;if((e|0)==1){break La}e=J[f+100>>2];if(e){d=J[f+104>>2];if((e|0)!=(d|0)){while(1){d=d-8|0;g=J[d+4>>2];Wa:{if(!g){break Wa}h=J[g+4>>2];J[g+4>>2]=h-1;if(h){break Wa}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((d|0)!=(e|0)){continue}break}e=J[f+100>>2];}$a(e);}k=k+1|0;if((o|0)!=(k|0)){continue}break Aa}break}d=Z()|0;break Ma}d=Z()|0;rb(i);}lb(f+132|0);$a(h);break Ka}d=Z()|0;}lb(f+100|0);break ya}g=J[f+20>>2];if(g){d=J[f+24>>2];if((g|0)!=(d|0)){while(1){k=d-12|0;h=J[k>>2];if(h){e=h;i=d-8|0;d=J[i>>2];if((e|0)!=(d|0)){while(1){d=d-32|0;e=J[d+4>>2];Xa:{if(!e){break Xa}j=J[e+4>>2];J[e+4>>2]=j-1;if(j){break Xa}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((d|0)!=(h|0)){continue}break}e=J[k>>2];}J[i>>2]=h;$a(e);}d=k;if((g|0)!=(d|0)){continue}break}g=J[f+20>>2];}$a(g);}s=s+1|0;d=J[f+44>>2];if(s>>>0<(J[f+48>>2]-d|0)/12>>>0){continue}break}}a=J[f+32>>2];if(a){$a(a);d=J[f+44>>2];}if(d){e=d;g=J[f+48>>2];if((e|0)!=(g|0)){while(1){a=g-12|0;b=J[a>>2];if(b){J[g-8>>2]=b;$a(b);}g=a;if((a|0)!=(d|0)){continue}break}e=J[f+44>>2];}J[f+48>>2]=d;$a(e);}a=J[n+12>>2];if(a){J[n+16>>2]=a;$a(a);}a=J[n>>2];if(!a){break g}J[n+4>>2]=a;$a(a);break g}J[5996]=0;ga(44,5170,1900,642,2497);a=J[5996];J[5996]=0;if((a|0)!=1){break d}d=Z()|0;}Xc(f+20|0);break xa}d=Z()|0;}a=J[f+32>>2];if(a){$a(a);}Wc(f+44|0);break b}a=Z()|0;Mc(n);da(a|0);B();}d=Z()|0;}Nc(f+80|0);break b}e=a+4|0;a=a+16|0;Xg(b,c,2,e,a);Xg(b,c,3,e,a);break g}wd(b,c,6,a+4|0,a+28|0);break g}wd(b,c,8,a+4|0,a+28|0);break g}wd(b,c,7,a+4|0,a+28|0);break g}wd(b,c,9,a+4|0,a+28|0);}Ua=f+144|0;return}d=Z()|0;break c}a=J[f+132>>2];if(a){$a(a);}Wc(f+80|0);break c}B();}Mc(f+56|0);da(d|0);B();}Mc(n);da(d|0);B();}a=Z()|0;$a(e);da(a|0);B();}function ig(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,E=0,F=0,G=0;q=Ua-48|0;Ua=q;a:{if(c>>>0<=2){c=c<<2;A=J[c+8972>>2];B=J[c+8960>>2];while(1){c=J[b+4>>2];b:{if((c|0)!=J[b+104>>2]){J[b+4>>2]=c+1;c=K[c|0];break b}c=gb(b);}if((c|0)==32|c-9>>>0<5){continue}break}t=1;c:{d:{switch(c-43|0){case 0:case 2:break d;default:break c}}t=(c|0)==45?-1:1;c=J[b+4>>2];if((c|0)!=J[b+104>>2]){J[b+4>>2]=c+1;c=K[c|0];break c}c=gb(b);}e:{f:{while(1){if(H[g+1031|0]==(c|32)){g:{if(g>>>0>6){break g}c=J[b+4>>2];if((c|0)!=J[b+104>>2]){J[b+4>>2]=c+1;c=K[c|0];break g}c=gb(b);}g=g+1|0;if((g|0)!=8){continue}break f}break}if((g|0)!=3){m=(g|0)==8;if(m){break f}if(!d|g>>>0<4){break e}if(m){break f}}c=J[b+116>>2];if((c|0)>0|(c|0)>=0){J[b+4>>2]=J[b+4>>2]-1;}if(!d|g>>>0<4){break f}c=(c|0)<0;while(1){if(!c){J[b+4>>2]=J[b+4>>2]-1;}g=g-1|0;if(g>>>0>3){continue}break}}l=Ua-16|0;Ua=l;h=(D(Q(Q(t|0)*Q(Infinity))),v(2));b=h&2147483647;h:{if(b-8388608>>>0<=2130706431){c=b;b=b>>>7|0;c=c<<25;d=b+1065353216|0;break h}c=h<<25;d=h>>>7|2147418112;if(b>>>0>=2139095040){break h}c=0;d=0;if(!b){break h}c=b;b=S(b);Cb(l,c,0,0,0,b+81|0);j=J[l>>2];i=J[l+4>>2];c=J[l+8>>2];d=J[l+12>>2]^65536|16265-b<<16;}J[q>>2]=j;J[q+4>>2]=i;J[q+8>>2]=c;J[q+12>>2]=h&-2147483648|d;Ua=l+16|0;j=J[q+8>>2];i=J[q+12>>2];h=J[q>>2];k=J[q+4>>2];break a}i:{j:{k:{if(g){break k}g=0;while(1){if(H[g+2020|0]!=(c|32)){break k}l:{if(g>>>0>1){break l}c=J[b+4>>2];if((c|0)!=J[b+104>>2]){J[b+4>>2]=c+1;c=K[c|0];break l}c=gb(b);}g=g+1|0;if((g|0)!=3){continue}break}break j}m:{switch(g|0){case 0:n:{if((c|0)!=48){break n}g=J[b+4>>2];o:{if((g|0)!=J[b+104>>2]){J[b+4>>2]=g+1;g=K[g|0];break o}g=gb(b);}if((g&-33)==88){m=0;f=Ua-432|0;Ua=f;c=J[b+4>>2];p:{if((c|0)!=J[b+104>>2]){J[b+4>>2]=c+1;g=K[c|0];break p}g=gb(b);}q:{r:{while(1){if((g|0)!=48){s:{if((g|0)!=46){break q}c=J[b+4>>2];if((c|0)==J[b+104>>2]){break s}J[b+4>>2]=c+1;g=K[c|0];break r}}else {c=J[b+4>>2];if((c|0)!=J[b+104>>2]){e=1;J[b+4>>2]=c+1;g=K[c|0];}else {e=1;g=gb(b);}continue}break}g=gb(b);}p=1;if((g|0)!=48){break q}while(1){c=r;r=c-1|0;s=s-!c|0;c=J[b+4>>2];t:{if((c|0)!=J[b+104>>2]){J[b+4>>2]=c+1;g=K[c|0];break t}g=gb(b);}if((g|0)==48){continue}break}e=1;}k=1073676288;u:{while(1){v:{c=g|32;w:{x:{E=g-48|0;if(E>>>0<10){break x}F=(g|0)!=46;if(F&c-97>>>0>5){break u}if(F){break x}if(p){break v}p=1;r=j;s=i;break w}c=(g|0)>57?c-87|0:E;y:{if((i|0)<=0&j>>>0<=7|(i|0)<0){m=c+(m<<4)|0;break y}if(!i&j>>>0<=28){Nb(f+48|0,c);ob(f+32|0,y,z,h,k,0,0,0,1073414144);y=J[f+32>>2];z=J[f+36>>2];h=J[f+40>>2];k=J[f+44>>2];ob(f+16|0,J[f+48>>2],J[f+52>>2],J[f+56>>2],J[f+60>>2],y,z,h,k);Hb(f,J[f+16>>2],J[f+20>>2],J[f+24>>2],J[f+28>>2],l,o,w,x);w=J[f+8>>2];x=J[f+12>>2];l=J[f>>2];o=J[f+4>>2];break y}if(C|!c){break y}ob(f+80|0,y,z,h,k,0,0,0,1073610752);Hb(f- -64|0,J[f+80>>2],J[f+84>>2],J[f+88>>2],J[f+92>>2],l,o,w,x);w=J[f+72>>2];x=J[f+76>>2];C=1;l=J[f+64>>2];o=J[f+68>>2];}j=j+1|0;i=j?i:i+1|0;e=1;}c=J[b+4>>2];if((c|0)!=J[b+104>>2]){J[b+4>>2]=c+1;g=K[c|0];}else {g=gb(b);}continue}break}g=46;}z:{if(!e){c=J[b+116>>2];A:{B:{if((c|0)>0|(c|0)>=0){c=J[b+4>>2];J[b+4>>2]=c-1;if(!d){break B}J[b+4>>2]=c-2;if(!p){break A}J[b+4>>2]=c-3;break A}if(d){break A}}Yb(b,0,0);}fc(f+96|0,+(t|0)*0);l=J[f+96>>2];o=J[f+100>>2];c=J[f+108>>2];b=J[f+104>>2];break z}if((i|0)<=0&j>>>0<=7|(i|0)<0){h=j;k=i;while(1){m=m<<4;h=h+1|0;k=h?k:k+1|0;if((h|0)!=8|k){continue}break}}C:{D:{E:{if((g&-33)==80){h=hg(b,d);c=Wa;k=c;if(h|(c|0)!=-2147483648){break C}if(d){c=J[b+116>>2];if((c|0)>0|(c|0)>=0){break E}break D}l=0;o=0;Yb(b,0,0);c=0;b=0;break z}h=0;k=0;if(J[b+116>>2]<0){break C}}J[b+4>>2]=J[b+4>>2]-1;}h=0;k=0;}if(!m){fc(f+112|0,+(t|0)*0);l=J[f+112>>2];o=J[f+116>>2];c=J[f+124>>2];b=J[f+120>>2];break z}b=p?r:j;i=(p?s:i)<<2|b>>>30;c=h+(b<<2)|0;b=i+k|0;j=c-32|0;i=(c>>>0<h>>>0?b+1|0:b)-(c>>>0<32)|0;b=i;if(j>>>0>0-A>>>0&(b|0)>=0|(b|0)>0){J[5732]=68;Nb(f+160|0,t);ob(f+144|0,J[f+160>>2],J[f+164>>2],J[f+168>>2],J[f+172>>2],-1,-1,-1,2147418111);ob(f+128|0,J[f+144>>2],J[f+148>>2],J[f+152>>2],J[f+156>>2],-1,-1,-1,2147418111);l=J[f+128>>2];o=J[f+132>>2];c=J[f+140>>2];b=J[f+136>>2];break z}b=A-226|0;c=b>>31;if((i|0)>=(c|0)&b>>>0<=j>>>0|(c|0)<(i|0)){if((m|0)>=0){while(1){Hb(f+416|0,l,o,w,x,0,0,0,-1073807360);b=Rg(l,o,w,x,1073610752);c=(b|0)>=0;b=c;Hb(f+400|0,l,o,w,x,b?J[f+416>>2]:l,b?J[f+420>>2]:o,b?J[f+424>>2]:w,b?J[f+428>>2]:x);b=j;j=b-1|0;i=i-!b|0;w=J[f+408>>2];x=J[f+412>>2];l=J[f+400>>2];o=J[f+404>>2];m=c|m<<1;if((m|0)>=0){continue}break}}b=i-((A>>31)+(j>>>0<A>>>0)|0)|0;c=(j-A|0)+32|0;b=c>>>0<32?b+1|0:b;c=c>>>0<B>>>0&(b|0)<=0|(b|0)<0?(c|0)>0?c:0:B;F:{if((c|0)>=113){Nb(f+384|0,t);r=J[f+392>>2];s=J[f+396>>2];y=J[f+384>>2];z=J[f+388>>2];h=0;b=0;break F}fc(f+352|0,xe(144-c|0));Nb(f+336|0,t);y=J[f+336>>2];z=J[f+340>>2];r=J[f+344>>2];s=J[f+348>>2];kg(f+368|0,J[f+352>>2],J[f+356>>2],J[f+360>>2],J[f+364>>2],y,z,r,s);n=J[f+376>>2];u=J[f+380>>2];h=J[f+372>>2];b=J[f+368>>2];}d=!(m&1)&((yc(l,o,w,x,0,0,0,0)|0)!=0&(c|0)<32);Ec(f+320|0,d+m|0);ob(f+304|0,y,z,r,s,J[f+320>>2],J[f+324>>2],J[f+328>>2],J[f+332>>2]);c=b;Hb(f+272|0,J[f+304>>2],J[f+308>>2],J[f+312>>2],J[f+316>>2],b,h,n,u);b=d;ob(f+288|0,y,z,r,s,b?0:l,b?0:o,b?0:w,b?0:x);Hb(f+256|0,J[f+288>>2],J[f+292>>2],J[f+296>>2],J[f+300>>2],J[f+272>>2],J[f+276>>2],J[f+280>>2],J[f+284>>2]);he(f+240|0,J[f+256>>2],J[f+260>>2],J[f+264>>2],J[f+268>>2],c,h,n,u);b=J[f+240>>2];d=J[f+244>>2];c=J[f+248>>2];h=J[f+252>>2];if(!yc(b,d,c,h,0,0,0,0)){J[5732]=68;}jg(f+224|0,b,d,c,h,j);l=J[f+224>>2];o=J[f+228>>2];c=J[f+236>>2];b=J[f+232>>2];break z}J[5732]=68;Nb(f+208|0,t);ob(f+192|0,J[f+208>>2],J[f+212>>2],J[f+216>>2],J[f+220>>2],0,0,0,65536);ob(f+176|0,J[f+192>>2],J[f+196>>2],J[f+200>>2],J[f+204>>2],0,0,0,65536);l=J[f+176>>2];o=J[f+180>>2];c=J[f+188>>2];b=J[f+184>>2];}J[q+16>>2]=l;J[q+20>>2]=o;J[q+24>>2]=b;J[q+28>>2]=c;Ua=f+432|0;j=J[q+24>>2];i=J[q+28>>2];h=J[q+16>>2];k=J[q+20>>2];break a}if(J[b+116>>2]<0){break n}J[b+4>>2]=J[b+4>>2]-1;}g=b;m=c;f=d;d=0;e=Ua-8976|0;Ua=e;F=0-A|0;E=F-B|0;G:{H:{while(1){if((m|0)!=48){I:{if((m|0)!=46){break G}b=J[g+4>>2];if((b|0)==J[g+104>>2]){break I}J[g+4>>2]=b+1;m=K[b|0];break H}}else {b=J[g+4>>2];if((b|0)!=J[g+104>>2]){J[g+4>>2]=b+1;m=K[b|0];}else {m=gb(g);}d=1;continue}break}m=gb(g);}C=1;if((m|0)!=48){break G}while(1){b=j;j=b-1|0;i=i-!b|0;b=J[g+4>>2];J:{if((b|0)!=J[g+104>>2]){J[g+4>>2]=b+1;m=K[b|0];break J}m=gb(g);}if((m|0)==48){continue}break}d=1;}J[e+784>>2]=0;K:{L:{b=(m|0)==46;c=m-48|0;M:{N:{O:{if(b|c>>>0<=9){while(1){P:{if(b&1){if(!C){j=h;i=k;C=1;break P}b=!d;break O}h=h+1|0;k=h?k:k+1|0;if((p|0)<=2044){u=(m|0)==48?u:h;b=(e+784|0)+(p<<2)|0;if(n){c=(P(J[b>>2],10)+m|0)-48|0;}J[b>>2]=c;d=1;c=n+1|0;b=(c|0)==9;n=b?0:c;p=b+p|0;break P}if((m|0)==48){break P}J[e+8960>>2]=J[e+8960>>2]|1;u=18396;}b=J[g+4>>2];Q:{if((b|0)!=J[g+104>>2]){J[g+4>>2]=b+1;m=K[b|0];break Q}m=gb(g);}b=(m|0)==46;c=m-48|0;if(b|c>>>0<10){continue}break}}j=C?j:h;i=C?i:k;if(!(!d|(m&-33)!=69)){l=hg(g,f);b=Wa;o=b;R:{if(l|(b|0)!=-2147483648){break R}if(!f){break M}l=0;o=0;if(J[g+116>>2]<0){break R}J[g+4>>2]=J[g+4>>2]-1;}i=i+o|0;j=j+l|0;i=j>>>0<l>>>0?i+1|0:i;break L}b=!d;if((m|0)<0){break N}}if(J[g+116>>2]<0){break N}J[g+4>>2]=J[g+4>>2]-1;}if(!b){break L}J[5732]=28;}h=0;k=0;Yb(g,0,0);c=0;b=0;break K}b=J[e+784>>2];if(!b){fc(e,+(t|0)*0);h=J[e>>2];k=J[e+4>>2];c=J[e+12>>2];b=J[e+8>>2];break K}if(!(h>>>0>9&(k|0)>=0|(k|0)>0|((h|0)!=(j|0)|(i|0)!=(k|0))|(b>>>B|0?(B|0)<=30:0))){Nb(e+48|0,t);Ec(e+32|0,b);ob(e+16|0,J[e+48>>2],J[e+52>>2],J[e+56>>2],J[e+60>>2],J[e+32>>2],J[e+36>>2],J[e+40>>2],J[e+44>>2]);h=J[e+16>>2];k=J[e+20>>2];c=J[e+28>>2];b=J[e+24>>2];break K}if(j>>>0>F>>>1>>>0&(i|0)>=0|(i|0)>0){J[5732]=68;Nb(e+96|0,t);ob(e+80|0,J[e+96>>2],J[e+100>>2],J[e+104>>2],J[e+108>>2],-1,-1,-1,2147418111);ob(e- -64|0,J[e+80>>2],J[e+84>>2],J[e+88>>2],J[e+92>>2],-1,-1,-1,2147418111);h=J[e+64>>2];k=J[e+68>>2];c=J[e+76>>2];b=J[e+72>>2];break K}b=A-226|0;c=j>>>0<b>>>0;b=b>>31;if(c&(i|0)<=(b|0)|(b|0)>(i|0)){J[5732]=68;Nb(e+144|0,t);ob(e+128|0,J[e+144>>2],J[e+148>>2],J[e+152>>2],J[e+156>>2],0,0,0,65536);ob(e+112|0,J[e+128>>2],J[e+132>>2],J[e+136>>2],J[e+140>>2],0,0,0,65536);h=J[e+112>>2];k=J[e+116>>2];c=J[e+124>>2];b=J[e+120>>2];break K}if(n){if((n|0)<=8){b=(e+784|0)+(p<<2)|0;g=J[b>>2];while(1){g=P(g,10);n=n+1|0;if((n|0)!=9){continue}break}J[b>>2]=g;}p=p+1|0;}n=j;S:{if((j|0)<(u|0)|(u|0)>=9|(j|0)>17){break S}if((j|0)==9){Nb(e+192|0,t);Ec(e+176|0,J[e+784>>2]);ob(e+160|0,J[e+192>>2],J[e+196>>2],J[e+200>>2],J[e+204>>2],J[e+176>>2],J[e+180>>2],J[e+184>>2],J[e+188>>2]);h=J[e+160>>2];k=J[e+164>>2];c=J[e+172>>2];b=J[e+168>>2];break K}if((n|0)<=8){Nb(e+272|0,t);Ec(e+256|0,J[e+784>>2]);ob(e+240|0,J[e+272>>2],J[e+276>>2],J[e+280>>2],J[e+284>>2],J[e+256>>2],J[e+260>>2],J[e+264>>2],J[e+268>>2]);Nb(e+224|0,J[(0-n<<2)+8960>>2]);Ng(e+208|0,J[e+240>>2],J[e+244>>2],J[e+248>>2],J[e+252>>2],J[e+224>>2],J[e+228>>2],J[e+232>>2],J[e+236>>2]);h=J[e+208>>2];k=J[e+212>>2];c=J[e+220>>2];b=J[e+216>>2];break K}b=(P(n,-3)+B|0)+27|0;c=J[e+784>>2];if(c>>>b|0?(b|0)<=30:0){break S}Nb(e+352|0,t);Ec(e+336|0,c);ob(e+320|0,J[e+352>>2],J[e+356>>2],J[e+360>>2],J[e+364>>2],J[e+336>>2],J[e+340>>2],J[e+344>>2],J[e+348>>2]);Nb(e+304|0,J[(n<<2)+8888>>2]);ob(e+288|0,J[e+320>>2],J[e+324>>2],J[e+328>>2],J[e+332>>2],J[e+304>>2],J[e+308>>2],J[e+312>>2],J[e+316>>2]);h=J[e+288>>2];k=J[e+292>>2];c=J[e+300>>2];b=J[e+296>>2];break K}while(1){b=p;p=b-1|0;if(!J[(e+784|0)+(p<<2)>>2]){continue}break}u=0;d=(n|0)%9|0;T:{if(!d){c=0;break T}c=0;d=(n|0)<0?d+9|0:d;U:{if(!b){b=0;break U}j=J[(0-d<<2)+8960>>2];l=1e9/(j|0)|0;m=0;g=0;while(1){h=m;i=e+784|0;k=i+(g<<2)|0;m=J[k>>2];p=(m>>>0)/(j>>>0)|0;h=h+p|0;J[k>>2]=h;h=!h&(c|0)==(g|0);c=h?c+1&2047:c;n=h?n-9|0:n;m=P(l,m-P(j,p)|0);g=g+1|0;if((g|0)!=(b|0)){continue}break}if(!m){break U}J[i+(b<<2)>>2]=m;b=b+1|0;}n=(n-d|0)+9|0;}while(1){g=(e+784|0)+(c<<2)|0;V:{while(1){W:{if((n|0)<36){break W}if((n|0)!=36){break V}if(M[g>>2]<=10384592){break W}n=36;break V}p=b+2047|0;d=0;while(1){h=b;l=p&2047;m=(e+784|0)+(l<<2)|0;b=J[m>>2];k=b>>>3|0;j=d;d=b<<29;j=j+d|0;b=k;i=d>>>0>j>>>0?b+1|0:b;if(!i&j>>>0<1000000001){d=0;}else {d=eo(j,i,1e9);b=co(d,Wa,-1e9,-1);j=b+j|0;}J[m>>2]=j;b=(c|0)==(l|0)?h:j?h:l;j=h-1&2047;b=(j|0)!=(l|0)?h:b;p=l-1|0;if((c|0)!=(l|0)){continue}break}u=u-29|0;b=h;if(!d){continue}break}c=c-1&2047;if((c|0)==(b|0)){g=(b+2046&2047)<<2;b=e+784|0;h=g+b|0;J[h>>2]=J[h>>2]|J[b+(j<<2)>>2];b=j;}n=n+9|0;J[(e+784|0)+(c<<2)>>2]=d;continue}break}X:{Y:while(1){j=b+1&2047;l=(e+784|0)+((b-1&2047)<<2)|0;while(1){h=(n|0)>45?9:1;Z:{while(1){d=c;g=0;_:{while(1){$:{c=d+g&2047;if((c|0)==(b|0)){break $}c=J[(e+784|0)+(c<<2)>>2];i=J[(g<<2)+8912>>2];if(c>>>0<i>>>0){break $}if(c>>>0>i>>>0){break _}g=g+1|0;if((g|0)!=4){continue}}break}if((n|0)!=36){break _}g=0;j=0;i=0;h=0;k=0;while(1){c=d+g&2047;if((c|0)==(b|0)){b=b+1&2047;J[(e+(b<<2)|0)+780>>2]=0;}Ec(e+768|0,J[(e+784|0)+(c<<2)>>2]);ob(e+752|0,j,i,h,k,0,0,1342177280,1075633366);Hb(e+736|0,J[e+752>>2],J[e+756>>2],J[e+760>>2],J[e+764>>2],J[e+768>>2],J[e+772>>2],J[e+776>>2],J[e+780>>2]);h=J[e+744>>2];k=J[e+748>>2];j=J[e+736>>2];i=J[e+740>>2];g=g+1|0;if((g|0)!=4){continue}break}Nb(e+720|0,t);ob(e+704|0,j,i,h,k,J[e+720>>2],J[e+724>>2],J[e+728>>2],J[e+732>>2]);h=J[e+712>>2];k=J[e+716>>2];j=0;i=0;l=J[e+704>>2];o=J[e+708>>2];p=u+113|0;g=p-A|0;m=(g|0)<(B|0);c=m?(g|0)>0?g:0:B;if((c|0)<=112){break Z}break X}u=h+u|0;c=b;if((b|0)==(d|0)){continue}break}k=1e9>>>h|0;m=-1<<h^-1;g=0;c=d;while(1){i=g;p=e+784|0;g=p+(d<<2)|0;f=J[g>>2];i=i+(f>>>h|0)|0;J[g>>2]=i;i=!i&(c|0)==(d|0);c=i?c+1&2047:c;n=i?n-9|0:n;g=P(k,f&m);d=d+1&2047;if((d|0)!=(b|0)){continue}break}if(!g){continue}if((c|0)!=(j|0)){J[p+(b<<2)>>2]=g;b=j;continue Y}J[l>>2]=J[l>>2]|1;continue}break}break}fc(e+656|0,xe(225-c|0));kg(e+688|0,J[e+656>>2],J[e+660>>2],J[e+664>>2],J[e+668>>2],l,o,h,k);y=J[e+696>>2];z=J[e+700>>2];w=J[e+688>>2];x=J[e+692>>2];fc(e+640|0,xe(113-c|0));Hg(e+672|0,l,o,h,k,J[e+640>>2],J[e+644>>2],J[e+648>>2],J[e+652>>2]);j=J[e+672>>2];i=J[e+676>>2];r=J[e+680>>2];s=J[e+684>>2];he(e+624|0,l,o,h,k,j,i,r,s);Hb(e+608|0,w,x,y,z,J[e+624>>2],J[e+628>>2],J[e+632>>2],J[e+636>>2]);h=J[e+616>>2];k=J[e+620>>2];l=J[e+608>>2];o=J[e+612>>2];}n=d+4&2047;aa:{if((n|0)==(b|0)){break aa}n=J[(e+784|0)+(n<<2)>>2];ba:{if(n>>>0<=499999999){if(!n&(d+5&2047)==(b|0)){break ba}fc(e+496|0,+(t|0)*.25);Hb(e+480|0,j,i,r,s,J[e+496>>2],J[e+500>>2],J[e+504>>2],J[e+508>>2]);r=J[e+488>>2];s=J[e+492>>2];j=J[e+480>>2];i=J[e+484>>2];break ba}if((n|0)!=5e8){fc(e+592|0,+(t|0)*.75);Hb(e+576|0,j,i,r,s,J[e+592>>2],J[e+596>>2],J[e+600>>2],J[e+604>>2]);r=J[e+584>>2];s=J[e+588>>2];j=J[e+576>>2];i=J[e+580>>2];break ba}G=+(t|0);if((d+5&2047)==(b|0)){fc(e+528|0,G*.5);Hb(e+512|0,j,i,r,s,J[e+528>>2],J[e+532>>2],J[e+536>>2],J[e+540>>2]);r=J[e+520>>2];s=J[e+524>>2];j=J[e+512>>2];i=J[e+516>>2];break ba}fc(e+560|0,G*.75);Hb(e+544|0,j,i,r,s,J[e+560>>2],J[e+564>>2],J[e+568>>2],J[e+572>>2]);r=J[e+552>>2];s=J[e+556>>2];j=J[e+544>>2];i=J[e+548>>2];}if((c|0)>111){break aa}Hg(e+464|0,j,i,r,s,0,0,0,1073676288);if(yc(J[e+464>>2],J[e+468>>2],J[e+472>>2],J[e+476>>2],0,0,0,0)){break aa}Hb(e+448|0,j,i,r,s,0,0,0,1073676288);r=J[e+456>>2];s=J[e+460>>2];j=J[e+448>>2];i=J[e+452>>2];}Hb(e+432|0,l,o,h,k,j,i,r,s);he(e+416|0,J[e+432>>2],J[e+436>>2],J[e+440>>2],J[e+444>>2],w,x,y,z);h=J[e+424>>2];k=J[e+428>>2];l=J[e+416>>2];o=J[e+420>>2];ca:{if((E-2|0)>=(p&2147483647)){break ca}J[e+408>>2]=h;J[e+412>>2]=k&2147483647;J[e+400>>2]=l;J[e+404>>2]=o;ob(e+384|0,l,o,h,k,0,0,0,1073610752);d=Rg(J[e+400>>2],J[e+404>>2],J[e+408>>2],J[e+412>>2],1081081856);b=(d|0)>=0;h=b?J[e+392>>2]:h;k=b?J[e+396>>2]:k;l=b?J[e+384>>2]:l;o=b?J[e+388>>2]:o;u=b+u|0;if(!(m&((c|0)!=(g|0)|(d|0)<0)&(yc(j,i,r,s,0,0,0,0)|0)!=0)&(u+110|0)<=(E|0)){break ca}J[5732]=68;}jg(e+368|0,l,o,h,k,u);h=J[e+368>>2];k=J[e+372>>2];c=J[e+380>>2];b=J[e+376>>2];}J[q+40>>2]=b;J[q+44>>2]=c;J[q+32>>2]=h;J[q+36>>2]=k;Ua=e+8976|0;j=J[q+40>>2];i=J[q+44>>2];h=J[q+32>>2];k=J[q+36>>2];break a;case 3:break j;default:break m}}c=J[b+116>>2];if((c|0)>0|(c|0)>=0){J[b+4>>2]=J[b+4>>2]-1;}break i}da:{c=J[b+4>>2];ea:{if((c|0)!=J[b+104>>2]){J[b+4>>2]=c+1;c=K[c|0];break ea}c=gb(b);}if((c|0)==40){g=1;break da}i=2147450880;if(J[b+116>>2]<0){break a}J[b+4>>2]=J[b+4>>2]-1;break a}while(1){fa:{c=J[b+4>>2];ga:{if((c|0)!=J[b+104>>2]){J[b+4>>2]=c+1;c=K[c|0];break ga}c=gb(b);}if(!(c-48>>>0<10|c-65>>>0<26|(c|0)==95)){if(c-97>>>0>=26){break fa}}g=g+1|0;continue}break}i=2147450880;if((c|0)==41){break a}c=J[b+116>>2];if((c|0)>0|(c|0)>=0){J[b+4>>2]=J[b+4>>2]-1;}ha:{if(d){if(g){break ha}break a}break i}while(1){if((c|0)>0|(c|0)>=0){J[b+4>>2]=J[b+4>>2]-1;}g=g-1|0;if(g){continue}break}break a}J[5732]=28;Yb(b,0,0);}i=0;}J[a>>2]=h;J[a+4>>2]=k;J[a+8>>2]=j;J[a+12>>2]=i;Ua=q+48|0;}function Bd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;c=Ua-112|0;Ua=c;f=J[b>>2];e=f;i=J[b+4>>2];a:{if(!i){break a}d=f+i|0;while(1){g=K[e|0];b:{if(!((g|0)!=123&(g|0)!=40)){h=h+1|0;break b}if(h){if((g|0)!=125&(g|0)!=41){break b}h=h-1|0;break b}h=0;c:{switch(g-41|0){case 0:case 3:break a;case 1:case 2:break b;default:break c}}if((g|0)==125){break a}}e=e+1|0;if((d|0)!=(e|0)){continue}break}e=d;}J[c+104>>2]=f;d=e-f|0;J[c+108>>2]=d;J[b+4>>2]=i-d;J[b>>2]=e;H[c+18|0]=0;I[c+16>>1]=27504;H[c+27|0]=2;d:{e:{f:{g:{h:{i:{j:{k:{if(K[f+2|0]!=40|d>>>0<4|(K[(d+f|0)-1|0]!=41|K[c+16|0]!=K[f|0])){break k}if(K[c+17|0]!=K[f+1|0]){break k}b=d-4|0;J[c+108>>2]=b;d=f+3|0;J[c+104>>2]=d;if(!(!b|(b|0)>17)){if(b>>>0>=2147483632){break g}l:{if(b>>>0<=10){H[c+27|0]=b;h=c+16|0;break l}e=(b|15)+1|0;h=cb(e);J[c+24>>2]=e|-2147483648;J[c+16>>2]=h;J[c+20>>2]=b;}H[fb(h,d,b)+b|0]=0;J[c+88>>2]=J[c+20>>2];b=K[c+23|0]|K[c+24|0]<<8|(K[c+25|0]<<16|K[c+26|0]<<24);H[c+91|0]=b;H[c+92|0]=b>>>8;H[c+93|0]=b>>>16;H[c+94|0]=b>>>24;J[5996]=0;d=J[c+16>>2];f=H[c+27|0];J[c+24>>2]=0;J[c+16>>2]=0;J[c+20>>2]=0;b=$(3,12)|0;e=J[5996];J[5996]=0;if((e|0)!=1){J[b>>2]=d;J[b+4>>2]=J[c+88>>2];d=K[c+91|0]|K[c+92|0]<<8|(K[c+93|0]<<16|K[c+94|0]<<24);H[b+7|0]=d;H[b+8|0]=d>>>8;H[b+9|0]=d>>>16;H[b+10|0]=d>>>24;H[b+11|0]=f;J[a+4>>2]=0;J[a+8>>2]=0;J[a>>2]=1;J[a+12>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+24>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;d=b+12|0;J[a+36>>2]=d;J[a+32>>2]=d;J[a+28>>2]=b;J[a+48>>2]=0;J[a+52>>2]=0;break h}e=Z()|0;rb(c+16|0);if((f|0)>=0){break j}$a(d);da(e|0);B();}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break h}H[c+21|0]=0;H[c+20|0]=K[1777];H[c+27|0]=5;J[c+16>>2]=K[1773]|K[1774]<<8|(K[1775]<<16|K[1776]<<24);m:{b=d>>>0<7;if(b|K[f+5|0]!=40|(K[(d+f|0)-1|0]!=41|K[c+16|0]!=K[f|0])){break m}if(K[c+17|0]!=K[f+1|0]|K[c+18|0]!=K[f+2|0]|(K[c+19|0]!=K[f+3|0]|K[c+20|0]!=K[f+4|0])){break m}g=d-7|0;J[c+108>>2]=g;d=f+6|0;J[c+104>>2]=d;if(g>>>0>=2147483632){break g}n:{o:{if(g>>>0>=11){b=(g|15)+1|0;e=cb(b);J[c+24>>2]=b|-2147483648;J[c+16>>2]=e;J[c+20>>2]=g;break o}H[c+27|0]=g;e=c+16|0;if(!g){break n}}f=g-1|0;i=g&7;p:{if(!i){b=d;break p}h=0;b=d;while(1){H[e|0]=K[b|0];e=e+1|0;b=b+1|0;h=h+1|0;if((i|0)!=(h|0)){continue}break}}if(f>>>0<7){break n}d=d+g|0;while(1){H[e|0]=K[b|0];H[e+1|0]=K[b+1|0];H[e+2|0]=K[b+2|0];H[e+3|0]=K[b+3|0];H[e+4|0]=K[b+4|0];H[e+5|0]=K[b+5|0];H[e+6|0]=K[b+6|0];H[e+7|0]=K[b+7|0];e=e+8|0;b=b+8|0;if((d|0)!=(b|0)){continue}break}}H[e|0]=0;b=jf(c+16|0,c+88|0);if(H[c+27|0]<0){$a(J[c+16>>2]);}if(!b){J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break h}b=J[c+88>>2];d=b-1|0;if(J[c+92>>2]==(!b|0)&d>>>0<=2147483646){J[a+4>>2]=0;J[a+8>>2]=0;J[a>>2]=3;J[a+52>>2]=b;J[a+12>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+48>>2]=0;break h}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break h}H[c+21|0]=0;H[c+20|0]=K[1783];H[c+27|0]=5;J[c+16>>2]=K[1779]|K[1780]<<8|(K[1781]<<16|K[1782]<<24);q:{if(K[f+5|0]!=40|b|(K[(d+f|0)-1|0]!=41|K[c+16|0]!=K[f|0])){break q}if(K[c+17|0]!=K[f+1|0]|K[c+18|0]!=K[f+2|0]|(K[c+19|0]!=K[f+3|0]|K[c+20|0]!=K[f+4|0])){break q}g=d-7|0;J[c+108>>2]=g;d=f+6|0;J[c+104>>2]=d;if(g>>>0>=2147483632){break g}r:{s:{if(g>>>0>=11){b=(g|15)+1|0;e=cb(b);J[c+24>>2]=b|-2147483648;J[c+16>>2]=e;J[c+20>>2]=g;break s}H[c+27|0]=g;e=c+16|0;if(!g){break r}}f=g-1|0;i=g&7;t:{if(!i){b=d;break t}h=0;b=d;while(1){H[e|0]=K[b|0];e=e+1|0;b=b+1|0;h=h+1|0;if((i|0)!=(h|0)){continue}break}}if(f>>>0<7){break r}d=d+g|0;while(1){H[e|0]=K[b|0];H[e+1|0]=K[b+1|0];H[e+2|0]=K[b+2|0];H[e+3|0]=K[b+3|0];H[e+4|0]=K[b+4|0];H[e+5|0]=K[b+5|0];H[e+6|0]=K[b+6|0];H[e+7|0]=K[b+7|0];e=e+8|0;b=b+8|0;if((d|0)!=(b|0)){continue}break}}H[e|0]=0;b=jf(c+16|0,c+88|0);if(H[c+27|0]<0){$a(J[c+16>>2]);}if(!b){J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break h}b=J[c+88>>2];d=b-1|0;if(J[c+92>>2]==(!b|0)&d>>>0<=2147483646){J[a+4>>2]=0;J[a+8>>2]=0;J[a>>2]=2;J[a+52>>2]=b;J[a+12>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+48>>2]=0;break h}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break h}H[c+22|0]=0;I[c+20>>1]=K[3881]|K[3882]<<8;H[c+27|0]=6;J[c+16>>2]=K[3877]|K[3878]<<8|(K[3879]<<16|K[3880]<<24);u:{if(K[f+6|0]!=40|d>>>0<8|(K[(d+f|0)-1|0]!=41|K[c+16|0]!=K[f|0])){break u}if(K[c+17|0]!=K[f+1|0]|K[c+18|0]!=K[f+2|0]|(K[c+19|0]!=K[f+3|0]|K[c+20|0]!=K[f+4|0])){break u}if(K[c+21|0]!=K[f+5|0]){break u}b=d-8|0;J[c+108>>2]=b;d=f+7|0;J[c+104>>2]=d;$c(c+16|0,d,b,32);b=J[c+20>>2];d=J[c+16>>2];if((b|0)!=(d|0)){J[a+4>>2]=0;J[a+8>>2]=0;J[a>>2]=7;J[a+16>>2]=d;J[a+12>>2]=0;J[a+20>>2]=b;b=J[c+24>>2];J[a+28>>2]=0;J[a+32>>2]=0;J[a+24>>2]=b;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;break h}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;if(!b){break h}$a(b);break h}H[c+25|0]=0;H[c+24|0]=K[4198];H[c+27|0]=9;b=K[4194]|K[4195]<<8|(K[4196]<<16|K[4197]<<24);J[c+16>>2]=K[4190]|K[4191]<<8|(K[4192]<<16|K[4193]<<24);J[c+20>>2]=b;v:{if(K[f+9|0]!=40|d>>>0<11|(K[(d+f|0)-1|0]!=41|K[c+16|0]!=K[f|0])){break v}if(K[c+17|0]!=K[f+1|0]|K[c+18|0]!=K[f+2|0]|(K[c+19|0]!=K[f+3|0]|K[c+20|0]!=K[f+4|0])){break v}if(K[c+21|0]!=K[f+5|0]|K[c+22|0]!=K[f+6|0]|(K[c+23|0]!=K[f+7|0]|K[c+24|0]!=K[f+8|0])){break v}b=d-11|0;J[c+108>>2]=b;d=f+10|0;J[c+104>>2]=d;$c(c+16|0,d,b,20);b=J[c+20>>2];d=J[c+16>>2];if((b|0)!=(d|0)){J[a+4>>2]=0;J[a+8>>2]=0;J[a>>2]=6;J[a+16>>2]=d;J[a+12>>2]=0;J[a+20>>2]=b;b=J[c+24>>2];J[a+28>>2]=0;J[a+32>>2]=0;J[a+24>>2]=b;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;break h}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;if(!b){break h}$a(b);break h}H[c+27|0]=7;H[c+23|0]=0;J[c+16>>2]=K[3869]|K[3870]<<8|(K[3871]<<16|K[3872]<<24);b=K[3872]|K[3873]<<8|(K[3874]<<16|K[3875]<<24);H[c+19|0]=b;H[c+20|0]=b>>>8;H[c+21|0]=b>>>16;H[c+22|0]=b>>>24;w:{if(K[f+7|0]!=40|d>>>0<9|(K[(d+f|0)-1|0]!=41|K[c+16|0]!=K[f|0])){break w}if(K[c+17|0]!=K[f+1|0]|K[c+18|0]!=K[f+2|0]|(K[c+19|0]!=K[f+3|0]|K[c+20|0]!=K[f+4|0])){break w}if(K[c+21|0]!=K[f+5|0]|K[c+22|0]!=K[f+6|0]){break w}b=d-9|0;J[c+108>>2]=b;d=f+8|0;J[c+104>>2]=d;$c(c+16|0,d,b,32);b=J[c+20>>2];d=J[c+16>>2];if((b|0)!=(d|0)){J[a+4>>2]=0;J[a+8>>2]=0;J[a>>2]=5;J[a+16>>2]=d;J[a+12>>2]=0;J[a+20>>2]=b;b=J[c+24>>2];J[a+28>>2]=0;J[a+32>>2]=0;J[a+24>>2]=b;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;break h}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;if(!b){break h}$a(b);break h}b=Kb(c+16|0,4182);d=fd(b,c+104|0);if(H[b+11|0]<0){$a(J[b>>2]);}if(d){$c(c+16|0,J[c+104>>2],J[c+108>>2],20);b=J[c+20>>2];d=J[c+16>>2];if((b|0)!=(d|0)){J[a+4>>2]=0;J[a+8>>2]=0;J[a>>2]=4;J[a+16>>2]=d;J[a+12>>2]=0;J[a+20>>2]=b;b=J[c+24>>2];J[a+28>>2]=0;J[a+32>>2]=0;J[a+24>>2]=b;J[a+36>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;break h}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;if(!b){break h}$a(b);break h}b=Kb(c+16|0,1743);d=fd(b,c+104|0);if(H[b+11|0]<0){$a(J[b>>2]);}if(d){J[c+96>>2]=0;J[c+88>>2]=0;J[c+92>>2]=0;J[c+84>>2]=0;J[c+76>>2]=0;J[c+80>>2]=0;J[5996]=0;b=c+16|0;ea(26,b|0,c+104|0,c+8|0);d=J[5996];J[5996]=0;if((d|0)!=1){J[5996]=0;aa(27,c+88|0,b|0);d=J[5996];J[5996]=0;x:{y:{if((d|0)!=1){Fb(b);b=J[c+92>>2];if(J[b-56>>2]){break y}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break x}e=Z()|0;Fb(c+16|0);break e}J[5996]=0;aa(28,c+76|0,J[c+8>>2]);d=J[5996];J[5996]=0;if((d|0)==1){break f}z:{A:{if(!J[c+108>>2]){break A}B:{C:{while(1){I[c+16>>1]=44;H[c+27|0]=1;b=c+16|0;d=c+104|0;if(!vb(b,d)){break z}J[5996]=0;ea(26,b|0,d|0,c+8|0);d=J[5996];J[5996]=0;if((d|0)==1){break C}J[5996]=0;aa(27,c+88|0,b|0);d=J[5996];J[5996]=0;if((d|0)==1){break B}Fb(b);b=J[c+92>>2];if(!J[b-56>>2]){break z}J[5996]=0;aa(28,c+76|0,J[c+8>>2]);d=J[5996];J[5996]=0;if((d|0)!=1){if(!J[c+108>>2]){break A}continue}break}e=Z()|0;break e}e=Z()|0;break e}e=Z()|0;Fb(c+16|0);break e}J[a>>2]=9;d=J[c+88>>2];J[a+8>>2]=b;J[a+4>>2]=d;J[a+12>>2]=J[c+96>>2];J[c+96>>2]=0;J[c+88>>2]=0;J[c+92>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+40>>2]=J[c+76>>2];J[a+44>>2]=J[c+80>>2];b=J[c+84>>2];J[a+52>>2]=0;J[a+48>>2]=b;break x}b=J[c+76>>2];J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;if(!b){break x}$a(b);}Oc(c+88|0);break h}e=Z()|0;break e}b=Kb(c+16|0,2464);d=fd(b,c+104|0);if(H[b+11|0]<0){$a(J[b>>2]);}if(d){J[c+96>>2]=0;J[c+88>>2]=0;J[c+92>>2]=0;J[5996]=0;b=c+16|0;aa(29,b|0,c+104|0);d=J[5996];J[5996]=0;D:{if((d|0)!=1){J[5996]=0;aa(27,c+88|0,b|0);d=J[5996];J[5996]=0;E:{F:{G:{if((d|0)!=1){Fb(b);e=J[c+92>>2];if(J[e-56>>2]){if(!J[c+108>>2]){break F}break G}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break E}e=Z()|0;Fb(c+16|0);break D}H:{I:{while(1){J[5996]=0;b=_(30,c+76|0,4354)|0;d=J[5996];J[5996]=0;J:{if((d|0)!=1){d=vb(b,c+104|0);if(H[c+87|0]<0){$a(J[b>>2]);}if(d){break J}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break E}e=Z()|0;break D}J[5996]=0;b=c+16|0;aa(29,b|0,c+104|0);d=J[5996];J[5996]=0;if((d|0)==1){break I}J[5996]=0;aa(27,c+88|0,b|0);d=J[5996];J[5996]=0;if((d|0)==1){break H}Fb(b);e=J[c+92>>2];if(J[e-56>>2]){if(!J[c+108>>2]){break F}continue}break}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break E}e=Z()|0;break D}e=Z()|0;Fb(c+16|0);break D}J[a>>2]=8;b=J[c+88>>2];J[a+8>>2]=e;J[a+4>>2]=b;J[a+12>>2]=J[c+96>>2];J[c+96>>2]=0;J[c+88>>2]=0;J[c+92>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;}Oc(c+88|0);break h}e=Z()|0;}break d}b=Kb(c+16|0,2197);d=fd(b,c+104|0);if(H[b+11|0]<0){$a(J[b>>2]);}if(!d){break i}e=0;h=J[c+104>>2];b=h;g=J[c+108>>2];K:{if(!g){break K}d=b+g|0;while(1){f=K[b|0];L:{if(!((f|0)!=123&(f|0)!=40)){e=e+1|0;break L}if(e){if((f|0)!=125&(f|0)!=41){break L}e=e-1|0;break L}e=0;M:{switch(f-41|0){case 0:case 3:break K;case 1:case 2:break L;default:break M}}if((f|0)==125){break K}}b=b+1|0;if((d|0)!=(b|0)){continue}break}b=d;}J[c+8>>2]=h;d=b-h|0;J[c+12>>2]=d;J[c+108>>2]=g-d;J[c+104>>2]=b;b=J[c+8>>2];d=Ad(c+16|0,b,b+J[c+12>>2]|0);f=c+4|0;b=0;e=Ua-16|0;Ua=e;g=K[d+11|0];h=g<<24>>24;h=(h|0)<0;g=h?J[d+4>>2]:g;N:{if(!g){break N}h=h?J[d>>2]:d;i=K[h|0];j=i-9&255;if(j>>>0<24&(8388639>>>j&1)){break N}j=K[(g+h|0)-1|0]-9|0;if((j&255)>>>0<24&(8388639>>>j&1)){break N}if((i|0)==45|(Gb(h)|0)!=(g|0)){break N}J[e+12>>2]=0;J[5732]=0;h=qe(H[d+11|0]<0?J[d>>2]:d,e+12|0,10,-1,0);if(f){J[f>>2]=h;}f=J[e+12>>2];if(!f|K[f|0]){break N}b=!J[5732];}Ua=e+16|0;if(H[d+11|0]<0){$a(J[d>>2]);}if(!b){J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break h}if(!J[c+4>>2]){J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break h}b=0;J[c+96>>2]=0;J[c+88>>2]=0;J[c+92>>2]=0;e=0;O:{P:{Q:{if(J[c+108>>2]){R:{S:{T:{while(1){J[5996]=0;b=_(30,c+76|0,4354)|0;d=J[5996];J[5996]=0;if((d|0)==1){break P}d=vb(b,c+104|0);if(H[c+87|0]<0){$a(J[b>>2]);}if(!d){J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break Q}J[5996]=0;b=c+16|0;aa(29,b|0,c+104|0);d=J[5996];J[5996]=0;if((d|0)==1){break T}J[5996]=0;aa(27,c+88|0,b|0);d=J[5996];J[5996]=0;if((d|0)==1){break S}Fb(b);e=J[c+92>>2];if(J[e-56>>2]){if(!J[c+108>>2]){break R}continue}break}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break Q}e=Z()|0;break O}e=Z()|0;Fb(c+16|0);break O}b=J[c+88>>2];}U:{d=(e-b|0)/56|0;if(d>>>0<=100){f=d;d=J[c+4>>2];if(f>>>0>=d>>>0){break U}}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;break Q}J[a+4>>2]=b;J[a>>2]=10;J[a+8>>2]=e;J[a+12>>2]=J[c+96>>2];J[c+96>>2]=0;J[c+88>>2]=0;J[c+92>>2]=0;J[a+48>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+52>>2]=d;}Oc(c+88|0);break h}e=Z()|0;}Oc(c+88|0);}da(e|0);B();}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;}Ua=c+112|0;return}ub();B();}e=Z()|0;}a=J[c+76>>2];if(a){$a(a);}}Oc(c+88|0);da(e|0);B();}function sn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;f=Ua-160|0;Ua=f;J[f+152>>2]=0;J[f+144>>2]=0;J[f+148>>2]=0;o=d+1|0;l=1;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{while(1){e=K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24);if((e|0)==(c|0)){break j}k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{x:{y:{z:{A:{if((c-e|0)<=0|c>>>0<=e>>>0){break A}h=e+1|0;g=0;k=K[e|0];B:{if(k>>>0>78){i=0;break B}i=k;C:{if(i>>>0<76){break C}D:{switch(i-76|0){case 0:if((c-h|0)<=0){break A}h=e+2|0;i=K[e+1|0];break C;case 1:if((c-h|0)<2){break A}h=e+3|0;i=K[e+1|0]|K[e+2|0]<<8;break C;default:break D}}if((c-h|0)<4){break A}h=e+5|0;i=K[e+1|0]|K[e+2|0]<<8|(K[e+3|0]<<16|K[e+4|0]<<24);}g=c-h|0;if((g|0)<0){break A}e=i;if(g>>>0<e>>>0){break A}E:{if(!e){i=0;g=0;break E}if((e|0)<0){J[5996]=0;ca(8);a=J[5996];J[5996]=0;if((a|0)==1){break z}break a}J[5996]=0;i=$(3,e|0)|0;j=J[5996];J[5996]=0;g=0;if((j|0)==1){break f}g=fb(i,h,e)+e|0;}h=e+h|0;}e=3;if(k-103>>>0<2){break k}H[b|0]=h;H[b+1|0]=h>>>8;H[b+2|0]=h>>>16;H[b+3|0]=h>>>24;if(!l){break y}e=0;if((d|0)<=0){break x}while(1){J[5996]=0;_(97,f+144|0,5573)|0;h=J[5996];J[5996]=0;if((h|0)==1){break w}e=e+1|0;if((e|0)!=(d|0)){continue}break}break x}b=K[f+155|0];d=b<<24>>24;i=(d|0)<0?J[f+148>>2]:b;c=i+8|0;if(c>>>0>=2147483632){J[5996]=0;ca(2);a=J[5996];J[5996]=0;if((a|0)!=1){break a}e=Z()|0;break d}F:{if(c>>>0<=10){J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;H[a+11|0]=c;break F}J[5996]=0;e=(c|15)+1|0;b=$(3,e|0)|0;h=J[5996];J[5996]=0;g=0;if((h|0)==1){break f}J[a+4>>2]=c;J[a>>2]=b;J[a+8>>2]=e|-2147483648;a=b;}a=eb(a,(d|0)<0?J[f+144>>2]:f+144|0,i)+i|0;H[a+8|0]=0;H[a|0]=32;H[a+1|0]=91;H[a+2|0]=101;H[a+3|0]=114;H[a+4|0]=114;H[a+5|0]=111;H[a+6|0]=114;H[a+7|0]=93;break c}e=Z()|0;break d}J[5996]=0;aa(98,f+144|0,32);e=J[5996];J[5996]=0;if((e|0)==1){break g}e=K[f+155|0];p=(e<<24>>24<0?J[f+148>>2]:e)-1|0;}G:{H:{I:{J:{K:{m=g-i|0;switch(m|0){case 0:break G;case 33:break I;case 32:break J;case 20:break K;default:break H}}J[5996]=0;j=$(3,20)|0;e=J[5996];J[5996]=0;if((e|0)==1){e=Z()|0;break h}e=j;H[e|0]=153;H[e+1|0]=153;H[e+2|0]=153;H[e+3|0]=153;H[e+4|0]=153;H[e+5|0]=153;H[e+6|0]=153;H[e+7|0]=153;H[e+16|0]=153;H[e+17|0]=153;H[e+18|0]=153;H[e+19|0]=153;H[e+8|0]=153;H[e+9|0]=153;H[e+10|0]=153;H[e+11|0]=153;H[e+12|0]=153;H[e+13|0]=153;H[e+14|0]=153;H[e+15|0]=153;h=i;if((g|0)==(h|0)){break p}while(1){if(K[h|0]==K[e|0]){e=e+1|0;h=h+1|0;if((g|0)!=(h|0)){continue}break p}break}$a(j);if(!(K[i|0]!=80|K[i+1|0]!=75|K[i+2|0]!=104)){L:{M:{while(1){e=g-1|0;if(!K[e|0]){g=e;if((e|0)!=(i|0)){continue}break M}break}g=(g-i|0)-3|0;if(g>>>0<2147483632){break L}}J[5996]=0;ca(2);a=J[5996];J[5996]=0;if((a|0)!=1){break a}e=Z()|0;break h}N:{O:{P:{Q:{R:{S:{T:{if(g>>>0<=10){H[f+111|0]=g;h=f+100|0;break T}J[5996]=0;e=(g|15)+1|0;h=$(3,e|0)|0;j=J[5996];J[5996]=0;if((j|0)==1){break S}J[f+100>>2]=h;J[f+104>>2]=g;J[f+108>>2]=e|-2147483648;}H[eb(h,i+3|0,g)+g|0]=0;J[5996]=0;g=ba(99,f+100|0,0,5383)|0;e=J[5996];J[5996]=0;if((e|0)==1){break R}J[f+120>>2]=J[g+8>>2];e=J[g+4>>2];J[f+112>>2]=J[g>>2];J[f+116>>2]=e;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;e=_(97,f+112|0,3723)|0;h=J[5996];J[5996]=0;if((h|0)==1){break Q}J[f+136>>2]=J[e+8>>2];h=J[e+4>>2];J[f+128>>2]=J[e>>2];J[f+132>>2]=h;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;h=K[f+139|0];j=h<<24>>24<0;ba(100,f+144|0,(j?J[f+128>>2]:f+128|0)|0,(j?J[f+132>>2]:h)|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break P}if(H[f+139|0]<0){$a(J[f+128>>2]);}if(H[f+123|0]<0){$a(J[e>>2]);}if(H[f+111|0]<0){$a(J[g>>2]);}if(!l){break m}break l}e=Z()|0;break h}e=Z()|0;break N}e=Z()|0;break O}e=Z()|0;if(H[f+139|0]>=0){break O}$a(J[f+128>>2]);}if(H[f+123|0]>=0){break N}$a(J[f+112>>2]);}if(H[f+111|0]>=0){break h}$a(J[f+100>>2]);break h}J[f+80>>2]=0;J[5996]=0;J[f+72>>2]=0;J[f+76>>2]=0;aa(101,f+72|0,40);e=J[5996];J[5996]=0;if((e|0)==1){break r}if(g>>>0>i>>>0){h=i+20|0;e=i;while(1){g=K[e|0];J[5996]=0;j=f+72|0;aa(98,j|0,H[(g>>>4|0)+6976|0]);k=J[5996];J[5996]=0;if((k|0)==1){break r}J[5996]=0;aa(98,j|0,H[(g&15)+6976|0]);g=J[5996];J[5996]=0;if((g|0)==1){break r}e=e+1|0;if((h|0)!=(e|0)){continue}break}}J[5996]=0;g=ba(99,f+72|0,0,3762)|0;e=J[5996];J[5996]=0;U:{V:{W:{X:{if((e|0)!=1){J[f+96>>2]=J[g+8>>2];e=J[g+4>>2];J[f+88>>2]=J[g>>2];J[f+92>>2]=e;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;e=_(97,f+88|0,3760)|0;h=J[5996];J[5996]=0;if((h|0)==1){break X}J[f+136>>2]=J[e+8>>2];h=J[e+4>>2];J[f+128>>2]=J[e>>2];J[f+132>>2]=h;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;h=K[f+139|0];j=h<<24>>24<0;ba(100,f+144|0,(j?J[f+128>>2]:f+128|0)|0,(j?J[f+132>>2]:h)|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break W}if(H[f+139|0]<0){$a(J[f+128>>2]);}if(H[f+99|0]<0){$a(J[e>>2]);}if(H[f+83|0]<0){$a(J[g>>2]);}if(!l){break m}break l}e=Z()|0;break U}e=Z()|0;break V}e=Z()|0;if(H[f+139|0]>=0){break V}$a(J[f+128>>2]);}if(H[f+99|0]>=0){break U}$a(J[f+88>>2]);}break q}J[5996]=0;j=$(3,32)|0;e=J[5996];J[5996]=0;if((e|0)==1){e=Z()|0;break h}e=j;H[e|0]=136;H[e+1|0]=136;H[e+2|0]=136;H[e+3|0]=136;H[e+4|0]=136;H[e+5|0]=136;H[e+6|0]=136;H[e+7|0]=136;H[e+24|0]=136;H[e+25|0]=136;H[e+26|0]=136;H[e+27|0]=136;H[e+28|0]=136;H[e+29|0]=136;H[e+30|0]=136;H[e+31|0]=136;H[e+16|0]=136;H[e+17|0]=136;H[e+18|0]=136;H[e+19|0]=136;H[e+20|0]=136;H[e+21|0]=136;H[e+22|0]=136;H[e+23|0]=136;H[e+8|0]=136;H[e+9|0]=136;H[e+10|0]=136;H[e+11|0]=136;H[e+12|0]=136;H[e+13|0]=136;H[e+14|0]=136;H[e+15|0]=136;h=i;if((g|0)==(h|0)){break p}while(1){q=K[h|0];r=K[e|0];if((q|0)==(r|0)){e=e+1|0;h=h+1|0;if((g|0)!=(h|0)){continue}}break}$a(j);if((q|0)==(r|0)){break o}if(!m){break G}if((m|0)!=33){break H}}if(K[i|0]!=2|K[i+1|0]!=80|(K[i+2|0]!=75|K[i+3|0]!=98)){break H}Y:{if((g|0)!=(i|0)){Z:{while(1){e=g-1|0;if(!K[e|0]){g=e;if((e|0)!=(i|0)){continue}break Z}break}g=(g-i|0)-4|0;if(g>>>0<2147483632){break Y}}g=i;}J[5996]=0;ca(2);a=J[5996];J[5996]=0;if((a|0)!=1){break a}e=Z()|0;break e}_:{$:{aa:{ba:{ca:{da:{ea:{if(g>>>0<=10){H[f+55|0]=g;h=f+44|0;break ea}J[5996]=0;e=(g|15)+1|0;h=$(3,e|0)|0;j=J[5996];J[5996]=0;if((j|0)==1){break da}J[f+44>>2]=h;J[f+48>>2]=g;J[f+52>>2]=e|-2147483648;}H[eb(h,i+4|0,g)+g|0]=0;J[5996]=0;g=ba(99,f+44|0,0,3762)|0;e=J[5996];J[5996]=0;if((e|0)==1){break ca}J[f- -64>>2]=J[g+8>>2];e=J[g+4>>2];J[f+56>>2]=J[g>>2];J[f+60>>2]=e;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;e=_(97,f+56|0,3760)|0;h=J[5996];J[5996]=0;if((h|0)==1){break ba}J[f+136>>2]=J[e+8>>2];h=J[e+4>>2];J[f+128>>2]=J[e>>2];J[f+132>>2]=h;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;h=K[f+139|0];j=h<<24>>24<0;ba(100,f+144|0,(j?J[f+128>>2]:f+128|0)|0,(j?J[f+132>>2]:h)|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break aa}if(H[f+139|0]<0){$a(J[f+128>>2]);}if(H[f+67|0]<0){$a(J[e>>2]);}if(H[f+55|0]<0){$a(J[g>>2]);}if(l){break l}break m}e=Z()|0;break h}e=Z()|0;break _}e=Z()|0;break $}e=Z()|0;if(H[f+139|0]>=0){break $}$a(J[f+128>>2]);}if(H[f+67|0]>=0){break _}$a(J[f+56>>2]);}if(H[f+55|0]>=0){break h}$a(J[f+44>>2]);break h}J[f+24>>2]=0;J[5996]=0;J[f+16>>2]=0;J[f+20>>2]=0;aa(101,f+16|0,m<<1);e=J[5996];J[5996]=0;if((e|0)==1){break t}if(g>>>0>i>>>0){h=i+m|0;e=i;while(1){g=K[e|0];J[5996]=0;j=f+16|0;aa(98,j|0,H[(g>>>4|0)+6976|0]);k=J[5996];J[5996]=0;if((k|0)==1){break t}J[5996]=0;aa(98,j|0,H[(g&15)+6976|0]);g=J[5996];J[5996]=0;if((g|0)==1){break t}e=e+1|0;if((h|0)!=(e|0)){continue}break}}J[5996]=0;g=ba(99,f+16|0,0,3762)|0;e=J[5996];J[5996]=0;fa:{ga:{ha:{ia:{if((e|0)!=1){J[f+40>>2]=J[g+8>>2];e=J[g+4>>2];J[f+32>>2]=J[g>>2];J[f+36>>2]=e;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;J[5996]=0;e=_(97,f+32|0,3760)|0;h=J[5996];J[5996]=0;if((h|0)==1){break ia}J[f+136>>2]=J[e+8>>2];h=J[e+4>>2];J[f+128>>2]=J[e>>2];J[f+132>>2]=h;J[e>>2]=0;J[e+4>>2]=0;J[e+8>>2]=0;J[5996]=0;h=K[f+139|0];j=h<<24>>24<0;ba(100,f+144|0,(j?J[f+128>>2]:f+128|0)|0,(j?J[f+132>>2]:h)|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break ha}if(H[f+139|0]<0){$a(J[f+128>>2]);}if(H[f+43|0]<0){$a(J[e>>2]);}if(H[f+27|0]<0){$a(J[g>>2]);}if(!l){break m}break l}e=Z()|0;break fa}e=Z()|0;break ga}e=Z()|0;if(H[f+139|0]>=0){break ga}$a(J[f+128>>2]);}if(H[f+43|0]>=0){break fa}$a(J[f+32>>2]);}break s}e=J[(k<<2)+5840>>2];g=Gb(e);if(g>>>0>=2147483632){J[5996]=0;ca(2);a=J[5996];J[5996]=0;if((a|0)!=1){break a}e=Z()|0;break h}ja:{ka:{la:{ma:{na:{oa:{pa:{qa:{ra:{sa:{ta:{ua:{va:{wa:{xa:{ya:{za:{Aa:{Ba:{if(g>>>0<=10){H[f+139|0]=g;h=f+128|0;break Ba}J[5996]=0;j=(g|15)+1|0;h=$(3,j|0)|0;m=J[5996];J[5996]=0;if((m|0)==1){break Aa}J[f+128>>2]=h;J[f+132>>2]=g;J[f+136>>2]=j|-2147483648;}H[eb(h,e,g)+g|0]=0;J[5996]=0;g=K[f+139|0];e=g<<24>>24<0;g=ba(100,f+144|0,(e?J[f+128>>2]:f+128|0)|0,(e?J[f+132>>2]:g)|0)|0;e=J[5996];J[5996]=0;if((e|0)==1){break za}if(H[f+139|0]<0){$a(J[f+128>>2]);}if(k-99>>>0>1){break n}J[5996]=0;aa(98,g|0,10);e=J[5996];J[5996]=0;if((e|0)==1){break g}J[5996]=0;e=f+128|0;ga(102,e|0,b|0,c|0,o|0);h=J[5996];J[5996]=0;if((h|0)==1){break ya}J[5996]=0;j=g;h=e;g=K[f+139|0];e=g<<24>>24<0;j=ba(100,j|0,(e?J[f+128>>2]:h)|0,(e?J[f+132>>2]:g)|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break xa}if(H[f+139|0]<0){$a(J[f+128>>2]);}h=K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24);if((h|0)==(c|0)){break na}if(K[h|0]!=103){break va}e=0;if((d|0)>0){while(1){J[5996]=0;_(97,j|0,5573)|0;g=J[5996];J[5996]=0;if((g|0)==1){break v}e=e+1|0;if((e|0)!=(d|0)){continue}break}h=K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24);}g=h+1|0;H[b|0]=g;H[b+1|0]=g>>>8;H[b+2|0]=g>>>16;H[b+3|0]=g>>>24;e=J[(K[h|0]<<2)+5840>>2];g=Gb(e);if(g>>>0<2147483632){break wa}J[5996]=0;ca(2);a=J[5996];J[5996]=0;if((a|0)!=1){break a}e=Z()|0;break h}e=Z()|0;break h}e=Z()|0;if(H[f+139|0]>=0){break h}$a(J[f+128>>2]);break h}e=Z()|0;break h}e=Z()|0;if(H[f+139|0]>=0){break h}$a(J[f+128>>2]);break h}Ca:{if(g>>>0<=10){H[f+11|0]=g;h=f;break Ca}J[5996]=0;k=(g|15)+1|0;h=$(3,k|0)|0;l=J[5996];J[5996]=0;if((l|0)==1){break ua}J[f>>2]=h;J[f+4>>2]=g;J[f+8>>2]=k|-2147483648;}H[eb(h,e,g)+g|0]=0;J[5996]=0;aa(98,f|0,10);g=J[5996];J[5996]=0;if((g|0)==1){break ta}J[f+136>>2]=J[f+8>>2];J[f+8>>2]=0;e=J[f+4>>2];g=J[f>>2];J[f+128>>2]=g;J[f+132>>2]=e;J[f>>2]=0;J[f+4>>2]=0;J[5996]=0;h=g;g=H[f+139|0];e=(g|0)<0;g=ba(100,j|0,(e?h:f+128|0)|0,(e?J[f+132>>2]:g&255)|0)|0;e=J[5996];J[5996]=0;if((e|0)==1){break sa}if(H[f+139|0]<0){$a(J[f+128>>2]);}if(H[f+11|0]<0){$a(J[f>>2]);}J[5996]=0;e=f+128|0;ga(102,e|0,b|0,c|0,o|0);h=J[5996];J[5996]=0;if((h|0)==1){break qa}J[5996]=0;k=g;h=e;g=K[f+139|0];e=g<<24>>24<0;ba(100,k|0,(e?J[f+128>>2]:h)|0,(e?J[f+132>>2]:g)|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break pa}if(H[f+139|0]<0){$a(J[f+128>>2]);}h=K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24);}if((c|0)==(h|0)|K[h|0]!=104){break na}e=0;if((d|0)>0){while(1){J[5996]=0;_(97,j|0,5573)|0;g=J[5996];J[5996]=0;if((g|0)==1){break u}e=e+1|0;if((e|0)!=(d|0)){continue}break}h=K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24);}g=h+1|0;H[b|0]=g;H[b+1|0]=g>>>8;H[b+2|0]=g>>>16;H[b+3|0]=g>>>24;e=J[(K[h|0]<<2)+5840>>2];g=Gb(e);if(g>>>0<2147483632){break oa}J[5996]=0;ca(2);a=J[5996];J[5996]=0;if((a|0)!=1){break a}e=Z()|0;break h}e=Z()|0;break h}e=Z()|0;break ra}e=Z()|0;if(H[f+139|0]>=0){break ra}$a(J[f+128>>2]);}if(H[f+11|0]>=0){break h}$a(J[f>>2]);break h}e=Z()|0;break h}e=Z()|0;if(H[f+139|0]>=0){break h}$a(J[f+128>>2]);break h}Da:{if(g>>>0<=10){H[f+11|0]=g;h=f;break Da}J[5996]=0;k=(g|15)+1|0;h=$(3,k|0)|0;l=J[5996];J[5996]=0;if((l|0)==1){break ma}J[f>>2]=h;J[f+4>>2]=g;J[f+8>>2]=k|-2147483648;}H[eb(h,e,g)+g|0]=0;J[5996]=0;aa(98,f|0,10);g=J[5996];J[5996]=0;if((g|0)==1){break la}J[f+136>>2]=J[f+8>>2];J[f+8>>2]=0;e=J[f+4>>2];g=J[f>>2];J[f+128>>2]=g;J[f+132>>2]=e;J[f>>2]=0;J[f+4>>2]=0;J[5996]=0;h=g;g=H[f+139|0];e=(g|0)<0;ba(100,j|0,(e?h:f+128|0)|0,(e?J[f+132>>2]:g&255)|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break ka}if(H[f+139|0]<0){$a(J[f+128>>2]);}if(H[f+11|0]>=0){break na}$a(J[f>>2]);}g=K[f+155|0];n=g<<24>>24<0?J[f+148>>2]:g;break l}e=Z()|0;break h}e=Z()|0;break ja}e=Z()|0;if(H[f+139|0]>=0){break ja}$a(J[f+128>>2]);}if(H[f+11|0]>=0){break h}$a(J[f>>2]);break h}e=Z()|0;break h}e=Z()|0;break h}e=Z()|0;break h}e=Z()|0;}if(H[f+27|0]>=0){break h}$a(J[f+16>>2]);break h}e=Z()|0;}if(H[f+83|0]>=0){break h}$a(J[f+72>>2]);break h}$a(j);}J[5996]=0;_(97,f+144|0,3719)|0;g=J[5996];J[5996]=0;if((g|0)==1){break g}}if(l){break l}}e=K[f+155|0];g=e<<24>>24;h=(g|0)<0;if((h?J[f+148>>2]:e)-n>>>0<81){break l}e=0;H[(h?J[f+144>>2]:f+144|0)+p|0]=10;n=p+1|0;if((d|0)<=0){break l}while(1){J[5996]=0;ba(99,f+144|0,n|0,5573)|0;g=J[5996];J[5996]=0;if((g|0)==1){break i}e=e+1|0;if((e|0)!=(d|0)){continue}break}}g=K[f+155|0];l=((g<<24>>24<0?J[f+148>>2]:g)|0)==(n|0);e=0;}if(i){$a(i);}if(!e){continue}break}if((e|0)!=3){break c}}Ea:{if(!l){J[5996]=0;aa(98,f+144|0,10);b=J[5996];J[5996]=0;if((b|0)==1){break Ea}}b=J[f+148>>2];J[a>>2]=J[f+144>>2];J[a+4>>2]=b;J[a+8>>2]=J[f+152>>2];break b}e=Z()|0;break d}e=Z()|0;}g=i;break e}g=i;}e=Z()|0;}if(!g){break d}$a(g);}if(H[f+155|0]<0){$a(J[f+144>>2]);}da(e|0);B();}if(H[f+155|0]>=0){break b}$a(J[f+144>>2]);}Ua=f+160|0;return}B();}function ah(){var a=0,b=0,c=0,d=0,e=0,f=0,g=0;while(1){b=a<<4;c=b+22944|0;J[b+22948>>2]=c;J[b+22952>>2]=c;a=a+1|0;if((a|0)!=64){continue}break}Cd(48);a=Ua-16|0;Ua=a;a:{if(Ga(a+12|0,a+8|0)|0){break a}b=sb((J[a+12>>2]<<2)+4|0);J[6181]=b;if(!b){break a}b=sb(J[a+8>>2]);if(b){c=J[6181];J[c+(J[a+12>>2]<<2)>>2]=0;if(!(Fa(c|0,b|0)|0)){break a}}J[6181]=0;}Ua=a+16|0;a=cb(64);J[5998]=a;J[5999]=62;J[6e3]=-2147483584;b=K[3832]|K[3833]<<8|(K[3834]<<16|K[3835]<<24);c=K[3828]|K[3829]<<8|(K[3830]<<16|K[3831]<<24);H[a+54|0]=c;H[a+55|0]=c>>>8;H[a+56|0]=c>>>16;H[a+57|0]=c>>>24;H[a+58|0]=b;H[a+59|0]=b>>>8;H[a+60|0]=b>>>16;H[a+61|0]=b>>>24;b=K[3826]|K[3827]<<8|(K[3828]<<16|K[3829]<<24);c=K[3822]|K[3823]<<8|(K[3824]<<16|K[3825]<<24);H[a+48|0]=c;H[a+49|0]=c>>>8;H[a+50|0]=c>>>16;H[a+51|0]=c>>>24;H[a+52|0]=b;H[a+53|0]=b>>>8;H[a+54|0]=b>>>16;H[a+55|0]=b>>>24;b=K[3818]|K[3819]<<8|(K[3820]<<16|K[3821]<<24);c=K[3814]|K[3815]<<8|(K[3816]<<16|K[3817]<<24);H[a+40|0]=c;H[a+41|0]=c>>>8;H[a+42|0]=c>>>16;H[a+43|0]=c>>>24;H[a+44|0]=b;H[a+45|0]=b>>>8;H[a+46|0]=b>>>16;H[a+47|0]=b>>>24;b=K[3810]|K[3811]<<8|(K[3812]<<16|K[3813]<<24);c=K[3806]|K[3807]<<8|(K[3808]<<16|K[3809]<<24);H[a+32|0]=c;H[a+33|0]=c>>>8;H[a+34|0]=c>>>16;H[a+35|0]=c>>>24;H[a+36|0]=b;H[a+37|0]=b>>>8;H[a+38|0]=b>>>16;H[a+39|0]=b>>>24;b=K[3802]|K[3803]<<8|(K[3804]<<16|K[3805]<<24);c=K[3798]|K[3799]<<8|(K[3800]<<16|K[3801]<<24);H[a+24|0]=c;H[a+25|0]=c>>>8;H[a+26|0]=c>>>16;H[a+27|0]=c>>>24;H[a+28|0]=b;H[a+29|0]=b>>>8;H[a+30|0]=b>>>16;H[a+31|0]=b>>>24;b=K[3794]|K[3795]<<8|(K[3796]<<16|K[3797]<<24);c=K[3790]|K[3791]<<8|(K[3792]<<16|K[3793]<<24);H[a+16|0]=c;H[a+17|0]=c>>>8;H[a+18|0]=c>>>16;H[a+19|0]=c>>>24;H[a+20|0]=b;H[a+21|0]=b>>>8;H[a+22|0]=b>>>16;H[a+23|0]=b>>>24;b=K[3786]|K[3787]<<8|(K[3788]<<16|K[3789]<<24);c=K[3782]|K[3783]<<8|(K[3784]<<16|K[3785]<<24);H[a+8|0]=c;H[a+9|0]=c>>>8;H[a+10|0]=c>>>16;H[a+11|0]=c>>>24;H[a+12|0]=b;H[a+13|0]=b>>>8;H[a+14|0]=b>>>16;H[a+15|0]=b>>>24;b=K[3778]|K[3779]<<8|(K[3780]<<16|K[3781]<<24);c=K[3774]|K[3775]<<8|(K[3776]<<16|K[3777]<<24);H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[a+4|0]=b;H[a+5|0]=b>>>8;H[a+6|0]=b>>>16;H[a+7|0]=b>>>24;H[a+62|0]=0;a=K[24003];b=a<<24>>24;b:{c:{d=(b|0)<0?J[5999]:a;a=d+12|0;if(a>>>0<2147483632){d:{if(a>>>0<=10){J[6004]=0;J[6005]=0;J[6006]=0;H[24027]=a;c=24016;break d}e=(a|15)+1|0;c=cb(e);J[6005]=a;J[6004]=c;J[6006]=e|-2147483648;}a=c;c=(b|0)>=0?23992:J[5998];a=eb(a,c,d)+d|0;H[a+12|0]=0;b=K[5207]|K[5208]<<8|(K[5209]<<16|K[5210]<<24);H[a+8|0]=b;H[a+9|0]=b>>>8;H[a+10|0]=b>>>16;H[a+11|0]=b>>>24;b=K[5203]|K[5204]<<8|(K[5205]<<16|K[5206]<<24);e=K[5199]|K[5200]<<8|(K[5201]<<16|K[5202]<<24);H[a|0]=e;H[a+1|0]=e>>>8;H[a+2|0]=e>>>16;H[a+3|0]=e>>>24;H[a+4|0]=b;H[a+5|0]=b>>>8;H[a+6|0]=b>>>16;H[a+7|0]=b>>>24;e:{a=d+8|0;f:{if(a>>>0>=2147483632){J[5996]=0;ca(2);b=J[5996];J[5996]=0;a=24028;if((b|0)==1){break f}break c}g:{if(a>>>0<=10){J[6007]=0;J[6008]=0;J[6009]=0;H[24039]=a;b=24028;break g}J[5996]=0;e=(a|15)+1|0;b=$(3,e|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){a=24028;break f}J[6008]=a;J[6007]=b;J[6009]=e|-2147483648;}a=eb(b,c,d)+d|0;H[a+8|0]=0;H[a|0]=32;H[a+1|0]=46;H[a+2|0]=44;H[a+3|0]=59;H[a+4|0]=45;H[a+5|0]=95;H[a+6|0]=63;H[a+7|0]=64;a=d+3|0;if(a>>>0>=2147483632){J[5996]=0;ca(2);b=J[5996];J[5996]=0;a=24040;if((b|0)!=1){break c}break f}h:{if(a>>>0<=10){J[6010]=0;J[6011]=0;J[6012]=0;H[24051]=a;b=24040;break h}J[5996]=0;e=(a|15)+1|0;b=$(3,e|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){a=24040;break f}J[6011]=a;J[6010]=b;J[6012]=e|-2147483648;}a=eb(b,c,d)+d|0;H[a+3|0]=0;H[a+2|0]=K[2557];b=K[2555]|K[2556]<<8;H[a|0]=b;H[a+1|0]=b>>>8;a=d+23|0;if(a>>>0>=2147483632){J[5996]=0;ca(2);b=J[5996];J[5996]=0;a=24052;if((b|0)!=1){break c}break f}J[5996]=0;e=(a|15)+1|0;b=$(3,e|0)|0;f=J[5996];J[5996]=0;if((f|0)!=1){break e}a=24052;}c=Z()|0;while(1){b=a-12|0;if(H[a-1|0]<0){$a(J[b>>2]);}a=b;if((a|0)!=24016){continue}break}da(c|0);B();}J[6014]=a;J[6013]=b;J[6015]=e|-2147483648;a=eb(b,c,d)+d|0;H[a+23|0]=0;b=K[5412]|K[5413]<<8|(K[5414]<<16|K[5415]<<24);c=K[5408]|K[5409]<<8|(K[5410]<<16|K[5411]<<24);H[a+15|0]=c;H[a+16|0]=c>>>8;H[a+17|0]=c>>>16;H[a+18|0]=c>>>24;H[a+19|0]=b;H[a+20|0]=b>>>8;H[a+21|0]=b>>>16;H[a+22|0]=b>>>24;b=K[5405]|K[5406]<<8|(K[5407]<<16|K[5408]<<24);c=K[5401]|K[5402]<<8|(K[5403]<<16|K[5404]<<24);H[a+8|0]=c;H[a+9|0]=c>>>8;H[a+10|0]=c>>>16;H[a+11|0]=c>>>24;H[a+12|0]=b;H[a+13|0]=b>>>8;H[a+14|0]=b>>>16;H[a+15|0]=b>>>24;b=K[5397]|K[5398]<<8|(K[5399]<<16|K[5400]<<24);c=K[5393]|K[5394]<<8|(K[5395]<<16|K[5396]<<24);H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[a+4|0]=b;H[a+5|0]=b>>>8;H[a+6|0]=b>>>16;H[a+7|0]=b>>>24;break b}ub();B();}B();}d=Ua-48|0;Ua=d;J[d+20>>2]=0;J[d+12>>2]=0;J[d+16>>2]=0;J[5996]=0;_(9,24064,d+12|0)|0;a=J[5996];J[5996]=0;i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{if((a|0)!=1){a=J[d+12>>2];if(a){$a(a);}a=cb(32);J[d+36>>2]=a;b=a+32|0;J[d+44>>2]=b;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;J[5996]=0;J[d+40>>2]=b;f=_(9,d+12|0,d+36|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break m}H[f+5|0]=1;J[6024]=J[f+8>>2];a=J[f+4>>2];J[6022]=J[f>>2];J[6023]=a;J[6025]=0;J[6026]=0;J[6027]=0;c=J[f+16>>2];b=J[f+12>>2];a=c-b|0;e=(a|0)/12|0;if((b|0)==(c|0)){break n}if(e>>>0<357913942){break r}J[5996]=0;ca(11);a=J[5996];J[5996]=0;if((a|0)==1){break q}B();}e=Z()|0;a=J[d+12>>2];if(!a){break i}$a(a);break i}J[5996]=0;a=$(3,a|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break q}J[6026]=a;J[6025]=a;J[6027]=a+P(e,12);J[5996]=0;b=ia(12,24108,b|0,c|0,a|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){break o}e=Z()|0;J[6026]=a;break p}e=Z()|0;}c=J[6025];if(c){a=J[6026];b=c;if((a|0)!=(b|0)){while(1){b=a-12|0;g=J[b>>2];if(g){J[a-8>>2]=g;$a(g);}a=b;if((c|0)!=(a|0)){continue}break}b=J[6025];}J[6026]=c;$a(b);}c=J[f+12>>2];if(!c){break j}a=J[f+16>>2];b=c;if((a|0)!=(b|0)){while(1){b=a-12|0;g=J[b>>2];if(g){J[a-8>>2]=g;$a(g);}a=b;if((c|0)!=(a|0)){continue}break}b=J[f+12>>2];}J[f+16>>2]=c;$a(b);break j}J[6026]=b;c=J[f+12>>2];}if(c){a=J[f+16>>2];b=c;if((a|0)!=(b|0)){while(1){b=a-12|0;e=J[b>>2];if(e){J[a-8>>2]=e;$a(e);}a=b;if((c|0)!=(a|0)){continue}break}b=J[f+12>>2];}J[f+16>>2]=c;$a(b);}a=J[d+36>>2];if(a){$a(a);}a=cb(1);J[d+36>>2]=a;b=a+1|0;J[d+44>>2]=b;H[a|0]=1;J[5996]=0;J[d+40>>2]=b;_(9,24112,d+36|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break l}a=J[d+36>>2];if(a){$a(a);}J[6036]=0;J[6037]=0;J[6034]=1;J[6038]=0;J[6039]=0;H[24142]=0;I[12070]=0;J[6044]=0;J[6045]=0;J[6042]=-1;J[6043]=0;H[24163]=0;H[24164]=0;H[24165]=0;H[24166]=0;J[6040]=0;Ua=d+48|0;break k}e=Z()|0;break j}e=Z()|0;break j}d=Ua-48|0;Ua=d;J[d+20>>2]=0;J[d+12>>2]=0;J[d+16>>2]=0;J[5996]=0;_(9,24184,d+12|0)|0;a=J[5996];J[5996]=0;s:{t:{u:{v:{w:{x:{y:{z:{A:{B:{if((a|0)!=1){a=J[d+12>>2];if(a){$a(a);}a=cb(32);J[d+36>>2]=a;b=a+32|0;J[d+44>>2]=b;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;J[5996]=0;J[d+40>>2]=b;f=_(9,d+12|0,d+36|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break w}H[f+5|0]=1;J[6054]=J[f+8>>2];a=J[f+4>>2];J[6052]=J[f>>2];J[6053]=a;J[6055]=0;J[6056]=0;J[6057]=0;c=J[f+16>>2];b=J[f+12>>2];a=c-b|0;e=(a|0)/12|0;if((b|0)==(c|0)){break x}if(e>>>0<357913942){break B}J[5996]=0;ca(11);a=J[5996];J[5996]=0;if((a|0)==1){break A}B();}e=Z()|0;a=J[d+12>>2];if(!a){break i}$a(a);break i}J[5996]=0;a=$(3,a|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break A}J[6056]=a;J[6055]=a;J[6057]=a+P(e,12);J[5996]=0;b=ia(12,24228,b|0,c|0,a|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){break y}e=Z()|0;J[6056]=a;break z}e=Z()|0;}c=J[6055];if(c){a=c;b=J[6056];if((a|0)!=(b|0)){while(1){a=b-12|0;g=J[a>>2];if(g){J[b-8>>2]=g;$a(g);}b=a;if((a|0)!=(c|0)){continue}break}a=J[6055];}J[6056]=c;$a(a);}c=J[f+12>>2];if(!c){break j}a=c;b=J[f+16>>2];if((a|0)!=(b|0)){while(1){a=b-12|0;g=J[a>>2];if(g){J[b-8>>2]=g;$a(g);}b=a;if((a|0)!=(c|0)){continue}break}a=J[f+12>>2];}J[f+16>>2]=c;$a(a);break j}J[6056]=b;c=J[f+12>>2];}if(c){a=c;b=J[f+16>>2];if((a|0)!=(b|0)){while(1){a=b-12|0;e=J[a>>2];if(e){J[b-8>>2]=e;$a(e);}b=a;if((a|0)!=(c|0)){continue}break}a=J[f+12>>2];}J[f+16>>2]=c;$a(a);}a=J[d+36>>2];if(a){$a(a);}a=cb(1);J[d+36>>2]=a;b=a+1|0;J[d+44>>2]=b;H[a|0]=1;J[5996]=0;J[d+40>>2]=b;_(9,24232,d+36|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break v}a=J[d+36>>2];if(a){$a(a);}J[6066]=0;J[6067]=0;J[6064]=1;J[6068]=0;J[6069]=0;H[24262]=0;I[12130]=0;J[6074]=0;J[6075]=0;J[6072]=-1;J[6073]=0;H[24283]=0;H[24284]=0;H[24285]=0;H[24286]=0;J[6070]=0;J[6076]=0;J[6077]=0;J[6078]=0;b=cb(56);J[b>>2]=0;J[b+4>>2]=0;J[b+40>>2]=0;J[b+44>>2]=0;J[b+32>>2]=0;J[b+36>>2]=0;J[b+24>>2]=0;J[b+28>>2]=0;J[b+16>>2]=0;J[b+20>>2]=0;J[b+8>>2]=0;J[b+12>>2]=0;mc(24304,b);a=cb(4);J[a>>2]=b;J[5996]=0;b=$(3,56)|0;c=J[5996];J[5996]=0;if((c|0)!=1){break u}break t}e=Z()|0;break j}e=Z()|0;break j}J[b+16>>2]=0;J[b+20>>2]=0;J[b+4>>2]=a;J[b>>2]=21;a=a+4|0;J[b+12>>2]=a;J[b+8>>2]=a;J[b+24>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[b+36>>2]=0;J[b+40>>2]=0;J[b+44>>2]=0;mc(24304,b);J[6079]=b;b=cb(56);J[b+4>>2]=0;J[b+8>>2]=0;J[b>>2]=1;J[b+12>>2]=0;J[b+16>>2]=0;J[b+20>>2]=0;J[b+24>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[b+36>>2]=0;J[b+40>>2]=0;J[b+44>>2]=0;mc(24304,b);a=cb(4);J[a>>2]=b;J[5996]=0;b=$(3,56)|0;c=J[5996];J[5996]=0;if((c|0)==1){break t}J[b+16>>2]=0;J[b+20>>2]=0;J[b+4>>2]=a;J[b>>2]=21;a=a+4|0;J[b+12>>2]=a;J[b+8>>2]=a;J[b+24>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[b+36>>2]=0;J[b+40>>2]=0;J[b+44>>2]=0;mc(24304,b);J[6080]=b;Ua=d+48|0;break s}b=Z()|0;$a(a);da(b|0);B();}d=Ua-48|0;Ua=d;J[d+20>>2]=0;J[d+12>>2]=0;J[d+16>>2]=0;J[5996]=0;_(9,24592,d+12|0)|0;a=J[5996];J[5996]=0;C:{D:{E:{F:{G:{H:{I:{J:{if((a|0)!=1){a=J[d+12>>2];if(a){$a(a);}a=cb(32);J[d+36>>2]=a;b=a+32|0;J[d+44>>2]=b;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;J[5996]=0;J[d+40>>2]=b;f=_(9,d+12|0,d+36|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break E}H[f+5|0]=1;J[6156]=J[f+8>>2];a=J[f+4>>2];J[6154]=J[f>>2];J[6155]=a;J[6157]=0;J[6158]=0;J[6159]=0;c=J[f+16>>2];b=J[f+12>>2];a=c-b|0;e=(a|0)/12|0;if((b|0)==(c|0)){break F}if(e>>>0<357913942){break J}J[5996]=0;ca(11);a=J[5996];J[5996]=0;if((a|0)==1){break I}B();}e=Z()|0;a=J[d+12>>2];if(!a){break i}$a(a);break i}J[5996]=0;a=$(3,a|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break I}J[6158]=a;J[6157]=a;J[6159]=a+P(e,12);J[5996]=0;b=ia(12,24636,b|0,c|0,a|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){break G}e=Z()|0;J[6158]=a;break H}e=Z()|0;}c=J[6157];if(c){a=J[6158];b=c;if((a|0)!=(b|0)){while(1){b=a-12|0;g=J[b>>2];if(g){J[a-8>>2]=g;$a(g);}a=b;if((c|0)!=(a|0)){continue}break}b=J[6157];}J[6158]=c;$a(b);}c=J[f+12>>2];if(!c){break j}a=J[f+16>>2];b=c;if((a|0)!=(b|0)){while(1){b=a-12|0;g=J[b>>2];if(g){J[a-8>>2]=g;$a(g);}a=b;if((c|0)!=(a|0)){continue}break}b=J[f+12>>2];}J[f+16>>2]=c;$a(b);break j}J[6158]=b;c=J[f+12>>2];}if(c){a=J[f+16>>2];b=c;if((a|0)!=(b|0)){while(1){b=a-12|0;e=J[b>>2];if(e){J[a-8>>2]=e;$a(e);}a=b;if((c|0)!=(a|0)){continue}break}b=J[f+12>>2];}J[f+16>>2]=c;$a(b);}a=J[d+36>>2];if(a){$a(a);}a=cb(1);J[d+36>>2]=a;b=a+1|0;J[d+44>>2]=b;H[a|0]=1;J[5996]=0;J[d+40>>2]=b;_(9,24640,d+36|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break D}a=J[d+36>>2];if(a){$a(a);}J[6168]=0;J[6169]=0;J[6166]=1;J[6170]=0;J[6171]=0;H[24670]=0;I[12334]=0;J[6176]=0;J[6177]=0;J[6174]=-1;J[6175]=0;H[24691]=0;H[24692]=0;H[24693]=0;H[24694]=0;J[6172]=0;Ua=d+48|0;break C}e=Z()|0;break j}e=Z()|0;break j}J[6178]=24816;return}a=J[d+36>>2];if(!a){break i}$a(a);}da(e|0);B();}function fn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;g=Ua-96|0;Ua=g;J[g+36>>2]=0;J[g+28>>2]=0;J[g+32>>2]=0;J[5996]=0;k=$(3,12)|0;c=J[5996];J[5996]=0;a:{if((c|0)!=1){r=g+36|0;H[k+8|0]=0;J[k+4>>2]=0;J[k>>2]=b;f=k+12|0;q=f;b:{while(1){i=f-12|0;c=i;j=J[c+4>>2];n=J[c>>2];d=J[n+32>>2];c:{d:{e:{h=J[n+36>>2]-d>>3;if(h>>>0>j>>>0){b=1;J[c+4>>2]=j+1;e=K[f-4|0];f:{g:{h:{c=J[n>>2];switch(c-11|0){case 0:break g;case 3:break f;default:break h}}b=0;if((j|0)!=1|(c|0)!=17){break f}}b=(e|0)!=0;}j=J[d+(j<<3)>>2];if(f>>>0<q>>>0){H[f+8|0]=b;J[f+4>>2]=0;J[f>>2]=j;f=f+12|0;break c}i:{d=(f-k|0)/12|0;i=d+1|0;j:{if(i>>>0>=357913942){J[5996]=0;ca(121);a=J[5996];J[5996]=0;if((a|0)==1){break j}break a}e=(q-k|0)/12|0;c=e<<1;c=e>>>0>=178956970?357913941:c>>>0>i>>>0?c:i;if(c>>>0<357913942){break i}J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}}l=Z()|0;break b}J[5996]=0;i=P(c,12);h=$(3,i|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break e}c=h+P(d,12)|0;H[c+8|0]=b;J[c+4>>2]=0;J[c>>2]=j;b=c;if((f|0)!=(k|0)){while(1){f=f-12|0;d=f;e=J[d+4>>2];b=b-12|0;J[b>>2]=J[d>>2];J[b+4>>2]=e;J[b+8>>2]=J[d+8>>2];if((d|0)!=(k|0)){continue}break}}q=h+i|0;f=c+12|0;if(k){$a(k);}k=b;break c}e=J[g+28>>2];c=J[g+32>>2]-e>>5;if(c>>>0<h>>>0){J[5996]=0;ga(44,5135,2210,439,2439);a=J[5996];J[5996]=0;if((a|0)!=1){break a}l=Z()|0;break b}b=K[f-4|0];J[5996]=0;oa(122,g+40|0,b|0,n|0,(e+(c<<5)|0)-(h<<5)|0,h|0);b=J[5996];J[5996]=0;if((b|0)==1){l=Z()|0;break b}b=J[g+64>>2];J[g+16>>2]=J[g+60>>2];J[g+20>>2]=b;J[g+24>>2]=J[g+68>>2];b=J[g+56>>2];J[g+8>>2]=J[g+52>>2];J[g+12>>2]=b;o=J[g+48>>2];m=J[g+44>>2];j=J[g+40>>2];b=J[g+32>>2];e=J[n+36>>2];c=J[n+32>>2];k:{if((e|0)==(c|0)){c=b;break k}e=e-c<<2;c=b-e|0;f=c+(e&-32)|0;if((f|0)!=(b|0)){while(1){d=g- -64|0;J[d>>2]=K[c+28|0]|K[c+29|0]<<8|(K[c+30|0]<<16|K[c+31|0]<<24);e=K[c+24|0]|K[c+25|0]<<8|(K[c+26|0]<<16|K[c+27|0]<<24);J[g+56>>2]=K[c+20|0]|K[c+21|0]<<8|(K[c+22|0]<<16|K[c+23|0]<<24);J[g+60>>2]=e;e=K[c+16|0]|K[c+17|0]<<8|(K[c+18|0]<<16|K[c+19|0]<<24);J[g+48>>2]=K[c+12|0]|K[c+13|0]<<8|(K[c+14|0]<<16|K[c+15|0]<<24);J[g+52>>2]=e;e=K[c+8|0]|K[c+9|0]<<8|(K[c+10|0]<<16|K[c+11|0]<<24);J[g+40>>2]=K[c+4|0]|K[c+5|0]<<8|(K[c+6|0]<<16|K[c+7|0]<<24);J[g+44>>2]=e;e=K[f+28|0]|K[f+29|0]<<8|(K[f+30|0]<<16|K[f+31|0]<<24);H[c+28|0]=e;H[c+29|0]=e>>>8;H[c+30|0]=e>>>16;H[c+31|0]=e>>>24;h=K[f+24|0]|K[f+25|0]<<8|(K[f+26|0]<<16|K[f+27|0]<<24);e=K[f+20|0]|K[f+21|0]<<8|(K[f+22|0]<<16|K[f+23|0]<<24);H[c+20|0]=e;H[c+21|0]=e>>>8;H[c+22|0]=e>>>16;H[c+23|0]=e>>>24;H[c+24|0]=h;H[c+25|0]=h>>>8;H[c+26|0]=h>>>16;H[c+27|0]=h>>>24;h=K[f+16|0]|K[f+17|0]<<8|(K[f+18|0]<<16|K[f+19|0]<<24);e=K[f+12|0]|K[f+13|0]<<8|(K[f+14|0]<<16|K[f+15|0]<<24);H[c+12|0]=e;H[c+13|0]=e>>>8;H[c+14|0]=e>>>16;H[c+15|0]=e>>>24;H[c+16|0]=h;H[c+17|0]=h>>>8;H[c+18|0]=h>>>16;H[c+19|0]=h>>>24;h=K[f+8|0]|K[f+9|0]<<8|(K[f+10|0]<<16|K[f+11|0]<<24);e=K[f+4|0]|K[f+5|0]<<8|(K[f+6|0]<<16|K[f+7|0]<<24);H[c+4|0]=e;H[c+5|0]=e>>>8;H[c+6|0]=e>>>16;H[c+7|0]=e>>>24;H[c+8|0]=h;H[c+9|0]=h>>>8;H[c+10|0]=h>>>16;H[c+11|0]=h>>>24;e=J[d>>2];H[f+28|0]=e;H[f+29|0]=e>>>8;H[f+30|0]=e>>>16;H[f+31|0]=e>>>24;d=J[g+60>>2];e=J[g+56>>2];H[f+20|0]=e;H[f+21|0]=e>>>8;H[f+22|0]=e>>>16;H[f+23|0]=e>>>24;H[f+24|0]=d;H[f+25|0]=d>>>8;H[f+26|0]=d>>>16;H[f+27|0]=d>>>24;d=J[g+52>>2];e=J[g+48>>2];H[f+12|0]=e;H[f+13|0]=e>>>8;H[f+14|0]=e>>>16;H[f+15|0]=e>>>24;H[f+16|0]=d;H[f+17|0]=d>>>8;H[f+18|0]=d>>>16;H[f+19|0]=d>>>24;d=J[g+44>>2];e=J[g+40>>2];H[f+4|0]=e;H[f+5|0]=e>>>8;H[f+6|0]=e>>>16;H[f+7|0]=e>>>24;H[f+8|0]=d;H[f+9|0]=d>>>8;H[f+10|0]=d>>>16;H[f+11|0]=d>>>24;e=J[c>>2];J[c>>2]=J[f>>2];J[f>>2]=e;c=c+32|0;f=f+32|0;if((f|0)!=(b|0)){continue}break}}if((b|0)!=(c|0)){while(1){e=b-32|0;if((K[e|0]|K[e+1|0]<<8|(K[e+2|0]<<16|K[e+3|0]<<24))>>>0>=29){b=b-24|0;$a(K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24));H[b|0]=0;H[b+1|0]=0;H[b+2|0]=0;H[b+3|0]=0;}b=e;if((c|0)!=(b|0)){continue}break}}J[g+32>>2]=c;}f=J[g+36>>2];if(f>>>0>c>>>0){H[c+4|0]=0;H[c+5|0]=0;H[c+6|0]=0;H[c+7|0]=0;H[c+8|0]=0;H[c+9|0]=0;H[c+10|0]=0;H[c+11|0]=0;H[c+28|0]=0;H[c+29|0]=0;H[c+30|0]=0;H[c+31|0]=0;H[c+20|0]=0;H[c+21|0]=0;H[c+22|0]=0;H[c+23|0]=0;H[c+24|0]=0;H[c+25|0]=0;H[c+26|0]=0;H[c+27|0]=0;H[c+12|0]=0;H[c+13|0]=0;H[c+14|0]=0;H[c+15|0]=0;H[c+16|0]=0;H[c+17|0]=0;H[c+18|0]=0;H[c+19|0]=0;H[c+8|0]=o;H[c+9|0]=o>>>8;H[c+10|0]=o>>>16;H[c+11|0]=o>>>24;H[c+4|0]=m;H[c+5|0]=m>>>8;H[c+6|0]=m>>>16;H[c+7|0]=m>>>24;e=J[g+12>>2];b=J[g+8>>2];H[c+12|0]=b;H[c+13|0]=b>>>8;H[c+14|0]=b>>>16;H[c+15|0]=b>>>24;H[c+16|0]=e;H[c+17|0]=e>>>8;H[c+18|0]=e>>>16;H[c+19|0]=e>>>24;e=J[g+20>>2];b=J[g+16>>2];H[c+20|0]=b;H[c+21|0]=b>>>8;H[c+22|0]=b>>>16;H[c+23|0]=b>>>24;H[c+24|0]=e;H[c+25|0]=e>>>8;H[c+26|0]=e>>>16;H[c+27|0]=e>>>24;b=J[g+24>>2];H[c+28|0]=b;H[c+29|0]=b>>>8;H[c+30|0]=b>>>16;H[c+31|0]=b>>>24;J[c>>2]=j;J[g+32>>2]=c+32;break d}l:{m:{n:{p=J[g+28>>2];d=c-p>>5;h=d+1|0;o:{if(h>>>0>=134217728){J[5996]=0;ca(123);break o}J[g+92>>2]=r;e=f-p|0;b=e>>4;h=e>>>0>=2147483616?134217727:b>>>0>h>>>0?b:h;if(!h){b=0;break m}if(h>>>0<134217728){break n}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}break l}J[5996]=0;b=$(3,h<<5)|0;e=J[5996];J[5996]=0;if((e|0)==1){break l}}J[g+76>>2]=b;l=(h<<5)+b|0;J[g+88>>2]=l;h=(d<<5)+b|0;J[g+80>>2]=h;d=h;H[d+24|0]=0;H[d+25|0]=0;H[d+26|0]=0;H[d+27|0]=0;H[d+28|0]=0;H[d+29|0]=0;H[d+30|0]=0;H[d+31|0]=0;H[d+16|0]=0;H[d+17|0]=0;H[d+18|0]=0;H[d+19|0]=0;H[d+20|0]=0;H[d+21|0]=0;H[d+22|0]=0;H[d+23|0]=0;H[d+8|0]=0;H[d+9|0]=0;H[d+10|0]=0;H[d+11|0]=0;H[d+12|0]=0;H[d+13|0]=0;H[d+14|0]=0;H[d+15|0]=0;H[d|0]=0;H[d+1|0]=0;H[d+2|0]=0;H[d+3|0]=0;H[d+4|0]=0;H[d+5|0]=0;H[d+6|0]=0;H[d+7|0]=0;J[g+56>>2]=K[d+28|0]|K[d+29|0]<<8|(K[d+30|0]<<16|K[d+31|0]<<24);b=K[d+24|0]|K[d+25|0]<<8|(K[d+26|0]<<16|K[d+27|0]<<24);J[g+48>>2]=K[d+20|0]|K[d+21|0]<<8|(K[d+22|0]<<16|K[d+23|0]<<24);J[g+52>>2]=b;b=K[d+16|0]|K[d+17|0]<<8|(K[d+18|0]<<16|K[d+19|0]<<24);J[g+40>>2]=K[d+12|0]|K[d+13|0]<<8|(K[d+14|0]<<16|K[d+15|0]<<24);J[g+44>>2]=b;H[d+8|0]=o;H[d+9|0]=o>>>8;H[d+10|0]=o>>>16;H[d+11|0]=o>>>24;H[d+4|0]=m;H[d+5|0]=m>>>8;H[d+6|0]=m>>>16;H[d+7|0]=m>>>24;b=J[g+24>>2];H[d+28|0]=b;H[d+29|0]=b>>>8;H[d+30|0]=b>>>16;H[d+31|0]=b>>>24;e=J[g+20>>2];b=J[g+16>>2];H[d+20|0]=b;H[d+21|0]=b>>>8;H[d+22|0]=b>>>16;H[d+23|0]=b>>>24;H[d+24|0]=e;H[d+25|0]=e>>>8;H[d+26|0]=e>>>16;H[d+27|0]=e>>>24;e=J[g+12>>2];b=J[g+8>>2];H[d+12|0]=b;H[d+13|0]=b>>>8;H[d+14|0]=b>>>16;H[d+15|0]=b>>>24;H[d+16|0]=e;H[d+17|0]=e>>>8;H[d+18|0]=e>>>16;H[d+19|0]=e>>>24;b=J[g+52>>2];J[g+16>>2]=J[g+48>>2];J[g+20>>2]=b;J[g+24>>2]=J[g+56>>2];b=J[g+44>>2];J[g+8>>2]=J[g+40>>2];J[g+12>>2]=b;J[d>>2]=j;b=d+32|0;J[g+84>>2]=b;p:{if((c|0)==(p|0)){e=c;}else {while(1){b=d;d=d-32|0;H[d|0]=0;H[d+1|0]=0;H[d+2|0]=0;H[d+3|0]=0;H[d+4|0]=0;H[d+5|0]=0;H[d+6|0]=0;H[d+7|0]=0;H[d+24|0]=0;H[d+25|0]=0;H[d+26|0]=0;H[d+27|0]=0;H[d+28|0]=0;H[d+29|0]=0;H[d+30|0]=0;H[d+31|0]=0;H[d+16|0]=0;H[d+17|0]=0;H[d+18|0]=0;H[d+19|0]=0;H[d+20|0]=0;H[d+21|0]=0;H[d+22|0]=0;H[d+23|0]=0;H[d+8|0]=0;H[d+9|0]=0;H[d+10|0]=0;H[d+11|0]=0;H[d+12|0]=0;H[d+13|0]=0;H[d+14|0]=0;H[d+15|0]=0;e=c;c=c-32|0;f=K[c|0]|K[c+1|0]<<8|(K[c+2|0]<<16|K[c+3|0]<<24);J[5996]=0;j=f>>>0<29?f:f-29|0;aa(124,d|0,j|0);f=J[5996];J[5996]=0;if((f|0)==1){break p}m=j+(K[d|0]|K[d+1|0]<<8|(K[d+2|0]<<16|K[d+3|0]<<24))|0;H[d|0]=m;H[d+1|0]=m>>>8;H[d+2|0]=m>>>16;H[d+3|0]=m>>>24;f=K[c|0]|K[c+1|0]<<8|(K[c+2|0]<<16|K[c+3|0]<<24);j=f>>>0<29;n=j?f:f-29|0;q:{if(!n){break q}f=b-28|0;b=b-24|0;f=m>>>0<29?f:K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24);l=0;b=e-24|0;j=j?e-28|0:K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24);b=j;e=n&7;if(e){while(1){H[f|0]=K[b|0];b=b+1|0;f=f+1|0;l=l+1|0;if((e|0)!=(l|0)){continue}break}}if(n>>>0<8){break q}e=j+n|0;while(1){H[f|0]=K[b|0];H[f+1|0]=K[b+1|0];H[f+2|0]=K[b+2|0];H[f+3|0]=K[b+3|0];H[f+4|0]=K[b+4|0];H[f+5|0]=K[b+5|0];H[f+6|0]=K[b+6|0];H[f+7|0]=K[b+7|0];f=f+8|0;b=b+8|0;if((e|0)!=(b|0)){continue}break}}if((c|0)!=(p|0)){continue}break}l=J[g+88>>2];f=J[g+36>>2];b=J[g+84>>2];c=J[g+32>>2];e=J[g+28>>2];}J[g+80>>2]=e;J[g+28>>2]=d;J[g+32>>2]=b;J[g+36>>2]=l;J[g+88>>2]=f;J[g+76>>2]=e;J[g+84>>2]=c;if((c|0)!=(e|0)){while(1){b=c-32|0;J[g+84>>2]=b;if((K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24))>>>0>=29){b=c-24|0;$a(K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24));H[b|0]=0;H[b+1|0]=0;H[b+2|0]=0;H[b+3|0]=0;b=J[g+84>>2];}c=b;if((e|0)!=(c|0)){continue}break}c=J[g+76>>2];}if(!c){break d}$a(c);f=i;break c}l=Z()|0;if((b|0)!=(h|0)){while(1){if((K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24))>>>0>=29){$a(K[b+8|0]|K[b+9|0]<<8|(K[b+10|0]<<16|K[b+11|0]<<24));H[b+8|0]=0;H[b+9|0]=0;H[b+10|0]=0;H[b+11|0]=0;}b=b+32|0;if((h|0)!=(b|0)){continue}break}}b=J[g+84>>2];c=J[g+80>>2];if((b|0)!=(c|0)){while(1){a=b-32|0;J[g+84>>2]=a;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0>=29){a=b-24|0;$a(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24));H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;a=J[g+84>>2];}b=a;if((c|0)!=(b|0)){continue}break}}a=J[g+76>>2];if(a){$a(a);}break b}l=Z()|0;if(j>>>0<29){break b}$a(o);break b}l=Z()|0;break b}f=i;}if((f|0)!=(k|0)){continue}break}b=J[g+32>>2];c=J[g+28>>2];if((b-c|0)!=32){J[5996]=0;ga(44,4102,2210,450,2439);a=J[5996];J[5996]=0;if((a|0)!=1){break a}l=Z()|0;break b}H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;i=g- -64|0;J[i>>2]=K[a+28|0]|K[a+29|0]<<8|(K[a+30|0]<<16|K[a+31|0]<<24);e=K[a+24|0]|K[a+25|0]<<8|(K[a+26|0]<<16|K[a+27|0]<<24);J[g+56>>2]=K[a+20|0]|K[a+21|0]<<8|(K[a+22|0]<<16|K[a+23|0]<<24);J[g+60>>2]=e;e=K[a+16|0]|K[a+17|0]<<8|(K[a+18|0]<<16|K[a+19|0]<<24);J[g+48>>2]=K[a+12|0]|K[a+13|0]<<8|(K[a+14|0]<<16|K[a+15|0]<<24);J[g+52>>2]=e;e=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);J[g+40>>2]=K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24);J[g+44>>2]=e;e=K[c+28|0]|K[c+29|0]<<8|(K[c+30|0]<<16|K[c+31|0]<<24);H[a+28|0]=e;H[a+29|0]=e>>>8;H[a+30|0]=e>>>16;H[a+31|0]=e>>>24;d=K[c+24|0]|K[c+25|0]<<8|(K[c+26|0]<<16|K[c+27|0]<<24);e=K[c+20|0]|K[c+21|0]<<8|(K[c+22|0]<<16|K[c+23|0]<<24);H[a+20|0]=e;H[a+21|0]=e>>>8;H[a+22|0]=e>>>16;H[a+23|0]=e>>>24;H[a+24|0]=d;H[a+25|0]=d>>>8;H[a+26|0]=d>>>16;H[a+27|0]=d>>>24;d=K[c+16|0]|K[c+17|0]<<8|(K[c+18|0]<<16|K[c+19|0]<<24);e=K[c+12|0]|K[c+13|0]<<8|(K[c+14|0]<<16|K[c+15|0]<<24);H[a+12|0]=e;H[a+13|0]=e>>>8;H[a+14|0]=e>>>16;H[a+15|0]=e>>>24;H[a+16|0]=d;H[a+17|0]=d>>>8;H[a+18|0]=d>>>16;H[a+19|0]=d>>>24;d=K[c+8|0]|K[c+9|0]<<8|(K[c+10|0]<<16|K[c+11|0]<<24);e=K[c+4|0]|K[c+5|0]<<8|(K[c+6|0]<<16|K[c+7|0]<<24);H[a+4|0]=e;H[a+5|0]=e>>>8;H[a+6|0]=e>>>16;H[a+7|0]=e>>>24;H[a+8|0]=d;H[a+9|0]=d>>>8;H[a+10|0]=d>>>16;H[a+11|0]=d>>>24;e=J[i>>2];H[c+28|0]=e;H[c+29|0]=e>>>8;H[c+30|0]=e>>>16;H[c+31|0]=e>>>24;i=J[g+60>>2];e=J[g+56>>2];H[c+20|0]=e;H[c+21|0]=e>>>8;H[c+22|0]=e>>>16;H[c+23|0]=e>>>24;H[c+24|0]=i;H[c+25|0]=i>>>8;H[c+26|0]=i>>>16;H[c+27|0]=i>>>24;i=J[g+52>>2];e=J[g+48>>2];H[c+12|0]=e;H[c+13|0]=e>>>8;H[c+14|0]=e>>>16;H[c+15|0]=e>>>24;H[c+16|0]=i;H[c+17|0]=i>>>8;H[c+18|0]=i>>>16;H[c+19|0]=i>>>24;i=J[g+44>>2];e=J[g+40>>2];H[c+4|0]=e;H[c+5|0]=e>>>8;H[c+6|0]=e>>>16;H[c+7|0]=e>>>24;H[c+8|0]=i;H[c+9|0]=i>>>8;H[c+10|0]=i>>>16;H[c+11|0]=i>>>24;J[a>>2]=J[c>>2];J[c>>2]=0;H[a+32|0]=1;if((b|0)!=(c|0)){while(1){a=b-32|0;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0>=29){b=b-24|0;$a(K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24));H[b|0]=0;H[b+1|0]=0;H[b+2|0]=0;H[b+3|0]=0;}b=a;if((c|0)!=(b|0)){continue}break}b=J[g+28>>2];}J[g+32>>2]=c;$a(b);if(k){$a(k);}Ua=g+96|0;return}Qg(g+28|0);if(k){$a(k);}da(l|0);B();}a=Z()|0;Qg(g+28|0);da(a|0);B();}B();}function xn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,C=0,D=0;g=Ua-48|0;Ua=g;J[g+32>>2]=0;J[g+24>>2]=0;J[g+28>>2]=0;J[5996]=0;o=$(3,12)|0;d=J[5996];J[5996]=0;a:{if((d|0)!=1){J[o+4>>2]=0;J[o>>2]=b;r=g+40|0;x=g+12|0;y=o+12|0;f=y;b:{c:{d:{while(1){e:{D=f-12|0;b=D;d=J[b+4>>2];f:{g:{h:{i:{j:{s=J[b>>2];n=J[s+36>>2];z=J[s+32>>2];A=n-z>>3;if(d>>>0<A>>>0){J[b+4>>2]=d+1;i=J[(d<<3)+z>>2];if(f>>>0<y>>>0){J[f+4>>2]=0;J[f>>2]=i;f=f+12|0;break f}k:{e=(f-o|0)/12|0;h=e+1|0;l:{if(h>>>0>=357913942){J[5996]=0;ca(95);a=J[5996];J[5996]=0;if((a|0)==1){break l}break a}d=(y-o|0)/12|0;b=d<<1;b=d>>>0>=178956970?357913941:b>>>0>h>>>0?b:h;if(b>>>0<357913942){break k}J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}}b=Z()|0;break b}J[5996]=0;h=P(b,12);j=$(3,h|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break j}d=j+P(e,12)|0;J[d+4>>2]=0;J[d>>2]=i;b=d;if((f|0)!=(o|0)){while(1){f=f-12|0;e=J[f+4>>2];b=b-12|0;J[b>>2]=J[f>>2];J[b+4>>2]=e;J[b+8>>2]=J[f+8>>2];if((f|0)!=(o|0)){continue}break}}y=h+j|0;f=d+12|0;if(o){$a(o);}o=b;break f}k=J[g+24>>2];j=(J[g+28>>2]-k|0)/12|0;if(j>>>0<A>>>0){J[5996]=0;ga(44,5135,2210,439,2439);a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}if(K[s+88|0]?J[c>>2]!=(s|0):0){break h}C=J[s+12>>2];l=J[s+8>>2];J[g+36>>2]=r;J[g+40>>2]=0;J[g+44>>2]=0;v=(C-l|0)/12|0;m=0;b=r;e=0;if((l|0)==(C|0)){break i}while(1){m:{n:{o:{p:{f=r;q:{if((f|0)==(b|0)){break q}d=f;b=e;r:{if(e){while(1){f=b;b=J[b+4>>2];if(b){continue}break r}}while(1){f=J[d+8>>2];b=J[f>>2]==(d|0);d=f;if(b){continue}break}}w=J[l>>2];p=K[l+11|0];h=p<<24>>24;t=(h|0)<0;b=K[f+27|0];u=b<<24>>24<0;s:{d=J[l+4>>2];q=t?d:p;i=u?J[f+20>>2]:b;b=i>>>0>q>>>0?q:i;if(b){b=Eb(u?J[f+16>>2]:f+16|0,t?w:l,b);if(b){break s}}if(i>>>0<q>>>0){break q}break p}if((b|0)>=0){break p}}b=e?f:r;i=e?f+4|0:r;break o}b=r;i=b;if(!e){break o}b=(h|0)>=0;t=b?l:w;w=b?p:d;d=e;while(1){b=d;f=K[d+27|0];u=f<<24>>24<0;p=u?J[d+20>>2]:f;q=p>>>0<w>>>0;t:{u:{v:{w:{h=q?p:w;x:{if(h){f=u?J[d+16>>2]:d+16|0;d=Eb(t,f,h);if(!d){if(p>>>0>w>>>0){break x}break w}if((d|0)>=0){break w}break x}if(p>>>0<=w>>>0){break v}}i=b;d=J[b>>2];if(d){continue}break n}d=Eb(f,t,h);if(d){break u}}if(!q){break o}break t}if((d|0)>=0){break o}}i=b+4|0;d=J[b+4>>2];if(d){continue}break}break n}if(J[i>>2]){break m}}J[5996]=0;f=$(3,28)|0;d=J[5996];J[5996]=0;y:{if((d|0)!=1){h=f+16|0;if(H[l+11|0]>=0){d=J[l+4>>2];J[h>>2]=J[l>>2];J[h+4>>2]=d;J[h+8>>2]=J[l+8>>2];break y}e=J[l+4>>2];d=J[l>>2];J[5996]=0;ea(40,h|0,d|0,e|0);d=J[5996];J[5996]=0;if((d|0)!=1){break y}b=Z()|0;$a(f);Db(J[g+40>>2]);break b}b=Z()|0;Db(e);break b}J[f+8>>2]=b;J[f>>2]=0;J[f+4>>2]=0;J[i>>2]=f;b=J[J[g+36>>2]>>2];if(b){J[g+36>>2]=b;f=J[i>>2];}zd(J[g+40>>2],f);m=J[g+44>>2]+1|0;J[g+44>>2]=m;}l=l+12|0;if((C|0)==(l|0)){break i}b=J[g+36>>2];e=J[g+40>>2];continue}}b=Z()|0;break b}z:{A:{if((m|0)!=(v|0)){break A}if((n|0)!=(z|0)){t=k+P(j,12)|0;m=t+P(A,-12)|0;while(1){d=J[m+8>>2];if(d>>>0>v>>>0){b=J[g+36>>2];J[g+36>>2]=J[m>>2];J[m>>2]=b;b=J[g+40>>2];J[g+40>>2]=J[m+4>>2];J[m+4>>2]=b;b=J[g+44>>2];J[g+44>>2]=d;J[m+8>>2]=b;J[(J[g+44>>2]?J[g+40>>2]+8|0:g+36|0)>>2]=r;J[(b?J[m+4>>2]+8|0:m)>>2]=m+4;}v=d+v|0;j=J[m>>2];u=m+4|0;if((j|0)!=(u|0)){while(1){h=0;d=J[g+40>>2];B:{if(!d){f=r;l=f;break B}e=K[j+27|0];b=e<<24>>24>=0;n=b?j+16|0:J[j+16>>2];p=b?e:J[j+20>>2];l=r;while(1){f=d;b=K[d+27|0];k=b<<24>>24<0;q=k?J[d+20>>2]:b;i=q>>>0<p>>>0;C:{D:{E:{F:{e=i?q:p;G:{if(e){d=k?J[d+16>>2]:d+16|0;b=Eb(n,d,e);if(!b){if(p>>>0<q>>>0){break G}break F}if((b|0)>=0){break F}break G}if(p>>>0>=q>>>0){break E}}l=f;d=J[f>>2];if(d){continue}break B}b=Eb(d,n,e);if(b){break D}}if(i){break C}h=f;break B}if((b|0)<0){break C}h=f;break B}l=f+4|0;d=J[f+4>>2];if(d){continue}break}}e=j;i=J[e+4>>2];d=i;H:{if(d){while(1){b=d;d=J[d>>2];if(d){continue}break H}}while(1){b=J[e+8>>2];d=J[b>>2]!=(e|0);e=b;if(d){continue}break}}if(!h){e=j;I:{if(i){while(1){d=i;i=J[d>>2];if(i){continue}break I}}while(1){d=J[e+8>>2];h=J[d>>2]!=(e|0);e=d;if(h){continue}break}}if(J[m>>2]==(j|0)){J[m>>2]=d;}J[m+8>>2]=J[m+8>>2]-1;i=J[m+4>>2];J:{K:{e=j;h=J[e>>2];if(h){d=J[e+4>>2];if(!d){break K}while(1){e=d;d=J[d>>2];if(d){continue}break}}h=J[e+4>>2];if(h){break K}h=0;k=1;break J}J[h+8>>2]=J[e+8>>2];k=0;}n=J[e+8>>2];d=J[n>>2];L:{if((e|0)==(d|0)){J[n>>2]=h;if((e|0)==(i|0)){d=0;i=h;break L}d=J[n+4>>2];break L}J[n+4>>2]=h;}p=!K[e+12|0];if((e|0)!=(j|0)){n=J[j+8>>2];J[e+8>>2]=n;J[n+((J[J[j+8>>2]>>2]!=(j|0))<<2)>>2]=e;n=J[j>>2];J[e>>2]=n;J[n+8>>2]=e;n=J[j+4>>2];J[e+4>>2]=n;if(n){J[n+8>>2]=e;}H[e+12|0]=K[j+12|0];i=(i|0)==(j|0)?e:i;}M:{if(p|!i){break M}if(!k){H[h+12|0]=1;break M}N:{O:{while(1){P:{e=K[d+12|0];k=J[d+8>>2];Q:{if(J[k>>2]!=(d|0)){if(!e){H[d+12|0]=1;H[k+12|0]=0;h=J[k+4>>2];e=J[h>>2];J[k+4>>2]=e;if(e){J[e+8>>2]=k;}J[h+8>>2]=J[k+8>>2];e=J[k+8>>2];J[(((k|0)!=J[e>>2])<<2)+e>>2]=h;J[h>>2]=k;J[k+8>>2]=h;e=d;d=J[d>>2];i=(d|0)==(i|0)?e:i;d=J[d+4>>2];}e=J[d>>2];R:{if(!(K[e+12|0]?0:e)){h=J[d+4>>2];if(!(!h|K[h+12|0])){e=d;break R}H[d+12|0]=0;d=J[d+8>>2];if((i|0)==(d|0)){H[i+12|0]=1;break M}if(K[d+12|0]){break Q}H[d+12|0]=1;break M}h=J[d+4>>2];if(!(!h|K[h+12|0])){e=d;break R}H[e+12|0]=1;H[d+12|0]=0;h=J[e+4>>2];J[d>>2]=h;if(h){J[h+8>>2]=d;}J[e+8>>2]=J[d+8>>2];h=J[d+8>>2];J[((J[h>>2]!=(d|0))<<2)+h>>2]=e;J[e+4>>2]=d;J[d+8>>2]=e;h=d;}i=J[e+8>>2];H[e+12|0]=K[i+12|0];H[i+12|0]=1;H[h+12|0]=1;e=J[i+4>>2];d=J[e>>2];J[i+4>>2]=d;if(d){J[d+8>>2]=i;}J[e+8>>2]=J[i+8>>2];d=J[i+8>>2];J[(((i|0)!=J[d>>2])<<2)+d>>2]=e;J[e>>2]=i;J[i+8>>2]=e;break M}if(!e){H[d+12|0]=1;H[k+12|0]=0;e=J[d+4>>2];J[k>>2]=e;if(e){J[e+8>>2]=k;}J[d+8>>2]=J[k+8>>2];e=J[k+8>>2];J[(((k|0)!=J[e>>2])<<2)+e>>2]=d;J[d+4>>2]=k;J[k+8>>2]=d;i=(i|0)==(k|0)?d:i;d=J[k>>2];}h=J[d>>2];if(!(!h|K[h+12|0])){e=d;break N}e=J[d+4>>2];if(K[e+12|0]?0:e){break O}H[d+12|0]=0;d=J[d+8>>2];if(!K[d+12|0]|(d|0)==(i|0)){break P}}e=d;d=J[d+8>>2];d=J[(((e|0)==J[d>>2])<<2)+d>>2];continue}break}H[d+12|0]=1;break M}if(!(K[h+12|0]|!h)){e=d;break N}H[e+12|0]=1;H[d+12|0]=0;h=J[e>>2];J[d+4>>2]=h;if(h){J[h+8>>2]=d;}J[e+8>>2]=J[d+8>>2];h=J[d+8>>2];J[((J[h>>2]!=(d|0))<<2)+h>>2]=e;J[e>>2]=d;J[d+8>>2]=e;h=d;}i=J[e+8>>2];H[e+12|0]=K[i+12|0];H[i+12|0]=1;H[h+12|0]=1;e=J[i>>2];d=J[e+4>>2];J[i>>2]=d;if(d){J[d+8>>2]=i;}J[e+8>>2]=J[i+8>>2];d=J[i+8>>2];J[(((i|0)!=J[d>>2])<<2)+d>>2]=e;J[e+4>>2]=i;J[i+8>>2]=e;}J[j+8>>2]=f;J[j>>2]=0;J[j+4>>2]=0;J[l>>2]=j;d=J[J[g+36>>2]>>2];if(d){J[g+36>>2]=d;j=J[l>>2];}zd(J[g+40>>2],j);J[g+44>>2]=J[g+44>>2]+1;}j=b;if((b|0)!=(u|0)){continue}break}}if(J[g+44>>2]!=(v|0)){break A}m=m+12|0;if((t|0)!=(m|0)){continue}break}}J[g+8>>2]=J[g+36>>2];J[g+16>>2]=v;b=J[g+40>>2];J[g+12>>2]=b;S:{if(!v){J[g+8>>2]=x;break S}J[b+8>>2]=x;J[g+40>>2]=0;J[g+44>>2]=0;J[g+36>>2]=r;}b=1;break z}H[g+8|0]=0;b=0;}H[g+20|0]=b;Db(J[g+40>>2]);if(K[g+20|0]){break g}}H[a+12|0]=0;H[a|0]=0;break c}d=J[g+28>>2];h=J[s+36>>2]-J[s+32>>2]>>3;e=J[g+24>>2];b=((d+P(h,-12)|0)-e|0)/12|0;T:{if(!P(h,-12)){f=d;break T}i=e+P(b,12)|0;f=i;b=f+P((P(h,12)|0)/12|0,12)|0;if((d|0)!=(b|0)){while(1){Db(J[f+4>>2]);J[f>>2]=J[b>>2];h=J[b+4>>2];J[f+4>>2]=h;e=J[b+8>>2];J[f+8>>2]=e;j=f+4|0;U:{if(!e){J[f>>2]=j;break U}J[h+8>>2]=j;J[b+4>>2]=0;J[b+8>>2]=0;J[b>>2]=b+4;}f=f+12|0;b=b+12|0;if((d|0)!=(b|0)){continue}break}d=J[g+28>>2];}f=i+P((f-i|0)/12|0,12)|0;if((f|0)!=(d|0)){while(1){d=d-12|0;Db(J[d+4>>2]);if((d|0)!=(f|0)){continue}break}}J[g+28>>2]=f;}b=J[g+32>>2];V:{if(b>>>0>f>>>0){J[f>>2]=J[g+8>>2];d=J[g+12>>2];J[f+4>>2]=d;b=J[g+16>>2];J[f+8>>2]=b;e=f+4|0;W:{if(!b){J[f>>2]=e;break W}J[d+8>>2]=e;J[g+12>>2]=0;J[g+16>>2]=0;J[g+8>>2]=x;}J[g+28>>2]=f+12;break V}X:{Y:{k=J[g+24>>2];h=(f-k|0)/12|0;e=h+1|0;Z:{if(e>>>0>=357913942){J[5996]=0;ca(96);break Z}d=(b-k|0)/12|0;b=d<<1;d=d>>>0>=178956970?357913941:b>>>0>e>>>0?b:e;if(!d){e=0;break X}if(d>>>0<357913942){break Y}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}break e}J[5996]=0;e=$(3,P(d,12)|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break e}}b=P(h,12)+e|0;J[b>>2]=J[g+8>>2];j=J[g+12>>2];J[b+4>>2]=j;h=J[g+16>>2];J[b+8>>2]=h;d=P(d,12);i=b+4|0;_:{if(!h){J[b>>2]=i;break _}J[j+8>>2]=i;J[g+12>>2]=0;J[g+16>>2]=0;J[g+8>>2]=x;}l=d+e|0;i=b+12|0;$:{if((f|0)==(k|0)){J[g+32>>2]=l;J[g+28>>2]=i;J[g+24>>2]=b;break $}while(1){b=b-12|0;f=f-12|0;J[b>>2]=J[f>>2];j=b+4|0;h=f+4|0;e=J[h>>2];J[j>>2]=e;d=J[f+8>>2];J[b+8>>2]=d;aa:{if(!d){J[b>>2]=j;break aa}J[e+8>>2]=j;J[f>>2]=h;J[f+4>>2]=0;J[f+8>>2]=0;}if((f|0)!=(k|0)){continue}break}J[g+32>>2]=l;d=J[g+28>>2];J[g+28>>2]=i;f=J[g+24>>2];J[g+24>>2]=b;if((d|0)==(f|0)){break $}while(1){d=d-12|0;Db(J[d+4>>2]);if((d|0)!=(f|0)){continue}break}}if(!f){break V}$a(f);}if(K[g+20|0]){Db(J[g+12>>2]);}f=D;}if((f|0)!=(o|0)){continue}break d}break}b=Z()|0;if(!K[g+20|0]){break b}Db(J[g+12>>2]);break b}e=J[g+24>>2];if((J[g+28>>2]-e|0)!=12){J[5996]=0;ga(44,4102,2210,450,2439);a=J[5996];J[5996]=0;if((a|0)!=1){break a}b=Z()|0;break b}J[a>>2]=J[e>>2];c=J[e+4>>2];J[a+4>>2]=c;b=J[e+8>>2];J[a+8>>2]=b;d=a+4|0;ba:{if(!b){J[a>>2]=d;break ba}J[c+8>>2]=d;J[e+4>>2]=0;J[e+8>>2]=0;J[e>>2]=e+4;}H[a+12|0]=1;}a=J[g+24>>2];if(a){f=J[g+28>>2];if((a|0)!=(f|0)){while(1){f=f-12|0;Db(J[f+4>>2]);if((a|0)!=(f|0)){continue}break}}$a(a);}if(o){$a(o);}Ua=g+48|0;return}Ug(g+24|0);if(o){$a(o);}da(b|0);B();}a=Z()|0;Ug(g+24|0);da(a|0);B();}B();}function fg(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;e=Ua-144|0;Ua=e;d=Sb(e,0,144);J[d+76>>2]=-1;J[d+44>>2]=a;J[d+32>>2]=178;J[d+84>>2]=a;s=c;a=0;j=Ua-304|0;Ua=j;a:{b:{c:{d:{if(J[d+4>>2]){break d}Dg(d);if(J[d+4>>2]){break d}break c}h=K[b|0];if(!h){break a}e:{f:{g:{h:{while(1){i:{c=h&255;j:{if((c|0)==32|c-9>>>0<5){while(1){h=b;b=b+1|0;c=K[h+1|0];if((c|0)==32|c-9>>>0<5){continue}break}Yb(d,0,0);while(1){b=J[d+4>>2];k:{if((b|0)!=J[d+104>>2]){J[d+4>>2]=b+1;b=K[b|0];break k}b=gb(d);}if((b|0)==32|b-9>>>0<5){continue}break}b=J[d+4>>2];c=J[d+116>>2];if((c|0)>0|(c|0)>=0){b=b-1|0;J[d+4>>2]=b;}b=b-J[d+44>>2]|0;e=b;i=o+J[d+124>>2]|0;c=b>>31;b=m+J[d+120>>2]|0;i=c+(b>>>0<m>>>0?i+1|0:i)|0;m=b+e|0;o=m>>>0<b>>>0?i+1|0:i;break j}l:{m:{n:{if((c|0)==37){c=K[b+1|0];if((c|0)==42){break n}if((c|0)!=37){break m}}Yb(d,0,0);o:{if(K[b|0]==37){while(1){c=J[d+4>>2];p:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;h=K[c|0];break p}h=gb(d);}if((h|0)==32|h-9>>>0<5){continue}break}b=b+1|0;break o}c=J[d+4>>2];if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;h=K[c|0];break o}h=gb(d);}if(K[b|0]!=(h|0)){b=J[d+116>>2];if((b|0)>0|(b|0)>=0){J[d+4>>2]=J[d+4>>2]-1;}if((h|0)>=0){break a}g=0;if(t){break a}break c}c=J[d+4>>2]-J[d+44>>2]|0;h=c;f=o+J[d+124>>2]|0;e=c>>31;c=m+J[d+120>>2]|0;g=e+(c>>>0<m>>>0?f+1|0:f)|0;m=c+h|0;o=m>>>0<c>>>0?g+1|0:g;h=b;break j}l=0;b=b+2|0;break l}e=c-48|0;if(!(K[b+2|0]!=36|e>>>0>=10)){c=Ua-16|0;J[c+12>>2]=s;f=c;c=(e>>>0>1?(e<<2)-4|0:0)+s|0;J[f+8>>2]=c+4;l=J[c>>2];b=b+3|0;break l}l=J[s>>2];s=s+4|0;b=b+1|0;}c=0;while(1){f=K[b|0];if(f-48>>>0<10){b=b+1|0;c=(P(c,10)+f|0)-48|0;continue}break}r=0;if((f|0)==109){p=0;r=(l|0)!=0;f=K[b+1|0];b=b+1|0;a=0;}h=b+1|0;k=3;g=r;q:{r:{switch((f&255)-65|0){case 39:e=b+2|0;b=K[b+1|0]==104;h=b?e:h;k=b?-2:-1;break q;case 43:e=b+2|0;b=K[b+1|0]==108;h=b?e:h;k=b?3:1;break q;case 51:case 57:k=1;break q;case 11:k=2;break q;case 41:break q;case 0:case 2:case 4:case 5:case 6:case 18:case 23:case 26:case 32:case 34:case 35:case 36:case 37:case 38:case 40:case 45:case 46:case 47:case 50:case 52:case 55:break r;default:break e}}k=0;h=b;}e=K[h|0];b=(e&47)==3;u=b?1:k;q=b?e|32:e;s:{if((q|0)==91){break s}t:{if((q|0)!=110){if((q|0)!=99){break t}c=(c|0)<=1?1:c;break s}gg(l,u,m,o);break j}Yb(d,0,0);while(1){b=J[d+4>>2];u:{if((b|0)!=J[d+104>>2]){J[d+4>>2]=b+1;b=K[b|0];break u}b=gb(d);}if((b|0)==32|b-9>>>0<5){continue}break}b=J[d+4>>2];e=J[d+116>>2];if((e|0)>0|(e|0)>=0){b=b-1|0;J[d+4>>2]=b;}b=b-J[d+44>>2]|0;f=b;i=o+J[d+124>>2]|0;e=b>>31;b=m+J[d+120>>2]|0;o=e+(b>>>0<m>>>0?i+1|0:i)|0;m=b+f|0;o=m>>>0<b>>>0?o+1|0:o;}i=c;n=c>>31;Yb(d,c,n);b=J[d+4>>2];v:{if((b|0)!=J[d+104>>2]){J[d+4>>2]=b+1;break v}if((gb(d)|0)<0){break f}}b=J[d+116>>2];if((b|0)>0|(b|0)>=0){J[d+4>>2]=J[d+4>>2]-1;}b=16;w:{x:{y:{z:{A:{switch(q-88|0){default:b=q-65|0;if(b>>>0>6|!(1<<b&113)){break w}case 9:case 13:case 14:case 15:ig(j+8|0,d,u,0);c=J[d+4>>2]-J[d+44>>2]|0;if(J[d+120>>2]!=(0-c|0)|J[d+124>>2]!=(0-((c>>31)+((c|0)!=0)|0)|0)){break y}break g;case 3:case 11:case 27:if((q|16)==115){Sb(j+32|0,-1,257);H[j+32|0]=0;if((q|0)!=115){break x}H[j+65|0]=0;H[j+46|0]=0;I[j+42>>1]=0;I[j+44>>1]=0;break x}f=K[h+1|0];e=(f|0)==94;Sb(j+32|0,e,257);H[j+32|0]=0;b=e?h+2|0:h+1|0;B:{C:{D:{e=K[(e?2:1)+h|0];if((e|0)!=45){if((e|0)==93){break D}k=(f|0)!=94;break B}k=(f|0)!=94;H[j+78|0]=k;break C}k=(f|0)!=94;H[j+126|0]=k;}b=b+1|0;}h=b;while(1){f=K[h|0];E:{if((f|0)!=45){if(!f){break f}if((f|0)==93){break x}break E}f=45;g=K[h+1|0];if(!g|(g|0)==93){break E}e=h+1|0;b=K[h-1|0];F:{if(g>>>0<=b>>>0){f=g;break F}while(1){b=b+1|0;H[b+(j+32|0)|0]=k;f=K[e|0];if(f>>>0>b>>>0){continue}break}}h=e;}H[(f+j|0)+33|0]=k;h=h+1|0;continue}case 23:b=8;break z;case 12:case 29:b=10;break z;case 1:case 2:case 4:case 5:case 6:case 7:case 8:case 10:case 16:case 18:case 19:case 20:case 21:case 22:case 25:case 26:case 28:case 30:case 31:break w;case 0:case 24:case 32:break z;case 17:break A}}b=0;}e=0;i=0;f=0;g=0;w=0;v=Ua-16|0;Ua=v;G:{if((b|0)==1){J[5732]=28;break G}while(1){c=J[d+4>>2];H:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break H}c=gb(d);}if((c|0)==32|c-9>>>0<5){continue}break}I:{J:{switch(c-43|0){case 0:case 2:break J;default:break I}}w=(c|0)==45?-1:0;c=J[d+4>>2];if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break I}c=gb(d);}K:{L:{M:{N:{if(!((b|0)!=0&(b|0)!=16|(c|0)!=48)){c=J[d+4>>2];O:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break O}c=gb(d);}if((c&-33)==88){b=16;c=J[d+4>>2];P:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break P}c=gb(d);}if(K[c+8641|0]<16){break M}b=J[d+116>>2];if((b|0)>0|(b|0)>=0){J[d+4>>2]=J[d+4>>2]-1;}Yb(d,0,0);break G}if(b){break N}b=8;break M}b=b?b:10;if(b>>>0>K[c+8641|0]){break N}b=J[d+116>>2];if((b|0)>0|(b|0)>=0){J[d+4>>2]=J[d+4>>2]-1;}Yb(d,0,0);J[5732]=28;break G}if((b|0)!=10){break M}f=c-48|0;if(f>>>0<=9){c=0;while(1){c=P(c,10)+f|0;g=c>>>0<429496729;e=J[d+4>>2];Q:{if((e|0)!=J[d+104>>2]){J[d+4>>2]=e+1;b=K[e|0];break Q}b=gb(d);}f=b-48|0;if(g&f>>>0<=9){continue}break}e=c;}if(f>>>0>9){break K}b=co(e,0,10,0);g=Wa;while(1){e=b+f|0;i=e>>>0<f>>>0?g+1|0:g;b=(i|0)==429496729&e>>>0<2576980378|i>>>0<429496729;c=J[d+4>>2];R:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break R}c=gb(d);}k=c-48|0;if(!(b&k>>>0<=9)){b=10;if(k>>>0<=9){break L}break K}b=co(e,i,10,0);g=Wa;f=k;if((g|0)==-1&(f^-1)>>>0>=b>>>0|(g|0)!=-1){continue}break}b=10;break L}if(b-1&b){g=K[c+8641|0];if(g>>>0<b>>>0){while(1){f=P(b,f)+g|0;e=f>>>0<119304647;c=J[d+4>>2];S:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break S}c=gb(d);}g=K[c+8641|0];if(e&g>>>0<b>>>0){continue}break}e=f;}if(b>>>0<=g>>>0){break L}n=b;while(1){f=co(e,i,n,0);k=Wa;g=g&255;if((k|0)==-1&(g^-1)>>>0<f>>>0){break L}i=k;e=f+g|0;i=e>>>0<g>>>0?i+1|0:i;c=J[d+4>>2];T:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break T}c=gb(d);}g=K[c+8641|0];if(b>>>0<=g>>>0){break L}xb(v,n,0,0,0,e,i,0,0);if(!(J[v+8>>2]|J[v+12>>2])){continue}break}break L}k=H[(P(b,23)>>>5&7)+8897|0];f=K[c+8641|0];if(f>>>0<b>>>0){while(1){g=g<<k|f;e=g>>>0<134217728;c=J[d+4>>2];U:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break U}c=gb(d);}f=K[c+8641|0];if(e&f>>>0<b>>>0){continue}break}e=g;}if(b>>>0<=f>>>0){break L}n=k&31;if((k&63)>>>0>=32){g=0;n=-1>>>n|0;}else {g=-1>>>n|0;n=g|(1<<n)-1<<32-n;}if(!g&e>>>0>n>>>0){break L}while(1){x=f&255;c=e;f=k&31;if((k&63)>>>0>=32){i=c<<f;c=0;}else {i=(1<<f)-1&c>>>32-f|i<<f;c=c<<f;}e=x|c;c=J[d+4>>2];V:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break V}c=gb(d);}f=K[c+8641|0];if(b>>>0<=f>>>0){break L}if((g|0)==(i|0)&e>>>0<=n>>>0|g>>>0>i>>>0){continue}break}}if(K[c+8641|0]>=b>>>0){break K}while(1){c=J[d+4>>2];W:{if((c|0)!=J[d+104>>2]){J[d+4>>2]=c+1;c=K[c|0];break W}c=gb(d);}if(K[c+8641|0]<b>>>0){continue}break}J[5732]=68;e=-1;i=-1;w=0;}b=J[d+116>>2];if((b|0)>0|(b|0)>=0){J[d+4>>2]=J[d+4>>2]-1;}b=w;f=b^e;e=f-b|0;c=b>>31;i=(c^i)-((b>>>0>f>>>0)+c|0)|0;}Ua=v+16|0;c=J[d+4>>2]-J[d+44>>2]|0;if(J[d+120>>2]==(0-c|0)&J[d+124>>2]==(0-((c>>31)+((c|0)!=0)|0)|0)){break g}if(!(!l|(q|0)!=112)){J[l>>2]=e;break w}gg(l,u,e,i);break w}if(!l){break w}c=J[j+16>>2];f=J[j+20>>2];b=J[j+8>>2];e=J[j+12>>2];X:{switch(u|0){case 0:N[l>>2]=Vf(b,e,c,f);break w;case 1:O[l>>3]=ge(b,e,c,f);break w;case 2:break X;default:break w}}J[l>>2]=b;J[l+4>>2]=e;J[l+8>>2]=c;J[l+12>>2]=f;break w}k=(q|0)!=99;c=k?31:c+1|0;Y:{if((u|0)==1){f=l;if(r){f=sb(c<<2);if(!f){break h}}J[j+296>>2]=0;J[j+300>>2]=0;b=0;while(1){a=f;Z:{while(1){e=J[d+4>>2];_:{if((e|0)!=J[d+104>>2]){J[d+4>>2]=e+1;e=K[e|0];break _}e=gb(d);}if(!K[(e+j|0)+33|0]){break Z}H[j+27|0]=e;e=qd(j+28|0,j+27|0,1,j+296|0);if((e|0)==-2){continue}p=0;if((e|0)==-1){break f}if(a){J[(b<<2)+a>>2]=J[j+28>>2];b=b+1|0;}if(!r|(b|0)!=(c|0)){continue}break}g=1;b=c;c=b<<1|1;f=Vc(a,c<<2);if(f){continue}break e}break}p=0;c=a;if(j+296|0?J[j+296>>2]:0){break f}break Y}if(r){b=0;f=sb(c);if(!f){break h}while(1){a=f;while(1){e=J[d+4>>2];$:{if((e|0)!=J[d+104>>2]){J[d+4>>2]=e+1;e=K[e|0];break $}e=gb(d);}if(!K[(e+j|0)+33|0]){c=0;p=a;break Y}H[a+b|0]=e;b=b+1|0;if((c|0)!=(b|0)){continue}break}g=1;b=c;c=b<<1|1;f=Vc(a,c);if(f){continue}break}p=a;a=0;break e}b=0;if(l){while(1){a=J[d+4>>2];aa:{if((a|0)!=J[d+104>>2]){J[d+4>>2]=a+1;a=K[a|0];break aa}a=gb(d);}if(K[(a+j|0)+33|0]){H[b+l|0]=a;b=b+1|0;continue}else {c=0;a=l;p=a;break Y}}}while(1){a=J[d+4>>2];ba:{if((a|0)!=J[d+104>>2]){J[d+4>>2]=a+1;a=K[a|0];break ba}a=gb(d);}if(K[(a+j|0)+33|0]){continue}break}a=0;p=0;c=0;}f=J[d+4>>2];e=J[d+116>>2];if((e|0)>0|(e|0)>=0){f=f-1|0;J[d+4>>2]=f;}e=f-J[d+44>>2]|0;f=e+J[d+120>>2]|0;g=J[d+124>>2]+(e>>31)|0;g=f>>>0<e>>>0?g+1|0:g;if(!(g|f)|!(k|(f|0)==(i|0)&(g|0)==(n|0))){break i}if(r){J[l>>2]=a;}ca:{if((q|0)==99){break ca}if(c){J[(b<<2)+c>>2]=0;}if(!p){p=0;break ca}H[b+p|0]=0;}a=c;}b=J[d+4>>2]-J[d+44>>2]|0;e=b;f=o+J[d+124>>2]|0;c=b>>31;b=m+J[d+120>>2]|0;i=c+(b>>>0<m>>>0?f+1|0:f)|0;m=b+e|0;o=m>>>0<b>>>0?i+1|0:i;t=((l|0)!=0)+t|0;}b=h+1|0;h=K[h+1|0];if(h){continue}break a}break}a=c;break g}g=1;p=0;a=0;break e}g=r;break b}g=r;}if(t){break b}}t=-1;}if(!g){break a}$a(p);$a(a);}Ua=j+304|0;Ua=d+144|0;return t}function ao(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0;d=Ua-320|0;Ua=d;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{if(!K[24336]){J[d+208>>2]=0;J[d+200>>2]=0;J[d+204>>2]=0;J[5996]=0;ba(66,24324,d+200|0,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break w}b=J[d+200>>2];if(b){J[d+204>>2]=b;$a(b);}H[24336]=1;}if(!K[24352]){J[5996]=0;b=d+200|0;ea(68,b|0,1598,8);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+308|0,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24340,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break v}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24352]=1;}if(!K[24368]){J[5996]=0;b=d+200|0;ea(68,b|0,1194,10);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+296|0,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24356,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break u}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24368]=1;}if(!K[24384]){J[5996]=0;b=d+200|0;ea(68,b|0,2432,6);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+284|0,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24372,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break t}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24384]=1;}if(!K[24400]){J[5996]=0;b=d+200|0;ea(68,b|0,1492,6);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+272|0,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24388,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break s}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24400]=1;}if(!K[24416]){J[5996]=0;b=d+200|0;ea(68,b|0,1152,8);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+260|0,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24404,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break r}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24416]=1;}if(!K[24432]){J[5996]=0;b=d+200|0;ea(68,b|0,1526,8);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+248|0,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24420,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break q}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24432]=1;}if(!K[24448]){J[5996]=0;b=d+200|0;ea(68,b|0,1628,10);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+236|0,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24436,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break p}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24448]=1;}if(!K[24464]){J[5996]=0;b=d+116|0;ea(68,b|0,1435,7);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ea(68,d+124|0,1183,10);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;c=ba(69,d+200|0,b|0,2)|0;b=J[5996];J[5996]=0;if((b|0)==1){break c}J[5996]=0;e=d+80|0;ea(68,e|0,1478,7);f=J[5996];J[5996]=0;b=c+12|0;if((f|0)==1){break n}J[5996]=0;ea(68,d+88|0,1172,10);f=J[5996];J[5996]=0;if((f|0)==1){break n}J[5996]=0;f=ba(69,b|0,e|0,2)|0;e=J[5996];J[5996]=0;if((e|0)==1){break n}J[5996]=0;e=d+56|0;ea(68,e|0,1435,7);g=J[5996];J[5996]=0;b=c+24|0;if((g|0)==1){break n}J[5996]=0;ea(68,d- -64|0,1161,10);g=J[5996];J[5996]=0;if((g|0)==1){break n}J[5996]=0;g=ba(69,b|0,e|0,2)|0;e=J[5996];J[5996]=0;if((e|0)==1){break n}J[5996]=0;ba(66,24452,c|0,3)|0;b=J[5996];J[5996]=0;if((b|0)==1){break o}b=J[g>>2];if(b){J[c+28>>2]=b;$a(b);}b=J[f>>2];if(b){J[c+16>>2]=b;$a(b);}b=J[c>>2];if(b){J[c+4>>2]=b;$a(b);}H[24464]=1;}if(!K[24480]){J[5996]=0;b=d+116|0;ea(68,b|0,1628,10);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ea(68,d+124|0,1617,10);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+188|0,b|0,2)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24468,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break m}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24480]=1;}if(!K[24496]){J[5996]=0;b=d+116|0;ea(68,b|0,1462,8);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ea(68,d+124|0,1453,8);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+176|0,b|0,2)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24484,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break l}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24496]=1;}if(!K[24512]){J[5996]=0;b=d+116|0;ea(68,b|0,1443,9);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ea(68,d+124|0,1587,10);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+164|0,b|0,2)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24500,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break k}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24512]=1;}if(!K[24528]){J[5996]=0;b=d+116|0;ea(68,b|0,1443,9);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ea(68,d+124|0,1471,6);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;b=ba(69,d+152|0,b|0,2)|0;c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ba(66,24516,b|0,1)|0;c=J[5996];J[5996]=0;if((c|0)==1){break j}c=J[b>>2];if(c){J[b+4>>2]=c;$a(c);}H[24528]=1;}if(!K[24544]){J[5996]=0;b=d+80|0;ea(68,b|0,1535,9);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ea(68,d+88|0,1535,9);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;c=ba(69,d+116|0,b|0,2)|0;b=J[5996];J[5996]=0;if((b|0)==1){break c}J[5996]=0;e=d+56|0;ea(68,e|0,1555,9);f=J[5996];J[5996]=0;b=c+12|0;if((f|0)==1){break h}J[5996]=0;ea(68,d- -64|0,1555,9);f=J[5996];J[5996]=0;if((f|0)==1){break h}J[5996]=0;f=ba(69,b|0,e|0,2)|0;e=J[5996];J[5996]=0;if((e|0)==1){break h}J[5996]=0;e=d+32|0;ea(68,e|0,1545,9);g=J[5996];J[5996]=0;b=c+24|0;if((g|0)==1){break h}J[5996]=0;ea(68,d+40|0,1545,9);g=J[5996];J[5996]=0;if((g|0)==1){break h}J[5996]=0;g=ba(69,b|0,e|0,2)|0;e=J[5996];J[5996]=0;if((e|0)==1){break h}J[5996]=0;ba(66,24532,c|0,3)|0;b=J[5996];J[5996]=0;if((b|0)==1){break i}b=J[g>>2];if(b){J[c+28>>2]=b;$a(b);}b=J[f>>2];if(b){J[c+16>>2]=b;$a(b);}b=J[c>>2];if(b){J[c+4>>2]=b;$a(b);}H[24544]=1;}if(!K[24560]){J[5996]=0;b=d+56|0;ea(68,b|0,1443,9);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ea(68,d- -64|0,1517,8);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;ea(68,d+72|0,1587,10);c=J[5996];J[5996]=0;if((c|0)==1){break c}J[5996]=0;c=ba(69,d+80|0,b|0,3)|0;b=J[5996];J[5996]=0;if((b|0)==1){break c}J[5996]=0;e=d+32|0;ea(68,e|0,1443,9);f=J[5996];J[5996]=0;b=c+12|0;if((f|0)==1){break f}J[5996]=0;ea(68,d+40|0,1508,8);f=J[5996];J[5996]=0;if((f|0)==1){break f}J[5996]=0;ea(68,d+48|0,1576,10);f=J[5996];J[5996]=0;if((f|0)==1){break f}J[5996]=0;f=ba(69,b|0,e|0,3)|0;e=J[5996];J[5996]=0;if((e|0)==1){break f}J[5996]=0;e=d+8|0;ea(68,e|0,1443,9);g=J[5996];J[5996]=0;b=c+24|0;if((g|0)==1){break f}J[5996]=0;ea(68,d+16|0,1499,8);g=J[5996];J[5996]=0;if((g|0)==1){break f}J[5996]=0;ea(68,d+24|0,1565,10);g=J[5996];J[5996]=0;if((g|0)==1){break f}J[5996]=0;g=ba(69,b|0,e|0,3)|0;e=J[5996];J[5996]=0;if((e|0)==1){break f}J[5996]=0;ba(66,24548,c|0,3)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}b=J[g>>2];if(b){J[c+28>>2]=b;$a(b);}b=J[f>>2];if(b){J[c+16>>2]=b;$a(b);}b=J[c>>2];if(b){J[c+4>>2]=b;$a(b);}H[24560]=1;}if(!(50331647>>>a&1)){break e}Ua=d+320|0;return J[(a<<2)+6864>>2]}e=Z()|0;a=J[d+200>>2];if(!a){break d}J[d+204>>2]=a;$a(a);break d}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[g>>2];if(a){J[c+28>>2]=a;$a(a);}a=J[f>>2];if(a){J[c+16>>2]=a;$a(a);}a=J[c>>2];if(!a){break d}break a}e=Z()|0;while(1){a=b-12|0;d=J[a>>2];if(d){J[b-8>>2]=d;$a(d);}b=a;if((b|0)!=(c|0)){continue}break}break d}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[b>>2];if(!a){break d}break b}e=Z()|0;a=J[g>>2];if(a){J[c+28>>2]=a;$a(a);}a=J[f>>2];if(a){J[c+16>>2]=a;$a(a);}a=J[c>>2];if(!a){break d}break a}e=Z()|0;while(1){a=b-12|0;d=J[a>>2];if(d){J[b-8>>2]=d;$a(d);}b=a;if((b|0)!=(c|0)){continue}break}break d}e=Z()|0;a=J[g>>2];if(a){J[c+28>>2]=a;$a(a);}a=J[f>>2];if(a){J[c+16>>2]=a;$a(a);}a=J[c>>2];if(!a){break d}break a}e=Z()|0;while(1){a=b-12|0;d=J[a>>2];if(d){J[b-8>>2]=d;$a(d);}b=a;if((b|0)!=(c|0)){continue}break}break d}la(2350,1900,622,1759);B();}da(e|0);B();}da(Z()|0);B();}J[b+4>>2]=a;$a(a);da(e|0);B();}J[c+4>>2]=a;$a(a);da(e|0);B();}function wd(a,b,c,d,e){var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;h=Ua-144|0;Ua=h;Yc(h+56|0,c,O[a+16>>3],O[a+24>>3],0,0);J[5996]=0;f=$(46,c|0)|0;g=J[5996];J[5996]=0;a:{b:{c:{if((g|0)!=1){J[h+52>>2]=0;J[h+44>>2]=0;J[h+48>>2]=0;H[h+128|0]=0;J[h+124>>2]=h+44;g=J[f+4>>2];j=J[f>>2];k=g-j|0;i=(k|0)/12|0;if((g|0)!=(j|0)){d:{e:{f:{if(i>>>0>=357913942){J[5996]=0;ca(47);a=J[5996];J[5996]=0;if((a|0)==1){break f}break a}J[5996]=0;g=$(3,k|0)|0;j=J[5996];J[5996]=0;if((j|0)==1){break f}J[h+48>>2]=g;J[h+44>>2]=g;J[h+52>>2]=g+P(i,12);i=J[f+4>>2];f=J[f>>2];J[5996]=0;f=ia(48,h+52|0,f|0,i|0,g|0)|0;i=J[5996];J[5996]=0;if((i|0)!=1){break d}f=Z()|0;J[h+48>>2]=g;break e}f=Z()|0;}Nc(h+124|0);break c}J[h+48>>2]=f;}J[h+40>>2]=0;J[h+32>>2]=0;J[h+36>>2]=0;f=J[d+4>>2];g=J[d>>2];J[5996]=0;aa(49,h+32|0,f-g>>2);f=J[5996];J[5996]=0;g:{if((f|0)!=1){f=J[h+48>>2];g=J[h+44>>2];if((f|0)==(g|0)){break b}f=g;h:{while(1){i:{J[h+28>>2]=0;J[h+20>>2]=0;J[h+24>>2]=0;i=J[d+4>>2];g=J[d>>2];n=P(s,12);f=n+f|0;if(i-g>>2!=J[f+4>>2]-J[f>>2]>>3){break i}j=0;r=1;k=0;j:{if((g|0)!=(i|0)){k:{l:{m:{while(1){f=k<<3;v=O[f+J[h+68>>2]>>3];w=O[f+J[h+56>>2]>>3];g=J[(k<<2)+g>>2];J[5996]=0;g=qa(50,g|0,+w,+v,b|0)|0;i=J[5996];J[5996]=0;if((i|0)==1){break l}f=f+J[n+J[h+44>>2]>>2]|0;i=J[f>>2];f=J[f+4>>2];m=J[g+4>>2];g=J[g>>2];J[5996]=0;oa(51,h+124|0,g|0,m|0,i|0,f|0);f=J[5996];J[5996]=0;if((f|0)!=1){i=J[h+28>>2];n:{if(i>>>0>j>>>0){J[j+8>>2]=0;J[j>>2]=0;J[j+4>>2]=0;J[j>>2]=J[h+124>>2];J[j+4>>2]=J[h+128>>2];J[j+8>>2]=J[h+132>>2];J[h+24>>2]=j+12;break n}o:{g=J[h+20>>2];m=(j-g|0)/12|0;f=m+1|0;p:{if(f>>>0>=357913942){J[5996]=0;ca(52);break p}i=(i-g|0)/12|0;l=i<<1;f=i>>>0>=178956970?357913941:f>>>0<l>>>0?l:f;if(f>>>0<357913942){break o}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}break m}J[5996]=0;l=P(f,12);i=$(3,l|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break m}f=i+P(m,12)|0;J[f>>2]=J[h+124>>2];J[f+4>>2]=J[h+128>>2];J[f+8>>2]=J[h+132>>2];J[h+132>>2]=0;J[h+124>>2]=0;J[h+128>>2]=0;i=i+l|0;m=f+12|0;q:{if((g|0)==(j|0)){J[h+28>>2]=i;J[h+24>>2]=m;J[h+20>>2]=f;break q}while(1){f=f-12|0;j=j-12|0;J[f>>2]=J[j>>2];J[f+4>>2]=J[j+4>>2];J[f+8>>2]=J[j+8>>2];J[j+8>>2]=0;J[j>>2]=0;J[j+4>>2]=0;if((g|0)!=(j|0)){continue}break}J[h+28>>2]=i;g=J[h+24>>2];J[h+24>>2]=m;j=J[h+20>>2];J[h+20>>2]=f;if((g|0)==(j|0)){break q}while(1){l=g-12|0;m=J[l>>2];if(m){o=g-8|0;f=J[o>>2];i=m;if((f|0)!=(i|0)){while(1){f=f-32|0;g=J[f+4>>2];r:{if(!g){break r}i=J[g+4>>2];J[g+4>>2]=i-1;if(i){break r}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((f|0)!=(m|0)){continue}break}i=J[l>>2];}J[o>>2]=m;$a(i);}g=l;if((j|0)!=(g|0)){continue}break}}if(j){$a(j);}i=J[h+124>>2];if(!i){break n}f=J[h+128>>2];g=i;if((f|0)!=(g|0)){while(1){f=f-32|0;g=J[f+4>>2];s:{if(!g){break s}j=J[g+4>>2];J[g+4>>2]=j-1;if(j){break s}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((f|0)!=(i|0)){continue}break}g=J[h+124>>2];}J[h+128>>2]=i;$a(g);}j=J[h+24>>2];f=j-12|0;r=P(J[f+4>>2]-J[f>>2]>>5,r);k=k+1|0;g=J[d>>2];if(k>>>0>=J[d+4>>2]-g>>2>>>0){break k}continue}break}f=Z()|0;break h}f=Z()|0;_b(h+124|0);break h}f=Z()|0;break h}if(!r){break j}}m=0;t:{u:{v:{w:{while(1){j=J[h+32>>2];if(J[d+4>>2]!=J[d>>2]){f=0;i=J[h+20>>2];g=m;while(1){k=P(f,12);l=k+i|0;i=J[l>>2];J[(f<<2)+j>>2]=i+((g>>>0)%(J[l+4>>2]-i>>5>>>0)<<5);l=g;i=J[h+20>>2];g=k+i|0;g=(l>>>0)/(J[g+4>>2]-J[g>>2]>>5>>>0)|0;f=f+1|0;if(f>>>0<J[d+4>>2]-J[d>>2]>>2>>>0){continue}break}}J[h+108>>2]=0;J[h+100>>2]=0;J[h+104>>2]=0;f=j;n=J[h+36>>2];if((f|0)!=(n|0)){x:{while(1){y:{k=J[j>>2];f=J[h+104>>2];z:{if((f|0)!=J[h+108>>2]){J[f>>2]=J[k>>2];g=J[k+4>>2];J[f+4>>2]=g;if(g){J[g+4>>2]=J[g+4>>2]+1;}J[h+104>>2]=f+8;break z}A:{i=J[h+100>>2];g=f-i|0;o=g>>3;l=o+1|0;B:{if(l>>>0>=536870912){J[5996]=0;ca(59);break B}p=g>>2;g=g>>>0>=2147483640?536870911:l>>>0<p>>>0?p:l;if(g>>>0<536870912){break A}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}f=Z()|0;break t}J[5996]=0;p=g<<3;l=$(3,p|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break y}g=l+(o<<3)|0;J[g>>2]=J[k>>2];k=J[k+4>>2];J[g+4>>2]=k;if(k){J[k+4>>2]=J[k+4>>2]+1;f=J[h+104>>2];}k=l+p|0;l=g+8|0;C:{if((f|0)==(i|0)){J[h+108>>2]=k;J[h+104>>2]=l;J[h+100>>2]=g;break C}while(1){g=g-8|0;f=f-8|0;J[g>>2]=J[f>>2];J[g+4>>2]=J[f+4>>2];J[f>>2]=0;J[f+4>>2]=0;if((f|0)!=(i|0)){continue}break}J[h+108>>2]=k;f=J[h+104>>2];J[h+104>>2]=l;i=J[h+100>>2];J[h+100>>2]=g;if((f|0)==(i|0)){break C}while(1){f=f-8|0;g=J[f+4>>2];D:{if(!g){break D}k=J[g+4>>2];J[g+4>>2]=k-1;if(k){break D}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((f|0)!=(i|0)){continue}break}}if(!i){break z}$a(i);}j=j+4|0;if((n|0)!=(j|0)){continue}break x}break}f=Z()|0;break t}j=J[h+36>>2];f=J[h+32>>2];}J[5996]=0;va(63,h+80|0,c|0,f|0,j|0,0);f=J[5996];J[5996]=0;if((f|0)==1){break u}J[5996]=0;j=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)==1){break u}J[j>>2]=7e3;J[j+4>>2]=0;J[j+8>>2]=0;p=J[h+100>>2];J[h+112>>2]=p;q=J[h+104>>2];J[h+116>>2]=q;l=J[h+108>>2];f=0;J[h+108>>2]=0;J[h+120>>2]=l;J[h+100>>2]=0;J[h+104>>2]=0;g=J[e>>2];n=J[e+4>>2];E:{if((g|0)==(n|0)){k=0;i=0;break E}o=n-g|0;if((o|0)<0){J[5996]=0;ca(8);a=J[5996];J[5996]=0;if((a|0)!=1){break a}f=Z()|0;break v}J[5996]=0;k=$(3,o|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break w}t=n+(g^-1)|0;i=0;f=k;u=o&7;if(u){while(1){H[f|0]=K[g|0];f=f+1|0;g=g+1|0;i=i+1|0;if((u|0)!=(i|0)){continue}break}}i=k+o|0;if(t>>>0<7){break E}while(1){H[f|0]=K[g|0];H[f+1|0]=K[g+1|0];H[f+2|0]=K[g+2|0];H[f+3|0]=K[g+3|0];H[f+4|0]=K[g+4|0];H[f+5|0]=K[g+5|0];H[f+6|0]=K[g+6|0];H[f+7|0]=K[g+7|0];f=f+8|0;g=g+8|0;if((n|0)!=(g|0)){continue}break}l=J[h+120>>2];q=J[h+116>>2];p=J[h+112>>2];}J[j+12>>2]=c;J[j+16>>2]=0;J[j+20>>2]=0;J[j+24>>2]=0;J[j+28>>2]=0;J[j+52>>2]=l;J[j+48>>2]=q;o=j+44|0;J[o>>2]=p;J[j+40>>2]=i;J[j+36>>2]=f;J[j+32>>2]=k;J[h+120>>2]=0;J[h+112>>2]=0;J[h+116>>2]=0;J[5996]=0;i=j+12|0;aa(86,j+56|0,i|0);f=J[5996];J[5996]=0;F:{if((f|0)==1){break F}J[5996]=0;aa(87,j+76|0,i|0);f=J[5996];J[5996]=0;if((f|0)==1){break F}J[5996]=0;f=$(88,i|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break F}J[j+92>>2]=f;g=0;l=0;k=J[j+44>>2];f=k;n=J[j+48>>2];if((f|0)!=(n|0)){while(1){g=J[J[f>>2]+84>>2]+g|0;f=f+8|0;if((n|0)!=(f|0)){continue}break}l=J[J[k>>2]+80>>2];}f=J[j+16>>2];p=J[j+12>>2];q=J[j+20>>2];t=J[j+24>>2];J[5996]=0;f=ka(89,p|0,l|0,g|0,f|0,n-k>>3,(t-q|0)/12|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break F}J[j+96>>2]=f;J[5996]=0;J[h+140>>2]=i;ea(90,h+124|0,i|0,h+140|0);f=J[5996];J[5996]=0;if((f|0)==1){break F}f=K[h+136|0];if(f){Db(J[h+128>>2]);}H[j+100|0]=f^1;J[h+128>>2]=j;J[h+124>>2]=i;J[5996]=0;f=J[h+128>>2];J[h+8>>2]=J[h+124>>2];J[h+12>>2]=f;ea(61,a|0,h+80|0,h+8|0);f=J[5996];J[5996]=0;if((f|0)==1){break u}g=J[h+100>>2];if(g){f=J[h+104>>2];if((g|0)!=(f|0)){while(1){f=f-8|0;i=J[f+4>>2];G:{if(!i){break G}j=J[i+4>>2];J[i+4>>2]=j-1;if(j){break G}Xa[J[J[i>>2]+8>>2]](i);bb(i);}if((f|0)!=(g|0)){continue}break}g=J[h+100>>2];}$a(g);}m=m+1|0;if((r|0)!=(m|0)){continue}break j}break}f=Z()|0;lb(o);a=J[j+32>>2];if(a){J[j+36>>2]=a;$a(a);}rb(j+20|0);break v}f=Z()|0;}lb(h+112|0);$a(j);break t}f=Z()|0;}lb(h+100|0);break h}i=J[h+20>>2];if(i){f=J[h+24>>2];if((i|0)!=(f|0)){while(1){k=f-12|0;j=J[k>>2];if(j){m=f-8|0;f=J[m>>2];g=j;if((f|0)!=(g|0)){while(1){f=f-32|0;g=J[f+4>>2];H:{if(!g){break H}l=J[g+4>>2];J[g+4>>2]=l-1;if(l){break H}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((f|0)!=(j|0)){continue}break}g=J[k>>2];}J[m>>2]=j;$a(g);}f=k;if((i|0)!=(f|0)){continue}break}i=J[h+20>>2];}$a(i);}s=s+1|0;f=J[h+44>>2];if(s>>>0<(J[h+48>>2]-f|0)/12>>>0){continue}break b}break}J[5996]=0;ga(44,5170,1900,642,2497);a=J[5996];J[5996]=0;if((a|0)!=1){break a}f=Z()|0;}Xc(h+20|0);break g}f=Z()|0;}a=J[h+32>>2];if(a){$a(a);}Wc(h+44|0);break c}f=Z()|0;}Mc(h+56|0);da(f|0);B();}a=J[h+32>>2];if(a){$a(a);f=J[h+44>>2];}if(f){g=f;i=J[h+48>>2];if((i|0)!=(f|0)){while(1){a=i-12|0;b=J[a>>2];if(b){J[i-8>>2]=b;$a(b);}i=a;if((i|0)!=(f|0)){continue}break}g=J[h+44>>2];}J[h+48>>2]=f;$a(g);}a=J[h+68>>2];if(a){J[h+72>>2]=a;$a(a);}a=J[h+56>>2];if(a){J[h+60>>2]=a;$a(a);}Ua=h+144|0;return}B();}function Wm(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;j=Ua-208|0;Ua=j;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{x:{y:{z:{k=Gb(a);if(k>>>0>=2147483632){J[5996]=0;ca(2);a=J[5996];J[5996]=0;if((a|0)==1){break z}break a}A:{if(k>>>0<=10){H[j+171|0]=k;n=j+160|0;break A}J[5996]=0;m=(k|15)+1|0;n=$(3,m|0)|0;l=J[5996];J[5996]=0;if((l|0)==1){break z}J[j+160>>2]=n;J[j+164>>2]=k;J[j+168>>2]=m|-2147483648;}H[fb(n,a,k)+k|0]=0;l=J[j+160>>2];a=K[j+171|0];p=a<<24>>24;k=(p|0)<0;o=k?l:j+160|0;r=k?J[j+164>>2]:a;k=o+r|0;n=-1;B:{while(1){if((k|0)==(o|0)){break B}k=k-1|0;m=K[k|0];s=m>>>0<=63;a=m&31;if((m&63)>>>0>=32){m=1<<a;a=0;}else {q=1<<a;m=q-1&1>>>32-a;a=q;}a=a&9728;if(s&(m&1|(a|0)!=0)){continue}break}n=k-o|0;}a=n+1|0;if(a>>>0>r>>>0){J[5996]=0;ca(108);a=J[5996];J[5996]=0;if((a|0)!=1){break a}k=fa(22864)|0;a=Va;break l}C:{if((p|0)<0){J[j+164>>2]=a;break C}H[j+171|0]=a;l=j+160|0;}H[a+l|0]=0;J[j+152>>2]=0;J[j+156>>2]=0;D:{if(H[j+171|0]>=0){J[j+144>>2]=J[j+168>>2];a=J[j+164>>2];J[j+136>>2]=J[j+160>>2];J[j+140>>2]=a;break D}J[5996]=0;ea(40,j+136|0,J[j+160>>2],J[j+164>>2]);a=J[5996];J[5996]=0;if((a|0)==1){break y}}J[5996]=0;a=j+172|0;aa(109,a|0,j+136|0);k=J[5996];J[5996]=0;if((k|0)==1){break x}m=a;a=H[j+183|0];k=(a|0)<0;J[j+104>>2]=k?J[j+172>>2]:m;J[j+108>>2]=k?J[j+176>>2]:a&255;J[5996]=0;a=J[j+108>>2];J[j+8>>2]=J[j+104>>2];J[j+12>>2]=a;aa(140,j+16|0,j+8|0);a=J[5996];J[5996]=0;if((a|0)==1){break w}a=J[j+20>>2];J[j+156>>2]=a;k=J[j+16>>2];J[j+152>>2]=k;if(H[j+183|0]<0){$a(J[j+172>>2]);}if(H[j+147|0]<0){$a(J[j+136>>2]);}E:{if(!k){break E}n=J[k+80>>2];if(!n|M[k+84>>2]>3600){break E}J[5996]=0;m=_(54,3557,1)|0;l=J[5996];J[5996]=0;if((l|0)==1){break u}if(!((n^-1)&m)){break r}}J[5996]=0;f=$(3,32)|0;g=J[5996];J[5996]=0;if((g|0)==1){break t}H[f+16|0]=0;g=K[2571]|K[2572]<<8|(K[2573]<<16|K[2574]<<24);h=K[2567]|K[2568]<<8|(K[2569]<<16|K[2570]<<24);H[f+8|0]=h;H[f+9|0]=h>>>8;H[f+10|0]=h>>>16;H[f+11|0]=h>>>24;H[f+12|0]=g;H[f+13|0]=g>>>8;H[f+14|0]=g>>>16;H[f+15|0]=g>>>24;g=K[2563]|K[2564]<<8|(K[2565]<<16|K[2566]<<24);h=K[2559]|K[2560]<<8|(K[2561]<<16|K[2562]<<24);H[f|0]=h;H[f+1|0]=h>>>8;H[f+2|0]=h>>>16;H[f+3|0]=h>>>24;H[f+4|0]=g;H[f+5|0]=g>>>8;H[f+6|0]=g>>>16;H[f+7|0]=g>>>24;g=((c|0)>=17?17:c)-1|0;H[fb(b,f,g)+g|0]=0;$a(f);J[5996]=0;f=$(3,32)|0;g=J[5996];J[5996]=0;if((g|0)==1){break s}H[f+16|0]=0;c=K[2571]|K[2572]<<8|(K[2573]<<16|K[2574]<<24);b=f;f=K[2567]|K[2568]<<8|(K[2569]<<16|K[2570]<<24);H[b+8|0]=f;H[b+9|0]=f>>>8;H[b+10|0]=f>>>16;H[b+11|0]=f>>>24;H[b+12|0]=c;H[b+13|0]=c>>>8;H[b+14|0]=c>>>16;H[b+15|0]=c>>>24;c=K[2563]|K[2564]<<8|(K[2565]<<16|K[2566]<<24);f=K[2559]|K[2560]<<8|(K[2561]<<16|K[2562]<<24);H[b|0]=f;H[b+1|0]=f>>>8;H[b+2|0]=f>>>16;H[b+3|0]=f>>>24;H[b+4|0]=c;H[b+5|0]=c>>>8;H[b+6|0]=c>>>16;H[b+7|0]=c>>>24;c=((e|0)>=17?17:e)-1|0;H[fb(d,b,c)+c|0]=0;$a(b);break q}k=fa(22864)|0;a=Va;break k}k=fa(22864)|0;a=Va;break m}k=fa(22864)|0;a=Va;break v}k=fa(22864)|0;a=Va;if(H[j+183|0]>=0){break v}$a(J[j+172>>2]);}if(H[j+147|0]>=0){break m}$a(J[j+136>>2]);break m}k=fa(22864)|0;a=Va;break m}k=fa(22864)|0;a=Va;break m}k=fa(22864)|0;a=Va;break m}a=J[k+84>>2];J[5996]=0;n=j+60|0;aa(115,n|0,a|0);a=J[5996];J[5996]=0;F:{G:{H:{I:{J:{K:{L:{M:{N:{O:{P:{Q:{R:{if((a|0)!=1){J[5996]=0;a=ba(99,n|0,0,5546)|0;n=J[5996];J[5996]=0;if((n|0)==1){break R}J[j+80>>2]=J[a+8>>2];n=J[a+4>>2];J[j+72>>2]=J[a>>2];J[j+76>>2]=n;J[a>>2]=0;J[a+4>>2]=0;J[a+8>>2]=0;J[5996]=0;n=_(97,j+72|0,3581)|0;m=J[5996];J[5996]=0;if((m|0)==1){break Q}J[j+96>>2]=J[n+8>>2];m=J[n+4>>2];J[j+88>>2]=J[n>>2];J[j+92>>2]=m;J[n>>2]=0;J[n+4>>2]=0;J[n+8>>2]=0;J[5996]=0;m=j+172|0;aa(141,m|0,j+152|0);l=J[5996];J[5996]=0;if((l|0)==1){break P}J[5996]=0;q=m;m=K[j+183|0];l=m<<24>>24<0;m=ba(100,j+88|0,(l?J[j+172>>2]:q)|0,(l?J[j+176>>2]:m)|0)|0;l=J[5996];J[5996]=0;if((l|0)==1){break O}J[j+112>>2]=J[m+8>>2];l=J[m+4>>2];J[j+104>>2]=J[m>>2];J[j+108>>2]=l;J[m>>2]=0;J[m+4>>2]=0;J[m+8>>2]=0;J[5996]=0;l=_(97,j+104|0,3570)|0;o=J[5996];J[5996]=0;if((o|0)==1){break N}J[j+128>>2]=J[l+8>>2];o=J[l+4>>2];J[j+120>>2]=J[l>>2];J[j+124>>2]=o;J[l>>2]=0;J[l+4>>2]=0;J[l+8>>2]=0;if(H[j+183|0]<0){$a(J[j+172>>2]);}if(H[m+11|0]<0){$a(J[m>>2]);}if(H[n+11|0]<0){$a(J[n>>2]);}if(H[a+11|0]<0){$a(J[a>>2]);}n=J[j+120>>2];a=K[j+131|0];m=a<<24>>24;l=(m|0)<0;q=l?n:j+120|0;a=l?J[j+124>>2]:a;l=c-1|0;a=(a|0)<(l|0)?a:l;H[fb(b,q,a)+a|0]=0;J[5996]=0;l=j+172|0;aa(117,l|0,k|0);a=J[5996];J[5996]=0;if((a|0)==1){break I}J[j+44>>2]=J[j+200>>2];a=J[j+196>>2];J[j+36>>2]=J[j+192>>2];J[j+40>>2]=a;a=J[j+188>>2];J[j+28>>2]=J[j+184>>2];J[j+32>>2]=a;a=J[j+180>>2];J[j+20>>2]=J[j+176>>2];J[j+24>>2]=a;a=J[j+172>>2];J[j+16>>2]=a;J[5996]=0;o=a>>>0<29;p=o?j+20|0:J[j+24>>2];J[j+172>>2]=p;r=j+48|0;ga(102,r|0,l|0,p+(o?a:a-29|0)|0,0);a=J[5996];J[5996]=0;if((a|0)==1){break H}a=J[j+48>>2];l=K[j+59|0];o=l<<24>>24;p=(o|0)<0;q=p?a:r;l=p?J[j+52>>2]:l;p=e-1|0;l=(l|0)<(p|0)?l:p;H[fb(d,q,l)+l|0]=0;if((o|0)<0){$a(a);}if(M[j+16>>2]>=29){$a(J[j+24>>2]);k=J[j+152>>2];}a=J[k+80>>2];if(!a|M[k+84>>2]>3600|(J[k+52>>2]+J[k+44>>2]>>>0>201|M[k+68>>2]>100)){break G}J[5996]=0;l=_(54,2049,1)|0;o=J[5996];J[5996]=0;if((o|0)==1){break p}if((a^-1)&l){break G}a=J[k+80>>2];J[5996]=0;l=_(54,2165,1)|0;o=J[5996];J[5996]=0;if((o|0)==1){break p}if(K[k+88|0]|(a^-1)&l){break G}H[j+176|0]=0;J[j+172>>2]=1702195828;H[j+183|0]=4;a=((i|0)>=5?5:i)-1|0;H[fb(h,j+172|0,a)+a|0]=0;break F}k=fa(22864)|0;a=Va;break m}k=fa(22864)|0;a=Va;break J}k=fa(22864)|0;a=Va;break K}k=fa(22864)|0;a=Va;break L}k=fa(22864)|0;a=Va;break M}k=fa(22864)|0;a=Va;if(H[j+115|0]>=0){break M}$a(J[j+104>>2]);}if(H[j+183|0]>=0){break L}$a(J[j+172>>2]);}if(H[j+99|0]>=0){break K}$a(J[j+88>>2]);}if(H[j+83|0]>=0){break J}$a(J[j+72>>2]);}if(H[j+71|0]>=0){break m}$a(J[j+60>>2]);break m}k=fa(22864)|0;break o}k=fa(22864)|0;a=Va;if(M[j+16>>2]<29){break n}$a(J[j+24>>2]);break n}H[j+176|0]=K[2354];H[j+183|0]=5;H[j+177|0]=0;J[j+172>>2]=K[2350]|K[2351]<<8|(K[2352]<<16|K[2353]<<24);a=((i|0)>=6?6:i)-1|0;H[fb(h,j+172|0,a)+a|0]=0;}J[5996]=0;a=$(118,k|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break p}S:{if(a){H[j+176|0]=0;J[j+172>>2]=1702195828;H[j+183|0]=4;a=((g|0)>=5?5:g)-1|0;H[fb(f,j+172|0,a)+a|0]=0;break S}H[j+176|0]=K[2354];H[j+183|0]=5;H[j+177|0]=0;J[j+172>>2]=K[2350]|K[2351]<<8|(K[2352]<<16|K[2353]<<24);a=((g|0)>=6?6:g)-1|0;H[fb(f,j+172|0,a)+a|0]=0;}if((m|0)<0){$a(n);}a=J[j+156>>2];}T:{if(!a){break T}b=J[a+4>>2];J[a+4>>2]=b-1;if(b){break T}Xa[J[J[a>>2]+8>>2]](a);bb(a);}if(H[j+171|0]>=0){break j}$a(J[j+160>>2]);break j}k=fa(22864)|0;}a=Va;}if((m|0)>=0){break m}$a(n);}mb(j+152|0);}if(H[j+171|0]>=0){break k}$a(J[j+160>>2]);}if((wa(22864)|0)!=(a|0)){break c}a=pa(k|0)|0;a=Xa[J[J[a>>2]+8>>2]](a)|0;J[5996]=0;g=_(30,j+120|0,a|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break i}J[5996]=0;a=ba(99,g|0,0,5474)|0;f=J[5996];J[5996]=0;if((f|0)==1){break h}J[j+168>>2]=J[a+8>>2];f=J[a+4>>2];J[j+160>>2]=J[a>>2];J[j+164>>2]=f;J[a>>2]=0;J[a+4>>2]=0;J[a+8>>2]=0;J[5996]=0;f=_(97,j+160|0,2611)|0;h=J[5996];J[5996]=0;if((h|0)==1){break g}J[j+24>>2]=J[f+8>>2];g=J[f+4>>2];J[j+16>>2]=J[f>>2];J[j+20>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;k=b;b=J[j+16>>2];g=K[j+27|0];h=g<<24>>24;i=(h|0)<0;g=i?J[j+20>>2]:g;c=c-1|0;c=(c|0)>(g|0)?g:c;H[fb(k,i?b:j+16|0,c)+c|0]=0;U:{if((h|0)>=0){break U}$a(b);if(H[f+11|0]>=0){break U}$a(J[f>>2]);}if(H[a+11|0]<0){$a(J[a>>2]);}J[5996]=0;a=_(30,j+16|0,5575)|0;b=J[5996];J[5996]=0;if((b|0)==1){break e}g=d;b=J[a>>2];c=K[a+11|0];d=c<<24>>24;f=(d|0)<0;h=f?b:a;a=f?J[a+4>>2]:c;c=e-1|0;a=(a|0)<(c|0)?a:c;H[fb(g,h,a)+a|0]=0;if((d|0)<0){$a(b);}ra();}Ua=j+208|0;return}k=Z()|0;break d}k=Z()|0;break f}k=Z()|0;if(H[j+171|0]>=0){break f}$a(J[j+160>>2]);}if(H[g+11|0]>=0){break d}$a(J[g>>2]);break d}k=Z()|0;}J[5996]=0;ca(110);a=J[5996];J[5996]=0;if((a|0)==1){break b}}da(k|0);B();}fa(0)|0;Vb();B();}B();}function Xg(a,b,c,d,e){var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;h=Ua-160|0;Ua=h;Yc(h+48|0,c,O[a+16>>3],O[a+24>>3],0,0);J[5996]=0;g=$(46,c|0)|0;f=J[5996];J[5996]=0;a:{b:{c:{if((f|0)!=1){J[h+44>>2]=0;J[h+36>>2]=0;J[h+40>>2]=0;H[h+140|0]=0;J[h+136>>2]=h+36;f=J[g+4>>2];j=J[g>>2];m=f-j|0;i=(m|0)/12|0;if((f|0)!=(j|0)){d:{e:{f:{if(i>>>0>=357913942){J[5996]=0;ca(47);a=J[5996];J[5996]=0;if((a|0)==1){break f}break a}J[5996]=0;f=$(3,m|0)|0;j=J[5996];J[5996]=0;if((j|0)==1){break f}J[h+40>>2]=f;J[h+36>>2]=f;J[h+44>>2]=f+P(i,12);i=J[g+4>>2];g=J[g>>2];J[5996]=0;g=ia(48,h+44|0,g|0,i|0,f|0)|0;i=J[5996];J[5996]=0;if((i|0)!=1){break d}g=Z()|0;J[h+40>>2]=f;break e}g=Z()|0;}Nc(h+136|0);break c}J[h+40>>2]=g;}J[h+32>>2]=0;J[h+24>>2]=0;J[h+28>>2]=0;f=J[d+4>>2];g=J[d>>2];J[5996]=0;aa(49,h+24|0,f-g>>2);f=J[5996];J[5996]=0;g:{if((f|0)!=1){g=J[h+40>>2];f=J[h+36>>2];if((g|0)==(f|0)){break b}s=h+112|0;g=f;h:{while(1){i:{J[h+20>>2]=0;J[h+12>>2]=0;J[h+16>>2]=0;i=J[d+4>>2];f=J[d>>2];n=P(r,12);g=n+g|0;if(i-f>>2!=J[g+4>>2]-J[g>>2]>>3){break i}j=0;o=1;l=0;j:{if((f|0)!=(i|0)){k:{l:{m:{while(1){g=l<<3;t=O[g+J[h+60>>2]>>3];u=O[g+J[h+48>>2]>>3];f=J[(l<<2)+f>>2];J[5996]=0;f=qa(50,f|0,+u,+t,b|0)|0;i=J[5996];J[5996]=0;if((i|0)==1){break l}g=g+J[n+J[h+36>>2]>>2]|0;i=J[g>>2];g=J[g+4>>2];m=J[f+4>>2];f=J[f>>2];J[5996]=0;oa(51,h+136|0,f|0,m|0,i|0,g|0);f=J[5996];J[5996]=0;if((f|0)!=1){i=J[h+20>>2];n:{if(i>>>0>j>>>0){J[j+8>>2]=0;J[j>>2]=0;J[j+4>>2]=0;J[j>>2]=J[h+136>>2];J[j+4>>2]=J[h+140>>2];J[j+8>>2]=J[h+144>>2];J[h+16>>2]=j+12;break n}o:{f=J[h+12>>2];m=(j-f|0)/12|0;g=m+1|0;p:{if(g>>>0>=357913942){J[5996]=0;ca(52);break p}i=(i-f|0)/12|0;k=i<<1;g=i>>>0>=178956970?357913941:g>>>0<k>>>0?k:g;if(g>>>0<357913942){break o}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}break m}J[5996]=0;k=P(g,12);i=$(3,k|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break m}g=i+P(m,12)|0;J[g>>2]=J[h+136>>2];J[g+4>>2]=J[h+140>>2];J[g+8>>2]=J[h+144>>2];J[h+144>>2]=0;J[h+136>>2]=0;J[h+140>>2]=0;i=i+k|0;m=g+12|0;q:{if((f|0)==(j|0)){J[h+20>>2]=i;J[h+16>>2]=m;J[h+12>>2]=g;break q}while(1){g=g-12|0;j=j-12|0;J[g>>2]=J[j>>2];J[g+4>>2]=J[j+4>>2];J[g+8>>2]=J[j+8>>2];J[j+8>>2]=0;J[j>>2]=0;J[j+4>>2]=0;if((f|0)!=(j|0)){continue}break}J[h+20>>2]=i;f=J[h+16>>2];J[h+16>>2]=m;j=J[h+12>>2];J[h+12>>2]=g;if((f|0)==(j|0)){break q}while(1){k=f-12|0;m=J[k>>2];if(m){p=f-8|0;g=J[p>>2];i=m;if((g|0)!=(i|0)){while(1){g=g-32|0;f=J[g+4>>2];r:{if(!f){break r}i=J[f+4>>2];J[f+4>>2]=i-1;if(i){break r}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((g|0)!=(m|0)){continue}break}i=J[k>>2];}J[p>>2]=m;$a(i);}f=k;if((j|0)!=(f|0)){continue}break}}if(j){$a(j);}i=J[h+136>>2];if(!i){break n}f=i;g=J[h+140>>2];if((f|0)!=(g|0)){while(1){g=g-32|0;f=J[g+4>>2];s:{if(!f){break s}j=J[f+4>>2];J[f+4>>2]=j-1;if(j){break s}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((g|0)!=(i|0)){continue}break}f=J[h+136>>2];}J[h+140>>2]=i;$a(f);}j=J[h+16>>2];f=j-12|0;o=P(J[f+4>>2]-J[f>>2]>>5,o);l=l+1|0;f=J[d>>2];if(l>>>0>=J[d+4>>2]-f>>2>>>0){break k}continue}break}g=Z()|0;break h}g=Z()|0;_b(h+136|0);break h}g=Z()|0;break h}if(!o){break j}}m=0;t:{u:{v:{w:{x:{y:{while(1){j=J[h+24>>2];if(J[d+4>>2]!=J[d>>2]){g=0;i=J[h+12>>2];f=m;while(1){k=P(g,12);l=k+i|0;i=J[l>>2];J[(g<<2)+j>>2]=i+((f>>>0)%(J[l+4>>2]-i>>5>>>0)<<5);l=f;i=J[h+12>>2];f=k+i|0;f=(l>>>0)/(J[f+4>>2]-J[f>>2]>>5>>>0)|0;g=g+1|0;if(g>>>0<J[d+4>>2]-J[d>>2]>>2>>>0){continue}break}}J[h+100>>2]=0;J[h+92>>2]=0;J[h+96>>2]=0;g=j;n=J[h+28>>2];if((g|0)!=(n|0)){z:{while(1){A:{k=J[j>>2];g=J[h+96>>2];B:{if((g|0)!=J[h+100>>2]){J[g>>2]=J[k>>2];f=J[k+4>>2];J[g+4>>2]=f;if(f){J[f+4>>2]=J[f+4>>2]+1;}J[h+96>>2]=g+8;break B}C:{i=J[h+92>>2];f=g-i|0;p=f>>3;l=p+1|0;D:{if(l>>>0>=536870912){J[5996]=0;ca(59);break D}q=f>>2;f=f>>>0>=2147483640?536870911:l>>>0<q>>>0?q:l;if(f>>>0<536870912){break C}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}g=Z()|0;break t}J[5996]=0;q=f<<3;l=$(3,q|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break A}f=l+(p<<3)|0;J[f>>2]=J[k>>2];k=J[k+4>>2];J[f+4>>2]=k;if(k){J[k+4>>2]=J[k+4>>2]+1;g=J[h+96>>2];}k=l+q|0;l=f+8|0;E:{if((g|0)==(i|0)){J[h+100>>2]=k;J[h+96>>2]=l;J[h+92>>2]=f;break E}while(1){f=f-8|0;g=g-8|0;J[f>>2]=J[g>>2];J[f+4>>2]=J[g+4>>2];J[g>>2]=0;J[g+4>>2]=0;if((g|0)!=(i|0)){continue}break}J[h+100>>2]=k;g=J[h+96>>2];J[h+96>>2]=l;i=J[h+92>>2];J[h+92>>2]=f;if((g|0)==(i|0)){break E}while(1){g=g-8|0;f=J[g+4>>2];F:{if(!f){break F}k=J[f+4>>2];J[f+4>>2]=k-1;if(k){break F}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((g|0)!=(i|0)){continue}break}}if(!i){break B}$a(i);}j=j+4|0;if((n|0)!=(j|0)){continue}break z}break}g=Z()|0;break t}j=J[h+28>>2];g=J[h+24>>2];}J[5996]=0;va(63,h+72|0,c|0,g|0,j|0,0);f=J[5996];J[5996]=0;if((f|0)==1){break x}J[5996]=0;j=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)==1){break x}J[j>>2]=7e3;J[j+4>>2]=0;J[j+8>>2]=0;J[h+112>>2]=0;J[h+104>>2]=0;J[h+108>>2]=0;J[h+116>>2]=J[h+92>>2];f=J[h+100>>2];g=J[h+96>>2];J[h+100>>2]=0;J[h+120>>2]=g;J[h+124>>2]=f;J[h+92>>2]=0;J[h+96>>2]=0;H[h+132|0]=0;J[h+128>>2]=h+104;k=J[e+4>>2];g=J[e>>2];i=k-g|0;f=(i|0)/12|0;G:{if((g|0)!=(k|0)){if(f>>>0>=357913942){J[5996]=0;ca(41);a=J[5996];J[5996]=0;if((a|0)!=1){break a}g=Z()|0;break v}J[5996]=0;i=$(3,i|0)|0;l=J[5996];J[5996]=0;if((l|0)==1){break G}J[h+108>>2]=i;J[h+104>>2]=i;J[h+112>>2]=i+P(f,12);J[h+156>>2]=i;J[h+152>>2]=i;H[h+148|0]=0;J[h+136>>2]=s;J[h+144>>2]=h+156;J[h+140>>2]=h+152;f=i;while(1){H:{if(H[g+11|0]>=0){l=J[g+4>>2];J[f>>2]=J[g>>2];J[f+4>>2]=l;J[f+8>>2]=J[g+8>>2];break H}l=J[g+4>>2];n=J[g>>2];J[5996]=0;ea(40,f|0,n|0,l|0);f=J[5996];J[5996]=0;if((f|0)==1){break w}f=J[h+156>>2];}f=f+12|0;J[h+156>>2]=f;g=g+12|0;if((k|0)!=(g|0)){continue}break}J[h+108>>2]=f;}J[5996]=0;k=xa(60,j+12|0,c|0,h+116|0,h+104|0,0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break y}i=J[h+104>>2];if(i){f=J[h+108>>2];g=i;if((f|0)!=(g|0)){while(1){g=f-12|0;if(H[f-1|0]<0){$a(J[g>>2]);}f=g;if((i|0)!=(f|0)){continue}break}g=J[h+104>>2];}J[h+108>>2]=i;$a(g);}f=J[h+116>>2];if(f){g=J[h+120>>2];if((f|0)!=(g|0)){while(1){g=g-8|0;i=J[g+4>>2];I:{if(!i){break I}l=J[i+4>>2];J[i+4>>2]=l-1;if(l){break I}Xa[J[J[i>>2]+8>>2]](i);bb(i);}if((f|0)!=(g|0)){continue}break}f=J[h+116>>2];}$a(f);}J[h+140>>2]=j;J[h+136>>2]=k;J[5996]=0;f=J[h+140>>2];J[h>>2]=J[h+136>>2];J[h+4>>2]=f;ea(61,a|0,h+72|0,h|0);f=J[5996];J[5996]=0;if((f|0)==1){break x}f=J[h+92>>2];if(f){g=J[h+96>>2];if((f|0)!=(g|0)){while(1){g=g-8|0;i=J[g+4>>2];J:{if(!i){break J}j=J[i+4>>2];J[i+4>>2]=j-1;if(j){break J}Xa[J[J[i>>2]+8>>2]](i);bb(i);}if((f|0)!=(g|0)){continue}break}f=J[h+92>>2];}$a(f);}m=m+1|0;if((o|0)!=(m|0)){continue}break j}break}g=Z()|0;break v}g=Z()|0;rb(h+104|0);break u}g=Z()|0;break t}g=Z()|0;Wg(h+136|0);J[h+108>>2]=i;}Vg(h+128|0);}lb(h+116|0);$a(j);}lb(h+92|0);break h}i=J[h+12>>2];if(i){g=J[h+16>>2];if((i|0)!=(g|0)){while(1){m=g-12|0;j=J[m>>2];if(j){f=j;k=g-8|0;g=J[k>>2];if((f|0)!=(g|0)){while(1){g=g-32|0;f=J[g+4>>2];K:{if(!f){break K}o=J[f+4>>2];J[f+4>>2]=o-1;if(o){break K}Xa[J[J[f>>2]+8>>2]](f);bb(f);}if((g|0)!=(j|0)){continue}break}f=J[m>>2];}J[k>>2]=j;$a(f);}g=m;if((i|0)!=(g|0)){continue}break}i=J[h+12>>2];}$a(i);}r=r+1|0;g=J[h+36>>2];if(r>>>0<(J[h+40>>2]-g|0)/12>>>0){continue}break b}break}J[5996]=0;ga(44,5170,1900,642,2497);a=J[5996];J[5996]=0;if((a|0)!=1){break a}g=Z()|0;}Xc(h+12|0);break g}g=Z()|0;}a=J[h+24>>2];if(a){$a(a);}Wc(h+36|0);break c}g=Z()|0;}Mc(h+48|0);da(g|0);B();}a=J[h+24>>2];if(a){$a(a);g=J[h+36>>2];}if(g){f=g;i=J[h+40>>2];if((f|0)!=(i|0)){while(1){a=i-12|0;b=J[a>>2];if(b){J[i-8>>2]=b;$a(b);}i=a;if((i|0)!=(g|0)){continue}break}f=J[h+36>>2];}J[h+40>>2]=g;$a(f);}a=J[h+60>>2];if(a){J[h- -64>>2]=a;$a(a);}a=J[h+48>>2];if(a){J[h+52>>2]=a;$a(a);}Ua=h+160|0;return}B();}function Ng(a,b,c,d,e,f,g,h,i){var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,K=0,L=0,N=0,O=0,P=0,Q=0;k=Ua-336|0;Ua=k;m=h;n=i&65535;o=d;p=e&65535;t=(e^i)&-2147483648;r=i>>>16&32767;s=e>>>16&32767;a:{b:{if(r-32767>>>0>4294934529&s-32767>>>0>=4294934530){break b}j=e&2147483647;if(!(!d&(j|0)==2147418112?!(b|c):j>>>0<2147418112)){q=d;t=e|32768;break a}e=i&2147483647;if(!(!h&(e|0)==2147418112?!(f|g):e>>>0<2147418112)){q=h;t=i|32768;b=f;c=g;break a}if(!(b|d|(j^2147418112|c))){if(!(f|h|(e^2147418112|g))){b=0;c=0;t=2147450880;break a}t=t|2147418112;b=0;c=0;break a}if(!(f|h|(e^2147418112|g))){b=0;c=0;break a}if(!(b|d|(c|j))){b=!(f|h|(e|g));q=b?0:q;t=b?2147450880:t;b=0;c=0;break a}if(!(f|h|(e|g))){t=t|2147418112;b=0;c=0;break a}if((j|0)==65535|j>>>0<65535){d=!(o|p);i=d;j=d?b:o;d=d<<6;i=S(i?c:p);d=d+((i|0)==32?S(j)+32|0:i)|0;Cb(k+320|0,b,c,o,p,d-15|0);u=16-d|0;o=J[k+328>>2];p=J[k+332>>2];c=J[k+324>>2];b=J[k+320>>2];}if(e>>>0>65535){break b}d=!(n|m);h=d;i=d?f:m;d=d<<6;h=S(h?g:n);d=d+((h|0)==32?S(i)+32|0:h)|0;Cb(k+304|0,f,g,m,n,d-15|0);u=(d+u|0)-16|0;m=J[k+312>>2];n=J[k+316>>2];f=J[k+304>>2];g=J[k+308>>2];}e=n|65536;z=e;A=m;d=m;j=e<<15|d>>>17;e=d<<15|g>>>17;d=e;i=0-d|0;h=j;j=1963258675-(j+((d|0)!=0)|0)|0;xb(k+288|0,d,h,0,0,i,j,0,0);d=J[k+296>>2];xb(k+272|0,0-d|0,0-(J[k+300>>2]+((d|0)!=0)|0)|0,0,0,i,j,0,0);d=J[k+280>>2];i=d<<1|J[k+276>>2]>>>31;d=J[k+284>>2]<<1|d>>>31;xb(k+256|0,i,d,0,0,e,h,0,0);j=J[k+264>>2];xb(k+240|0,i,d,0,0,0-j|0,0-(J[k+268>>2]+((j|0)!=0)|0)|0,0,0);i=J[k+248>>2];j=i<<1|J[k+244>>2]>>>31;d=J[k+252>>2]<<1|i>>>31;xb(k+224|0,j,d,0,0,e,h,0,0);i=J[k+232>>2];xb(k+208|0,j,d,0,0,0-i|0,0-(J[k+236>>2]+((i|0)!=0)|0)|0,0,0);d=J[k+216>>2];i=d<<1|J[k+212>>2]>>>31;d=J[k+220>>2]<<1|d>>>31;xb(k+192|0,i,d,0,0,e,h,0,0);j=J[k+200>>2];xb(k+176|0,i,d,0,0,0-j|0,0-(J[k+204>>2]+((j|0)!=0)|0)|0,0,0);i=e;e=J[k+184>>2];d=h;m=e<<1|J[k+180>>2]>>>31;h=m-1|0;e=(J[k+188>>2]<<1|e>>>31)-!m|0;xb(k+160|0,i,d,0,0,h,e,0,0);d=h;xb(k+144|0,f<<15,g<<15|f>>>17,0,0,d,e,0,0);w=k+112|0;x=J[k+168>>2];h=J[k+172>>2];m=J[k+160>>2];i=J[k+152>>2];l=m+i|0;n=J[k+164>>2];j=n+J[k+156>>2]|0;j=i>>>0>l>>>0?j+1|0:j;i=j;j=(n|0)==(j|0)&l>>>0<m>>>0|j>>>0<n>>>0;n=j+x|0;j=j>>>0>n>>>0?h+1|0:h;m=!i&l>>>0>1|(i|0)!=0;h=n+m|0;j=m>>>0>h>>>0?j+1|0:j;xb(w,d,e,0,0,0-h|0,0-(((h|0)!=0)+j|0)|0,0,0);xb(k+128|0,1-l|0,0-((l>>>0>1)+i|0)|0,0,0,d,e,0,0);I=(s-r|0)+u|0;e=J[k+116>>2];w=e;d=J[k+112>>2];j=e<<1|d>>>31;i=d<<1;n=j;d=j;h=J[k+140>>2];y=h;e=J[k+136>>2];j=h<<1|e>>>31;l=e<<1|J[k+132>>2]>>>31;h=l+i|0;d=d+j|0;d=h>>>0<l>>>0?d+1|0:d;e=d;d=d-(h>>>0<13927)|0;v=d;x=d;l=0;j=p|65536;K=j;L=o;d=o;j=j<<1|d>>>31;O=d<<1;P=j;E=j;d=co(v,l,j,0);j=Wa;B=d;C=j;u=b<<1;d=c<<1|b>>>31;r=d;j=0;s=j;m=h-13927|0;v=(e|0)==(v|0)&m>>>0<h>>>0|e>>>0>v>>>0;e=(e|0)==(n|0)&h>>>0<i>>>0|e>>>0<n>>>0;d=J[k+120>>2];h=J[k+124>>2]<<1|d>>>31;d=d<<1|w>>>31;l=y>>>31|0;d=l+d|0;j=h;j=d>>>0<l>>>0?j+1|0:j;h=d;d=d+e|0;j=h>>>0>d>>>0?j+1|0:j;e=d;d=d+v|0;l=e>>>0>d>>>0?j+1|0:j;e=d-1|0;D=l-!d|0;y=0;i=co(r,s,D,y);d=i+B|0;h=Wa+C|0;h=d>>>0<i>>>0?h+1|0:h;n=(C|0)==(h|0)&d>>>0<B>>>0|h>>>0<C>>>0;B=e;N=c>>>31|0;G=N|o<<1;v=0;e=co(e,0,G,v);o=e+d|0;j=Wa+h|0;l=0;j=e>>>0>o>>>0?j+1|0:j;p=j;d=(j|0)==(h|0)&d>>>0>o>>>0|h>>>0>j>>>0;e=d;d=d+n|0;l=e>>>0>d>>>0?1:l;e=co(E,s,D,y);d=e+d|0;j=Wa+l|0;n=d;d=d>>>0<e>>>0?j+1|0:j;e=co(E,s,B,v);l=Wa;h=e;e=co(G,v,D,y);i=h+e|0;j=Wa+l|0;j=e>>>0>i>>>0?j+1|0:j;e=j;j=(l|0)==(j|0)&h>>>0>i>>>0|j>>>0<l>>>0;l=n+e|0;d=d+j|0;d=l>>>0<e>>>0?d+1|0:d;n=l;l=d;e=0;d=e+o|0;j=i+p|0;j=d>>>0<e>>>0?j+1|0:j;e=j;h=(j|0)==(p|0)&d>>>0<o>>>0|j>>>0<p>>>0;j=l;i=h;h=h+n|0;j=i>>>0>h>>>0?j+1|0:j;F=h;l=j;w=d;o=d;C=m;d=co(m,0,G,v);i=Wa;h=d;m=co(x,q,r,q);d=d+m|0;j=Wa+i|0;j=d>>>0<m>>>0?j+1|0:j;m=(i|0)==(j|0)&d>>>0<h>>>0|i>>>0>j>>>0;h=j;H=u&-2;i=co(B,v,H,0);p=i+d|0;j=Wa+j|0;j=i>>>0>p>>>0?j+1|0:j;i=j;d=(j|0)==(h|0)&d>>>0>p>>>0|h>>>0>j>>>0;h=0;j=d+m|0;d=(j>>>0<d>>>0?1:h)+e|0;n=j+o|0;d=n>>>0<j>>>0?d+1|0:d;j=l;o=d;d=(d|0)==(e|0)&n>>>0<w>>>0|d>>>0<e>>>0;e=d;d=d+F|0;j=e>>>0>d>>>0?j+1|0:j;Q=d;w=j;d=co(E,s,C,q);F=Wa;E=d;e=co(D,y,H,q);d=d+e|0;j=Wa+F|0;j=d>>>0<e>>>0?j+1|0:j;m=d;l=co(x,q,G,v);e=d+l|0;h=j;d=j+Wa|0;d=e>>>0<l>>>0?d+1|0:d;s=e;j=co(r,q,B,v);e=e+j|0;l=Wa+d|0;l=e>>>0<j>>>0?l+1|0:l;D=(d|0)==(l|0)&e>>>0<s>>>0|d>>>0>l>>>0;j=(h|0)==(F|0)&m>>>0<E>>>0|h>>>0<F>>>0;d=(d|0)==(h|0)&m>>>0>s>>>0|d>>>0<h>>>0;d=d+j|0;d=d+D|0;h=l;s=h+n|0;j=(d|y)+o|0;j=h>>>0>s>>>0?j+1|0:j;m=j;d=(o|0)==(j|0)&n>>>0>s>>>0|j>>>0<o>>>0;j=w;h=d;d=d+Q|0;j=h>>>0>d>>>0?j+1|0:j;y=d;o=j;d=co(x,q,H,q);x=Wa;n=d;h=co(r,q,C,q);d=d+h|0;j=Wa+x|0;j=d>>>0<h>>>0?j+1|0:j;w=0;h=(j|0)==(x|0)&d>>>0<n>>>0|j>>>0<x>>>0;n=j;d=j+p|0;j=(h|w)+i|0;j=d>>>0<n>>>0?j+1|0:j;i=(i|0)==(j|0)&d>>>0<p>>>0|i>>>0>j>>>0;h=j;j=e;p=0;e=p+d|0;l=h+j|0;j=0;l=e>>>0<p>>>0?l+1|0:l;d=(h|0)==(l|0)&d>>>0>e>>>0|h>>>0>l>>>0;e=d;d=d+i|0;j=(e>>>0>d>>>0?1:j)+m|0;l=o;e=d;d=d+s|0;j=e>>>0>d>>>0?j+1|0:j;e=j;h=(m|0)==(j|0)&d>>>0<s>>>0|j>>>0<m>>>0;i=h;h=h+y|0;l=i>>>0>h>>>0?l+1|0:l;i=l;c:{if((l|0)==131071|l>>>0<131071){L=O|N;K=v|P;xb(k+80|0,d,j,h,l,f,g,A,z);l=J[k+84>>2];n=l;j=b<<17;m=0;p=J[k+88>>2];c=m-p|0;b=J[k+80>>2];l=(l|b)!=0;o=c-l|0;p=(j-(J[k+92>>2]+(m>>>0<p>>>0)|0)|0)-(c>>>0<l>>>0)|0;m=0-b|0;n=0-(((b|0)!=0)+n|0)|0;b=I+16382|0;break c}d=(e&1)<<31|d>>>1;e=h<<31|e>>>1;h=(i&1)<<31|h>>>1;i=i>>>1|0;xb(k+96|0,d,e,h,i,f,g,A,z);o=J[k+100>>2];r=o;n=0;u=J[k+104>>2];m=n-u|0;l=J[k+96>>2];p=(o|l)!=0;o=m-p|0;p=((b<<16)-(J[k+108>>2]+(n>>>0<u>>>0)|0)|0)-(m>>>0<p>>>0)|0;m=0-l|0;n=0-(((l|0)!=0)+r|0)|0;u=b;r=c;b=I+16383|0;}if((b|0)>=32767){t=t|2147418112;b=0;c=0;break a}d:{if((b|0)>0){l=p<<1|o>>>31;o=o<<1|n>>>31;p=l;u=h;r=i&65535|b<<16;l=n<<1|m>>>31;i=m<<1;break d}if((b|0)<=-113){b=0;c=0;break a}xc(k- -64|0,d,e,h,i,1-b|0);Cb(k+48|0,u,r,L,K,b+112|0);d=J[k+64>>2];e=J[k+68>>2];u=J[k+72>>2];r=J[k+76>>2];xb(k+32|0,f,g,A,z,d,e,u,r);b=J[k+40>>2];c=J[k+56>>2];l=J[k+36>>2];o=b<<1|l>>>31;m=c-o|0;p=J[k+60>>2]-((J[k+44>>2]<<1|b>>>31)+(c>>>0<o>>>0)|0)|0;b=J[k+32>>2];h=l<<1|b>>>31;j=b<<1;i=J[k+52>>2];c=J[k+48>>2];b=(h|0)==(i|0)&j>>>0>c>>>0|h>>>0>i>>>0;o=m-b|0;p=p-(b>>>0>m>>>0)|0;l=i-((c>>>0<j>>>0)+h|0)|0;i=c-j|0;}b=i;xb(k+16|0,f,g,A,z,3,0,0,0);xb(k,f,g,A,z,5,0,0,0);c=0;h=l+c|0;j=d&1;b=b+j|0;h=i>>>0>b>>>0?h+1|0:h;i=b;g=(h|0)==(g|0)&f>>>0<i>>>0|g>>>0<h>>>0;l=p;b=(c|0)==(h|0)&i>>>0<j>>>0|c>>>0>h>>>0;f=b+o|0;l=b>>>0>f>>>0?l+1|0:l;j=e;b=(l|0)==(z|0);b=b&(f|0)==(A|0)?g:b&f>>>0>A>>>0|l>>>0>z>>>0;c=b;b=b+d|0;j=c>>>0>b>>>0?j+1|0:j;c=j;d=(e|0)==(j|0)&b>>>0<d>>>0|e>>>0>j>>>0;j=r;e=d;d=d+u|0;j=e>>>0>d>>>0?j+1|0:j;g=d;e=J[k+20>>2];n=(e|0)==(h|0)&M[k+16>>2]<i>>>0|e>>>0<h>>>0;e=J[k+28>>2];d=J[k+24>>2];e=j>>>0<2147418112&((d|0)==(f|0)&(e|0)==(l|0)?n:(e|0)==(l|0)&d>>>0<f>>>0|e>>>0<l>>>0);d=c;n=e;e=b+e|0;d=n>>>0>e>>>0?d+1|0:d;b=(c|0)==(d|0)&b>>>0>e>>>0|c>>>0>d>>>0;c=b;b=b+g|0;j=c>>>0>b>>>0?j+1|0:j;g=b;c=J[k+4>>2];h=(c|0)==(h|0)&M[k>>2]<i>>>0|c>>>0<h>>>0;c=J[k+12>>2];b=J[k+8>>2];b=j>>>0<2147418112&((b|0)==(f|0)&(c|0)==(l|0)?h:(c|0)==(l|0)&b>>>0<f>>>0|c>>>0<l>>>0);c=b;b=b+e|0;l=c>>>0>b>>>0?d+1|0:d;c=l;e=(d|0)==(l|0)&b>>>0<e>>>0|d>>>0>l>>>0;d=j;f=e;e=e+g|0;d=f>>>0>e>>>0?d+1|0:d;q=e|q;t=d|t;}J[a>>2]=b;J[a+4>>2]=c;J[a+8>>2]=q;J[a+12>>2]=t;Ua=k+336|0;}function hc(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;h=Ua-128|0;Ua=h;Yc(h+56|0,c,O[a+16>>3],O[a+24>>3],e,f);J[5996]=0;f=$(46,c|0)|0;g=J[5996];J[5996]=0;a:{b:{c:{if((g|0)!=1){J[h+52>>2]=0;J[h+44>>2]=0;J[h+48>>2]=0;H[h+84|0]=0;J[h+80>>2]=h+44;g=J[f+4>>2];j=J[f>>2];l=g-j|0;i=(l|0)/12|0;if((g|0)!=(j|0)){d:{e:{f:{if(i>>>0>=357913942){J[5996]=0;ca(47);a=J[5996];J[5996]=0;if((a|0)==1){break f}break a}J[5996]=0;g=$(3,l|0)|0;j=J[5996];J[5996]=0;if((j|0)==1){break f}J[h+48>>2]=g;J[h+44>>2]=g;J[h+52>>2]=g+P(i,12);i=J[f+4>>2];f=J[f>>2];J[5996]=0;f=ia(48,h+52|0,f|0,i|0,g|0)|0;i=J[5996];J[5996]=0;if((i|0)!=1){break d}f=Z()|0;J[h+48>>2]=g;break e}f=Z()|0;}Nc(h+80|0);break c}J[h+48>>2]=f;}J[h+40>>2]=0;J[h+32>>2]=0;J[h+36>>2]=0;f=J[d+4>>2];g=J[d>>2];J[5996]=0;aa(49,h+32|0,f-g>>2);f=J[5996];J[5996]=0;g:{if((f|0)!=1){f=J[h+48>>2];g=J[h+44>>2];if((f|0)==(g|0)){break b}f=g;h:{while(1){i:{J[h+28>>2]=0;J[h+20>>2]=0;J[h+24>>2]=0;i=J[d+4>>2];g=J[d>>2];o=P(r,12);f=o+f|0;if(i-g>>2!=J[f+4>>2]-J[f>>2]>>3){break i}j=0;n=1;m=0;j:{if((g|0)!=(i|0)){k:{l:{m:{while(1){f=m<<3;s=O[f+J[h+68>>2]>>3];t=O[f+J[h+56>>2]>>3];g=J[(m<<2)+g>>2];J[5996]=0;g=qa(50,g|0,+t,+s,b|0)|0;i=J[5996];J[5996]=0;if((i|0)==1){break l}f=f+J[o+J[h+44>>2]>>2]|0;i=J[f>>2];f=J[f+4>>2];l=J[g+4>>2];g=J[g>>2];J[5996]=0;oa(51,h+80|0,g|0,l|0,i|0,f|0);f=J[5996];J[5996]=0;if((f|0)!=1){i=J[h+28>>2];n:{if(i>>>0>j>>>0){J[j+8>>2]=0;J[j>>2]=0;J[j+4>>2]=0;J[j>>2]=J[h+80>>2];J[j+4>>2]=J[h+84>>2];J[j+8>>2]=J[h+88>>2];J[h+24>>2]=j+12;break n}o:{g=J[h+20>>2];l=(j-g|0)/12|0;f=l+1|0;p:{if(f>>>0>=357913942){J[5996]=0;ca(52);break p}i=(i-g|0)/12|0;k=i<<1;f=i>>>0>=178956970?357913941:f>>>0<k>>>0?k:f;if(f>>>0<357913942){break o}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}break m}J[5996]=0;k=P(f,12);i=$(3,k|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break m}f=i+P(l,12)|0;J[f>>2]=J[h+80>>2];J[f+4>>2]=J[h+84>>2];J[f+8>>2]=J[h+88>>2];J[h+88>>2]=0;J[h+80>>2]=0;J[h+84>>2]=0;i=i+k|0;l=f+12|0;q:{if((g|0)==(j|0)){J[h+28>>2]=i;J[h+24>>2]=l;J[h+20>>2]=f;break q}while(1){f=f-12|0;j=j-12|0;J[f>>2]=J[j>>2];J[f+4>>2]=J[j+4>>2];J[f+8>>2]=J[j+8>>2];J[j+8>>2]=0;J[j>>2]=0;J[j+4>>2]=0;if((g|0)!=(j|0)){continue}break}J[h+28>>2]=i;g=J[h+24>>2];J[h+24>>2]=l;j=J[h+20>>2];J[h+20>>2]=f;if((g|0)==(j|0)){break q}while(1){k=g-12|0;l=J[k>>2];if(l){p=g-8|0;f=J[p>>2];i=l;if((f|0)!=(i|0)){while(1){f=f-32|0;g=J[f+4>>2];r:{if(!g){break r}i=J[g+4>>2];J[g+4>>2]=i-1;if(i){break r}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((f|0)!=(l|0)){continue}break}i=J[k>>2];}J[p>>2]=l;$a(i);}g=k;if((j|0)!=(g|0)){continue}break}}if(j){$a(j);}i=J[h+80>>2];if(!i){break n}f=J[h+84>>2];g=i;if((f|0)!=(g|0)){while(1){f=f-32|0;g=J[f+4>>2];s:{if(!g){break s}j=J[g+4>>2];J[g+4>>2]=j-1;if(j){break s}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((f|0)!=(i|0)){continue}break}g=J[h+80>>2];}J[h+84>>2]=i;$a(g);}j=J[h+24>>2];f=j-12|0;n=P(J[f+4>>2]-J[f>>2]>>5,n);m=m+1|0;g=J[d>>2];if(m>>>0>=J[d+4>>2]-g>>2>>>0){break k}continue}break}f=Z()|0;break h}f=Z()|0;_b(h+80|0);break h}f=Z()|0;break h}if(!n){break j}}l=0;t:{u:{while(1){j=J[h+32>>2];if(J[d+4>>2]!=J[d>>2]){f=0;i=J[h+20>>2];g=l;while(1){k=P(f,12);m=k+i|0;i=J[m>>2];J[(f<<2)+j>>2]=i+((g>>>0)%(J[m+4>>2]-i>>5>>>0)<<5);m=g;i=J[h+20>>2];g=k+i|0;g=(m>>>0)/(J[g+4>>2]-J[g>>2]>>5>>>0)|0;f=f+1|0;if(f>>>0<J[d+4>>2]-J[d>>2]>>2>>>0){continue}break}}J[h+104>>2]=0;J[h+96>>2]=0;J[h+100>>2]=0;f=j;o=J[h+36>>2];if((f|0)!=(o|0)){v:{while(1){w:{k=J[j>>2];f=J[h+100>>2];x:{if((f|0)!=J[h+104>>2]){J[f>>2]=J[k>>2];g=J[k+4>>2];J[f+4>>2]=g;if(g){J[g+4>>2]=J[g+4>>2]+1;}J[h+100>>2]=f+8;break x}y:{i=J[h+96>>2];g=f-i|0;p=g>>3;m=p+1|0;z:{if(m>>>0>=536870912){J[5996]=0;ca(59);break z}q=g>>2;g=g>>>0>=2147483640?536870911:m>>>0<q>>>0?q:m;if(g>>>0<536870912){break y}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break a}f=Z()|0;break t}J[5996]=0;q=g<<3;m=$(3,q|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break w}g=m+(p<<3)|0;J[g>>2]=J[k>>2];k=J[k+4>>2];J[g+4>>2]=k;if(k){J[k+4>>2]=J[k+4>>2]+1;f=J[h+100>>2];}k=m+q|0;m=g+8|0;A:{if((f|0)==(i|0)){J[h+104>>2]=k;J[h+100>>2]=m;J[h+96>>2]=g;break A}while(1){g=g-8|0;f=f-8|0;J[g>>2]=J[f>>2];J[g+4>>2]=J[f+4>>2];J[f>>2]=0;J[f+4>>2]=0;if((f|0)!=(i|0)){continue}break}J[h+104>>2]=k;f=J[h+100>>2];J[h+100>>2]=m;i=J[h+96>>2];J[h+96>>2]=g;if((f|0)==(i|0)){break A}while(1){f=f-8|0;g=J[f+4>>2];B:{if(!g){break B}k=J[g+4>>2];J[g+4>>2]=k-1;if(k){break B}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((f|0)!=(i|0)){continue}break}}if(!i){break x}$a(i);}j=j+4|0;if((o|0)!=(j|0)){continue}break v}break}f=Z()|0;break t}j=J[h+36>>2];f=J[h+32>>2];}J[5996]=0;va(63,h+80|0,c|0,f|0,j|0,+e);f=J[5996];J[5996]=0;if((f|0)==1){break u}J[5996]=0;i=$(3,104)|0;f=J[5996];J[5996]=0;if((f|0)==1){break u}J[i>>2]=7e3;J[i+4>>2]=0;J[i+8>>2]=0;J[5996]=0;J[h+116>>2]=J[h+96>>2];f=J[h+104>>2];g=J[h+100>>2];J[h+104>>2]=0;J[h+120>>2]=g;J[h+124>>2]=f;J[h+96>>2]=0;J[h+100>>2]=0;k=ia(64,i+12|0,c|0,h+116|0,0)|0;f=J[5996];J[5996]=0;if((f|0)!=1){g=J[h+116>>2];if(g){f=J[h+120>>2];if((g|0)!=(f|0)){while(1){f=f-8|0;j=J[f+4>>2];C:{if(!j){break C}m=J[j+4>>2];J[j+4>>2]=m-1;if(m){break C}Xa[J[J[j>>2]+8>>2]](j);bb(j);}if((f|0)!=(g|0)){continue}break}g=J[h+116>>2];}$a(g);}J[h+112>>2]=i;J[h+108>>2]=k;J[5996]=0;f=J[h+112>>2];J[h+8>>2]=J[h+108>>2];J[h+12>>2]=f;ea(61,a|0,h+80|0,h+8|0);f=J[5996];J[5996]=0;if((f|0)==1){break u}g=J[h+96>>2];if(g){f=J[h+100>>2];if((g|0)!=(f|0)){while(1){f=f-8|0;i=J[f+4>>2];D:{if(!i){break D}j=J[i+4>>2];J[i+4>>2]=j-1;if(j){break D}Xa[J[J[i>>2]+8>>2]](i);bb(i);}if((f|0)!=(g|0)){continue}break}g=J[h+96>>2];}$a(g);}l=l+1|0;if((n|0)!=(l|0)){continue}break j}break}f=Z()|0;lb(h+116|0);$a(i);break t}f=Z()|0;}lb(h+96|0);break h}i=J[h+20>>2];if(i){f=J[h+24>>2];if((i|0)!=(f|0)){while(1){l=f-12|0;j=J[l>>2];if(j){k=f-8|0;f=J[k>>2];g=j;if((f|0)!=(g|0)){while(1){f=f-32|0;g=J[f+4>>2];E:{if(!g){break E}n=J[g+4>>2];J[g+4>>2]=n-1;if(n){break E}Xa[J[J[g>>2]+8>>2]](g);bb(g);}if((f|0)!=(j|0)){continue}break}g=J[l>>2];}J[k>>2]=j;$a(g);}f=l;if((i|0)!=(f|0)){continue}break}i=J[h+20>>2];}$a(i);}r=r+1|0;f=J[h+44>>2];if(r>>>0<(J[h+48>>2]-f|0)/12>>>0){continue}break b}break}J[5996]=0;ga(44,5170,1900,642,2497);a=J[5996];J[5996]=0;if((a|0)!=1){break a}f=Z()|0;}Xc(h+20|0);break g}f=Z()|0;}a=J[h+32>>2];if(a){$a(a);}Wc(h+44|0);break c}f=Z()|0;}Mc(h+56|0);da(f|0);B();}a=J[h+32>>2];if(a){$a(a);f=J[h+44>>2];}if(f){g=f;i=J[h+48>>2];if((i|0)!=(f|0)){while(1){a=i-12|0;b=J[a>>2];if(b){J[i-8>>2]=b;$a(b);}i=a;if((i|0)!=(f|0)){continue}break}g=J[h+44>>2];}J[h+48>>2]=f;$a(g);}a=J[h+68>>2];if(a){J[h+72>>2]=a;$a(a);}a=J[h+56>>2];if(a){J[h+60>>2]=a;$a(a);}Ua=h+128|0;return}B();}function tk(a,b,c,d,e,f,g,h,i,j,k){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;l=Ua-528|0;Ua=l;J[l+520>>2]=k;J[l+524>>2]=b;a:{b:{if(Tb(a,l+524|0)){J[f>>2]=J[f>>2]|4;a=0;break b}J[l+72>>2]=220;t=l+104|0;J[t>>2]=l+112;s=l+72|0;J[t+4>>2]=J[s>>2];o=J[t>>2];J[l+100>>2]=o;J[l+96>>2]=o+400;J[s>>2]=0;J[s+4>>2]=0;J[s+8>>2]=0;p=l+60|0;J[p>>2]=0;J[p+4>>2]=0;J[p+8>>2]=0;m=l+48|0;J[m>>2]=0;J[m+4>>2]=0;J[m+8>>2]=0;n=l+36|0;J[n>>2]=0;J[n+4>>2]=0;J[n+8>>2]=0;q=l+24|0;J[q>>2]=0;J[q+4>>2]=0;J[q+8>>2]=0;b=J[d>>2];J[5996]=0;sa(229,c|0,b|0,l+92|0,l+88|0,l+84|0,s|0,p|0,m|0,n|0,l+20|0);b=J[5996];J[5996]=0;if((b|0)!=1){J[j>>2]=J[i>>2];v=e&512;u=J[l+20>>2];e=0;while(1){c:{d:{e:{f:{g:{if((e|0)==4){break g}J[5996]=0;b=_(202,a|0,l+524|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(b){break g}h:{i:{j:{k:{l:{switch(H[(l+92|0)+e|0]){case 1:if((e|0)==3){break c}b=J[a>>2];J[5996]=0;b=$(203,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[5996]=0;b=ba(230,h|0,1,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(b){J[5996]=0;aa(231,l+12|0,a|0);b=J[5996];J[5996]=0;if((b|0)!=1){J[5996]=0;aa(232,q|0,J[l+12>>2]);b=J[5996];J[5996]=0;if((b|0)!=1){break k}}break a}J[f>>2]=J[f>>2]|4;a=0;break d;case 4:break h;case 2:break i;case 3:break j;case 0:break l;default:break c}}if((e|0)==3){break c}}while(1){J[5996]=0;b=_(202,a|0,l+524|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(b){break c}b=J[a>>2];J[5996]=0;b=$(203,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[5996]=0;b=ba(230,h|0,1,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(!b){break c}J[5996]=0;aa(231,l+12|0,a|0);b=J[5996];J[5996]=0;if((b|0)!=1){J[5996]=0;aa(232,q|0,J[l+12>>2]);b=J[5996];J[5996]=0;if((b|0)!=1){continue}}break}break a}m:{b=K[m+11|0];if(!((b&128)>>>7|0?J[m+4>>2]:b&127)){break m}b=J[a>>2];J[5996]=0;b=$(203,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(J[((K[m+11|0]&128)>>>7|0?J[m>>2]:m)>>2]!=(b|0)){break m}J[5996]=0;$(205,a|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}H[g|0]=0;b=K[m+11|0];r=((b&128)>>>7|0?J[m+4>>2]:b&127)>>>0>1?m:r;break c}n:{o:{k=J[n+4>>2];b=K[n+11|0];if((b&128)>>>7|0?k:b&127){b=J[a>>2];J[5996]=0;b=$(203,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(J[((K[n+11|0]&128)>>>7|0?J[n>>2]:n)>>2]==(b|0)){break o}k=J[n+4>>2];b=K[n+11|0];}c=K[m+11|0];c=(c&128)>>>7|0?J[m+4>>2]:c&127;if(!c|!((b&128)>>>7|0?k:b&127)){break n}J[f>>2]=J[f>>2]|4;a=0;break d}J[5996]=0;$(205,a|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}H[g|0]=1;b=K[n+11|0];r=((b&128)>>>7|0?J[n+4>>2]:b&127)>>>0>1?n:r;break c}b=(b&128)>>>7|0?k:b&127;if(!(b|c)){break c}H[g|0]=!b;break c}if(!(r|e>>>0<2|((e|0)==2&K[l+95|0]!=0|v))){r=0;break c}J[l+12>>2]=Mb(p);p:{if(!e|K[(e+l|0)+91|0]>1){break p}q:{while(1){c=qc(p);b=J[l+12>>2];if((c|0)==(b|0)){break q}b=J[b>>2];J[5996]=0;b=ba(230,h|0,1,b|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(!b){break q}J[l+12>>2]=J[l+12>>2]+4;continue}break}break a}b=Mb(p);b=J[l+12>>2]-b>>2;c=K[q+11|0];if(b>>>0<=((c&128)>>>7|0?J[q+4>>2]:c&127)>>>0){c=Rd(qc(q),0-b|0);d=qc(q);k=Mb(p);b=Ua-16|0;Ua=b;J[b+8>>2]=k;J[b+12>>2]=c;while(1){k=(c|0)!=(d|0);if(!(!k|J[c>>2]!=J[J[b+8>>2]>>2])){J[b+12>>2]=J[b+12>>2]+4;J[b+8>>2]=J[b+8>>2]+4;c=J[b+12>>2];continue}break}Ua=b+16|0;if(!k){break p}}J[l+8>>2]=Mb(p);J[l+12>>2]=J[l+8>>2];}J[l+8>>2]=J[l+12>>2];r:{while(1){if((qc(p)|0)==J[l+8>>2]){break r}J[5996]=0;b=_(202,a|0,l+524|0)|0;c=J[5996];J[5996]=0;s:{if((c|0)==1){break s}if(b){break r}b=J[a>>2];J[5996]=0;b=$(203,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break s}if(J[J[l+8>>2]>>2]!=(b|0)){break r}J[5996]=0;$(205,a|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}J[l+8>>2]=J[l+8>>2]+4;continue}break}break a}if(!v){break c}if((qc(p)|0)==J[l+8>>2]){break c}J[f>>2]=J[f>>2]|4;a=0;break d}b=0;w=J[l+84>>2];c=o;t:{while(1){u:{J[5996]=0;d=_(202,a|0,l+524|0)|0;k=J[5996];J[5996]=0;if((k|0)==1){break u}if(d){break t}d=J[a>>2];J[5996]=0;k=$(203,d|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}J[5996]=0;d=ba(230,h|0,64,k|0)|0;x=J[5996];J[5996]=0;if((x|0)==1){break a}v:{if(d){d=J[j>>2];if((d|0)==J[l+520>>2]){J[5996]=0;ea(233,i|0,j|0,l+520|0);d=J[5996];J[5996]=0;if((d|0)==1){break a}d=J[j>>2];}J[j>>2]=d+4;J[d>>2]=k;b=b+1|0;break v}d=K[s+11|0];if(!((d&128)>>>7|0?J[s+4>>2]:d&127)|!b|(k|0)!=(w|0)){break t}if(J[l+96>>2]==(o|0)){J[5996]=0;ea(226,t|0,l+100|0,l+96|0);c=J[5996];J[5996]=0;if((c|0)==1){break a}o=J[l+100>>2];}c=o+4|0;J[l+100>>2]=c;J[o>>2]=b;o=c;b=0;}J[5996]=0;$(205,a|0)|0;d=J[5996];J[5996]=0;if((d|0)!=1){continue}}break}break a}if(!b|J[t>>2]==(c|0)){break f}if(J[l+96>>2]==(c|0)){J[5996]=0;ea(226,t|0,l+100|0,l+96|0);c=J[5996];J[5996]=0;if((c|0)==1){break a}c=J[l+100>>2];}o=c+4|0;J[l+100>>2]=o;J[c>>2]=b;break e}J[l+20>>2]=u;w:{if(!r){break w}k=1;while(1){b=K[r+11|0];if(((b&128)>>>7|0?J[r+4>>2]:b&127)>>>0<=k>>>0){break w}J[5996]=0;b=_(202,a|0,l+524|0)|0;c=J[5996];J[5996]=0;x:{if((c|0)==1){break x}y:{if(!b){b=J[a>>2];J[5996]=0;b=$(203,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break x}if(J[(k<<2)+((K[r+11|0]&128)>>>7|0?J[r>>2]:r)>>2]==(b|0)){break y}}J[f>>2]=J[f>>2]|4;a=0;break d}J[5996]=0;$(205,a|0)|0;b=J[5996];J[5996]=0;k=k+1|0;if((b|0)!=1){continue}}break}break a}a=1;b=J[t>>2];if((b|0)==(o|0)){break d}a=0;J[l+12>>2]=0;zb(s,b,o,l+12|0);if(J[l+12>>2]){J[f>>2]=J[f>>2]|4;break d}a=1;break d}o=c;}z:{if((u|0)<=0){break z}J[5996]=0;b=_(202,a|0,l+524|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}A:{if(!b){b=J[a>>2];J[5996]=0;b=$(203,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(J[l+88>>2]==(b|0)){break A}}J[f>>2]=J[f>>2]|4;a=0;break d}J[5996]=0;b=$(205,a|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}while(1){if((u|0)<=0){u=0;break z}J[5996]=0;c=_(202,b|0,l+524|0)|0;d=J[5996];J[5996]=0;B:{if((d|0)==1){break B}C:{if(!c){c=J[b>>2];J[5996]=0;c=$(203,c|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break B}J[5996]=0;c=ba(230,h|0,64,c|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break B}if(c){break C}}J[f>>2]=J[f>>2]|4;a=0;break d}if(J[j>>2]==J[l+520>>2]){J[5996]=0;ea(233,i|0,j|0,l+520|0);c=J[5996];J[5996]=0;if((c|0)==1){break B}}c=J[b>>2];J[5996]=0;c=$(203,c|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break B}d=J[j>>2];J[j>>2]=d+4;J[d>>2]=c;J[5996]=0;$(205,b|0)|0;c=J[5996];J[5996]=0;u=u-1|0;if((c|0)!=1){continue}}break}break a}if(J[j>>2]!=J[i>>2]){break c}J[f>>2]=J[f>>2]|4;a=0;}ab(q);ab(n);ab(m);ab(p);ab(s);db(t);break b}e=e+1|0;continue}}break a}Ua=l+528|0;return a|0}a=Z()|0;ab(q);ab(n);ab(m);ab(p);ab(s);db(t);da(a|0);B();}function Ak(a,b,c,d,e,f,g,h,i,j,k){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;l=Ua-528|0;Ua=l;J[l+520>>2]=k;J[l+524>>2]=b;a:{b:{if(Ub(a,l+524|0)){J[f>>2]=J[f>>2]|4;a=0;break b}J[l+76>>2]=220;t=l+104|0;J[t>>2]=l+112;s=l+76|0;J[t+4>>2]=J[s>>2];o=J[t>>2];J[l+100>>2]=o;J[l+96>>2]=o+400;J[s>>2]=0;J[s+4>>2]=0;J[s+8>>2]=0;p=l- -64|0;J[p>>2]=0;J[p+4>>2]=0;J[p+8>>2]=0;m=l+52|0;J[m>>2]=0;J[m+4>>2]=0;J[m+8>>2]=0;n=l+40|0;J[n>>2]=0;J[n+4>>2]=0;J[n+8>>2]=0;q=l+28|0;J[q>>2]=0;J[q+4>>2]=0;J[q+8>>2]=0;b=J[d>>2];J[5996]=0;sa(223,c|0,b|0,l+92|0,l+91|0,l+90|0,s|0,p|0,m|0,n|0,l+24|0);b=J[5996];J[5996]=0;if((b|0)!=1){J[j>>2]=J[i>>2];w=e&512;u=J[l+24>>2];x=K[l+95|0];y=K[l+91|0];z=K[l+90|0];d=o;e=0;while(1){c:{d:{e:{f:{if((e|0)==4){break f}J[5996]=0;b=_(186,a|0,l+524|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(b){break f}b=0;g:{h:{i:{j:{k:{switch(H[(l+92|0)+e|0]){case 1:if((e|0)==3){break c}b=J[a>>2];J[5996]=0;b=$(187,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}c=J[h+8>>2];if(J[c+((b&255)<<2)>>2]&1&(b|0)>=0){J[5996]=0;aa(224,l+16|0,a|0);b=J[5996];J[5996]=0;if((b|0)!=1){J[5996]=0;aa(98,q|0,H[l+16|0]);b=J[5996];J[5996]=0;if((b|0)!=1){break j}}break a}J[f>>2]=J[f>>2]|4;a=0;break d;case 4:break g;case 2:break h;case 3:break i;case 0:break k;default:break c}}if((e|0)==3){break c}}while(1){J[5996]=0;b=_(186,a|0,l+524|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(b){break c}b=J[a>>2];J[5996]=0;b=$(187,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}c=J[h+8>>2];if(!(J[c+((b&255)<<2)>>2]&1&(b|0)>=0)){break c}J[5996]=0;aa(224,l+16|0,a|0);b=J[5996];J[5996]=0;if((b|0)!=1){J[5996]=0;aa(98,q|0,H[l+16|0]);b=J[5996];J[5996]=0;if((b|0)!=1){continue}}break}break a}l:{b=K[m+11|0];if(!((b&128)>>>7|0?J[m+4>>2]:b&127)){break l}b=J[a>>2];J[5996]=0;b=$(187,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(K[((K[m+11|0]&128)>>>7|0?J[m>>2]:m)|0]!=(b&255)){break l}J[5996]=0;$(189,a|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}H[g|0]=0;b=K[m+11|0];r=((b&128)>>>7|0?J[m+4>>2]:b&127)>>>0>1?m:r;break c}m:{n:{k=J[n+4>>2];b=K[n+11|0];if((b&128)>>>7|0?k:b&127){b=J[a>>2];J[5996]=0;b=$(187,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if(K[((K[n+11|0]&128)>>>7|0?J[n>>2]:n)|0]==(b&255)){break n}k=J[n+4>>2];b=K[n+11|0];}c=K[m+11|0];c=(c&128)>>>7|0?J[m+4>>2]:c&127;if(!c|!((b&128)>>>7|0?k:b&127)){break m}J[f>>2]=J[f>>2]|4;a=0;break d}J[5996]=0;$(189,a|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}H[g|0]=1;b=K[n+11|0];r=((b&128)>>>7|0?J[n+4>>2]:b&127)>>>0>1?n:r;break c}b=(b&128)>>>7|0?k:b&127;if(!(b|c)){break c}H[g|0]=!b;break c}if(!(r|e>>>0<2|((e|0)==2&(x|0)!=0|w))){r=0;break c}J[l+16>>2]=Mb(p);o:{if(!e|K[(e+l|0)+91|0]>1){break o}while(1){p:{c=sc(p);b=J[l+16>>2];if((c|0)==(b|0)){break p}c=J[h+8>>2];b=H[b|0];if((b|0)>=0){b=J[c+((b&255)<<2)>>2]&1;}else {b=0;}if(!b){break p}J[l+16>>2]=J[l+16>>2]+1;continue}break}b=Mb(p);b=J[l+16>>2]-b|0;c=K[q+11|0];if(b>>>0<=((c&128)>>>7|0?J[q+4>>2]:c&127)>>>0){c=Td(sc(q),0-b|0);k=sc(q);v=Mb(p);b=Ua-16|0;Ua=b;J[b+8>>2]=v;J[b+12>>2]=c;while(1){v=(c|0)!=(k|0);if(!(!v|K[c|0]!=K[J[b+8>>2]])){J[b+12>>2]=J[b+12>>2]+1;J[b+8>>2]=J[b+8>>2]+1;c=J[b+12>>2];continue}break}Ua=b+16|0;if(!v){break o}}J[l+12>>2]=Mb(p);J[l+16>>2]=J[l+12>>2];}J[l+12>>2]=J[l+16>>2];q:{while(1){if((sc(p)|0)==J[l+12>>2]){break q}J[5996]=0;b=_(186,a|0,l+524|0)|0;c=J[5996];J[5996]=0;r:{if((c|0)==1){break r}if(b){break q}b=J[a>>2];J[5996]=0;b=$(187,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break r}if(K[J[l+12>>2]]!=(b&255)){break q}J[5996]=0;$(189,a|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}J[l+12>>2]=J[l+12>>2]+1;continue}break}break a}if(!w){break c}if((sc(p)|0)==J[l+12>>2]){break c}J[f>>2]=J[f>>2]|4;a=0;break d}s:{while(1){t:{J[5996]=0;c=_(186,a|0,l+524|0)|0;k=J[5996];J[5996]=0;if((k|0)==1){break t}if(c){break s}c=J[a>>2];J[5996]=0;k=$(187,c|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}c=J[h+8>>2];u:{if((k|0)>=0?J[c+((k&255)<<2)>>2]&64:0){c=J[j>>2];if((c|0)==J[l+520>>2]){J[5996]=0;ea(225,i|0,j|0,l+520|0);c=J[5996];J[5996]=0;if((c|0)==1){break a}c=J[j>>2];}J[j>>2]=c+1;H[c|0]=k;b=b+1|0;break u}c=K[s+11|0];if(!((c&128)>>>7|0?J[s+4>>2]:c&127)|!b|(k&255)!=(z|0)){break s}if(J[l+96>>2]==(d|0)){J[5996]=0;ea(226,t|0,l+100|0,l+96|0);c=J[5996];J[5996]=0;if((c|0)==1){break a}d=J[l+100>>2];}o=d+4|0;J[l+100>>2]=o;J[d>>2]=b;d=o;b=0;}J[5996]=0;$(189,a|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){continue}}break}break a}if(!(!b|J[t>>2]==(o|0))){if(J[l+96>>2]==(o|0)){J[5996]=0;ea(226,t|0,l+100|0,l+96|0);c=J[5996];J[5996]=0;if((c|0)==1){break a}o=J[l+100>>2];}c=o+4|0;J[l+100>>2]=c;J[o>>2]=b;o=c;}if((u|0)<=0){break e}J[5996]=0;b=_(186,a|0,l+524|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}v:{if(!b){b=J[a>>2];J[5996]=0;b=$(187,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}if((b&255)==(y|0)){break v}}J[f>>2]=J[f>>2]|4;a=0;break d}J[5996]=0;b=$(189,a|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}while(1){if((u|0)<=0){u=0;break e}J[5996]=0;c=_(186,b|0,l+524|0)|0;d=J[5996];J[5996]=0;w:{if((d|0)==1){break w}x:{if(!c){c=J[b>>2];J[5996]=0;c=$(187,c|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break w}d=J[h+8>>2];if((c|0)>=0?J[d+((c&255)<<2)>>2]&64:0){break x}}J[f>>2]=J[f>>2]|4;a=0;break d}if(J[j>>2]==J[l+520>>2]){J[5996]=0;ea(225,i|0,j|0,l+520|0);c=J[5996];J[5996]=0;if((c|0)==1){break w}}c=J[b>>2];J[5996]=0;c=$(187,c|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break w}d=J[j>>2];J[j>>2]=d+1;H[d|0]=c;J[5996]=0;$(189,b|0)|0;c=J[5996];J[5996]=0;u=u-1|0;if((c|0)!=1){continue}}break}break a}J[l+24>>2]=u;y:{if(!r){break y}k=1;while(1){b=K[r+11|0];if(((b&128)>>>7|0?J[r+4>>2]:b&127)>>>0<=k>>>0){break y}J[5996]=0;b=_(186,a|0,l+524|0)|0;c=J[5996];J[5996]=0;z:{if((c|0)==1){break z}A:{if(!b){b=J[a>>2];J[5996]=0;b=$(187,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break z}if(K[((K[r+11|0]&128)>>>7|0?J[r>>2]:r)+k|0]==(b&255)){break A}}J[f>>2]=J[f>>2]|4;a=0;break d}J[5996]=0;$(189,a|0)|0;b=J[5996];J[5996]=0;k=k+1|0;if((b|0)!=1){continue}}break}break a}a=1;b=J[t>>2];if((b|0)==(o|0)){break d}a=0;J[l+16>>2]=0;zb(s,b,o,l+16|0);if(J[l+16>>2]){J[f>>2]=J[f>>2]|4;break d}a=1;break d}d=o;if(J[j>>2]!=J[i>>2]){break c}J[f>>2]=J[f>>2]|4;a=0;}ab(q);ab(n);ab(m);ab(p);ab(s);db(t);break b}e=e+1|0;continue}}break a}Ua=l+528|0;return a|0}a=Z()|0;ab(q);ab(n);ab(m);ab(p);ab(s);db(t);da(a|0);B();}function An(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;a:{b:{c:{d:{e:{f:{g:{switch(J[b>>2]){case 0:J[a+12>>2]=1;J[a+16>>2]=0;J[a+4>>2]=0;J[a+8>>2]=0;J[a>>2]=0;return;case 2:J[a+12>>2]=1;J[a+16>>2]=0;break b;case 3:J[a+12>>2]=1;J[a+16>>2]=0;J[a+4>>2]=1;J[a+8>>2]=0;J[a>>2]=3;return;case 4:case 5:J[a+12>>2]=0;J[a+16>>2]=0;J[a+4>>2]=1;J[a+8>>2]=0;J[a>>2]=1;return;case 6:case 7:case 8:case 9:J[a+12>>2]=0;J[a+16>>2]=0;J[a+4>>2]=1;J[a+8>>2]=0;J[a>>2]=4;return;case 17:b=J[b+32>>2];c=J[b+8>>2];h=J[c+52>>2];b=J[b>>2];f=J[b+52>>2];e=K[b+48|0];g=K[c+48|0];c=J[c+44>>2];b=J[b+44>>2];J[a+12>>2]=0;J[a+16>>2]=0;J[a>>2]=b+c;break a;case 18:b=J[b+32>>2];m=J[b+8>>2];h=J[m+52>>2];j=J[b>>2];f=J[j+52>>2];e=K[j+48|0];g=K[m+48|0];i=J[m+60>>2];d=J[j+60>>2];c=K[j+56|0];b=K[m+56|0];J[a>>2]=(J[j+44>>2]+J[m+44>>2]|0)+1;c=(c|0)!=0&(b|0)!=0;b=c&0;J[a+12>>2]=b|c;J[a+16>>2]=c?d+i|0:0;break a;case 19:b=J[b+32>>2];h=J[b>>2];g=J[h+60>>2];f=K[h+56|0]!=0;c=J[b+8>>2];l=f&K[c+48|0]!=0;e=l?g+J[c+52>>2]|0:0;b=(J[h+44>>2]+J[c+44>>2]|0)+1|0;i=J[c+60>>2];d=K[c+56|0];if(!(!K[h+48|0]|!d)){c=i+J[h+52>>2]|0;e=l?c>>>0>e>>>0?c:e:c;l=1;}J[a>>2]=b;J[a+4>>2]=l;J[a+8>>2]=e;e=f&(d|0)!=0;b=e&0;J[a+12>>2]=b|e;J[a+16>>2]=e?g+i|0:0;return;case 21:b=J[b+32>>2];c=J[b>>2];j=J[c+60>>2];m=J[b+8>>2];e=j+J[m+52>>2]|0;h=K[c+56|0];b=K[m+48|0]!=0&(h|0)!=0;g=(J[c+44>>2]+J[m+44>>2]|0)+3|0;d=b?e:0;h:{if(!K[c+48|0]){break h}if(!b){b=J[c+48>>2];f=b&-256;d=J[c+52>>2];break h}b=1;c=J[c+52>>2];d=c>>>0>e>>>0?c:e;}i=J[m+60>>2];e=K[m+56|0];J[a>>2]=g;c=b&255;b=0;J[a+4>>2]=c|(f|b);J[a+8>>2]=d|p;c=(h|0)!=0&(e|0)!=0;b=c?b:0;J[a+12>>2]=b|c;J[a+16>>2]=c?i+j|0:0;return;case 20:b=J[b+32>>2];i=J[b>>2];c=J[b+8>>2];d=J[i+60>>2]+J[c+52>>2]|0;b=K[c+48|0]!=0&K[i+56|0]!=0;e=(J[i+44>>2]+J[c+44>>2]|0)+2|0;c=b?d:0;i:{if(!K[i+48|0]){break i}if(!b){b=J[i+48>>2];f=b&-256;c=J[i+52>>2];break i}b=1;c=J[i+52>>2];c=c>>>0>d>>>0?c:d;}J[a+12>>2]=0;J[a+16>>2]=0;J[a>>2]=e;J[a+4>>2]=f|b&255;J[a+8>>2]=c|p;return;case 22:b=J[b+32>>2];d=J[b>>2];j=J[b+8>>2];f=J[d+44>>2]+J[j+44>>2]|0;j:{if(!K[d+48|0]){b=J[j+48>>2];h=b&-256;e=J[j+52>>2];break j}if(!K[j+48|0]){b=J[d+48>>2];h=b&-256;e=J[d+52>>2];break j}b=1;e=J[d+52>>2];c=J[j+52>>2];e=c>>>0<e>>>0?e:c;}i=f+3|0;k:{if(!K[d+56|0]){f=J[j+56>>2];g=f&-256;c=J[j+60>>2];break k}if(!K[j+56|0]){f=J[d+56>>2];g=f&-256;c=J[d+60>>2];break k}f=1;d=J[d+60>>2];c=J[j+60>>2];c=c>>>0<d>>>0?d:c;}J[a>>2]=i;J[a+12>>2]=f&255|g&-256;d=0;J[a+16>>2]=d|(c|d);J[a+4>>2]=b&255|h&-256;f=0;J[a+8>>2]=f|(e|f);return;case 23:b=J[b+32>>2];h=J[b+16>>2];f=J[b>>2];g=J[f+60>>2];i=K[f+56|0]!=0;d=i&K[h+48|0]!=0;e=d?J[h+52>>2]+g|0:0;b=J[b+8>>2];c=(J[h+44>>2]+(J[f+44>>2]+J[b+44>>2]|0)|0)+3|0;if(!(!K[b+48|0]|!K[f+48|0])){b=J[f+52>>2]+J[b+52>>2]|0;e=d?b>>>0>e>>>0?b:e:b;d=1;}f=J[h+60>>2];b=K[h+56|0];J[a>>2]=c;J[a+4>>2]=d;J[a+8>>2]=e;e=i&(b|0)!=0;b=e&0;J[a+12>>2]=b|e;J[a+16>>2]=e?f+g|0:0;return;case 25:c=J[b+12>>2];b=J[b+8>>2];J[a>>2]=1;b=(c-b|0)/12|0;c=1;J[a+12>>2]=c;J[a+16>>2]=b;J[a+4>>2]=c;J[a+8>>2]=b;return;case 11:case 12:case 16:d=J[J[b+32>>2]>>2];f=J[d+48>>2];e=J[d+52>>2];c=J[d+44>>2];b=J[d+60>>2];J[a+12>>2]=J[d+56>>2];J[a+16>>2]=b;J[a+4>>2]=f;J[a+8>>2]=e;J[a>>2]=c+1;return;case 10:d=J[J[b+32>>2]>>2];f=J[d+48>>2];e=J[d+52>>2];c=J[d+44>>2];b=J[d+60>>2];J[a+12>>2]=J[d+56>>2];J[a+16>>2]=b;J[a+4>>2]=f;J[a+8>>2]=e;J[a>>2]=c+2;return;case 13:b=J[J[b+32>>2]>>2];e=J[b+48>>2];c=J[b+52>>2];b=J[b+44>>2];J[a+12>>2]=1;J[a+16>>2]=0;J[a+4>>2]=e;J[a+8>>2]=c;J[a>>2]=b+3;return;case 15:b=J[J[b+32>>2]>>2];e=J[b+48>>2];c=J[b+52>>2];b=J[b+44>>2];J[a+12>>2]=1;J[a+16>>2]=0;J[a+4>>2]=e;J[a+8>>2]=c;J[a>>2]=b+4;return;case 14:c=J[J[b+32>>2]>>2];d=J[c+44>>2];f=J[c+80>>2];e=Wb(1239,1);b=J[J[b+32>>2]>>2];c=J[b+48>>2];b=J[b+52>>2];J[a+12>>2]=0;J[a+16>>2]=0;J[a+4>>2]=c;J[a+8>>2]=b;J[a>>2]=d+!(e&(f^-1));return;case 24:c=cb(8);J[c>>2]=1;J[c+4>>2]=0;l=c+8|0;n=J[b+32>>2];p=J[b+36>>2];if((n|0)!=(p|0)){while(1){e=J[n>>2];h=J[e+60>>2];g=K[e+56|0];d=J[c+4>>2];i=c;f=K[c|0];m=J[e+44>>2];J[5996]=0;e=$(3,8)|0;c=J[5996];J[5996]=0;l:{m:{if((c|0)!=1){c=d+h|0;d=(f|0)!=0&(g|0)!=0;f=d&0;J[e>>2]=d|f;J[e+4>>2]=d?c:0;g=e+8|0;c=l-i|0;r=c>>3;if(c>>>0>=9){break m}f=g;break l}f=Z()|0;c=i;break e}j=r>>>0<=2?2:r;l=1;f=g;while(1){q=J[n>>2];c=i+(l<<3)|0;k=J[q+60>>2]+J[c+4>>2]|0;d=c-8|0;o=K[d|0]!=0&K[q+48|0]!=0;h=K[c|0]!=0&K[q+56|0]!=0;c=h?k:0;d=o?J[q+52>>2]+J[d+4>>2]|0:0;c=h?o?c>>>0>d>>>0?c:d:k:d;o=h|o;n:{if(f>>>0<g>>>0){J[f>>2]=o;J[f+4>>2]=c;d=f;break n}h=f-e>>3;k=h+1|0;if(k>>>0>=536870912){J[5996]=0;ca(93);a=J[5996];J[5996]=0;if((a|0)==1){break f}break c}g=g-e|0;d=g>>2;k=g>>>0>=2147483640?536870911:d>>>0>k>>>0?d:k;o:{if(!k){g=0;break o}if(k>>>0>=536870912){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break c}break f}J[5996]=0;g=$(3,k<<3)|0;d=J[5996];J[5996]=0;if((d|0)==1){break f}}d=(h<<3)+g|0;J[d>>2]=o;J[d+4>>2]=c;g=(k<<3)+g|0;c=d;p:{if((e|0)!=(f|0)){while(1){f=f-8|0;h=J[f+4>>2];c=c-8|0;J[c>>2]=J[f>>2];J[c+4>>2]=h;if((e|0)!=(f|0)){continue}break}if(!e){break p}}$a(e);}e=c;}f=d+8|0;l=l+1|0;if((j|0)!=(l|0)){continue}break}}d=(i+(r<<3)|0)-8|0;c=J[n>>2];k=K[d|0]!=0&K[c+48|0]!=0;d=k?J[c+52>>2]+J[d+4>>2]|0:0;q:{if(f>>>0<g>>>0){J[f>>2]=k;J[f+4>>2]=d;l=f+8|0;c=e;break q}r:{s:{h=f-e>>3;j=h+1|0;t:{if(j>>>0>=536870912){J[5996]=0;ca(93);break t}g=g-e|0;c=g>>2;c=g>>>0>=2147483640?536870911:c>>>0>j>>>0?c:j;if(!c){c=0;break r}if(c>>>0<536870912){break s}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break c}break f}J[5996]=0;c=$(3,c<<3)|0;g=J[5996];J[5996]=0;if((g|0)==1){break f}}c=(h<<3)+c|0;J[c>>2]=k;J[c+4>>2]=d;l=c+8|0;if((e|0)!=(f|0)){while(1){f=f-8|0;d=J[f+4>>2];c=c-8|0;J[c>>2]=J[f>>2];J[c+4>>2]=d;if((e|0)!=(f|0)){continue}break}if(!e){break q}}$a(e);}s=(m+s|0)+1|0;$a(i);n=n+8|0;if((p|0)!=(n|0)){continue}break}}b=J[b+4>>2];if(b>>>0<=l-c>>3>>>0){b=(b<<3)+c|0;f=J[b>>2];e=J[b+4>>2];b=J[c+4>>2];J[a+12>>2]=J[c>>2];J[a+16>>2]=b;J[a+4>>2]=f;J[a+8>>2]=e;J[a>>2]=s;$a(c);return}J[5996]=0;ga(44,5118,2210,799,1422);a=J[5996];J[5996]=0;if((a|0)!=1){break c}f=Z()|0;if(!c){break d}break e;default:la(2350,2210,803,1422);B();case 1:break g}}J[a+12>>2]=0;J[a+16>>2]=0;break b}f=Z()|0;if(!e){c=i;break e}$a(e);c=i;}$a(c);}da(f|0);B();}B();}J[a+4>>2]=1;J[a+8>>2]=0;J[a>>2]=0;return}e=(e|0)!=0&(g|0)!=0;b=e&0;J[a+4>>2]=b|e;J[a+8>>2]=e?f+h|0:0;}function Em(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0;e=Ua-80|0;Ua=e;d=cb(32);J[e+68>>2]=d;J[e+72>>2]=19;J[e+76>>2]=-2147483616;f=K[5568]|K[5569]<<8|(K[5570]<<16|K[5571]<<24);H[d+15|0]=f;H[d+16|0]=f>>>8;H[d+17|0]=f>>>16;H[d+18|0]=f>>>24;f=K[5565]|K[5566]<<8|(K[5567]<<16|K[5568]<<24);g=K[5561]|K[5562]<<8|(K[5563]<<16|K[5564]<<24);H[d+8|0]=g;H[d+9|0]=g>>>8;H[d+10|0]=g>>>16;H[d+11|0]=g>>>24;H[d+12|0]=f;H[d+13|0]=f>>>8;H[d+14|0]=f>>>16;H[d+15|0]=f>>>24;f=K[5557]|K[5558]<<8|(K[5559]<<16|K[5560]<<24);g=K[5553]|K[5554]<<8|(K[5555]<<16|K[5556]<<24);H[d|0]=g;H[d+1|0]=g>>>8;H[d+2|0]=g>>>16;H[d+3|0]=g>>>24;H[d+4|0]=f;H[d+5|0]=f>>>8;H[d+6|0]=f>>>16;H[d+7|0]=f>>>24;H[d+19|0]=0;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{d=J[J[b>>2]+80>>2];q:{if(!d){J[5996]=0;_(97,e+68|0,2603)|0;d=J[5996];J[5996]=0;if((d|0)!=1){break q}break b}J[5996]=0;f=_(54,3557,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break p}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,66);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,2796,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break o}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,86);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,2777,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break n}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,87);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,3310,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break m}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,75);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,1029,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break l}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,122);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,1959,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break k}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,111);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,2029,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break j}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,110);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,2522,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break i}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,100);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,2315,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break h}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,102);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,2451,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break g}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,101);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,2049,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break f}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,109);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,1295,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break e}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,117);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,1681,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(!((d^-1)&f)){J[5996]=0;aa(98,e+68|0,115);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+80>>2];J[5996]=0;f=_(54,2165,1)|0;g=J[5996];J[5996]=0;if((g|0)==1){break c}if((d^-1)&f){break q}J[5996]=0;aa(98,e+68|0,107);d=J[5996];J[5996]=0;if((d|0)==1){break b}}d=J[J[b>>2]+84>>2];J[5996]=0;f=e+44|0;aa(115,f|0,d|0);d=J[5996];J[5996]=0;r:{s:{t:{u:{v:{w:{x:{y:{z:{A:{B:{C:{D:{E:{F:{if((d|0)!=1){J[5996]=0;d=ba(99,f|0,0,5487)|0;f=J[5996];J[5996]=0;if((f|0)==1){break F}J[e- -64>>2]=J[d+8>>2];f=J[d+4>>2];J[e+56>>2]=J[d>>2];J[e+60>>2]=f;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;f=K[e+67|0];g=f<<24>>24<0;f=ba(100,e+68|0,(g?J[e+56>>2]:e+56|0)|0,(g?J[e+60>>2]:f)|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break E}if(H[e+67|0]<0){$a(J[e+56>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}d=J[b>>2];g=J[d+52>>2];d=J[d+44>>2];J[5996]=0;h=e+32|0;aa(164,h|0,d+g|0);d=J[5996];J[5996]=0;if((d|0)==1){break C}J[5996]=0;d=ba(99,h|0,0,5459)|0;g=J[5996];J[5996]=0;if((g|0)==1){break B}J[e- -64>>2]=J[d+8>>2];g=J[d+4>>2];J[e+56>>2]=J[d>>2];J[e+60>>2]=g;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;h=f;f=K[e+67|0];g=f<<24>>24<0;f=ba(100,h|0,(g?J[e+56>>2]:e+56|0)|0,(g?J[e+60>>2]:f)|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break A}if(H[e+67|0]<0){$a(J[e+56>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}b=J[J[b>>2]+68>>2];J[5996]=0;d=e+20|0;aa(164,d|0,b+1|0);b=J[5996];J[5996]=0;if((b|0)==1){break y}J[5996]=0;b=ba(99,d|0,0,5524)|0;d=J[5996];J[5996]=0;if((d|0)==1){break x}J[e- -64>>2]=J[b+8>>2];d=J[b+4>>2];J[e+56>>2]=J[b>>2];J[e+60>>2]=d;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;h=f;d=K[e+67|0];f=d<<24>>24<0;d=ba(100,h|0,(f?J[e+56>>2]:e+56|0)|0,(f?J[e+60>>2]:d)|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break w}if(H[e+67|0]<0){$a(J[e+56>>2]);}if(H[b+11|0]<0){$a(J[b>>2]);}J[5996]=0;d=_(97,d|0,3759)|0;b=J[5996];J[5996]=0;if((b|0)==1){break u}J[e+16>>2]=J[d+8>>2];b=J[d+4>>2];J[e+8>>2]=J[d>>2];J[e+12>>2]=b;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;f=J[c>>2];g=J[c+4>>2];b=K[c+11|0];J[5996]=0;h=c;c=b<<24>>24<0;b=ba(100,e+8|0,(c?f:h)|0,(c?g:b)|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break t}J[e- -64>>2]=J[b+8>>2];c=J[b+4>>2];J[e+56>>2]=J[b>>2];J[e+60>>2]=c;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[5996]=0;c=_(97,e+56|0,3559)|0;f=J[5996];J[5996]=0;if((f|0)==1){break s}f=J[c+4>>2];J[a>>2]=J[c>>2];J[a+4>>2]=f;J[a+8>>2]=J[c+8>>2];J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;if(H[b+11|0]<0){$a(J[b>>2]);}if(H[d+11|0]<0){$a(J[d>>2]);}Ua=e+80|0;return}b=Z()|0;break a}b=Z()|0;break D}b=Z()|0;if(H[e+67|0]>=0){break D}$a(J[e+56>>2]);}if(H[e+55|0]>=0){break a}$a(J[e+44>>2]);break a}b=Z()|0;break a}b=Z()|0;break z}b=Z()|0;if(H[e+67|0]>=0){break z}$a(J[e+56>>2]);}if(H[e+43|0]>=0){break a}$a(J[e+32>>2]);break a}b=Z()|0;break a}b=Z()|0;break v}b=Z()|0;if(H[e+67|0]>=0){break v}$a(J[e+56>>2]);}if(H[e+31|0]>=0){break a}$a(J[e+20>>2]);break a}b=Z()|0;break a}b=Z()|0;break r}b=Z()|0;if(H[e+67|0]>=0){break r}$a(J[e+56>>2]);}if(H[e+19|0]>=0){break a}$a(J[e+8>>2]);break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;break a}b=Z()|0;}if(H[e+79|0]<0){$a(J[e+68>>2]);}da(b|0);B();}function Gg(a,b,c,d,e,f){a=a|0;b=+b;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0;m=Ua-560|0;Ua=m;J[m+44>>2]=0;A(+b);g=v(1)|0;v(0)|0;a:{if((g|0)<0){s=1;x=1222;b=-b;A(+b);g=v(1)|0;v(0)|0;break a}if(e&2048){s=1;x=1225;break a}s=e&1;x=s?1228:1223;z=!s;}b:{if((g&2146435072)==2146435072){g=s+3|0;Bb(a,32,c,g,e&-65537);wb(a,x,s);d=f&32;wb(a,b!=b?d?2020:3082:d?2300:3355,3);Bb(a,32,c,g,e^8192);o=(c|0)<(g|0)?g:c;break b}u=m+16|0;c:{d:{e:{b=Lg(b,m+44|0);b=b+b;if(b!=0){g=J[m+44>>2];J[m+44>>2]=g-1;w=f|32;if((w|0)!=97){break e}break c}w=f|32;if((w|0)==97){break c}j=J[m+44>>2];l=(d|0)<0?6:d;break d}j=g-29|0;J[m+44>>2]=j;b=b*268435456;l=(d|0)<0?6:d;}q=(m+48|0)+((j|0)>=0?288:0)|0;h=q;while(1){if(b<4294967296&b>=0){d=~~b>>>0;}else {d=0;}J[h>>2]=d;h=h+4|0;b=(b-+(d>>>0))*1e9;if(b!=0){continue}break}f:{if((j|0)<=0){d=j;g=h;i=q;break f}i=q;d=j;while(1){k=(d|0)>=29?29:d;g=h-4|0;g:{if(i>>>0>g>>>0){break g}n=0;while(1){d=J[g>>2];o=k&31;y=n;if((k&63)>>>0>=32){n=d<<o;d=0;}else {n=(1<<o)-1&d>>>32-o;d=d<<o;}o=y+d|0;n=n+p|0;n=eo(o,d>>>0>o>>>0?n+1|0:n,1e9);d=co(n,Wa,-1e9,0)+o|0;J[g>>2]=d;g=g-4|0;if(i>>>0<=g>>>0){continue}break}if(!n){break g}i=i-4|0;J[i>>2]=n;}while(1){g=h;if(i>>>0<g>>>0){h=g-4|0;if(!J[h>>2]){continue}}break}d=J[m+44>>2]-k|0;J[m+44>>2]=d;h=g;if((d|0)>0){continue}break}}if((d|0)<0){t=((l+25>>>0)/9|0)+1|0;p=(w|0)==102;while(1){d=0-d|0;o=(d|0)>=9?9:d;h:{if(g>>>0<=i>>>0){h=J[i>>2];break h}n=1e9>>>o|0;k=-1<<o^-1;d=0;h=i;while(1){y=d;d=J[h>>2];J[h>>2]=y+(d>>>o|0);d=P(n,d&k);h=h+4|0;if(h>>>0<g>>>0){continue}break}h=J[i>>2];if(!d){break h}J[g>>2]=d;g=g+4|0;}d=o+J[m+44>>2]|0;J[m+44>>2]=d;i=(!h<<2)+i|0;h=p?q:i;g=g-h>>2>(t|0)?h+(t<<2)|0:g;if((d|0)<0){continue}break}}d=0;i:{if(g>>>0<=i>>>0){break i}d=P(q-i>>2,9);h=10;k=J[i>>2];if(k>>>0<10){break i}while(1){d=d+1|0;h=P(h,10);if(k>>>0>=h>>>0){continue}break}}h=(l-((w|0)!=102?d:0)|0)-((w|0)==103&(l|0)!=0)|0;if((h|0)<(P(g-q>>2,9)-9|0)){n=h+9216|0;k=(n|0)/9|0;j=((((j|0)<0?4:292)+m|0)+(k<<2)|0)-4048|0;h=10;o=n+P(k,-9)|0;if((o|0)<=7){while(1){h=P(h,10);o=o+1|0;if((o|0)!=8){continue}break}}n=J[j>>2];t=(n>>>0)/(h>>>0)|0;p=P(t,h);k=j+4|0;j:{if((n|0)==(p|0)&(k|0)==(g|0)){break j}n=n-p|0;k:{if(!(t&1)){b=9007199254740992;if(!(H[j-4|0]&1)|((h|0)!=1e9|i>>>0>=j>>>0)){break k}}b=9007199254740994;}r=(g|0)==(k|0)?1:1.5;k=h>>>1|0;r=k>>>0>n>>>0?.5:(k|0)==(n|0)?r:1.5;if(!(K[x|0]!=45|z)){r=-r;b=-b;}J[j>>2]=p;if(b+r==b){break j}d=h+p|0;J[j>>2]=d;if(d>>>0>=1e9){while(1){J[j>>2]=0;j=j-4|0;if(j>>>0<i>>>0){i=i-4|0;J[i>>2]=0;}d=J[j>>2]+1|0;J[j>>2]=d;if(d>>>0>999999999){continue}break}}d=P(q-i>>2,9);h=10;k=J[i>>2];if(k>>>0<10){break j}while(1){d=d+1|0;h=P(h,10);if(k>>>0>=h>>>0){continue}break}}h=j+4|0;g=g>>>0>h>>>0?h:g;}while(1){k=g;n=g>>>0<=i>>>0;if(!n){g=g-4|0;if(!J[g>>2]){continue}}break}l:{if((w|0)!=103){j=e&8;break l}h=l?l:1;g=(h|0)>(d|0)&(d|0)>-5;l=(g?d^-1:-1)+h|0;f=(g?-1:-2)+f|0;j=e&8;if(j){break l}g=-9;m:{if(n){break m}j=J[k-4>>2];if(!j){break m}o=10;g=0;if((j>>>0)%10|0){break m}while(1){h=g;g=g+1|0;o=P(o,10);if(!((j>>>0)%(o>>>0)|0)){continue}break}g=h^-1;}h=P(k-q>>2,9);if((f&-33)==70){j=0;g=(g+h|0)-9|0;g=(g|0)>0?g:0;l=(g|0)>(l|0)?l:g;break l}j=0;g=((d+h|0)+g|0)-9|0;g=(g|0)>0?g:0;l=(g|0)>(l|0)?l:g;}o=-1;n=j|l;if(((n?2147483645:2147483646)|0)<(l|0)){break b}p=(((n|0)!=0)+l|0)+1|0;h=f&-33;n:{if((h|0)==70){if((p^2147483647)<(d|0)){break b}g=(d|0)>0?d:0;break n}g=d>>31;g=Jc((g^d)-g|0,0,u);if((u-g|0)<=1){while(1){g=g-1|0;H[g|0]=48;if((u-g|0)<2){continue}break}}t=g-2|0;H[t|0]=f;H[g-1|0]=(d|0)<0?45:43;g=u-t|0;if((g|0)>(p^2147483647)){break b}}d=g+p|0;if((d|0)>(s^2147483647)){break b}p=d+s|0;Bb(a,32,c,p,e);wb(a,x,s);Bb(a,48,c,p,e^65536);o:{p:{q:{if((h|0)==70){f=m+16|0;d=f|8;j=f|9;h=i>>>0>q>>>0?q:i;i=h;while(1){g=Jc(J[i>>2],0,j);r:{if((h|0)!=(i|0)){if(m+16>>>0>=g>>>0){break r}while(1){g=g-1|0;H[g|0]=48;if(m+16>>>0<g>>>0){continue}break}break r}if((g|0)!=(j|0)){break r}H[m+24|0]=48;g=d;}wb(a,g,j-g|0);i=i+4|0;if(q>>>0>=i>>>0){continue}break}if(n){wb(a,4352,1);}if((l|0)<=0|i>>>0>=k>>>0){break q}while(1){g=Jc(J[i>>2],0,j);if(g>>>0>m+16>>>0){while(1){g=g-1|0;H[g|0]=48;if(m+16>>>0<g>>>0){continue}break}}wb(a,g,(l|0)>=9?9:l);g=l-9|0;i=i+4|0;if(k>>>0<=i>>>0){break p}d=(l|0)>9;l=g;if(d){continue}break}break p}s:{if((l|0)<0){break s}q=i>>>0<k>>>0?k:i+4|0;f=m+16|0;d=f|8;k=f|9;h=i;while(1){g=Jc(J[h>>2],0,k);if((k|0)==(g|0)){H[m+24|0]=48;g=d;}t:{if((h|0)!=(i|0)){if(m+16>>>0>=g>>>0){break t}while(1){g=g-1|0;H[g|0]=48;if(m+16>>>0<g>>>0){continue}break}break t}wb(a,g,1);g=g+1|0;if(!(j|l)){break t}wb(a,4352,1);}f=k-g|0;wb(a,g,(f|0)<(l|0)?f:l);l=l-f|0;h=h+4|0;if(q>>>0<=h>>>0){break s}if((l|0)>=0){continue}break}}Bb(a,48,l+18|0,18,0);wb(a,t,u-t|0);break o}g=l;}Bb(a,48,g+9|0,9,0);}Bb(a,32,c,p,e^8192);o=(c|0)<(p|0)?p:c;break b}j=(f<<26>>31&9)+x|0;u:{if(d>>>0>11){break u}g=12-d|0;r=16;while(1){r=r*16;g=g-1|0;if(g){continue}break}if(K[j|0]==45){b=-(r+(-b-r));break u}b=b+r-r;}q=s|2;i=f&32;h=J[m+44>>2];g=h>>31;g=Jc((g^h)-g|0,0,u);if((u|0)==(g|0)){H[m+15|0]=48;g=m+15|0;}l=g-2|0;H[l|0]=f+15;H[g-1|0]=(h|0)<0?45:43;g=e&8;h=m+16|0;while(1){f=h;if(R(b)<2147483648){k=~~b;}else {k=-2147483648;}H[h|0]=i|K[k+7488|0];b=(b-+(k|0))*16;h=f+1|0;if(!(!((d|0)>0|g)&b==0|(h-(m+16|0)|0)!=1)){H[f+1|0]=46;h=f+2|0;}if(b!=0){continue}break}o=-1;g=u-l|0;f=g+q|0;if((2147483645-f|0)<(d|0)){break b}k=f;f=m+16|0;i=h-f|0;d=d?(i-2|0)<(d|0)?d+2|0:i:i;h=k+d|0;Bb(a,32,c,h,e);wb(a,j,q);Bb(a,48,c,h,e^65536);wb(a,f,i);Bb(a,48,d-i|0,0,0);wb(a,l,g);Bb(a,32,c,h,e^8192);o=(c|0)<(h|0)?h:c;}Ua=m+560|0;return o|0}function zn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;a:{b:{c:{d:{e:{f:{g:{switch(J[b>>2]){case 1:case 4:case 5:J[a+8>>2]=0;J[a+12>>2]=0;J[a>>2]=1;J[a+4>>2]=0;return;case 2:J[a+8>>2]=1;J[a+12>>2]=1;break a;case 3:J[a+8>>2]=1;J[a+12>>2]=2;J[a>>2]=1;J[a+4>>2]=2;return;case 6:case 7:case 8:case 9:J[a+8>>2]=0;J[a+12>>2]=0;break a;case 23:d=J[b+32>>2];b=J[d+16>>2];c=J[d>>2];e=J[c+76>>2];j=K[c+72|0]!=0;i=j&K[b+64|0]!=0;f=i?J[b+68>>2]+e|0:0;h:{if(!K[c+64|0]){break h}d=J[d+8>>2];if(!K[d+64|0]){break h}c=J[d+68>>2]+J[c+68>>2]|0;f=i?c>>>0>f>>>0?c:f:c;i=1;}d=J[b+76>>2];b=K[b+72|0];J[a>>2]=i;J[a+4>>2]=f;b=j&(b|0)!=0;c=b&0;J[a+8>>2]=b|c;J[a+12>>2]=b?d+e|0:0;return;case 17:b=J[b+32>>2];c=J[b+8>>2];d=J[c+68>>2];b=J[b>>2];f=J[b+68>>2];b=K[b+64|0];e=K[c+64|0];J[a+8>>2]=0;J[a+12>>2]=0;c=d+f|0;b=(b|0)!=0&(e|0)!=0;d=b&0;J[a>>2]=b|d;J[a+4>>2]=b?c:0;return;case 18:c=J[b+32>>2];b=J[c+8>>2];f=J[b+68>>2];d=J[c>>2];e=J[d+68>>2];j=K[d+64|0];g=K[b+64|0];c=J[b+76>>2]+J[d+76>>2]|0;b=K[d+72|0]!=0&K[b+72|0]!=0;d=b&0;J[a+8>>2]=b|d;J[a+12>>2]=b?c:0;b=(j|0)!=0&(g|0)!=0;d=b&0;J[a>>2]=b|d;J[a+4>>2]=b?e+f|0:0;return;case 19:c=J[b+32>>2];b=J[c+8>>2];f=J[b+76>>2];j=K[b+72|0]!=0;d=J[c>>2];i=j&K[d+64|0]!=0;c=i?f+J[d+68>>2]|0:0;e=J[d+76>>2];g=K[d+72|0];if(!(!g|!K[b+64|0])){b=e+J[b+68>>2]|0;c=i?b>>>0>c>>>0?b:c:b;i=1;}J[a>>2]=i;J[a+4>>2]=c;b=j&(g|0)!=0;d=b&0;J[a+8>>2]=b|d;J[a+12>>2]=b?e+f|0:0;return;case 20:b=J[b+32>>2];e=J[b+8>>2];c=J[b>>2];d=J[e+68>>2]+J[c+76>>2]|0;b=K[c+72|0]!=0&K[e+64|0]!=0;e=b?d:0;i:{if(!K[c+64|0]){break i}if(!b){b=J[c+64>>2];f=b&-256;e=J[c+68>>2];break i}b=1;c=J[c+68>>2];e=c>>>0>d>>>0?c:d;}c=e;J[a+8>>2]=0;J[a+12>>2]=0;J[a>>2]=f|b&255;J[a+4>>2]=c|j;return;case 21:b=J[b+32>>2];d=J[b+8>>2];c=J[b>>2];g=J[c+76>>2];e=J[d+68>>2]+g|0;i=K[c+72|0];b=(i|0)!=0&K[d+64|0]!=0;h=b?e:0;j:{if(!K[c+64|0]){break j}if(!b){b=J[c+64>>2];f=b&-256;h=J[c+68>>2];break j}b=1;c=J[c+68>>2];h=c>>>0>e>>>0?c:e;}e=h;c=J[d+76>>2];d=K[d+72|0];h=b&255;b=0;J[a>>2]=h|(f|b);J[a+4>>2]=e|j;e=c+g|0;c=b;b=(i|0)!=0&(d|0)!=0;c=b?c:0;J[a+8>>2]=b|c;J[a+12>>2]=b?e:0;return;case 22:d=J[b+32>>2];b=J[d+8>>2];f=K[b+64|0];c=f?J[b+68>>2]+1|0:0;e=J[d>>2];if(K[e+64|0]){d=J[e+68>>2]+1|0;c=f?c>>>0<d>>>0?d:c:d;f=1;}j=J[b+76>>2]+1|0;b=K[b+72|0];d=b?j:0;if(K[e+72|0]){e=J[e+76>>2]+1|0;d=b?d>>>0<e>>>0?e:d:e;b=1;}j=b;b=0;J[a+8>>2]=j|b;J[a+12>>2]=d;J[a>>2]=b|f;J[a+4>>2]=c;return;case 25:c=J[b+4>>2]+1|0;b=1;J[a+8>>2]=b;J[a+12>>2]=c;break b;case 10:case 11:case 12:case 16:b=J[J[b+32>>2]>>2];c=J[b+68>>2];J[a>>2]=J[b+64>>2];J[a+4>>2]=c;c=J[b+76>>2];J[a+8>>2]=J[b+72>>2];J[a+12>>2]=c;return;case 13:b=J[J[b+32>>2]>>2];c=J[b+68>>2];b=K[b+64|0];J[a+8>>2]=1;J[a+12>>2]=1;j=b;b=!b;J[a>>2]=j|b&0;J[a+4>>2]=b?0:c+1|0;return;case 14:c=J[J[b+32>>2]>>2];b=J[c+64>>2];c=J[c+68>>2];J[a+8>>2]=0;J[a+12>>2]=0;break b;case 15:c=J[J[b+32>>2]>>2];b=J[c+64>>2];c=J[c+68>>2];J[a+8>>2]=1;J[a+12>>2]=1;break b;case 24:c=cb(8);J[c>>2]=1;J[c+4>>2]=0;i=c+8|0;l=J[b+32>>2];o=J[b+36>>2];if((l|0)!=(o|0)){while(1){d=J[l>>2];e=J[d+76>>2];d=K[d+72|0];g=J[c+4>>2];j=c;k=K[c|0];J[5996]=0;f=$(3,8)|0;c=J[5996];J[5996]=0;k:{l:{if((c|0)!=1){c=e+g|0;d=(k|0)!=0&(d|0)!=0;e=d&0;J[f>>2]=d|e;J[f+4>>2]=d?c:0;g=f+8|0;c=i-j|0;k=c>>3;if(c>>>0>=9){break l}d=g;break k}d=Z()|0;c=j;break e}q=k>>>0<=2?2:k;i=1;d=g;while(1){c=J[l>>2];h=j+(i<<3)|0;m=J[c+76>>2]+J[h+4>>2]|0;n=h-8|0;e=K[n|0]!=0&K[c+64|0]!=0;h=K[h|0]!=0&K[c+72|0]!=0;p=h?m:0;c=e?J[c+68>>2]+J[n+4>>2]|0:0;c=h?e?c>>>0<p>>>0?p:c:m:c;m=e|h;m:{if(d>>>0<g>>>0){J[d>>2]=m;J[d+4>>2]=c;e=d;break m}n=d-f>>3;e=n+1|0;if(e>>>0>=536870912){J[5996]=0;ca(93);a=J[5996];J[5996]=0;if((a|0)==1){break f}break c}g=g-f|0;h=g>>2;h=g>>>0>=2147483640?536870911:e>>>0<h>>>0?h:e;n:{if(!h){g=0;break n}if(h>>>0>=536870912){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break c}break f}J[5996]=0;g=$(3,h<<3)|0;e=J[5996];J[5996]=0;if((e|0)==1){break f}}e=(n<<3)+g|0;J[e>>2]=m;J[e+4>>2]=c;g=(h<<3)+g|0;c=e;o:{if((d|0)!=(f|0)){while(1){d=d-8|0;h=J[d+4>>2];c=c-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=h;if((d|0)!=(f|0)){continue}break}if(!f){break o}}$a(f);}f=c;}d=e+8|0;i=i+1|0;if((q|0)!=(i|0)){continue}break}}c=(j+(k<<3)|0)-8|0;e=J[l>>2];i=K[c|0]!=0&K[e+64|0]!=0;e=i?J[e+68>>2]+J[c+4>>2]|0:0;p:{if(d>>>0<g>>>0){J[d>>2]=i;J[d+4>>2]=e;i=d+8|0;c=f;break p}q:{r:{k=d-f>>3;c=k+1|0;s:{if(c>>>0>=536870912){J[5996]=0;ca(93);break s}g=g-f|0;h=g>>2;c=g>>>0>=2147483640?536870911:c>>>0<h>>>0?h:c;if(!c){c=0;break q}if(c>>>0<536870912){break r}J[5996]=0;ca(35);}a=J[5996];J[5996]=0;if((a|0)!=1){break c}break f}J[5996]=0;c=$(3,c<<3)|0;g=J[5996];J[5996]=0;if((g|0)==1){break f}}c=(k<<3)+c|0;J[c>>2]=i;J[c+4>>2]=e;i=c+8|0;if((d|0)!=(f|0)){while(1){d=d-8|0;e=J[d+4>>2];c=c-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=e;if((d|0)!=(f|0)){continue}break}if(!f){break p}}$a(f);}$a(j);l=l+8|0;if((o|0)!=(l|0)){continue}break}}b=J[b+4>>2];if(b>>>0<=i-c>>3>>>0){b=(b<<3)+c|0;d=J[b>>2];b=J[b+4>>2];f=J[c+4>>2];J[a+8>>2]=J[c>>2];J[a+12>>2]=f;J[a>>2]=d;J[a+4>>2]=b;$a(c);return}J[5996]=0;ga(44,5118,2210,850,2317);a=J[5996];J[5996]=0;if((a|0)!=1){break c}d=Z()|0;if(!c){break d}break e;default:la(2350,2210,854,2317);B();case 0:break g}}J[a+8>>2]=1;J[a+12>>2]=0;J[a>>2]=0;J[a+4>>2]=0;return}d=Z()|0;if(!f){c=j;break e}$a(f);c=j;}$a(c);}da(d|0);B();}B();}J[a>>2]=b;J[a+4>>2]=c;return}J[a>>2]=1;J[a+4>>2]=1;}function Kg(a,b,c,d,e){var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;h=Ua-80|0;Ua=h;J[h+76>>2]=b;x=h+55|0;q=h+56|0;a:{b:{c:{d:while(1){f=0;e:while(1){k=b;if((p^2147483647)<(f|0)){break c}p=f+p|0;f:{g:{h:{f=b;g=K[f|0];if(g){while(1){i:{b=g&255;j:{if(!b){b=f;break j}if((b|0)!=37){break i}g=f;while(1){if(K[g+1|0]!=37){b=g;break j}f=f+1|0;l=K[g+2|0];b=g+2|0;g=b;if((l|0)==37){continue}break}}f=f-k|0;w=p^2147483647;if((f|0)>(w|0)){break c}if(a){wb(a,k,f);}if(f){continue e}J[h+76>>2]=b;f=b+1|0;o=-1;g=H[b+1|0];if(!(K[b+2|0]!=36|g-48>>>0>=10)){o=g-48|0;r=1;f=b+3|0;}J[h+76>>2]=f;m=0;g=H[f|0];b=g-32|0;k:{if(b>>>0>31){l=f;break k}l=f;b=1<<b;if(!(b&75913)){break k}while(1){l=f+1|0;J[h+76>>2]=l;m=b|m;g=H[f+1|0];b=g-32|0;if(b>>>0>=32){break k}f=l;b=1<<b;if(b&75913){continue}break}}l:{if((g|0)==42){b=H[l+1|0];m:{if(!(K[l+2|0]!=36|b-48>>>0>=10)){b=b-48|0;n:{if(!a){J[(b<<2)+e>>2]=10;n=0;break n}n=J[(b<<3)+d>>2];}b=l+3|0;r=1;break m}if(r){break h}b=l+1|0;if(!a){J[h+76>>2]=b;r=0;n=0;break l}f=J[c>>2];J[c>>2]=f+4;n=J[f>>2];r=0;}J[h+76>>2]=b;if((n|0)>=0){break l}n=0-n|0;m=m|8192;break l}n=Jg(h+76|0);if((n|0)<0){break c}b=J[h+76>>2];}f=0;i=-1;g=0;o:{if(K[b|0]!=46){break o}if(K[b+1|0]==42){g=H[b+2|0];p:{if(!(K[b+3|0]!=36|g-48>>>0>=10)){g=g-48|0;b=b+4|0;q:{if(!a){J[(g<<2)+e>>2]=10;i=0;break q}i=J[(g<<3)+d>>2];}break p}if(r){break h}b=b+2|0;i=0;if(!a){break p}g=J[c>>2];J[c>>2]=g+4;i=J[g>>2];}J[h+76>>2]=b;g=(i^-1)>>>31|0;break o}J[h+76>>2]=b+1;i=Jg(h+76|0);b=J[h+76>>2];g=1;}t=g;while(1){s=f;j=28;u=b;g=H[b|0];if(g-123>>>0<4294967238){break b}b=b+1|0;f=K[(g+P(f,58)|0)+6959|0];if(f-1>>>0<8){continue}break}J[h+76>>2]=b;r:{if((f|0)!=27){if(!f){break b}if((o|0)>=0){if(!a){J[(o<<2)+e>>2]=f;continue d}f=(o<<3)+d|0;g=J[f+4>>2];J[h+64>>2]=J[f>>2];J[h+68>>2]=g;break r}if(!a){break f}Ig(h- -64|0,f,c);break r}if((o|0)>=0){break b}f=0;if(!a){continue e}}j=-1;if(K[a|0]&32){break a}g=m&-65537;m=m&8192?g:m;o=0;v=1212;l=q;s:{t:{u:{v:{w:{x:{y:{z:{A:{B:{C:{D:{E:{F:{G:{H:{f=H[u|0];f=s?(f&15)==3?f&-33:f:f;switch(f-88|0){case 11:break s;case 9:case 13:case 14:case 15:break t;case 27:break y;case 12:case 17:break B;case 23:break C;case 0:case 32:break D;case 24:break E;case 22:break F;case 29:break G;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 10:case 16:case 18:case 19:case 20:case 21:case 25:case 26:case 28:case 30:case 31:break g;default:break H}}I:{switch(f-65|0){case 0:case 4:case 5:case 6:break t;case 2:break w;case 1:case 3:break g;default:break I}}if((f|0)==83){break x}break g}g=J[h+64>>2];j=J[h+68>>2];f=1212;break A}f=0;J:{switch(s&255){case 0:J[J[h+64>>2]>>2]=p;continue e;case 1:J[J[h+64>>2]>>2]=p;continue e;case 2:g=J[h+64>>2];J[g>>2]=p;J[g+4>>2]=p>>31;continue e;case 3:I[J[h+64>>2]>>1]=p;continue e;case 4:H[J[h+64>>2]]=p;continue e;case 6:J[J[h+64>>2]>>2]=p;continue e;case 7:break J;default:continue e}}g=J[h+64>>2];J[g>>2]=p;J[g+4>>2]=p>>31;continue e}i=i>>>0<=8?8:i;m=m|8;f=120;}k=q;u=f&32;g=J[h+64>>2];j=J[h+68>>2];if(g|j){while(1){k=k-1|0;H[k|0]=u|K[(g&15)+7488|0];s=!j&g>>>0>15|(j|0)!=0;g=(j&15)<<28|g>>>4;j=j>>>4|0;if(s){continue}break}}if(!(J[h+64>>2]|J[h+68>>2])|!(m&8)){break z}v=(f>>>4|0)+1212|0;o=2;break z}f=q;k=J[h+68>>2];j=k;g=J[h+64>>2];if(k|g){while(1){f=f-1|0;H[f|0]=g&7|48;s=!j&g>>>0>7|(j|0)!=0;g=(j&7)<<29|g>>>3;j=j>>>3|0;if(s){continue}break}}k=f;if(!(m&8)){break z}f=q-f|0;i=(f|0)<(i|0)?i:f+1|0;break z}g=J[h+64>>2];f=J[h+68>>2];j=f;if((f|0)<0){k=0-(f+((g|0)!=0)|0)|0;j=k;g=0-g|0;J[h+64>>2]=g;J[h+68>>2]=k;o=1;f=1212;break A}if(m&2048){o=1;f=1213;break A}o=m&1;f=o?1214:1212;}v=f;k=Jc(g,j,q);}if((i|0)<0?t:0){break c}m=t?m&-65537:m;f=J[h+64>>2];g=J[h+68>>2];if(!(i|(f|g)!=0)){k=q;i=0;break g}f=!(f|g)+(q-k|0)|0;i=(f|0)<(i|0)?i:f;break g}f=J[h+64>>2];k=f?f:4806;f=k;l=i>>>0>=2147483647?2147483647:i;j=Zb(f,0,l);f=j?j-f|0:l;l=f+k|0;if((i|0)>=0){m=g;i=f;break g}m=g;i=f;if(K[l|0]){break c}break g}if(i){g=J[h+64>>2];break v}f=0;Bb(a,32,n,0,m);break u}J[h+12>>2]=0;J[h+8>>2]=J[h+64>>2];g=h+8|0;J[h+64>>2]=g;i=-1;}f=0;K:{while(1){k=J[g>>2];if(!k){break K}k=Mg(h+4|0,k);l=(k|0)<0;if(!(l|k>>>0>i-f>>>0)){g=g+4|0;f=f+k|0;if(i>>>0>f>>>0){continue}break K}break}if(l){break a}}j=61;if((f|0)<0){break b}Bb(a,32,n,f,m);if(!f){f=0;break u}l=0;g=J[h+64>>2];while(1){k=J[g>>2];if(!k){break u}j=h+4|0;k=Mg(j,k);l=k+l|0;if(l>>>0>f>>>0){break u}wb(a,j,k);g=g+4|0;if(f>>>0>l>>>0){continue}break}}Bb(a,32,n,f,m^8192);f=(f|0)<(n|0)?n:f;continue e}if((i|0)<0?t:0){break c}j=61;f=Gg(a,O[h+64>>3],n,i,m,f);if((f|0)>=0){continue e}break b}H[h+55|0]=J[h+64>>2];i=1;k=x;m=g;break g}g=K[f+1|0];f=f+1|0;continue}}j=p;if(a){break a}if(!r){break f}f=1;while(1){a=J[(f<<2)+e>>2];if(a){Ig((f<<3)+d|0,a,c);j=1;f=f+1|0;if((f|0)!=10){continue}break a}break}j=1;if(f>>>0>=10){break a}while(1){if(J[(f<<2)+e>>2]){break h}f=f+1|0;if((f|0)!=10){continue}break}break a}j=28;break b}l=l-k|0;i=(i|0)>(l|0)?i:l;if((i|0)>(o^2147483647)){break c}j=61;g=i+o|0;f=(g|0)<(n|0)?n:g;if((w|0)<(f|0)){break b}Bb(a,32,f,g,m);wb(a,v,o);Bb(a,48,f,g,m^65536);Bb(a,48,i,l,0);wb(a,k,l);Bb(a,32,f,g,m^8192);continue}break}break}j=0;break a}j=61;}J[5732]=j;j=-1;}Ua=h+80|0;return j}function un(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;a:{if(a>>>0<=211){d=J[Eg(7504,7696,a)>>2];break a}if(a>>>0>=4294967292){a=Rb(8);J[5996]=0;d=$(167,a|0)|0;e=J[5996];J[5996]=0;if((e|0)!=1){na(d|0,22716,92);B();}d=Z()|0;ic(a);da(d|0);B();}f=(a>>>0)/210|0;d=P(f,210);e=Eg(7696,7888,a-d|0)-7696>>2;while(1){d=J[(e<<2)+7696>>2]+d|0;a=5;while(1){b:{if((a|0)==47){a=211;while(1){b=(d>>>0)/(a>>>0)|0;if(b>>>0<a>>>0){break a}if((P(a,b)|0)==(d|0)){break b}b=a+10|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+12|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+16|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+18|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+22|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+28|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+30|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+36|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+40|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+42|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+46|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+52|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+58|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+60|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+66|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+70|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+72|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+78|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+82|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+88|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+96|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+100|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+102|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+106|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+108|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+112|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+120|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+126|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+130|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+136|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+138|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+142|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+148|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+150|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+156|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+162|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+166|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+168|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+172|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+178|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+180|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+186|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+190|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+192|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+196|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+198|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((P(b,c)|0)==(d|0)){break b}b=a+208|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}a=a+210|0;if((P(b,c)|0)!=(d|0)){continue}break}break b}b=J[(a<<2)+7504>>2];c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}a=a+1|0;if((P(b,c)|0)!=(d|0)){continue}}break}d=e+1|0;a=(d|0)==48;e=a?0:d;f=a+f|0;d=P(f,210);continue}}return d|0}function ob(a,b,c,d,e,f,g,h,i){var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0;k=Ua-96|0;Ua=k;u=i&65535;o=(e^i)&-2147483648;r=e&65535;y=r;Q=i>>>16&32767;R=e>>>16&32767;a:{b:{if(Q-32767>>>0>4294934529&R-32767>>>0>=4294934530){break b}s=e&2147483647;q=s;j=d;if(!(!d&(q|0)==2147418112?!(b|c):q>>>0<2147418112)){m=d;o=e|32768;break a}s=i&2147483647;p=s;e=h;if(!(!e&(p|0)==2147418112?!(f|g):p>>>0<2147418112)){m=e;o=i|32768;b=f;c=g;break a}if(!(b|j|(q^2147418112|c))){if(!(e|f|(g|p))){o=2147450880;b=0;c=0;break a}o=o|2147418112;b=0;c=0;break a}if(!(e|f|(p^2147418112|g))){e=b|j;d=c|q;b=0;c=0;if(!(d|e)){o=2147450880;break a}o=o|2147418112;break a}if(!(b|j|(c|q))){b=0;c=0;break a}if(!(e|f|(g|p))){b=0;c=0;break a}if((q|0)==65535|q>>>0<65535){j=!(d|r);i=j?b:d;s=j<<6;e=S(i)+32|0;i=S(j?c:r);i=s+((i|0)==32?e:i)|0;Cb(k+80|0,b,c,d,r,i-15|0);t=16-i|0;d=J[k+88>>2];y=J[k+92>>2];c=J[k+84>>2];b=J[k+80>>2];}if(p>>>0>65535){break b}i=!(h|u);e=i?f:h;r=i<<6;j=S(e)+32|0;e=S(i?g:u);e=r+((e|0)==32?j:e)|0;Cb(k- -64|0,f,g,h,u,e-15|0);t=(t-e|0)+16|0;h=J[k+72>>2];u=J[k+76>>2];f=J[k+64>>2];g=J[k+68>>2];}e=f;f=g<<15|f>>>17;i=e<<15;e=0;v=i&-32768;K=c;s=co(v,e,c,0);e=Wa;z=e;L=f;q=b;c=co(f,0,b,0);b=c+s|0;f=Wa+e|0;i=b;c=b>>>0<c>>>0?f+1|0:f;f=b;j=0;b=co(q,l,v,l);p=j+b|0;e=Wa+f|0;e=b>>>0>p>>>0?e+1|0:e;r=e;M=(f|0)==(e|0)&j>>>0>p>>>0|e>>>0<f>>>0;N=d;w=co(v,l,d,0);O=Wa;b=co(K,l,L,l);x=b+w|0;j=Wa+O|0;j=b>>>0>x>>>0?j+1|0:j;b=u<<15|h>>>17;A=h<<15|g>>>17;d=co(A,0,q,l);B=d+x|0;f=Wa+j|0;f=d>>>0>B>>>0?f+1|0:f;C=f;d=(c|0)==(z|0)&i>>>0<s>>>0|c>>>0<z>>>0;D=c+B|0;f=d+f|0;f=c>>>0>D>>>0?f+1|0:f;u=f;g=D;c=f;E=y|65536;y=co(v,l,E,n);P=Wa;d=co(N,m,L,l);F=d+y|0;e=Wa+P|0;e=d>>>0>F>>>0?e+1|0:e;i=e;G=b|-2147483648;b=co(G,0,q,l);H=b+F|0;f=Wa+e|0;f=b>>>0>H>>>0?f+1|0:f;d=co(A,m,K,l);b=d+H|0;I=f;f=f+Wa|0;z=b;s=b>>>0<d>>>0?f+1|0:f;f=b;b=0;q=b+g|0;e=c+f|0;e=b>>>0>q>>>0?e+1|0:e;v=e;f=e;b=q+M|0;c=b>>>0<q>>>0?f+1|0:f;t=((R+Q|0)+t|0)-16383|0;d=co(G,m,K,l);h=Wa;e=co(E,m,L,l);g=e+d|0;f=Wa+h|0;f=e>>>0>g>>>0?f+1|0:f;n=(h|0)==(f|0)&d>>>0>g>>>0|f>>>0<h>>>0;h=f;e=co(A,m,N,m);d=e+g|0;f=Wa+f|0;f=d>>>0<e>>>0?f+1|0:f;e=f;g=(f|0)==(h|0)&d>>>0<g>>>0|f>>>0<h>>>0;f=0;h=g;g=g+n|0;f=h>>>0>g>>>0?1:f;h=g;g=co(G,m,E,m);h=h+g|0;f=Wa+f|0;M=h;g=g>>>0>h>>>0?f+1|0:f;h=d;l=e;e=(j|0)==(O|0)&w>>>0>x>>>0|j>>>0<O>>>0;f=0;j=(j|0)==(C|0)&x>>>0>B>>>0|j>>>0>C>>>0;n=j;j=e+j|0;e=(n>>>0>j>>>0?1:f)+l|0;f=g;d=d+j|0;e=d>>>0<j>>>0?e+1|0:e;n=e;w=d;d=(e|0)==(l|0)&d>>>0<h>>>0|e>>>0<l>>>0;e=d;d=d+M|0;f=e>>>0>d>>>0?f+1|0:f;j=d;h=f;e=co(A,m,E,m);l=Wa;g=co(G,m,N,m);d=g+e|0;f=Wa+l|0;f=d>>>0<g>>>0?f+1|0:f;g=f;f=(l|0)==(f|0)&d>>>0<e>>>0|f>>>0<l>>>0;x=g+j|0;e=f+h|0;e=g>>>0>x>>>0?e+1|0:e;l=x;h=e;j=d;e=0;d=e+w|0;f=j+n|0;f=d>>>0<e>>>0?f+1|0:f;e=f;g=(n|0)==(f|0)&d>>>0<w>>>0|f>>>0<n>>>0;f=h;h=g;g=g+l|0;f=h>>>0>g>>>0?f+1|0:f;w=g;g=f;h=d;j=e;e=(s|0)==(I|0)&z>>>0<H>>>0|s>>>0<I>>>0;d=(i|0)==(P|0)&y>>>0>F>>>0|i>>>0<P>>>0;i=(i|0)==(I|0)&F>>>0>H>>>0|i>>>0>I>>>0;d=d+i|0;d=d+e|0;n=s;i=n+h|0;e=d+j|0;f=g;d=i;e=d>>>0<n>>>0?e+1|0:e;h=(e|0)==(j|0)&h>>>0>d>>>0|e>>>0<j>>>0;g=h+w|0;f=h>>>0>g>>>0?f+1|0:f;j=g;g=f;h=d;f=0;i=e;n=(u|0)==(v|0)&q>>>0<D>>>0|u>>>0>v>>>0;l=n;n=n+((u|0)==(C|0)&B>>>0>D>>>0|u>>>0<C>>>0)|0;e=e+(l>>>0>n>>>0?1:f)|0;f=g;d=d+n|0;e=d>>>0<n>>>0?e+1|0:e;h=(e|0)==(i|0)&d>>>0<h>>>0|e>>>0<i>>>0;g=h;h=h+j|0;f=g>>>0>h>>>0?f+1|0:f;i=f;c:{if(f&65536){t=t+1|0;break c}j=r>>>31|0;g=0;f=i<<1|h>>>31;h=h<<1|e>>>31;i=f;f=e<<1|d>>>31;d=d<<1|c>>>31;e=f;f=r<<1|p>>>31;p=p<<1;r=f;f=c<<1|b>>>31;b=b<<1|j;c=f|g;}if((t|0)>=32767){o=o|2147418112;b=0;c=0;break a}d:{if((t|0)<=0){g=1-t|0;if(g>>>0<=127){f=t+127|0;Cb(k+48|0,p,r,b,c,f);Cb(k+32|0,d,e,h,i,f);xc(k+16|0,p,r,b,c,g);xc(k,d,e,h,i,g);p=J[k+32>>2]|J[k+16>>2]|(J[k+48>>2]|J[k+56>>2]|(J[k+52>>2]|J[k+60>>2]))!=0;r=J[k+36>>2]|J[k+20>>2];b=J[k+40>>2]|J[k+24>>2];c=J[k+44>>2]|J[k+28>>2];d=J[k>>2];e=J[k+4>>2];g=J[k+8>>2];f=J[k+12>>2];break d}b=0;c=0;break a}g=h;f=i&65535|t<<16;}m=g|m;o=f|o;if(!(!b&(c|0)==-2147483648?!(p|r):(c|0)>0|(c|0)>=0)){b=d+1|0;j=b?e:e+1|0;e=o;c=j;d=!(j|b);m=d+m|0;o=d>>>0>m>>>0?e+1|0:e;break a}if(b|p|(c^-2147483648|r)){b=d;c=e;break a}f=e;b=d&1;c=b;b=b+d|0;c=c>>>0>b>>>0?f+1|0:f;d=(f|0)==(c|0)&b>>>0<d>>>0|c>>>0<f>>>0;f=o;m=d+m|0;o=m>>>0<d>>>0?f+1|0:f;}J[a>>2]=b;J[a+4>>2]=c;J[a+8>>2]=m;J[a+12>>2]=o;Ua=k+96|0;}function Pg(){var a=0,b=0,c=0;if(K[25020]){return J[6254]}J[6663]=0;J[6662]=22008;J[6662]=14144;J[6662]=12664;a=Ua-16|0;Ua=a;J[6664]=0;J[6665]=0;J[6666]=0;H[26792]=0;J[a+4>>2]=26656;c=J[a+4>>2];b=a+8|0;H[b+4|0]=0;J[b>>2]=c;J[5996]=0;ha(273,26656);c=J[5996];J[5996]=0;a:{if((c|0)!=1){ff(26656,30);H[b+4|0]=1;ef(b);Ua=a+16|0;break a}b=Z()|0;ef(a+8|0);da(b|0);B();}J[5996]=0;b=_(30,26800,3538)|0;a=J[5996];J[5996]=0;b:{c:{d:{if((a|0)!=1){df(26656);J[6581]=0;J[6580]=22008;J[6580]=14144;J[6580]=15252;J[5996]=0;ha(240,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6583]=0;J[6582]=22008;J[6582]=14144;J[6582]=15284;J[5996]=0;ha(241,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6585]=0;J[6584]=22008;J[6584]=14144;H[26348]=0;J[6586]=0;J[6584]=12684;J[6586]=12736;J[5996]=0;ha(242,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6589]=0;J[6588]=22008;J[6588]=14144;J[6588]=14200;J[5996]=0;ha(243,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6591]=0;J[6590]=22008;J[6590]=14144;J[6590]=14348;J[5996]=0;ha(244,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[5996]=0;ca(245);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[5996]=0;ha(246,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6597]=0;J[6596]=22008;J[6596]=14144;J[6596]=14496;J[5996]=0;ha(247,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6599]=0;J[6598]=22008;J[6598]=14144;J[6598]=14728;J[5996]=0;ha(248,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6601]=0;J[6600]=22008;J[6600]=14144;J[6600]=14612;J[5996]=0;ha(249,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6603]=0;J[6602]=22008;J[6602]=14144;J[6602]=14844;J[5996]=0;ha(250,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6605]=0;J[6604]=22008;J[6604]=14144;I[13212]=11310;J[6604]=13816;J[6607]=0;J[6608]=0;J[6609]=0;J[5996]=0;ha(251,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6611]=0;J[6610]=22008;J[6610]=14144;J[6612]=46;J[6613]=44;J[6610]=13856;J[6614]=0;J[6615]=0;J[6616]=0;J[5996]=0;ha(252,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6619]=0;J[6618]=22008;J[6618]=14144;J[6618]=15316;J[5996]=0;ha(253,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6621]=0;J[6620]=22008;J[6620]=14144;J[6620]=15560;J[5996]=0;ha(254,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6623]=0;J[6622]=22008;J[6622]=14144;J[6622]=15772;J[5996]=0;ha(255,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6625]=0;J[6624]=22008;J[6624]=14144;J[6624]=16004;J[5996]=0;ha(256,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6627]=0;J[6626]=22008;J[6626]=14144;J[6626]=16988;J[5996]=0;ha(257,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6629]=0;J[6628]=22008;J[6628]=14144;J[6628]=17136;J[5996]=0;ha(258,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6631]=0;J[6630]=22008;J[6630]=14144;J[6630]=17252;J[5996]=0;ha(259,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6633]=0;J[6632]=22008;J[6632]=14144;J[6632]=17368;J[5996]=0;ha(260,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6635]=0;J[6634]=22008;J[6634]=14144;J[6634]=17484;J[5996]=0;ha(261,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6637]=0;J[6636]=22008;J[6636]=14144;J[6636]=17648;J[5996]=0;ha(262,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6639]=0;J[6638]=22008;J[6638]=14144;J[6638]=17812;J[5996]=0;ha(263,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6641]=0;J[6640]=22008;J[6640]=14144;J[6640]=17976;J[5996]=0;ha(264,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6643]=0;J[6642]=22008;J[6642]=14144;J[6644]=19232;J[6644]=16252;J[6642]=16204;J[5996]=0;ha(265,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6647]=0;J[6646]=22008;J[6646]=14144;J[6648]=19268;J[6648]=16516;J[6646]=16468;J[5996]=0;ha(266,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[5996]=0;ca(267);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[5996]=0;ha(268,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[5996]=0;ca(269);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[5996]=0;ha(270,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6659]=0;J[6658]=22008;J[6658]=14144;J[6658]=18140;J[5996]=0;ha(271,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}J[6661]=0;J[6660]=22008;J[6660]=14144;J[6660]=18260;J[5996]=0;ha(272,26648);a=J[5996];J[5996]=0;if((a|0)==1){break d}break b}a=Z()|0;break c}a=Z()|0;ab(b);}gf(26656);da(a|0);B();}J[6253]=26648;H[25020]=1;J[6254]=25012;return 25012}function Ek(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0;h=Ua-48|0;Ua=h;J[h+44>>2]=b;J[e>>2]=0;i=J[d+28>>2];J[h>>2]=i;J[i+4>>2]=J[i+4>>2]+1;J[5996]=0;i=$(197,J[h>>2])|0;j=J[5996];J[5996]=0;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{x:{y:{z:{A:{if((j|0)!=1){j=J[h>>2];k=J[j+4>>2]-1|0;J[j+4>>2]=k;if((k|0)==-1){Xa[J[J[j>>2]+8>>2]](j);}switch(g-65|0){case 54:break j;case 19:break k;case 18:break l;case 17:break m;case 49:break n;case 47:break o;case 45:case 51:break p;case 12:break q;case 44:break r;case 41:break s;case 8:break t;case 7:break u;case 5:break v;case 3:break w;case 35:case 36:break x;case 34:break y;case 1:case 33:case 39:break z;case 0:case 32:break A;case 2:case 4:case 6:case 9:case 10:case 11:case 13:case 14:case 15:case 16:case 20:case 21:case 22:case 25:case 26:case 27:case 28:case 29:case 30:case 31:case 37:case 38:case 40:case 42:case 43:case 46:case 48:case 50:case 52:case 53:break d;case 24:break f;case 56:break g;case 23:break h;case 55:break i;default:break e}}c=Z()|0;a=J[h>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}Bf(a,f+24|0,h+44|0,c,e,i);break b}Af(a,f+16|0,h+44|0,c,e,i);break b}g=Xa[J[J[a+8>>2]+12>>2]](a+8|0)|0;i=K[g+11|0];j=a;k=b;b=(i&128)>>>7|0;a=b?J[g>>2]:g;J[h+44>>2]=jc(j,k,c,d,e,f,a,a+((b?J[g+4>>2]:i&127)<<2)|0);break b}a=bc(h+44|0,c,e,i,2);b=J[e>>2];B:{if(!(a-1>>>0>30|b&4)){J[f+12>>2]=a;break B}J[e>>2]=b|4;}break b}g=J[3127];J[h+24>>2]=J[3126];J[h+28>>2]=g;g=J[3125];J[h+16>>2]=J[3124];J[h+20>>2]=g;g=J[3123];J[h+8>>2]=J[3122];J[h+12>>2]=g;g=J[3121];J[h>>2]=J[3120];J[h+4>>2]=g;J[h+44>>2]=jc(a,b,c,d,e,f,h,h+32|0);break b}g=J[3135];J[h+24>>2]=J[3134];J[h+28>>2]=g;g=J[3133];J[h+16>>2]=J[3132];J[h+20>>2]=g;g=J[3131];J[h+8>>2]=J[3130];J[h+12>>2]=g;g=J[3129];J[h>>2]=J[3128];J[h+4>>2]=g;J[h+44>>2]=jc(a,b,c,d,e,f,h,h+32|0);break b}a=bc(h+44|0,c,e,i,2);b=J[e>>2];C:{if(!((a|0)>23|b&4)){J[f+8>>2]=a;break C}J[e>>2]=b|4;}break b}a=bc(h+44|0,c,e,i,2);b=J[e>>2];D:{if(!(a-1>>>0>11|b&4)){J[f+8>>2]=a;break D}J[e>>2]=b|4;}break b}a=bc(h+44|0,c,e,i,3);b=J[e>>2];E:{if(!((a|0)>365|b&4)){J[f+28>>2]=a;break E}J[e>>2]=b|4;}break b}b=bc(h+44|0,c,e,i,2)-1|0;a=J[e>>2];F:{if(!(b>>>0>11|a&4)){J[f+16>>2]=b;break F}J[e>>2]=a|4;}break b}a=bc(h+44|0,c,e,i,2);b=J[e>>2];G:{if(!((a|0)>59|b&4)){J[f+4>>2]=a;break G}J[e>>2]=b|4;}break b}a=h+44|0;b=Ua-16|0;Ua=b;J[b+12>>2]=c;while(1){H:{if(Tb(a,b+12|0)){break H}c=J[a>>2];d=J[c+12>>2];I:{if((d|0)==J[c+16>>2]){c=Xa[J[J[c>>2]+36>>2]](c)|0;break I}c=J[d>>2];}if(!(Xa[J[J[i>>2]+12>>2]](i,1,c)|0)){break H}Hc(a);continue}break}if(Tb(a,b+12|0)){J[e>>2]=J[e>>2]|2;}Ua=b+16|0;break b}d=h+44|0;a=Xa[J[J[a+8>>2]+8>>2]](a+8|0)|0;b=K[a+11|0];g=(b&128)>>>7|0?J[a+4>>2]:b&127;b=K[a+23|0];J:{if((g|0)==(0-((b&128)>>>7|0?J[a+16>>2]:b&127)|0)){J[e>>2]=J[e>>2]|4;break J}c=ld(d,c,a,a+24|0,i,e,0);b=J[f+8>>2];if(!((c|0)!=(a|0)|(b|0)!=12)){J[f+8>>2]=0;break J}if(!((c-a|0)!=12|(b|0)>11)){J[f+8>>2]=b+12;}}break b}g=fb(h,12544,44);J[g+44>>2]=jc(a,b,c,d,e,f,g,g+44|0);break b}J[h+16>>2]=J[3152];g=J[3151];J[h+8>>2]=J[3150];J[h+12>>2]=g;g=J[3149];J[h>>2]=J[3148];J[h+4>>2]=g;J[h+44>>2]=jc(a,b,c,d,e,f,h,h+20|0);break b}a=bc(h+44|0,c,e,i,2);b=J[e>>2];K:{if(!((a|0)>60|b&4)){J[f>>2]=a;break K}J[e>>2]=b|4;}break b}g=J[3163];J[h+24>>2]=J[3162];J[h+28>>2]=g;g=J[3161];J[h+16>>2]=J[3160];J[h+20>>2]=g;g=J[3159];J[h+8>>2]=J[3158];J[h+12>>2]=g;g=J[3157];J[h>>2]=J[3156];J[h+4>>2]=g;J[h+44>>2]=jc(a,b,c,d,e,f,h,h+32|0);break b}a=bc(h+44|0,c,e,i,1);b=J[e>>2];L:{if(!((a|0)>6|b&4)){J[f+24>>2]=a;break L}J[e>>2]=b|4;}break b}a=Xa[J[J[a>>2]+20>>2]](a,b,c,d,e,f)|0;break a}g=Xa[J[J[a+8>>2]+24>>2]](a+8|0)|0;i=K[g+11|0];j=a;k=b;b=(i&128)>>>7|0;a=b?J[g>>2]:g;J[h+44>>2]=jc(j,k,c,d,e,f,a,a+((b?J[g+4>>2]:i&127)<<2)|0);break b}zf(f+20|0,h+44|0,c,e,i);break b}a=bc(h+44|0,c,e,i,4);if(!(K[e|0]&4)){J[f+20>>2]=a-1900;}break b}if((g|0)==37){break c}}J[e>>2]=J[e>>2]|4;break b}a=Ua-16|0;Ua=a;J[a+12>>2]=c;b=6;d=h+44|0;g=a+12|0;M:{N:{if(Tb(d,g)){break N}b=4;c=J[d>>2];f=J[c+12>>2];O:{if((f|0)==J[c+16>>2]){c=Xa[J[J[c>>2]+36>>2]](c)|0;break O}c=J[f>>2];}if((Xa[J[J[i>>2]+52>>2]](i,c,0)|0)!=37){break N}b=2;if(!Tb(Hc(d),g)){break M}}J[e>>2]=J[e>>2]|b;}Ua=a+16|0;}a=J[h+44>>2];}Ua=h+48|0;return a|0}function qh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0;g=J[b+4>>2]-J[b>>2]|0;a:{if(g>>>0<=75){c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;e=c>>>0<29?c:d;f=e+1|0;if(f>>>0>(c>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){Ob(a,f+(f>>>1|0)|0);c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;}h=c>>>0<29;f=e+(h?a+4|0:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(f+1|0,f,(h?c:d)-e|0);c=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[f|0]=g;break a}if(g>>>0<=255){c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;e=c>>>0<29?c:d;f=e+1|0;if(f>>>0>(c>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){Ob(a,f+(f>>>1|0)|0);c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;}h=a+4|0;g=c>>>0<29;f=e+(g?h:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(f+1|0,f,(g?c:d)-e|0);c=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[f|0]=76;g=J[b+4>>2]-J[b>>2]|0;c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;e=c>>>0<29?c:d;f=e+1|0;if(f>>>0>(c>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){Ob(a,f+(f>>>1|0)|0);c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;}i=h;h=c>>>0<29;f=e+(h?i:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(f+1|0,f,(h?c:d)-e|0);c=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[f|0]=g;break a}c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=c-29|0;f=c>>>0<29?c:e;d=f+1|0;i=c>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24);h=a+4|0;if(g>>>0<=65535){if(d>>>0>i>>>0){Ob(a,d+(d>>>1|0)|0);c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=c-29|0;}g=c>>>0<29;d=f+(g?h:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(d+1|0,d,(g?c:e)-f|0);c=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[d|0]=77;f=J[b+4>>2]-J[b>>2]|0;c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;g=c>>>0<29?c:d;e=g+2|0;if(e>>>0>(c>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){Ob(a,e+(e>>>1|0)|0);c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;}i=h;h=c>>>0<29;e=g+(h?i:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(e+2|0,e,(h?c:d)-g|0);c=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+2|0;H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[e|0]=f;H[e+1|0]=f>>>8;break a}if(d>>>0>i>>>0){Ob(a,d+(d>>>1|0)|0);c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=c-29|0;}g=c>>>0<29;d=f+(g?h:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(d+1|0,d,(g?c:e)-f|0);c=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[d|0]=78;f=J[b+4>>2]-J[b>>2]|0;c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;g=c>>>0<29?c:d;e=g+4|0;if(e>>>0>(c>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){Ob(a,e+(e>>>1|0)|0);c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);d=c-29|0;}i=h;h=c>>>0<29;e=g+(h?i:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(e+4|0,e,(h?c:d)-g|0);c=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+4|0;H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[e|0]=f;H[e+1|0]=f>>>8;H[e+2|0]=f>>>16;H[e+3|0]=f>>>24;}d=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=d-29|0;f=J[b+4>>2];b=J[b>>2];h=f-b|0;g=d>>>0<29?d:e;c=h+g|0;if(c>>>0>(d>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){Ob(a,c+(c>>>1|0)|0);d=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=d-29|0;}i=d>>>0<29;c=g+(i?a+4|0:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(h+c|0,c,(i?d:e)-g|0);d=h+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=d;H[a+1|0]=d>>>8;H[a+2|0]=d>>>16;H[a+3|0]=d>>>24;b:{if((b|0)==(f|0)){break b}e=f+(b^-1)|0;h=h&7;if(h){d=0;while(1){H[c|0]=K[b|0];b=b+1|0;c=c+1|0;d=d+1|0;if((h|0)!=(d|0)){continue}break}}if(e>>>0<7){break b}while(1){H[c|0]=K[b|0];H[c+1|0]=K[b+1|0];H[c+2|0]=K[b+2|0];H[c+3|0]=K[b+3|0];H[c+4|0]=K[b+4|0];H[c+5|0]=K[b+5|0];H[c+6|0]=K[b+6|0];H[c+7|0]=K[b+7|0];c=c+8|0;b=b+8|0;if((f|0)!=(b|0)){continue}break}}return a|0}function Kk(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0;h=Ua-16|0;Ua=h;J[h+12>>2]=b;J[e>>2]=0;i=J[d+28>>2];J[h>>2]=i;J[i+4>>2]=J[i+4>>2]+1;J[5996]=0;i=$(170,J[h>>2])|0;j=J[5996];J[5996]=0;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{x:{y:{z:{A:{if((j|0)!=1){j=J[h>>2];k=J[j+4>>2]-1|0;J[j+4>>2]=k;if((k|0)==-1){Xa[J[J[j>>2]+8>>2]](j);}switch(g-65|0){case 54:break j;case 19:break k;case 18:break l;case 17:break m;case 49:break n;case 47:break o;case 45:case 51:break p;case 12:break q;case 44:break r;case 41:break s;case 8:break t;case 7:break u;case 5:break v;case 3:break w;case 35:case 36:break x;case 34:break y;case 1:case 33:case 39:break z;case 0:case 32:break A;case 2:case 4:case 6:case 9:case 10:case 11:case 13:case 14:case 15:case 16:case 20:case 21:case 22:case 25:case 26:case 27:case 28:case 29:case 30:case 31:case 37:case 38:case 40:case 42:case 43:case 46:case 48:case 50:case 52:case 53:break d;case 24:break f;case 56:break g;case 23:break h;case 55:break i;default:break e}}c=Z()|0;a=J[h>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}Ef(a,f+24|0,h+12|0,c,e,i);break b}Df(a,f+16|0,h+12|0,c,e,i);break b}g=Xa[J[J[a+8>>2]+12>>2]](a+8|0)|0;i=K[g+11|0];j=a;k=b;b=(i&128)>>>7|0;a=b?J[g>>2]:g;J[h+12>>2]=kc(j,k,c,d,e,f,a,a+(b?J[g+4>>2]:i&127)|0);break b}a=cc(h+12|0,c,e,i,2);b=J[e>>2];B:{if(!(a-1>>>0>30|b&4)){J[f+12>>2]=a;break B}J[e>>2]=b|4;}break b}J[h>>2]=623865125;J[h+4>>2]=2032480100;J[h+12>>2]=kc(a,b,c,d,e,f,h,h+8|0);break b}J[h>>2]=623728933;J[h+4>>2]=1680158061;J[h+12>>2]=kc(a,b,c,d,e,f,h,h+8|0);break b}a=cc(h+12|0,c,e,i,2);b=J[e>>2];C:{if(!((a|0)>23|b&4)){J[f+8>>2]=a;break C}J[e>>2]=b|4;}break b}a=cc(h+12|0,c,e,i,2);b=J[e>>2];D:{if(!(a-1>>>0>11|b&4)){J[f+8>>2]=a;break D}J[e>>2]=b|4;}break b}a=cc(h+12|0,c,e,i,3);b=J[e>>2];E:{if(!((a|0)>365|b&4)){J[f+28>>2]=a;break E}J[e>>2]=b|4;}break b}b=cc(h+12|0,c,e,i,2)-1|0;a=J[e>>2];F:{if(!(b>>>0>11|a&4)){J[f+16>>2]=b;break F}J[e>>2]=a|4;}break b}a=cc(h+12|0,c,e,i,2);b=J[e>>2];G:{if(!((a|0)>59|b&4)){J[f+4>>2]=a;break G}J[e>>2]=b|4;}break b}a=h+12|0;b=Ua-16|0;Ua=b;J[b+12>>2]=c;while(1){H:{if(Ub(a,b+12|0)){break H}c=J[a>>2];d=J[c+12>>2];I:{if((d|0)==J[c+16>>2]){c=Xa[J[J[c>>2]+36>>2]](c)|0;break I}c=K[d|0];}d=J[i+8>>2];c=c<<24>>24;if((c|0)>=0){c=J[d+((c&255)<<2)>>2]&1;}else {c=0;}if(!c){break H}Ic(a);continue}break}if(Ub(a,b+12|0)){J[e>>2]=J[e>>2]|2;}Ua=b+16|0;break b}d=h+12|0;a=Xa[J[J[a+8>>2]+8>>2]](a+8|0)|0;b=K[a+11|0];g=(b&128)>>>7|0?J[a+4>>2]:b&127;b=K[a+23|0];J:{if((g|0)==(0-((b&128)>>>7|0?J[a+16>>2]:b&127)|0)){J[e>>2]=J[e>>2]|4;break J}c=nd(d,c,a,a+24|0,i,e,0);b=J[f+8>>2];if(!((c|0)!=(a|0)|(b|0)!=12)){J[f+8>>2]=0;break J}if(!((c-a|0)!=12|(b|0)>11)){J[f+8>>2]=b+12;}}break b}g=K[12456]|K[12457]<<8|(K[12458]<<16|K[12459]<<24);H[h+7|0]=g;H[h+8|0]=g>>>8;H[h+9|0]=g>>>16;H[h+10|0]=g>>>24;g=K[12453]|K[12454]<<8|(K[12455]<<16|K[12456]<<24);J[h>>2]=K[12449]|K[12450]<<8|(K[12451]<<16|K[12452]<<24);J[h+4>>2]=g;J[h+12>>2]=kc(a,b,c,d,e,f,h,h+11|0);break b}H[h+4|0]=K[12464];J[h>>2]=K[12460]|K[12461]<<8|(K[12462]<<16|K[12463]<<24);J[h+12>>2]=kc(a,b,c,d,e,f,h,h+5|0);break b}a=cc(h+12|0,c,e,i,2);b=J[e>>2];K:{if(!((a|0)>60|b&4)){J[f>>2]=a;break K}J[e>>2]=b|4;}break b}J[h>>2]=624576549;J[h+4>>2]=1394948685;J[h+12>>2]=kc(a,b,c,d,e,f,h,h+8|0);break b}a=cc(h+12|0,c,e,i,1);b=J[e>>2];L:{if(!((a|0)>6|b&4)){J[f+24>>2]=a;break L}J[e>>2]=b|4;}break b}a=Xa[J[J[a>>2]+20>>2]](a,b,c,d,e,f)|0;break a}g=Xa[J[J[a+8>>2]+24>>2]](a+8|0)|0;i=K[g+11|0];j=a;k=b;b=(i&128)>>>7|0;a=b?J[g>>2]:g;J[h+12>>2]=kc(j,k,c,d,e,f,a,a+(b?J[g+4>>2]:i&127)|0);break b}Cf(f+20|0,h+12|0,c,e,i);break b}a=cc(h+12|0,c,e,i,4);if(!(K[e|0]&4)){J[f+20>>2]=a-1900;}break b}if((g|0)==37){break c}}J[e>>2]=J[e>>2]|4;break b}a=Ua-16|0;Ua=a;J[a+12>>2]=c;b=6;d=h+12|0;g=a+12|0;M:{N:{if(Ub(d,g)){break N}b=4;c=J[d>>2];f=J[c+12>>2];O:{if((f|0)==J[c+16>>2]){c=Xa[J[J[c>>2]+36>>2]](c)|0;break O}c=K[f|0];}if((Xa[J[J[i>>2]+36>>2]](i,c<<24>>24,0)|0)!=37){break N}b=2;if(!Ub(Ic(d),g)){break M}}J[e>>2]=J[e>>2]|b;}Ua=a+16|0;}a=J[h+12>>2];}Ua=h+16|0;return a|0}function Yc(a,b,c,d,e,f){var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;g=Ua-32|0;Ua=g;if(!K[24588]){J[6145]=0;J[6146]=0;J[6143]=0;J[6144]=0;J[6141]=0;J[6142]=0;H[24588]=1;}i=1-e;a:{b:{c:{d:{e:{f:{switch(b|0){case 10:case 11:case 12:case 16:b=cb(8);J[g+20>>2]=b;f=b+8|0;J[g+28>>2]=f;O[b>>3]=c;J[g+24>>2]=f;J[5996]=0;f=$(3,8)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}J[g+8>>2]=f;h=f+8|0;J[g+16>>2]=h;O[f>>3]=d;J[5996]=0;J[g+12>>2]=h;ba(65,a|0,g+20|0,g+8|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){$a(f);$a(b);break e}break c;case 13:case 14:case 15:b=cb(8);J[g+20>>2]=b;f=b+8|0;J[g+28>>2]=f;O[b>>3]=c;J[g+24>>2]=f;J[5996]=0;f=$(3,8)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}J[g+8>>2]=f;h=f+8|0;J[g+16>>2]=h;J[f>>2]=0;J[f+4>>2]=0;J[5996]=0;J[g+12>>2]=h;ba(65,a|0,g+20|0,g+8|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){$a(f);$a(b);break e}break c;case 17:case 18:b=cb(16);J[g+20>>2]=b;f=b+16|0;J[g+28>>2]=f;O[b+8>>3]=c;O[b>>3]=c;J[g+24>>2]=f;J[5996]=0;f=$(3,16)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}J[g+8>>2]=f;h=f+16|0;J[g+16>>2]=h;O[f+8>>3]=d;O[f>>3]=d;J[5996]=0;J[g+12>>2]=h;ba(65,a|0,g+20|0,g+8|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){$a(f);$a(b);break e}break c;case 19:b=cb(16);J[g+20>>2]=b;f=b+16|0;J[g+28>>2]=f;i=i*c;O[b+8>>3]=i;c=c*e;O[b>>3]=c;J[g+24>>2]=f;J[5996]=0;f=$(3,16)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}J[g+8>>2]=f;h=f+16|0;J[g+16>>2]=h;O[f+8>>3]=c+d;O[f>>3]=i+d;J[5996]=0;J[g+12>>2]=h;ba(65,a|0,g+20|0,g+8|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){$a(f);$a(b);break e}break c;case 21:b=cb(16);J[g+20>>2]=b;f=b+16|0;J[g+28>>2]=f;i=i*c;O[b+8>>3]=i;O[b>>3]=c*e;J[g+24>>2]=f;J[5996]=0;f=$(3,16)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}J[g+8>>2]=f;h=f+16|0;J[g+16>>2]=h;O[f+8>>3]=d;O[f>>3]=i+d;J[5996]=0;J[g+12>>2]=h;ba(65,a|0,g+20|0,g+8|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){$a(f);$a(b);break e}break c;case 20:b=cb(16);J[g+20>>2]=b;f=b+16|0;J[g+28>>2]=f;d=i*c;O[b+8>>3]=d;O[b>>3]=c*e;J[g+24>>2]=f;J[5996]=0;f=$(3,16)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}J[g+8>>2]=f;h=f+16|0;J[g+16>>2]=h;J[f+8>>2]=0;J[f+12>>2]=0;O[f>>3]=d;J[5996]=0;J[g+12>>2]=h;ba(65,a|0,g+20|0,g+8|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){$a(f);$a(b);break e}break c;case 22:b=cb(16);J[g+20>>2]=b;h=b+16|0;J[g+28>>2]=h;O[b+8>>3]=i*c;O[b>>3]=c*e;J[g+24>>2]=h;J[5996]=0;h=$(3,16)|0;j=J[5996];J[5996]=0;if((j|0)==1){break b}J[g+8>>2]=h;j=h+16|0;J[g+16>>2]=j;O[h+8>>3]=(f|0)==1?d:0;O[h>>3]=f?0:d;J[5996]=0;J[g+12>>2]=j;ba(65,a|0,g+20|0,g+8|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){$a(h);$a(b);break e}a=Z()|0;$a(h);break a;case 23:b=cb(24);J[g+20>>2]=b;f=b+24|0;J[g+28>>2]=f;i=i*c;O[b+16>>3]=i;c=c*e;O[b+8>>3]=c;O[b>>3]=c;J[g+24>>2]=f;J[5996]=0;f=$(3,24)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}J[g+8>>2]=f;h=f+24|0;J[g+16>>2]=h;O[f+16>>3]=d;J[f+8>>2]=0;J[f+12>>2]=0;O[f>>3]=i+d;J[5996]=0;J[g+12>>2]=h;ba(65,a|0,g+20|0,g+8|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){$a(f);$a(b);break e}break c;case 24:g:{h:{if(!f){f=0;break h}if(f>>>0>=536870912){break d}e=c*e;h=f<<3;k=cb(h);b=k;l=f&7;if(l){while(1){O[b>>3]=e;b=b+8|0;j=j+1|0;if((l|0)!=(j|0)){continue}break}}m=h+k|0;n=f-1&536870911;if(n>>>0>=7){while(1){O[b+56>>3]=e;O[b+48>>3]=e;O[b+40>>3]=e;O[b+32>>3]=e;O[b+24>>3]=e;O[b+16>>3]=e;O[b+8>>3]=e;O[b>>3]=e;b=b- -64|0;if((m|0)!=(b|0)){continue}break}}j=0;J[5996]=0;h=$(3,h|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break g}c=c*i+d;b=h;if(l){while(1){O[b>>3]=c;b=b+8|0;j=j+1|0;if((l|0)!=(j|0)){continue}break}}f=(f<<3)+h|0;if(n>>>0<7){break h}while(1){O[b+56>>3]=c;O[b+48>>3]=c;O[b+40>>3]=c;O[b+32>>3]=c;O[b+24>>3]=c;O[b+16>>3]=c;O[b+8>>3]=c;O[b>>3]=c;b=b- -64|0;if((f|0)!=(b|0)){continue}break}}J[a+12>>2]=h;J[a+8>>2]=m;J[a+4>>2]=m;J[a>>2]=k;J[a+20>>2]=f;J[a+16>>2]=f;break e}a=Z()|0;$a(k);da(a|0);B();default:la(2350,1900,558,1676);B();case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 25:break f}}Yg(a);}Ua=g+32|0;return}nb();B();}a=Z()|0;$a(f);break a}a=Z()|0;}$a(b);da(a|0);B();}function Zg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;a:{b:{e=J[c>>2];d=J[e+80>>2];c:{if(!d|M[e+84>>2]>3600|(J[e+52>>2]+J[e+44>>2]>>>0>201|M[e+68>>2]>100)){break c}J[5996]=0;h=_(54,2049,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break b}if((d^-1)&h){break c}d=J[e+80>>2];J[5996]=0;h=_(54,2165,1)|0;f=J[5996];J[5996]=0;if((f|0)==1){break b}if(K[e+88|0]|(d^-1)&h){break c}i=O[a+24>>3];k=i==0?0:i*O[b+8>>3];i=O[a+16>>3];g=J[e+84>>2];i=k+((i==0?0:i*O[b>>3])+ +(g>>>0));if(i>1e4){break c}f=J[e+80>>2];d:{e:{d=J[a>>2];h=J[a+4>>2];if((d|0)==(h|0)){break e}e=d;while(1){j=J[e>>2];f:{if(f&(J[j+80>>2]^-1)){break f}k=O[e+24>>3];if(k<i){break c}if(i<k){break f}if(g>>>0<=M[j+84>>2]){break c}}e=e+32|0;if((h|0)!=(e|0)){continue}break}e=f^-1;while(1){j=J[d>>2];g:{if(e&J[j+80>>2]){break g}k=O[d+24>>3];if(k<i){break g}if(g>>>0>=M[j+84>>2]|i<k){break e}}d=d+32|0;if((h|0)!=(d|0)){continue}break}e=h;break d}if((d|0)==(h|0)){e=h;break d}g=d+32|0;h:{if((g|0)==(h|0)){e=d;break h}j=f^-1;e=d;while(1){f=d;d=g;g=J[f+32>>2];i:{j:{if(j&J[g+80>>2]){break j}k=O[f+56>>3];if(k<i){break j}if(M[g+84>>2]<=M[J[c>>2]+84>>2]|i<k){break i}}l=J[f+36>>2];J[d>>2]=0;J[f+36>>2]=0;J[e>>2]=g;g=J[e+4>>2];J[e+4>>2]=l;k:{if(!g){break k}l=J[g+4>>2];J[g+4>>2]=l-1;if(l){break k}Xa[J[J[g>>2]+8>>2]](g);bb(g);}g=J[f+60>>2];J[e+24>>2]=J[f+56>>2];J[e+28>>2]=g;g=J[f+52>>2];J[e+16>>2]=J[f+48>>2];J[e+20>>2]=g;g=J[f+44>>2];J[e+8>>2]=J[f+40>>2];J[e+12>>2]=g;e=e+32|0;}g=d+32|0;if((g|0)!=(h|0)){continue}break}h=J[a+4>>2];}if((e|0)==(h|0)){e=h;break d}d=(h-e|0)+e|0;if((h|0)!=(d|0)){while(1){g=J[d>>2];j=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;f=J[e+4>>2];J[e>>2]=g;J[e+4>>2]=j;l:{if(!f){break l}g=J[f+4>>2];J[f+4>>2]=g-1;if(g){break l}Xa[J[J[f>>2]+8>>2]](f);bb(f);}f=J[d+12>>2];J[e+8>>2]=J[d+8>>2];J[e+12>>2]=f;f=J[d+28>>2];J[e+24>>2]=J[d+24>>2];J[e+28>>2]=f;f=J[d+20>>2];J[e+16>>2]=J[d+16>>2];J[e+20>>2]=f;e=e+32|0;d=d+32|0;if((h|0)!=(d|0)){continue}break}h=J[a+4>>2];}if((e|0)!=(h|0)){while(1){h=h-32|0;d=J[h+4>>2];m:{if(!d){break m}f=J[d+4>>2];J[d+4>>2]=f-1;if(f){break m}Xa[J[J[d>>2]+8>>2]](d);bb(d);}if((e|0)!=(h|0)){continue}break}}J[a+4>>2]=e;}f=J[a+8>>2];n:{if(f>>>0>e>>>0){J[e>>2]=J[c>>2];J[e+4>>2]=J[c+4>>2];J[c>>2]=0;J[c+4>>2]=0;d=J[b+12>>2];J[e+16>>2]=J[b+8>>2];J[e+20>>2]=d;d=J[b+4>>2];J[e+8>>2]=J[b>>2];J[e+12>>2]=d;O[e+24>>3]=i;J[a+4>>2]=e+32;break n}h=J[a>>2];g=e-h>>5;d=g+1|0;if(d>>>0>=134217728){J[5996]=0;ca(62);a=J[5996];J[5996]=0;if((a|0)==1){break b}break a}f=f-h|0;j=f>>4;d=f>>>0>=2147483616?134217727:d>>>0<j>>>0?j:d;if(d>>>0>=134217728){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break b}J[5996]=0;j=d<<5;f=$(3,j|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break b}d=f+(g<<5)|0;J[d>>2]=J[c>>2];J[d+4>>2]=J[c+4>>2];J[c>>2]=0;J[c+4>>2]=0;g=J[b+12>>2];J[d+16>>2]=J[b+8>>2];J[d+20>>2]=g;g=J[b+4>>2];J[d+8>>2]=J[b>>2];J[d+12>>2]=g;O[d+24>>3]=i;b=f+j|0;f=d+32|0;o:{if((e|0)!=(h|0)){while(1){d=d-32|0;e=e-32|0;J[d>>2]=J[e>>2];J[d+4>>2]=J[e+4>>2];J[e>>2]=0;J[e+4>>2]=0;g=J[e+28>>2];J[d+24>>2]=J[e+24>>2];J[d+28>>2]=g;g=J[e+20>>2];J[d+16>>2]=J[e+16>>2];J[d+20>>2]=g;g=J[e+12>>2];J[d+8>>2]=J[e+8>>2];J[d+12>>2]=g;if((e|0)!=(h|0)){continue}break}J[a+8>>2]=b;b=J[a+4>>2];J[a+4>>2]=f;e=J[a>>2];J[a>>2]=d;if((b|0)==(e|0)){break o}while(1){b=b-32|0;d=J[b+4>>2];p:{if(!d){break p}h=J[d+4>>2];J[d+4>>2]=h-1;if(h){break p}Xa[J[J[d>>2]+8>>2]](d);bb(d);}if((b|0)!=(e|0)){continue}break}break o}J[a+8>>2]=b;J[a+4>>2]=f;J[a>>2]=d;}if(!e){break n}$a(e);}J[a+32>>2]=J[a+32>>2]+1;}a=J[c+4>>2];q:{if(!a){break q}b=J[a+4>>2];J[a+4>>2]=b-1;if(b){break q}Xa[J[J[a>>2]+8>>2]](a);bb(a);}return}a=Z()|0;mb(c);da(a|0);B();}B();}function eh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=Q(0),j=0,k=0,l=0,m=0,n=Q(0),o=0;d=P(a,1540483477);d=P(d>>>24^d,1540483477)^1866966612;d=P(d>>>13^d,1540483477);g=d>>>15^d;a:{b:{c:{d:{h=J[b+4>>2];e:{if(!h){break e}e=J[b>>2];k=fo(h);d=h-1&g;f:{if(k>>>0<=1){break f}d=g;if(d>>>0<h>>>0){break f}d=(d>>>0)%(h>>>0)|0;}f=d;d=J[e+(f<<2)>>2];if(!d){break e}d=J[d>>2];if(!d){break e}if(k>>>0<=1){e=h-1|0;while(1){h=J[d+4>>2];g:{if((h|0)!=(g|0)){if((f|0)==(e&h)){break g}break e}if(J[d+8>>2]==(a|0)){break d}}d=J[d>>2];if(d){continue}break}break e}while(1){e=J[d+4>>2];h:{if((e|0)!=(g|0)){if(e>>>0>=h>>>0){e=(e>>>0)%(h>>>0)|0;}if((e|0)==(f|0)){break h}break e}if(J[d+8>>2]==(a|0)){break d}}d=J[d>>2];if(d){continue}break}}m=ze(a,b,c);if(!m){return 0}d=J[b+4>>2];if(!d){break c}e=d-1|0;if(e&d){c=d>>>0<=g>>>0?(g>>>0)%(d>>>0)|0:g;f=J[J[b>>2]+(c<<2)>>2];if(!f){break c}while(1){f=J[f>>2];if(!f){break c}e=J[f+4>>2];if((e|0)!=(g|0)){if(d>>>0<=e>>>0){e=(e>>>0)%(d>>>0)|0;}if((c|0)!=(e|0)){break c}}if(J[f+8>>2]!=(a|0)){continue}break}break b}c=e&g;f=J[J[b>>2]+(c<<2)>>2];if(!f){break c}while(1){f=J[f>>2];if(!f){break c}h=J[f+4>>2];if((h|0)!=(g|0)&(e&h)!=(c|0)){break c}if(J[f+8>>2]!=(a|0)){continue}break}break b}return J[d+12>>2]}h=cb(16);J[h+8>>2]=a;J[h+4>>2]=g;J[h>>2]=0;J[h+12>>2]=m;k=b+8|0;n=Q(J[b+12>>2]+1>>>0);i=N[b+16>>2];i:{if(!(!d|n>Q(i*Q(d>>>0)))){g=c;break i}e=2;c=(d-1&d)!=0|d>>>0<3|d<<1;i=Q(W(Q(n/i)));j:{if(i<Q(4294967296)&i>=Q(0)){a=~~i>>>0;break j}a=0;}a=a>>>0<c>>>0?c:a;k:{if((a|0)==1){break k}if(!(a&a-1)){e=a;break k}J[5996]=0;e=$(43,a|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break a}d=J[b+4>>2];}l:{m:{if(d>>>0>=e>>>0){if(d>>>0<=e>>>0){break l}c=d>>>0<3;i=Q(W(Q(Q(M[b+12>>2])/N[b+16>>2])));n:{if(i<Q(4294967296)&i>=Q(0)){a=~~i>>>0;break n}a=0;}o:{p:{if(c){break p}if(fo(d)>>>0>1){break p}a=a>>>0<2?a:1<<32-S(a-1|0);break o}J[5996]=0;a=$(43,a|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}}e=a>>>0<e>>>0?e:a;if(e>>>0>=d>>>0){d=J[b+4>>2];break l}if(!e){break m}}if(e>>>0>=1073741824){J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)==1){break a}B();}J[5996]=0;c=$(3,e<<2)|0;a=J[5996];J[5996]=0;if((a|0)==1){break a}a=J[b>>2];J[b>>2]=c;if(a){$a(a);}J[b+4>>2]=e;f=0;d=0;j=e-1|0;if(j>>>0>=3){c=e&-4;while(1){a=d<<2;J[a+J[b>>2]>>2]=0;J[J[b>>2]+(a|4)>>2]=0;J[J[b>>2]+(a|8)>>2]=0;J[J[b>>2]+(a|12)>>2]=0;d=d+4|0;if((c|0)!=(d|0)){continue}break}}a=e&3;if(a){while(1){J[J[b>>2]+(d<<2)>>2]=0;d=d+1|0;f=f+1|0;if((a|0)!=(f|0)){continue}break}}d=J[b+8>>2];if(!d){d=e;break l}c=J[d+4>>2];q:{if(e-1&e){c=c>>>0>=e>>>0?(c>>>0)%(e>>>0)|0:c;J[J[b>>2]+(c<<2)>>2]=k;f=J[d>>2];if(f){break q}d=e;break l}c=c&j;J[J[b>>2]+(c<<2)>>2]=k;a=J[d>>2];if(!a){d=e;break l}while(1){f=j&J[a+4>>2];r:{if((f|0)==(c|0)){d=a;break r}l=f<<2;o=l+J[b>>2]|0;if(J[o>>2]){J[d>>2]=J[a>>2];J[a>>2]=J[J[l+J[b>>2]>>2]>>2];J[J[l+J[b>>2]>>2]>>2]=a;break r}J[o>>2]=d;d=a;c=f;}a=J[d>>2];if(a){continue}break}d=e;break l}while(1){a=J[f+4>>2];if(e>>>0<=a>>>0){a=(a>>>0)%(e>>>0)|0;}s:{if((a|0)==(c|0)){d=f;break s}j=a<<2;l=j+J[b>>2]|0;if(!J[l>>2]){J[l>>2]=d;d=f;c=a;break s}J[d>>2]=J[f>>2];J[f>>2]=J[J[j+J[b>>2]>>2]>>2];J[J[j+J[b>>2]>>2]>>2]=f;}f=J[d>>2];if(f){continue}break}d=e;break l}a=J[b>>2];d=0;J[b>>2]=0;if(a){$a(a);}J[b+4>>2]=0;}a=d-1|0;if(!(a&d)){g=a&g;break i}if(d>>>0>g>>>0){break i}g=(g>>>0)%(d>>>0)|0;}a=J[b>>2]+(g<<2)|0;g=J[a>>2];t:{u:{if(!g){J[h>>2]=J[b+8>>2];J[b+8>>2]=h;J[a>>2]=k;a=J[h>>2];if(!a){break t}g=J[a+4>>2];a=d-1|0;v:{if(!(a&d)){g=a&g;break v}if(d>>>0>g>>>0){break v}g=(g>>>0)%(d>>>0)|0;}g=J[b>>2]+(g<<2)|0;break u}J[h>>2]=J[g>>2];}J[g>>2]=h;}J[b+12>>2]=J[b+12>>2]+1;}return m|0}a=Z()|0;$a(h);da(a|0);B();}function bo(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;i=Ua-16|0;Ua=i;J[i+8>>2]=0;J[i+12>>2]=0;k=i+8|0;J[i+4>>2]=k;a:{b:{c:{d:{e:{if((b|0)!=(c|0)){while(1){j=J[b>>2];g=J[j+80>>2];f:{if((g^-1)&d){break f}l=e&g;h=k;g=h;g:{m=J[i+8>>2];f=m;h:{if(!f){break h}while(1){g=f;f=J[g+16>>2];if(f>>>0>l>>>0){h=g;f=J[g>>2];if(f){continue}break h}if(f>>>0>=l>>>0){break g}f=J[g+4>>2];if(f){continue}break}h=g+4|0;}J[5996]=0;f=$(3,56)|0;p=J[5996];J[5996]=0;if((p|0)==1){break e}J[f+16>>2]=l;J[f+24>>2]=j;j=J[b+4>>2];J[f+28>>2]=j;if(j){J[j+4>>2]=J[j+4>>2]+1;}j=J[b+12>>2];J[f+32>>2]=J[b+8>>2];J[f+36>>2]=j;j=J[b+28>>2];J[f+48>>2]=J[b+24>>2];J[f+52>>2]=j;j=J[b+20>>2];J[f+40>>2]=J[b+16>>2];J[f+44>>2]=j;J[f+8>>2]=g;J[f>>2]=0;J[f+4>>2]=0;J[h>>2]=f;g=J[J[i+4>>2]>>2];if(g){J[i+4>>2]=g;f=J[h>>2];}zd(J[i+8>>2],f);J[i+12>>2]=J[i+12>>2]+1;break f}n=O[b+24>>3];o=O[g+48>>3];if(!(n<o)&(M[j+84>>2]<=M[J[g+24>>2]+84>>2]|n>o)){break f}h=J[b+4>>2];if(h){J[h+4>>2]=J[h+4>>2]+1;}J[g+24>>2]=j;f=J[g+28>>2];J[g+28>>2]=h;i:{if(!f){break i}h=J[f+4>>2];J[f+4>>2]=h-1;if(h){break i}Xa[J[J[f>>2]+8>>2]](f);bb(f);}f=J[b+12>>2];J[g+32>>2]=J[b+8>>2];J[g+36>>2]=f;f=J[b+28>>2];J[g+48>>2]=J[b+24>>2];J[g+52>>2]=f;f=J[b+20>>2];J[g+40>>2]=J[b+16>>2];J[g+44>>2]=f;}b=b+32|0;if((c|0)!=(b|0)){continue}break d}}J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;break a}g=Z()|0;break c}d=J[i+4>>2];J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;if((d|0)==(k|0)){break a}while(1){j:{g=J[a+4>>2];k:{if((g|0)!=J[a+8>>2]){J[g>>2]=J[d+24>>2];b=J[d+28>>2];J[g+4>>2]=b;if(b){J[b+4>>2]=J[b+4>>2]+1;}b=J[d+52>>2];J[g+24>>2]=J[d+48>>2];J[g+28>>2]=b;b=J[d+44>>2];J[g+16>>2]=J[d+40>>2];J[g+20>>2]=b;b=J[d+36>>2];J[g+8>>2]=J[d+32>>2];J[g+12>>2]=b;J[a+4>>2]=g+32;break k}b=J[a>>2];c=g-b|0;f=c>>5;e=f+1|0;if(e>>>0>=134217728){J[5996]=0;ca(62);b=J[5996];J[5996]=0;if((b|0)==1){break j}break b}h=c>>4;e=c>>>0>=2147483616?134217727:e>>>0<h>>>0?h:e;l:{if(!e){c=0;break l}if(e>>>0>=134217728){J[5996]=0;ca(35);b=J[5996];J[5996]=0;if((b|0)!=1){break b}break j}J[5996]=0;c=$(3,e<<5)|0;h=J[5996];J[5996]=0;if((h|0)==1){break j}}f=(f<<5)+c|0;J[f>>2]=J[d+24>>2];h=J[d+28>>2];J[f+4>>2]=h;if(h){J[h+4>>2]=J[h+4>>2]+1;g=J[a+4>>2];b=J[a>>2];}c=(e<<5)+c|0;e=J[d+36>>2];J[f+8>>2]=J[d+32>>2];J[f+12>>2]=e;e=J[d+52>>2];J[f+24>>2]=J[d+48>>2];J[f+28>>2]=e;e=J[d+44>>2];J[f+16>>2]=J[d+40>>2];J[f+20>>2]=e;e=f+32|0;m:{if((b|0)==(g|0)){J[a+8>>2]=c;J[a+4>>2]=e;J[a>>2]=f;break m}while(1){f=f-32|0;g=g-32|0;J[f>>2]=J[g>>2];J[f+4>>2]=J[g+4>>2];J[g>>2]=0;J[g+4>>2]=0;h=J[g+28>>2];J[f+24>>2]=J[g+24>>2];J[f+28>>2]=h;h=J[g+20>>2];J[f+16>>2]=J[g+16>>2];J[f+20>>2]=h;h=J[g+12>>2];J[f+8>>2]=J[g+8>>2];J[f+12>>2]=h;if((b|0)!=(g|0)){continue}break}J[a+8>>2]=c;g=J[a+4>>2];J[a+4>>2]=e;b=J[a>>2];J[a>>2]=f;if((b|0)==(g|0)){break m}while(1){g=g-32|0;c=J[g+4>>2];n:{if(!c){break n}e=J[c+4>>2];J[c+4>>2]=e-1;if(e){break n}Xa[J[J[c>>2]+8>>2]](c);bb(c);}if((b|0)!=(g|0)){continue}break}}if(!b){break k}$a(b);}f=J[d+4>>2];o:{if(f){while(1){g=f;f=J[g>>2];if(f){continue}break o}}while(1){g=J[d+8>>2];b=J[g>>2]!=(d|0);d=g;if(b){continue}break}}d=g;if((g|0)!=(k|0)){continue}break a}break}g=Z()|0;_b(a);m=J[i+8>>2];}yd(m);da(g|0);B();}B();}yd(J[i+8>>2]);Ua=i+16|0;}function Hb(a,b,c,d,e,f,g,h,i){var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;j=Ua-112|0;Ua=j;k=i&2147483647;a:{b:{m=e&2147483647;l=2147418112;n=!(b|c);if(!(d|m?m-l>>>0<2147549184:n)){p=k-l|0;if(!h&(p|0)==-2147418112?f|g:(p|0)==-2147418112&(h|0)!=0|p>>>0>2147549184){break b}}if(!(!d&(m|0)==2147418112?n:m>>>0<2147418112)){h=d;i=e|32768;f=b;g=c;break a}if(!(!h&(k|0)==2147418112?!(f|g):k>>>0<2147418112)){i=i|32768;break a}if(!(b|d|(m^2147418112|c))){l=d;d=!(b^f|d^h|(c^g|e^i^-2147483648));h=d?0:l;i=d?2147450880:e;f=d?0:b;g=d?0:c;break a}l=f|h;if(!(l|(k^2147418112|g))){break a}if(!(b|d|(c|m))){if(g|k|l){break a}f=b&f;g=c&g;h=d&h;i=e&i;break a}if(f|h|(g|k)){break b}f=b;g=c;h=d;i=e;break a}l=(k|0)==(m|0);s=l&(d|0)==(h|0)?(c|0)==(g|0)&b>>>0<f>>>0|c>>>0<g>>>0:l&d>>>0<h>>>0|k>>>0>m>>>0;n=s;m=n?f:b;p=n?g:c;l=n?i:e;t=l;n=n?h:d;q=l&65535;d=s?d:h;e=s?e:i;r=e;l=e>>>16&32767;o=t>>>16&32767;if(!o){e=!(n|q);i=e;k=e?m:n;e=e<<6;i=S(i?p:q);e=e+((i|0)==32?S(k)+32|0:i)|0;Cb(j+96|0,m,p,n,q,e-15|0);n=J[j+104>>2];q=J[j+108>>2];p=J[j+100>>2];o=16-e|0;m=J[j+96>>2];}f=s?b:f;g=s?c:g;h=d;i=r&65535;if(!l){b=!(d|i);e=b;k=b?f:d;b=b<<6;e=S(e?g:i);b=b+((e|0)==32?S(k)+32|0:e)|0;Cb(j+80|0,f,g,d,i,b-15|0);l=16-b|0;h=J[j+88>>2];i=J[j+92>>2];g=J[j+84>>2];f=J[j+80>>2];}c=i<<3|h>>>29;b=h<<3|g>>>29;c=c|524288;e=q<<3|n>>>29;q=n<<3|p>>>29;h=e;i=r^t;k=g<<3|f>>>29;d=f<<3;c:{if((l|0)==(o|0)){break c}e=o-l|0;if(e>>>0>127){b=0;c=0;k=0;d=1;break c}Cb(j- -64|0,d,k,b,c,128-e|0);xc(j+48|0,d,k,b,c,e);b=J[j+56>>2];c=J[j+60>>2];k=J[j+52>>2];d=J[j+48>>2]|(J[j+64>>2]|J[j+72>>2]|(J[j+68>>2]|J[j+76>>2]))!=0;}n=d;l=k;r=h|524288;k=p<<3|m>>>29;m=m<<3;d:{if((i|0)<0){f=0;g=0;h=0;i=0;if(!(m^n|b^q|(k^l|c^r))){break a}d=m-n|0;e=k-((m>>>0<n>>>0)+l|0)|0;f=q-b|0;g=(k|0)==(l|0)&m>>>0<n>>>0|k>>>0<l>>>0;h=f-g|0;b=(r-((b>>>0>q>>>0)+c|0)|0)-(f>>>0<g>>>0)|0;i=b;if(b>>>0>524287){break d}c=!(b|h);g=c;i=g?d:h;c=g<<6;g=S(g?e:b);c=c+((g|0)==32?S(i)+32|0:g)|0;f=b;b=c-12|0;Cb(j+32|0,d,e,h,f,b);o=o-b|0;h=J[j+40>>2];i=J[j+44>>2];d=J[j+32>>2];e=J[j+36>>2];break d}k=k+l|0;d=m+n|0;e=d>>>0<m>>>0?k+1|0:k;f=(l|0)==(e|0)&d>>>0<n>>>0|e>>>0<l>>>0;k=c+r|0;b=b+q|0;k=b>>>0<q>>>0?k+1|0:k;h=b+f|0;i=h>>>0<b>>>0?k+1|0:k;if(!(i&1048576)){break d}d=n&1|((e&1)<<31|d>>>1);e=h<<31|e>>>1;o=o+1|0;h=(i&1)<<31|h>>>1;i=i>>>1|0;}c=0;b=t&-2147483648;p=b;if((o|0)>=32767){h=c;i=b|2147418112;f=0;g=0;break a}l=0;e:{if((o|0)>0){l=o;break e}Cb(j+16|0,d,e,h,i,o+127|0);xc(j,d,e,h,i,1-o|0);d=J[j>>2]|(J[j+16>>2]|J[j+24>>2]|(J[j+20>>2]|J[j+28>>2]))!=0;e=J[j+4>>2];h=J[j+8>>2];i=J[j+12>>2];}m=d&7;d=(e&7)<<29|d>>>3;f=(m>>>0>4)+d|0;b=h<<29|e>>>3;g=d>>>0>f>>>0?b+1|0:b;d=(b|0)==(g|0)&d>>>0>f>>>0|b>>>0>g>>>0;b=c|((i&7)<<29|h>>>3);h=d+b|0;i=p|(i>>>3&65535|l<<16);i=b>>>0>h>>>0?i+1|0:i;f:{if((m|0)==4){b=0;k=g+b|0;d=f;c=f&1;f=f+c|0;g=d>>>0>f>>>0?k+1|0:k;b=(b|0)==(g|0)&c>>>0>f>>>0|b>>>0>g>>>0;h=b+h|0;i=b>>>0>h>>>0?i+1|0:i;break f}if(!m){break a}}}J[a>>2]=f;J[a+4>>2]=g;J[a+8>>2]=h;J[a+12>>2]=i;Ua=j+112|0;}function rh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;g=Ua-16|0;Ua=g;a:{f=c-!b|0;if(!((!f&b-1>>>0>15|(f|0)!=0)&(b&c)!=-1)){d=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=d-29|0;c=(d>>>0<29?d:e)+1|0;if(c>>>0>(d>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){Ob(a,c+(c>>>1|0)|0);d=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=d-29|0;}c=d>>>0<29;H[(c?a+4|0:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))+(c?d:e)|0]=b+80;b=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;break a}if(!(b|c)){d=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=d-29|0;b=(d>>>0<29?d:e)+1|0;if(b>>>0>(d>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){Ob(a,b+(b>>>1|0)|0);d=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=d-29|0;}b=d>>>0<29;H[(b?a+4|0:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))+(b?d:e)|0]=0;b=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;break a}J[g+12>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;f=b;b=c>>31;f=f^b;h=f-b|0;b=(b^c)-((f>>>0<b>>>0)+b|0)|0;b:{c:{d:{while(1){j=b;k=h;e:{if(d>>>0<e>>>0){H[d|0]=h;f=d;break e}m=d-i|0;h=m+1|0;if((h|0)<0){J[5996]=0;ca(8);a=J[5996];J[5996]=0;if((a|0)==1){break d}break b}f=e-i|0;b=f<<1;n=f>>>0>=1073741823?2147483647:b>>>0>h>>>0?b:h;f:{if(!n){h=0;break f}J[5996]=0;h=$(3,n|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break d}}f=h+m|0;H[f|0]=k;if((d|0)==(i|0)){b=f;}else {o=(i^-1)+d|0;l=0;e=f;b=m&3;if(b){while(1){e=e-1|0;d=d-1|0;H[e|0]=K[d|0];l=l+1|0;if((b|0)!=(l|0)){continue}break}}if(o>>>0>=3){while(1){H[e-1|0]=K[d-1|0];H[e-2|0]=K[d-2|0];H[e-3|0]=K[d-3|0];e=e-4|0;d=d-4|0;H[e|0]=K[d|0];if((d|0)!=(i|0)){continue}break}}d=i;b=h;}i=b;e=h+n|0;if(!d){break e}$a(d);}b=j>>>8|0;h=(j&255)<<24|k>>>8;d=f+1|0;if(!j&k>>>0>=256|j){continue}break}J[g+8>>2]=d;J[g+4>>2]=i;J[g+12>>2]=e;g:{h:{i:{b=H[f|0];if((b|0)<0){h=c>>>24&128;if(d>>>0<e>>>0){H[f+1|0]=h;J[g+8>>2]=f+2;break g}k=d-i|0;f=k+1|0;if((f|0)<0){J[5996]=0;ca(8);a=J[5996];J[5996]=0;if((a|0)!=1){break b}break d}c=e-i|0;b=c<<1;c=c>>>0>=1073741823?2147483647:b>>>0>f>>>0?b:f;j:{if(!c){f=0;break j}J[5996]=0;f=$(3,c|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break d}}e=f+k|0;H[e|0]=h;j=c+f|0;h=e+1|0;if((d|0)==(i|0)){break i}c=(i^-1)+d|0;b=k&3;if(b){l=0;while(1){e=e-1|0;d=d-1|0;H[e|0]=K[d|0];l=l+1|0;if((b|0)!=(l|0)){continue}break}}if(c>>>0>=3){while(1){H[e-1|0]=K[d-1|0];H[e-2|0]=K[d-2|0];H[e-3|0]=K[d-3|0];e=e-4|0;d=d-4|0;H[e|0]=K[d|0];if((d|0)!=(i|0)){continue}break}}J[g+12>>2]=j;J[g+8>>2]=h;J[g+4>>2]=f;if(!i){break g}break h}if((c|0)>0|(c|0)>=0){break g}H[f|0]=b|128;break g}J[g+12>>2]=j;J[g+8>>2]=h;J[g+4>>2]=e;}$a(i);}J[5996]=0;_(19,a|0,g+4|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[g+4>>2];if(!b){break a}$a(b);break a}d=Z()|0;a=J[g+4>>2];if(!a){break c}$a(a);da(d|0);B();}d=Z()|0;if(!i){break c}$a(i);}da(d|0);B();}B();}Ua=g+16|0;return a|0}function se(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;k=K[b+8|0]|K[b+9|0]<<8|(K[b+10|0]<<16|K[b+11|0]<<24);f=-29;g=K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24);i=g>>>0<29;a:{g=i?g:g-29|0;if(g>>>0>=29){J[5996]=0;aa(124,a|0,g+(g>>>1|0)|0);f=J[5996];J[5996]=0;if((f|0)==1){break a}e=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);h=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);f=h-29|0;}j=a+4|0;l=h>>>0<29;e=l?j:e;eb(g+e|0,e,l?h:f);f=g+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=f;H[a+1|0]=f>>>8;H[a+2|0]=f>>>16;H[a+3|0]=f>>>24;b:{if(!g){break b}f=i?b+4|0:k;i=g&7;c:{if(!i){b=f;break c}h=0;b=f;while(1){H[e|0]=K[b|0];b=b+1|0;e=e+1|0;h=h+1|0;if((i|0)!=(h|0)){continue}break}}if(g>>>0<8){break b}f=f+g|0;while(1){H[e|0]=K[b|0];H[e+1|0]=K[b+1|0];H[e+2|0]=K[b+2|0];H[e+3|0]=K[b+3|0];H[e+4|0]=K[b+4|0];H[e+5|0]=K[b+5|0];H[e+6|0]=K[b+6|0];H[e+7|0]=K[b+7|0];e=e+8|0;b=b+8|0;if((f|0)!=(b|0)){continue}break}}k=K[c+8|0]|K[c+9|0]<<8|(K[c+10|0]<<16|K[c+11|0]<<24);e=K[c|0]|K[c+1|0]<<8|(K[c+2|0]<<16|K[c+3|0]<<24);h=e>>>0<29;b=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);f=b-29|0;g=h?e:e-29|0;i=b>>>0<29?b:f;e=g+i|0;if(e>>>0>(b>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){J[5996]=0;aa(124,a|0,e+(e>>>1|0)|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}b=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);f=b-29|0;}e=j;j=b>>>0<29;e=i+(j?e:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))|0;eb(g+e|0,e,(j?b:f)-i|0);b=g+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;d:{if(!g){break d}c=h?c+4|0:k;f=g&7;e:{if(!f){b=c;break e}h=0;b=c;while(1){H[e|0]=K[b|0];b=b+1|0;e=e+1|0;h=h+1|0;if((f|0)!=(h|0)){continue}break}}if(g>>>0<8){break d}c=c+g|0;while(1){H[e|0]=K[b|0];H[e+1|0]=K[b+1|0];H[e+2|0]=K[b+2|0];H[e+3|0]=K[b+3|0];H[e+4|0]=K[b+4|0];H[e+5|0]=K[b+5|0];H[e+6|0]=K[b+6|0];H[e+7|0]=K[b+7|0];e=e+8|0;b=b+8|0;if((c|0)!=(b|0)){continue}break}}b=J[d>>2];J[5996]=0;_(127,a|0,b|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}return}b=Z()|0;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0>=29){$a(K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24));H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;}da(b|0);B();}function Zn(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=+d;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;f=Ua+-64|0;Ua=f;J[f+40>>2]=0;J[f+32>>2]=0;J[f+36>>2]=0;k=J[c>>2];n=J[c+4>>2];a:{b:{if((k|0)==(n|0)){c=k;break b}c:{d:{while(1){e:{j=J[k>>2];g=J[f+36>>2];f:{if((g|0)!=J[f+40>>2]){J[g>>2]=J[j>>2];i=J[j+4>>2];J[g+4>>2]=i;if(i){J[i+4>>2]=J[i+4>>2]+1;}J[f+36>>2]=g+8;break f}g:{i=J[f+32>>2];h=g-i|0;o=h>>3;l=o+1|0;h:{if(l>>>0>=536870912){J[5996]=0;ca(59);a=J[5996];J[5996]=0;if((a|0)==1){break h}break d}m=h>>2;h=h>>>0>=2147483640?536870911:l>>>0<m>>>0?m:l;if(h>>>0<536870912){break g}J[5996]=0;ca(35);a=J[5996];J[5996]=0;if((a|0)!=1){break d}}g=Z()|0;break a}J[5996]=0;m=h<<3;l=$(3,m|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break e}h=l+(o<<3)|0;J[h>>2]=J[j>>2];j=J[j+4>>2];J[h+4>>2]=j;if(j){J[j+4>>2]=J[j+4>>2]+1;g=J[f+36>>2];}j=l+m|0;l=h+8|0;i:{if((g|0)==(i|0)){J[f+40>>2]=j;J[f+36>>2]=l;J[f+32>>2]=h;break i}while(1){h=h-8|0;g=g-8|0;J[h>>2]=J[g>>2];J[h+4>>2]=J[g+4>>2];J[g>>2]=0;J[g+4>>2]=0;if((g|0)!=(i|0)){continue}break}J[f+40>>2]=j;g=J[f+36>>2];J[f+36>>2]=l;i=J[f+32>>2];J[f+32>>2]=h;if((g|0)==(i|0)){break i}while(1){g=g-8|0;h=J[g+4>>2];j:{if(!h){break j}j=J[h+4>>2];J[h+4>>2]=j-1;if(j){break j}Xa[J[J[h>>2]+8>>2]](h);bb(h);}if((g|0)!=(i|0)){continue}break}}if(!i){break f}$a(i);}k=k+4|0;if((n|0)!=(k|0)){continue}break c}break}g=Z()|0;break a}B();}k=J[c+4>>2];c=J[c>>2];}J[5996]=0;va(63,f+16|0,b|0,c|0,k|0,+d);c=J[5996];J[5996]=0;k:{if((c|0)==1){break k}J[5996]=0;c=$(3,104)|0;k=J[5996];J[5996]=0;if((k|0)==1){break k}J[c>>2]=7e3;J[c+4>>2]=0;J[c+8>>2]=0;J[f+52>>2]=J[f+32>>2];k=J[f+40>>2];g=J[f+36>>2];J[f+40>>2]=0;J[f+56>>2]=g;J[f+60>>2]=k;J[f+32>>2]=0;J[f+36>>2]=0;e=J[e>>2];J[5996]=0;k=ia(64,c+12|0,b|0,f+52|0,e|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[f+52>>2];if(b){g=J[f+56>>2];if((b|0)!=(g|0)){while(1){g=g-8|0;e=J[g+4>>2];l:{if(!e){break l}i=J[e+4>>2];J[e+4>>2]=i-1;if(i){break l}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((b|0)!=(g|0)){continue}break}b=J[f+52>>2];}$a(b);}J[f+48>>2]=c;J[f+44>>2]=k;J[5996]=0;b=J[f+48>>2];J[f+8>>2]=J[f+44>>2];J[f+12>>2]=b;ea(61,a|0,f+16|0,f+8|0);a=J[5996];J[5996]=0;if((a|0)==1){break k}a=J[f+32>>2];if(a){g=J[f+36>>2];if((a|0)!=(g|0)){while(1){g=g-8|0;b=J[g+4>>2];m:{if(!b){break m}c=J[b+4>>2];J[b+4>>2]=c-1;if(c){break m}Xa[J[J[b>>2]+8>>2]](b);bb(b);}if((a|0)!=(g|0)){continue}break}a=J[f+32>>2];}$a(a);}Ua=f- -64|0;return}g=Z()|0;lb(f+52|0);$a(c);break a}g=Z()|0;}lb(f+32|0);da(g|0);B();}function $g(a,b,c,d){a=a|0;b=+b;c=+c;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;g=Ua-48|0;Ua=g;a:{b:{if(J[a>>2]==21){j=d+4|0;c:{d:{e:{f:{e=J[d+4>>2];if(!e){break f}f=j;while(1){g:{h:{i:{i=J[e+16>>2];if(i>>>0<a>>>0){break i}if(a>>>0<i>>>0){break h}k=O[e+24>>3];if(k<b){break i}if(b<k){break h}h=O[e+32>>3]<c;i=h?e+4|0:e;f=h?f:e;break g}i=e+4|0;break g}i=e;f=e;}e=J[i>>2];if(e){continue}break}if((f|0)==(j|0)){break f}e=J[f+16>>2];if(e>>>0>a>>>0){break f}j:{if(a>>>0>e>>>0){break j}k=O[f+24>>3];if(k>b){break f}if(b>k){break j}if(O[f+32>>3]>c){break f}}if(O[f+56>>3]!=b){break e}if(O[f- -64>>3]!=c){break d}l=f+40|0;break a}J[g+40>>2]=0;O[g+32>>3]=c;O[g+24>>3]=b;J[g+16>>2]=0;J[g+8>>2]=0;J[g+12>>2]=0;e=J[a+4>>2];if((e|0)==J[a+8>>2]){J[5996]=0;ga(44,4277,1900,673,1984);a=J[5996];J[5996]=0;if((a|0)!=1){break c}break b}e=J[e>>2];J[5996]=0;ea(45,e|0,g+8|0,d|0);e=J[5996];J[5996]=0;if((e|0)==1){break b}k:{l:{e=j;i=J[e>>2];m:{if(!i){break m}while(1){n:{o:{e=i;f=J[e+16>>2];p:{if(f>>>0>a>>>0){break p}if(a>>>0>f>>>0){break n}k=O[e+24>>3];if(k>b){break p}if(b>k){break n}k=O[e+32>>3];if(!(k>c)){break o}}j=e;i=J[e>>2];if(i){continue}break m}if(!(c>k)){break l}}i=J[e+4>>2];if(i){continue}break}j=e+4|0;}J[5996]=0;h=$(3,80)|0;f=J[5996];J[5996]=0;if((f|0)==1){break b}J[h+16>>2]=a;O[h+32>>3]=c;O[h+24>>3]=b;l=h+40|0;J[l>>2]=J[g+8>>2];J[h+44>>2]=J[g+12>>2];J[h+48>>2]=J[g+16>>2];J[g+16>>2]=0;J[g+8>>2]=0;J[g+12>>2]=0;J[h+72>>2]=J[g+40>>2];i=J[g+36>>2];f=h- -64|0;J[f>>2]=J[g+32>>2];J[f+4>>2]=i;f=J[g+28>>2];J[h+56>>2]=J[g+24>>2];J[h+60>>2]=f;J[h+8>>2]=e;J[h>>2]=0;J[h+4>>2]=0;J[j>>2]=h;e=h;f=J[J[d>>2]>>2];if(f){J[d>>2]=f;e=J[j>>2];}zd(J[d+4>>2],e);J[d+8>>2]=J[d+8>>2]+1;j=J[a+4>>2];if(J[a+8>>2]-j>>>0>=5){f=J[h+72>>2];i=1;e=1;while(1){j=J[(e<<2)+j>>2];J[5996]=0;ea(45,j|0,l|0,d|0);j=J[5996];J[5996]=0;if((j|0)==1){break k}j=f;f=J[h+72>>2];i=(j|0)==(f|0)?i:e;e=e+1|0;j=J[a+4>>2];e=(e|0)==J[a+8>>2]-j>>2?1:e;if((i|0)!=(e|0)){continue}break}}d=J[g+8>>2];if(!d){break a}a=J[g+12>>2];if((d|0)!=(a|0)){while(1){a=a-32|0;e=J[a+4>>2];q:{if(!e){break q}f=J[e+4>>2];J[e+4>>2]=f-1;if(f){break q}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((a|0)!=(d|0)){continue}break}d=J[g+8>>2];}$a(d);break a}J[5996]=0;ga(44,2453,1900,676,1984);a=J[5996];J[5996]=0;if((a|0)!=1){break c}break b}break b}la(1940,1900,668,1984);B();}la(1841,1900,669,1984);}B();}la(3430,1900,664,1984);B();}a=Z()|0;_b(g+8|0);da(a|0);B();}Ua=g+48|0;return l|0}function hk(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;j=Ua-1056|0;Ua=j;J[j+16>>2]=f;J[j+20>>2]=g;J[j+24>>2]=h;J[j+28>>2]=i;a=j+944|0;J[j+940>>2]=a;l=od(a,100,2304,j+16|0);J[j+48>>2]=184;n=j+520|0;J[n>>2]=0;J[n+4>>2]=J[j+48>>2];J[j+48>>2]=184;m=j+512|0;J[m>>2]=0;J[m+4>>2]=J[j+48>>2];a:{b:{c:{d:{if(l>>>0<100){h=j+528|0;break d}a=jb();J[j>>2]=f;J[j+4>>2]=g;J[j+8>>2]=h;J[j+12>>2]=i;l=dc(j+940|0,a,2304,j);if((l|0)!=-1){a=J[j+940>>2];tb(n,a);tb(m,sb(l<<2));h=J[m>>2];if(h){break d}}J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)!=1){break a}l=Z()|0;break c}f=J[d+28>>2];J[j+508>>2]=f;J[f+4>>2]=J[f+4>>2]+1;J[5996]=0;r=$(197,J[j+508>>2])|0;f=J[5996];J[5996]=0;e:{f:{g:{h:{i:{j:{if((f|0)==1){break j}J[5996]=0;ga(208,r|0,a|0,a+l|0,h|0);f=J[5996];J[5996]=0;if((f|0)==1){break j}p=(l|0)>0?K[a|0]==45:p;g=j+484|0;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;a=j+472|0;J[a>>2]=0;J[a+4>>2]=0;J[a+8>>2]=0;f=j+460|0;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;J[5996]=0;sa(238,c|0,p|0,J[j+508>>2],j+504|0,j+500|0,j+496|0,g|0,a|0,f|0,j+456|0);c=J[5996];J[5996]=0;if((c|0)==1){break i}J[j+36>>2]=184;c=j+40|0;J[c>>2]=0;J[c+4>>2]=J[j+36>>2];i=j+48|0;o=J[j+456>>2];k:{if((o|0)<(l|0)){k=K[f+11|0];q=(l-o<<1)+((k&128)>>>7|0?J[f+4>>2]:k&127)|0;k=K[a+11|0];k=(q+((k&128)>>>7|0?J[a+4>>2]:k&127)|0)+1|0;break k}k=K[f+11|0];q=(k&128)>>>7|0?J[f+4>>2]:k&127;k=K[a+11|0];k=(q+((k&128)>>>7|0?J[a+4>>2]:k&127)|0)+2|0;}k=k+o|0;if(k>>>0<101){break h}tb(c,sb(k<<2));i=J[c>>2];if(i){break h}J[5996]=0;ca(185);b=J[5996];J[5996]=0;if((b|0)!=1){break a}break g}l=Z()|0;break e}l=Z()|0;break f}k=J[d+4>>2];J[5996]=0;ta(239,i|0,j+36|0,j+32|0,k|0,h|0,(l<<2)+h|0,r|0,p|0,j+504|0,J[j+500>>2],J[j+496>>2],g|0,a|0,f|0,o|0);h=J[5996];J[5996]=0;if((h|0)!=1){J[5996]=0;d=ka(219,b|0,i|0,J[j+36>>2],J[j+32>>2],d|0,e|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break b}}}l=Z()|0;db(c);}ab(f);ab(a);ab(g);}a=J[j+508>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}}db(m);db(n);da(l|0);B();}db(c);ab(f);ab(a);ab(g);a=J[j+508>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}db(m);db(n);Ua=j+1056|0;return d|0}B();}function ih(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=J[a+4>>2];d=J[a+8>>2];if(c>>>0<d>>>0){d=J[b>>2];J[c+12>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;J[c>>2]=d;J[c+4>>2]=J[b+4>>2];J[c+8>>2]=J[b+8>>2];J[c+12>>2]=J[b+12>>2];J[b+12>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[c+24>>2]=0;J[c+16>>2]=0;J[c+20>>2]=0;J[c+16>>2]=J[b+16>>2];J[c+20>>2]=J[b+20>>2];J[c+24>>2]=J[b+24>>2];J[b+24>>2]=0;J[b+16>>2]=0;J[b+20>>2]=0;J[c+36>>2]=0;J[c+28>>2]=0;J[c+32>>2]=0;J[c+28>>2]=J[b+28>>2];J[c+32>>2]=J[b+32>>2];J[c+36>>2]=J[b+36>>2];J[b+36>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[c+48>>2]=0;J[c+40>>2]=0;J[c+44>>2]=0;J[c+40>>2]=J[b+40>>2];J[c+44>>2]=J[b+44>>2];J[c+48>>2]=J[b+48>>2];J[b+48>>2]=0;J[b+40>>2]=0;J[b+44>>2]=0;J[c+52>>2]=J[b+52>>2];J[a+4>>2]=c+56;return}a:{b:{c:{e=J[a>>2];f=(c-e|0)/56|0;c=f+1|0;if(c>>>0<76695845){d=(d-e|0)/56|0;e=d<<1;c=d>>>0>=38347922?76695844:c>>>0<e>>>0?e:c;if(c>>>0>=76695845){break c}d=P(c,56);e=cb(d);c=e+P(f,56)|0;J[c>>2]=J[b>>2];J[c+4>>2]=J[b+4>>2];J[c+8>>2]=J[b+8>>2];J[c+12>>2]=J[b+12>>2];J[b+12>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[c+16>>2]=J[b+16>>2];J[c+20>>2]=J[b+20>>2];J[c+24>>2]=J[b+24>>2];J[b+24>>2]=0;J[b+16>>2]=0;J[b+20>>2]=0;J[c+28>>2]=J[b+28>>2];J[c+32>>2]=J[b+32>>2];J[c+36>>2]=J[b+36>>2];J[b+36>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[c+40>>2]=J[b+40>>2];J[c+44>>2]=J[b+44>>2];J[c+48>>2]=J[b+48>>2];J[b+48>>2]=0;J[b+40>>2]=0;J[b+44>>2]=0;J[c+52>>2]=J[b+52>>2];d=d+e|0;e=c+56|0;b=J[a+4>>2];f=J[a>>2];if((b|0)==(f|0)){break b}while(1){c=c-56|0;b=b-56|0;J[c>>2]=J[b>>2];J[c+4>>2]=J[b+4>>2];J[c+8>>2]=J[b+8>>2];J[c+12>>2]=J[b+12>>2];J[b+12>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[c+16>>2]=J[b+16>>2];J[c+20>>2]=J[b+20>>2];J[c+24>>2]=J[b+24>>2];J[b+24>>2]=0;J[b+16>>2]=0;J[b+20>>2]=0;J[c+28>>2]=J[b+28>>2];J[c+32>>2]=J[b+32>>2];J[c+36>>2]=J[b+36>>2];J[b+36>>2]=0;J[b+28>>2]=0;J[b+32>>2]=0;J[c+40>>2]=J[b+40>>2];J[c+44>>2]=J[b+44>>2];J[c+48>>2]=J[b+48>>2];J[b+48>>2]=0;J[b+40>>2]=0;J[b+44>>2]=0;J[c+52>>2]=J[b+52>>2];if((b|0)!=(f|0)){continue}break}J[a+8>>2]=d;d=J[a+4>>2];J[a+4>>2]=e;b=J[a>>2];J[a>>2]=c;if((b|0)==(d|0)){break a}while(1){d=Fb(d-56|0);if((d|0)!=(b|0)){continue}break}break a}nb();B();}Pb();B();}J[a+8>>2]=d;J[a+4>>2]=e;J[a>>2]=c;}if(b){$a(b);}}function lk(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;j=Ua-448|0;Ua=j;J[j+16>>2]=f;J[j+20>>2]=g;J[j+24>>2]=h;J[j+28>>2]=i;a=j+336|0;J[j+332>>2]=a;l=od(a,100,2304,j+16|0);J[j+48>>2]=184;n=j+216|0;J[n>>2]=0;J[n+4>>2]=J[j+48>>2];J[j+48>>2]=184;m=j+208|0;J[m>>2]=0;J[m+4>>2]=J[j+48>>2];a:{b:{c:{d:{if(l>>>0<100){h=j+224|0;break d}a=jb();J[j>>2]=f;J[j+4>>2]=g;J[j+8>>2]=h;J[j+12>>2]=i;l=dc(j+332|0,a,2304,j);if((l|0)!=-1){a=J[j+332>>2];tb(n,a);tb(m,sb(l));h=J[m>>2];if(h){break d}}J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)!=1){break a}l=Z()|0;break c}f=J[d+28>>2];J[j+204>>2]=f;J[f+4>>2]=J[f+4>>2]+1;J[5996]=0;r=$(170,J[j+204>>2])|0;f=J[5996];J[5996]=0;e:{f:{g:{h:{i:{j:{if((f|0)==1){break j}J[5996]=0;ga(195,r|0,a|0,a+l|0,h|0);f=J[5996];J[5996]=0;if((f|0)==1){break j}p=(l|0)>0?K[a|0]==45:p;g=j+184|0;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;a=j+172|0;J[a>>2]=0;J[a+4>>2]=0;J[a+8>>2]=0;f=j+160|0;J[f>>2]=0;J[f+4>>2]=0;J[f+8>>2]=0;J[5996]=0;sa(236,c|0,p|0,J[j+204>>2],j+200|0,j+199|0,j+198|0,g|0,a|0,f|0,j+156|0);c=J[5996];J[5996]=0;if((c|0)==1){break i}J[j+36>>2]=184;c=j+40|0;J[c>>2]=0;J[c+4>>2]=J[j+36>>2];i=j+48|0;o=J[j+156>>2];k:{if((o|0)<(l|0)){k=K[f+11|0];q=(l-o<<1)+((k&128)>>>7|0?J[f+4>>2]:k&127)|0;k=K[a+11|0];k=(q+((k&128)>>>7|0?J[a+4>>2]:k&127)|0)+1|0;break k}k=K[f+11|0];q=(k&128)>>>7|0?J[f+4>>2]:k&127;k=K[a+11|0];k=(q+((k&128)>>>7|0?J[a+4>>2]:k&127)|0)+2|0;}k=k+o|0;if(k>>>0<101){break h}tb(c,sb(k));i=J[c>>2];if(i){break h}J[5996]=0;ca(185);b=J[5996];J[5996]=0;if((b|0)!=1){break a}break g}l=Z()|0;break e}l=Z()|0;break f}k=J[d+4>>2];J[5996]=0;ta(237,i|0,j+36|0,j+32|0,k|0,h|0,h+l|0,r|0,p|0,j+200|0,H[j+199|0],H[j+198|0],g|0,a|0,f|0,o|0);h=J[5996];J[5996]=0;if((h|0)!=1){J[5996]=0;d=ka(213,b|0,i|0,J[j+36>>2],J[j+32>>2],d|0,e|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break b}}}l=Z()|0;db(c);}ab(f);ab(a);ab(g);}a=J[j+204>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}}db(m);db(n);da(l|0);B();}db(c);ab(f);ab(a);ab(g);a=J[j+204>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}db(m);db(n);Ua=j+448|0;return d|0}B();}function Vn(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;var f=0,g=0,h=0,i=0,j=0;a:{b:{if(!(b-19>>>0>=7&e!=0)){f=1-e;c:{switch(b|0){case 24:if((c|0)!=(d|0)){while(1){b=J[c>>2];h=h+O[b+8>>3];g=g+O[b+16>>3];c=c+4|0;if((d|0)!=(c|0)){continue}break}}O[a+8>>3]=g;O[a>>3]=(f==0?0:f*g)+(e==0?0:h*e);return;case 3:J[a+8>>2]=0;J[a+12>>2]=1078034432;J[a>>2]=0;J[a+4>>2]=1079689216;return;case 6:case 7:case 8:case 9:J[a+8>>2]=0;J[a+12>>2]=1077968896;J[a>>2]=0;J[a+4>>2]=1077968896;return;case 10:case 11:case 12:case 16:b=J[c>>2];c=J[b+12>>2];J[a>>2]=J[b+8>>2];J[a+4>>2]=c;c=J[b+20>>2];J[a+8>>2]=J[b+16>>2];J[a+12>>2]=c;return;case 13:e=O[J[c>>2]+8>>3];J[a+8>>2]=0;J[a+12>>2]=1072693248;O[a>>3]=e+2;return;case 14:e=O[J[c>>2]+8>>3];J[a+8>>2]=0;J[a+12>>2]=2146435072;O[a>>3]=e;return;case 15:e=O[J[c>>2]+8>>3];J[a+8>>2]=0;J[a+12>>2]=1072693248;O[a>>3]=e;return;case 0:J[a+8>>2]=0;J[a+12>>2]=0;J[a>>2]=0;J[a+4>>2]=2146435072;return;case 17:e=O[J[c+4>>2]+8>>3];f=O[J[c>>2]+8>>3];J[a+8>>2]=0;J[a+12>>2]=2146435072;O[a>>3]=f+e;return;case 18:b=J[c+4>>2];e=O[b+16>>3];c=J[c>>2];f=O[c+16>>3];O[a>>3]=O[c+8>>3]+O[b+8>>3];O[a+8>>3]=f+e;return;case 19:b=J[c>>2];g=O[b+8>>3];c=J[c+4>>2];h=O[c+8>>3];i=O[c+16>>3];j=O[b+16>>3];O[a+8>>3]=i+j;O[a>>3]=(e==0?0:(g+i)*e)+(f==0?0:f*(j+h));return;case 20:case 21:b=J[c+4>>2];g=O[b+8>>3];c=J[c>>2];h=O[c+8>>3];i=O[c+16>>3];O[a+8>>3]=i+O[b+16>>3];O[a>>3]=(e==0?0:h*e)+(f==0?0:f*(i+g));return;case 22:b=J[c>>2];g=O[b+8>>3];c=J[c+4>>2];h=O[c+8>>3];i=O[c+16>>3]+1;j=O[b+16>>3]+2;O[a+8>>3]=i<j?i:j;O[a>>3]=(e==0?0:(g+2)*e)+(f==0?0:f*(h+1));return;case 23:b=J[c+8>>2];g=O[b+8>>3];h=O[J[c+4>>2]+8>>3];c=J[c>>2];i=O[c+8>>3];j=O[c+16>>3];O[a+8>>3]=j+O[b+16>>3];O[a>>3]=(e==0?0:(i+h)*e)+(f==0?0:f*(j+g));return;default:a=Rb(8);J[5996]=0;b=_(91,a|0,1318)|0;c=J[5996];J[5996]=0;if((c|0)!=1){break b}b=Z()|0;ic(a);da(b|0);B();case 1:case 4:case 5:break a;case 2:break c}}J[a+8>>2]=0;J[a+12>>2]=1072693248;J[a>>2]=0;J[a+4>>2]=1079132160;return}la(4323,1900,476,1746);B();}na(b|0,22664,92);B();}J[a+8>>2]=0;J[a+12>>2]=2146435072;J[a>>2]=0;J[a+4>>2]=0;}function Hg(a,b,c,d,e,f,g,h,i){var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;j=Ua-128|0;Ua=j;a:{b:{c:{if(!yc(f,g,h,i,0,0,0,0)){break c}k=i&65535;n=i>>>16&32767;d:{e:{if((n|0)!=32767){l=4;if(n){break e}l=f|h|(g|k)?3:2;break d}l=!(f|h|(g|k));}}s=e>>>16|0;o=s&32767;if((o|0)==32767){break c}if(l){break b}}ob(j+16|0,b,c,d,e,f,g,h,i);b=J[j+16>>2];d=J[j+20>>2];e=J[j+24>>2];c=J[j+28>>2];Ng(j,b,d,e,c,b,d,e,c);d=J[j+8>>2];e=J[j+12>>2];h=J[j>>2];i=J[j+4>>2];break a}l=d;p=e&2147483647;k=p;n=h;m=i&2147483647;if((yc(b,c,l,k,f,g,h,m)|0)<=0){if(yc(b,c,l,k,f,g,h,m)){h=b;i=c;break a}ob(j+112|0,b,c,d,e,0,0,0,0);d=J[j+120>>2];e=J[j+124>>2];h=J[j+112>>2];i=J[j+116>>2];break a}q=i>>>16&32767;if(o){i=c;h=b;}else {ob(j+96|0,b,c,l,p,0,0,0,1081540608);l=J[j+104>>2];h=J[j+108>>2];p=h;o=(h>>>16|0)-120|0;i=J[j+100>>2];h=J[j+96>>2];}if(!q){ob(j+80|0,f,g,n,m,0,0,0,1081540608);n=J[j+88>>2];f=J[j+92>>2];m=f;q=(f>>>16|0)-120|0;g=J[j+84>>2];f=J[j+80>>2];}r=n;t=m&65535|65536;p=p&65535|65536;if((o|0)>(q|0)){while(1){m=l-r|0;k=(g|0)==(i|0)&f>>>0>h>>>0|g>>>0>i>>>0;n=m-k|0;k=(p-((l>>>0<r>>>0)+t|0)|0)-(k>>>0>m>>>0)|0;f:{if((k|0)>0|(k|0)>=0){l=h;h=h-f|0;i=i-((f>>>0>l>>>0)+g|0)|0;if(!(h|n|(i|k))){ob(j+32|0,b,c,d,e,0,0,0,0);d=J[j+40>>2];e=J[j+44>>2];h=J[j+32>>2];i=J[j+36>>2];break a}k=k<<1|n>>>31;l=n<<1|i>>>31;break f}k=p<<1|l>>>31;l=l<<1|i>>>31;}p=k;k=i<<1|h>>>31;h=h<<1;i=k;o=o-1|0;if((o|0)>(q|0)){continue}break}o=q;}m=l-r|0;k=(g|0)==(i|0)&f>>>0>h>>>0|g>>>0>i>>>0;n=m-k|0;k=(p-((l>>>0<r>>>0)+t|0)|0)-(k>>>0>m>>>0)|0;m=k;g:{if((k|0)<0){n=l;m=p;break g}l=h;h=h-f|0;i=i-((f>>>0>l>>>0)+g|0)|0;if(h|n|(i|m)){break g}ob(j+48|0,b,c,d,e,0,0,0,0);d=J[j+56>>2];e=J[j+60>>2];h=J[j+48>>2];i=J[j+52>>2];break a}if((m|0)==65535|m>>>0<65535){while(1){b=i>>>31|0;o=o-1|0;p=i<<1|h>>>31;h=h<<1;i=p;c=b;b=m<<1|n>>>31;n=c|n<<1;m=b;if(b>>>0<65536){continue}break}}b=s&32768;if((o|0)<=0){ob(j- -64|0,h,i,n,m&65535|(b|o+120)<<16,0,0,0,1065811968);d=J[j+72>>2];e=J[j+76>>2];h=J[j+64>>2];i=J[j+68>>2];break a}d=n;e=m&65535|(b|o)<<16;}J[a>>2]=h;J[a+4>>2]=i;J[a+8>>2]=d;J[a+12>>2]=e;Ua=j+128|0;}function tn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0;h=J[b>>2];f=K[b+11|0];g=f<<24>>24;c=(g|0)<0;i=J[b+4>>2];d=c?i:f;a:{if((d|0)<9){break a}f=c?h:b;e=f+d|0;while(1){c=f;while(1){c=Zb(c,115,d-8|0);if(!c){break a}if(Eb(c,4824,9)){c=c+1|0;d=e-c|0;if((d|0)>=9){continue}break a}break}if((c|0)==(e|0)){break a}c=c-f|0;if((c|0)==-1){break a}Lc(b,c,9,5034);h=J[b>>2];c=K[b+11|0];g=c<<24>>24;e=(g|0)<0;f=e?h:b;i=J[b+4>>2];d=e?i:c;e=f+d|0;if((d|0)>8){continue}break}}c=g<<24>>24;d=(c|0)<0?i:g&255;b:{if((d|0)<10){break b}f=(c|0)<0?h:b;e=f+d|0;while(1){c=f;while(1){c=Zb(c,104,d-9|0);if(!c){break b}if(Eb(c,4813,10)){c=c+1|0;d=e-c|0;if((d|0)>=10){continue}break b}break}if((c|0)==(e|0)){break b}c=c-f|0;if((c|0)==-1){break b}Lc(b,c,10,4960);h=J[b>>2];c=K[b+11|0];g=c<<24>>24;e=(g|0)<0;f=e?h:b;i=J[b+4>>2];d=e?i:c;e=f+d|0;if((d|0)>9){continue}break}}c=g<<24>>24<0;d=c?i:g&255;c:{if((d|0)<12){break c}f=c?h:b;e=f+d|0;while(1){c=f;while(1){c=Zb(c,114,d-11|0);if(!c){break c}if(Eb(c,4845,12)){c=c+1|0;d=e-c|0;if((d|0)>=12){continue}break c}break}if((c|0)==(e|0)){break c}c=c-f|0;if((c|0)==-1){break c}Lc(b,c,12,4908);h=J[b>>2];c=K[b+11|0];g=c<<24>>24;e=(g|0)<0;f=e?h:b;i=J[b+4>>2];d=e?i:c;e=f+d|0;if((d|0)>11){continue}break}}c=g<<24>>24;d=(c|0)<0?i:g&255;d:{if((d|0)<10){break d}f=(c|0)<0?h:b;e=f+d|0;while(1){c=f;while(1){c=Zb(c,104,d-9|0);if(!c){break d}if(Eb(c,4834,10)){c=c+1|0;d=e-c|0;if((d|0)>=10){continue}break d}break}if((c|0)==(e|0)){break d}c=c-f|0;if((c|0)==-1){break d}Lc(b,c,10,4858);h=J[b>>2];c=K[b+11|0];g=c<<24>>24;e=(g|0)<0;f=e?h:b;i=J[b+4>>2];d=e?i:c;e=f+d|0;if((d|0)>9){continue}break}}c=g<<24>>24<0;d=c?i:g&255;e:{if((d|0)<=0){break e}e=c?h:b;g=e+d|0;while(1){c=e;while(1){c=Zb(c,32,d);if(!c){break e}if(K[c|0]!=32){c=c+1|0;d=g-c|0;if((d|0)>0){continue}break e}break}if((c|0)==(g|0)){break e}c=c-e|0;if((c|0)==-1){break e}Lc(b,c,1,5575);c=K[b+11|0];f=c<<24>>24<0;e=f?J[b>>2]:b;d=f?J[b+4>>2]:c;g=e+d|0;if((d|0)>0){continue}break}}c=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=c;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;}
function Sk(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;k=Ua-16|0;Ua=k;l=je(J[g>>2]);o=Zd(J[g>>2]);g=o;Xa[J[J[g>>2]+20>>2]](k+4|0,g);J[f>>2]=d;a:{b:{c:{i=a;g=K[i|0];switch(g-43|0){case 0:case 2:break c;default:break b}}J[5996]=0;g=_(216,l|0,g<<24>>24)|0;i=J[5996];J[5996]=0;if((i|0)==1){break a}i=J[f>>2];J[f>>2]=i+4;J[i>>2]=g;i=a+1|0;}d:{g=i;if(!((c-g|0)<=1|K[g|0]!=48|(K[g+1|0]|32)!=120)){J[5996]=0;i=_(216,l|0,48)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}h=J[f>>2];J[f>>2]=h+4;J[h>>2]=i;i=H[g+1|0];J[5996]=0;i=_(216,l|0,i|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}h=J[f>>2];J[f>>2]=h+4;J[h>>2]=i;i=g+2|0;g=i;while(1){if(c>>>0<=g>>>0){break d}h=H[g|0];jb();if(!(h-48>>>0<10|(h|32)-97>>>0<6)){break d}g=g+1|0;continue}}while(1){if(c>>>0<=g>>>0){break d}h=H[g|0];jb();if(h-48>>>0>=10){break d}g=g+1|0;continue}}e:{h=K[k+15|0];if(!((h&128)>>>7|0?J[k+8>>2]:h&127)){h=J[f>>2];J[5996]=0;ga(208,l|0,i|0,g|0,h|0);h=J[5996];J[5996]=0;if((h|0)==1){break a}J[f>>2]=J[f>>2]+(g-i<<2);break e}vc(i,g);J[5996]=0;q=$(206,o|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}h=i;while(1){if(g>>>0<=h>>>0){md((i-a<<2)+d|0,J[f>>2]);break e}j=k+4|0;m=(K[j+11|0]&128)>>>7|0;if(!(H[(m?J[j>>2]:j)+n|0]<=0|H[(m?J[j>>2]:j)+n|0]!=(p|0))){j=J[f>>2];J[f>>2]=j+4;J[j>>2]=q;p=0;j=K[k+15|0];n=(((j&128)>>>7|0?J[k+8>>2]:j&127)-1>>>0>n>>>0)+n|0;}j=H[h|0];J[5996]=0;j=_(216,l|0,j|0)|0;m=J[5996];J[5996]=0;if((m|0)!=1){m=J[f>>2];J[f>>2]=m+4;J[m>>2]=j;h=h+1|0;p=p+1|0;continue}break}break a}f:{while(1){if(c>>>0>g>>>0){i=K[g|0];if((i|0)==46){J[5996]=0;i=$(209,o|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}j=J[f>>2];h=j+4|0;J[f>>2]=h;J[j>>2]=i;g=g+1|0;break f}J[5996]=0;i=_(216,l|0,i<<24>>24)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}h=J[f>>2];J[f>>2]=h+4;J[h>>2]=i;g=g+1|0;continue}break}h=J[f>>2];}J[5996]=0;ga(208,l|0,g|0,c|0,h|0);i=J[5996];J[5996]=0;if((i|0)==1){break a}i=f;f=J[f>>2]+(c-g<<2)|0;J[i>>2]=f;J[e>>2]=(b|0)==(c|0)?f:(b-a<<2)+d|0;ab(k+4|0);Ua=k+16|0;return}a=Z()|0;ab(k+4|0);da(a|0);B();}function bl(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;k=Ua-16|0;Ua=k;l=le(J[g>>2]);o=de(J[g>>2]);g=o;Xa[J[J[g>>2]+20>>2]](k+4|0,g);J[f>>2]=d;a:{b:{c:{i=a;g=K[i|0];switch(g-43|0){case 0:case 2:break c;default:break b}}J[5996]=0;g=_(171,l|0,g<<24>>24)|0;i=J[5996];J[5996]=0;if((i|0)==1){break a}i=J[f>>2];J[f>>2]=i+1;H[i|0]=g;i=a+1|0;}d:{g=i;if(!((c-g|0)<=1|K[g|0]!=48|(K[g+1|0]|32)!=120)){J[5996]=0;i=_(171,l|0,48)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}h=J[f>>2];J[f>>2]=h+1;H[h|0]=i;i=H[g+1|0];J[5996]=0;i=_(171,l|0,i|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}h=J[f>>2];J[f>>2]=h+1;H[h|0]=i;i=g+2|0;g=i;while(1){if(c>>>0<=g>>>0){break d}h=H[g|0];jb();if(!(h-48>>>0<10|(h|32)-97>>>0<6)){break d}g=g+1|0;continue}}while(1){if(c>>>0<=g>>>0){break d}h=H[g|0];jb();if(h-48>>>0>=10){break d}g=g+1|0;continue}}e:{h=K[k+15|0];if(!((h&128)>>>7|0?J[k+8>>2]:h&127)){h=J[f>>2];J[5996]=0;ga(195,l|0,i|0,g|0,h|0);h=J[5996];J[5996]=0;if((h|0)==1){break a}J[f>>2]=J[f>>2]+(g-i|0);break e}vc(i,g);J[5996]=0;q=$(193,o|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}h=i;while(1){if(g>>>0<=h>>>0){vc((i-a|0)+d|0,J[f>>2]);break e}j=k+4|0;m=(K[j+11|0]&128)>>>7|0;if(!(H[(m?J[j>>2]:j)+n|0]<=0|H[(m?J[j>>2]:j)+n|0]!=(p|0))){j=J[f>>2];J[f>>2]=j+1;H[j|0]=q;p=0;j=K[k+15|0];n=(((j&128)>>>7|0?J[k+8>>2]:j&127)-1>>>0>n>>>0)+n|0;}j=H[h|0];J[5996]=0;j=_(171,l|0,j|0)|0;m=J[5996];J[5996]=0;if((m|0)!=1){m=J[f>>2];J[f>>2]=m+1;H[m|0]=j;h=h+1|0;p=p+1|0;continue}break}break a}while(1){f:{if(c>>>0>g>>>0){i=K[g|0];if((i|0)!=46){break f}J[5996]=0;i=$(196,o|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}h=J[f>>2];J[f>>2]=h+1;H[h|0]=i;g=g+1|0;}i=J[f>>2];J[5996]=0;ga(195,l|0,g|0,c|0,i|0);i=J[5996];J[5996]=0;if((i|0)==1){break a}i=f;f=J[f>>2]+(c-g|0)|0;J[i>>2]=f;J[e>>2]=(b|0)==(c|0)?f:(b-a|0)+d|0;ab(k+4|0);Ua=k+16|0;return}J[5996]=0;i=_(171,l|0,i<<24>>24)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}h=J[f>>2];J[f>>2]=h+1;H[h|0]=i;g=g+1|0;continue}}a=Z()|0;ab(k+4|0);da(a|0);B();}function bg(a,b,c,d){var e=0,f=0,g=0,h=0,i=0;e=J[b>>2];a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{if(!d){break l}g=J[d>>2];if(!g){break l}if(!a){d=c;break j}J[d>>2]=0;d=c;break k}m:{if(!J[J[6178]>>2]){if(!a){break m}if(!c){break a}g=c;while(1){d=H[e|0];if(d){J[a>>2]=d&57343;a=a+4|0;e=e+1|0;g=g-1|0;if(g){continue}break a}break}J[a>>2]=0;J[b>>2]=0;return c-g|0}d=c;if(!a){break i}break g}return Gb(e)}f=1;break g}f=0;break h}f=1;}while(1){if(!f){f=K[e|0]>>>3|0;if((f-16|f+(g>>26))>>>0>7){break f}f=e+1|0;n:{if(!(g&33554432)){break n}if((K[f|0]&192)!=128){e=e-1|0;break d}f=e+2|0;if(!(g&524288)){break n}if((K[f|0]&192)!=128){e=e-1|0;break d}f=e+3|0;}e=f;d=d-1|0;f=1;continue}while(1){g=K[e|0];o:{if(e&3|g-1>>>0>126){break o}g=J[e>>2];if((g|g-16843009)&-2139062144){break o}while(1){d=d-4|0;g=J[e+4>>2];e=e+4|0;if(!((g-16843009|g)&-2139062144)){continue}break}}f=g&255;if(f-1>>>0<=126){d=d-1|0;e=e+1|0;continue}break}f=f-194|0;if(f>>>0>50){break e}e=e+1|0;g=J[(f<<2)+12208>>2];f=0;continue}}while(1){if(!f){if(!d){break a}while(1){p:{f=K[e|0];h=f-1|0;q:{r:{if(h>>>0>126){g=f;break r}if(e&3|d>>>0<5){break q}s:{while(1){g=J[e>>2];if((g|g-16843009)&-2139062144){break s}J[a>>2]=g&255;J[a+4>>2]=K[e+1|0];J[a+8>>2]=K[e+2|0];J[a+12>>2]=K[e+3|0];a=a+16|0;e=e+4|0;d=d-4|0;if(d>>>0>4){continue}break}g=K[e|0];}f=g&255;h=f-1|0;}if(h>>>0>126){break p}}J[a>>2]=f;a=a+4|0;e=e+1|0;d=d-1|0;if(d){continue}break a}break}f=f-194|0;if(f>>>0>50){break e}e=e+1|0;g=J[(f<<2)+12208>>2];f=1;continue}i=K[e|0];f=i>>>3|0;if((f-16|f+(g>>26))>>>0>7){break f}t:{u:{h=e+1|0;f=i-128|g<<6;v:{if((f|0)>=0){break v}i=K[h|0]-128|0;if(i>>>0>63){break u}h=e+2|0;f=i|f<<6;if((f|0)>=0){break v}h=K[h|0]-128|0;if(h>>>0>63){break u}f=h|f<<6;h=e+3|0;}e=h;J[a>>2]=f;d=d-1|0;a=a+4|0;break t}J[5732]=25;e=e-1|0;break c}f=0;continue}}e=e-1|0;if(g){break d}g=K[e|0];}if(g&255){break d}if(a){J[a>>2]=0;J[b>>2]=0;}return c-d|0}J[5732]=25;if(!a){break b}}J[b>>2]=e;}return -1}J[b>>2]=e;return c}function ul(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;a=Ua-256|0;Ua=a;J[a+248>>2]=c;J[a+252>>2]=b;h=a+196|0;J[h>>2]=0;J[h+4>>2]=0;J[h+8>>2]=0;g=a+16|0;b=J[d+28>>2];J[g>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;b=$(170,J[a+16>>2])|0;c=J[5996];J[5996]=0;a:{b:{if((c|0)==1){break b}J[5996]=0;ga(195,b|0,12416,12442,a+208|0);b=J[5996];J[5996]=0;if((b|0)==1){break b}b=J[a+16>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}c=a+184|0;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;b=(K[c+11|0]&128)>>>7|0?(J[c+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,c|0,b|0);b=J[5996];J[5996]=0;if((b|0)!=1){c:{b=(K[c+11|0]&128)>>>7|0?J[c>>2]:c;J[a+180>>2]=b;J[a+12>>2]=g;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(186,a+252|0,a+248|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break d}d=J[a+180>>2];e:{if(!g){g=d;d=K[c+11|0];d=(d&128)>>>7|0?J[c+4>>2]:d&127;if((g|0)==(d+b|0)){J[5996]=0;aa(172,c|0,d<<1);b=J[5996];J[5996]=0;if((b|0)==1){break c}b=(K[c+11|0]&128)>>>7|0?(J[c+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,c|0,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break c}b=(K[c+11|0]&128)>>>7|0?J[c>>2]:c;J[a+180>>2]=d+b;}J[5996]=0;d=$(187,J[a+252>>2])|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(!Dc(d,16,b,a+180|0,a+8|0,0,J[h+4>>2],K[h+11|0],a+16|0,a+12|0,a+208|0)){break e}d=J[a+180>>2];}J[5996]=0;aa(172,c|0,d-b|0);b=J[5996];J[5996]=0;if((b|0)==1){break d}b=J[c>>2];d=(K[c+11|0]&128)>>>7|0;g=jb();J[a>>2]=f;if((Kf(d?b:c,g,a)|0)!=1){J[e>>2]=4;}J[5996]=0;b=_(186,a+252|0,a+248|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break d}if(b){J[e>>2]=J[e>>2]|2;}b=J[a+252>>2];ab(c);ab(h);Ua=a+256|0;return b|0}J[5996]=0;$(189,a+252|0)|0;d=J[5996];J[5996]=0;if((d|0)!=1){continue}}break}}}b=Z()|0;ab(c);break a}b=Z()|0;a=J[a+16>>2];c=J[a+4>>2]-1|0;J[a+4>>2]=c;if((c|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}}ab(h);da(b|0);B();}function jl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;a=Ua-320|0;Ua=a;J[a+312>>2]=c;J[a+316>>2]=b;h=a+196|0;J[h>>2]=0;J[h+4>>2]=0;J[h+8>>2]=0;g=a+16|0;b=J[d+28>>2];J[g>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;b=$(197,J[a+16>>2])|0;c=J[5996];J[5996]=0;a:{b:{if((c|0)==1){break b}J[5996]=0;ga(208,b|0,12416,12442,a+208|0);b=J[5996];J[5996]=0;if((b|0)==1){break b}b=J[a+16>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}c=a+184|0;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;b=(K[c+11|0]&128)>>>7|0?(J[c+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,c|0,b|0);b=J[5996];J[5996]=0;if((b|0)!=1){c:{b=(K[c+11|0]&128)>>>7|0?J[c>>2]:c;J[a+180>>2]=b;J[a+12>>2]=g;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(202,a+316|0,a+312|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break d}d=J[a+180>>2];e:{if(!g){g=d;d=K[c+11|0];d=(d&128)>>>7|0?J[c+4>>2]:d&127;if((g|0)==(d+b|0)){J[5996]=0;aa(172,c|0,d<<1);b=J[5996];J[5996]=0;if((b|0)==1){break c}b=(K[c+11|0]&128)>>>7|0?(J[c+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,c|0,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break c}b=(K[c+11|0]&128)>>>7|0?J[c>>2]:c;J[a+180>>2]=d+b;}J[5996]=0;d=$(203,J[a+316>>2])|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(!Cc(d,16,b,a+180|0,a+8|0,0,J[h+4>>2],K[h+11|0],a+16|0,a+12|0,a+208|0)){break e}d=J[a+180>>2];}J[5996]=0;aa(172,c|0,d-b|0);b=J[5996];J[5996]=0;if((b|0)==1){break d}b=J[c>>2];d=(K[c+11|0]&128)>>>7|0;g=jb();J[a>>2]=f;if((Kf(d?b:c,g,a)|0)!=1){J[e>>2]=4;}J[5996]=0;b=_(202,a+316|0,a+312|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break d}if(b){J[e>>2]=J[e>>2]|2;}b=J[a+316>>2];ab(c);ab(h);Ua=a+320|0;return b|0}J[5996]=0;$(205,a+316|0)|0;d=J[5996];J[5996]=0;if((d|0)!=1){continue}}break}}}b=Z()|0;ab(c);break a}b=Z()|0;a=J[a+16>>2];c=J[a+4>>2]-1|0;J[a+4>>2]=c;if((c|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}}ab(h);da(b|0);B();}function ek(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=Ua-480|0;Ua=a;g=J[d+28>>2];J[a+476>>2]=g;J[g+4>>2]=J[g+4>>2]+1;J[5996]=0;o=$(197,J[a+476>>2])|0;g=J[5996];J[5996]=0;a:{b:{c:{d:{e:{if((g|0)!=1){i=K[f+11|0];g=(i&128)>>>7|0;if(g?J[f+4>>2]:i&127){g=J[(g?J[f>>2]:f)>>2];J[5996]=0;i=_(216,o|0,45)|0;k=J[5996];J[5996]=0;if((k|0)==1){break e}p=(g|0)==(i|0);}k=a+452|0;J[k>>2]=0;J[k+4>>2]=0;J[k+8>>2]=0;g=a+440|0;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;i=a+428|0;J[i>>2]=0;J[i+4>>2]=0;J[i+8>>2]=0;J[5996]=0;sa(238,c|0,p|0,J[a+476>>2],a+472|0,a+468|0,a+464|0,k|0,g|0,i|0,a+424|0);c=J[5996];J[5996]=0;if((c|0)==1){break d}J[a+4>>2]=184;l=a+8|0;J[l>>2]=0;J[l+4>>2]=J[a+4>>2];c=a+16|0;j=K[f+11|0];j=(j&128)>>>7|0?J[f+4>>2]:j&127;m=J[a+424>>2];f:{if((j|0)>(m|0)){h=K[i+11|0];n=(j-m<<1)+((h&128)>>>7|0?J[i+4>>2]:h&127)|0;h=K[g+11|0];h=(n+((h&128)>>>7|0?J[g+4>>2]:h&127)|0)+1|0;break f}h=K[i+11|0];n=(h&128)>>>7|0?J[i+4>>2]:h&127;h=K[g+11|0];h=(n+((h&128)>>>7|0?J[g+4>>2]:h&127)|0)+2|0;}g:{h=h+m|0;if(h>>>0>=101){tb(l,sb(h<<2));c=J[l>>2];if(!c){break g}j=K[f+11|0];j=(j&128)>>>7|0?J[f+4>>2]:j&127;}h=J[d+4>>2];f=(K[f+11|0]&128)>>>7|0?J[f>>2]:f;J[5996]=0;ta(239,c|0,a+4|0,a|0,h|0,f|0,f+(j<<2)|0,o|0,p|0,a+472|0,J[a+468>>2],J[a+464>>2],k|0,g|0,i|0,m|0);f=J[5996];J[5996]=0;if((f|0)==1){break c}J[5996]=0;d=ka(219,b|0,c|0,J[a+4>>2],J[a>>2],d|0,e|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break c}db(l);ab(i);ab(g);ab(k);b=J[a+476>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}Ua=a+480|0;return d|0}J[5996]=0;ca(185);b=J[5996];J[5996]=0;if((b|0)==1){break c}B();}f=Z()|0;break a}f=Z()|0;break a}f=Z()|0;break b}f=Z()|0;db(l);}ab(i);ab(g);ab(k);}a=J[a+476>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(f|0);B();}function ik(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=Ua-176|0;Ua=a;g=J[d+28>>2];J[a+172>>2]=g;J[g+4>>2]=J[g+4>>2]+1;J[5996]=0;o=$(170,J[a+172>>2])|0;g=J[5996];J[5996]=0;a:{b:{c:{d:{e:{if((g|0)!=1){i=K[f+11|0];g=(i&128)>>>7|0;if(g?J[f+4>>2]:i&127){g=K[(g?J[f>>2]:f)|0];J[5996]=0;i=_(171,o|0,45)|0;k=J[5996];J[5996]=0;if((k|0)==1){break e}p=(i&255)==(g|0);}k=a+152|0;J[k>>2]=0;J[k+4>>2]=0;J[k+8>>2]=0;g=a+140|0;J[g>>2]=0;J[g+4>>2]=0;J[g+8>>2]=0;i=a+128|0;J[i>>2]=0;J[i+4>>2]=0;J[i+8>>2]=0;J[5996]=0;sa(236,c|0,p|0,J[a+172>>2],a+168|0,a+167|0,a+166|0,k|0,g|0,i|0,a+124|0);c=J[5996];J[5996]=0;if((c|0)==1){break d}J[a+4>>2]=184;l=a+8|0;J[l>>2]=0;J[l+4>>2]=J[a+4>>2];c=a+16|0;j=K[f+11|0];j=(j&128)>>>7|0?J[f+4>>2]:j&127;m=J[a+124>>2];f:{if((j|0)>(m|0)){h=K[i+11|0];n=(j-m<<1)+((h&128)>>>7|0?J[i+4>>2]:h&127)|0;h=K[g+11|0];h=(n+((h&128)>>>7|0?J[g+4>>2]:h&127)|0)+1|0;break f}h=K[i+11|0];n=(h&128)>>>7|0?J[i+4>>2]:h&127;h=K[g+11|0];h=(n+((h&128)>>>7|0?J[g+4>>2]:h&127)|0)+2|0;}g:{h=h+m|0;if(h>>>0>=101){tb(l,sb(h));c=J[l>>2];if(!c){break g}j=K[f+11|0];j=(j&128)>>>7|0?J[f+4>>2]:j&127;}h=J[d+4>>2];f=(K[f+11|0]&128)>>>7|0?J[f>>2]:f;J[5996]=0;ta(237,c|0,a+4|0,a|0,h|0,f|0,f+j|0,o|0,p|0,a+168|0,H[a+167|0],H[a+166|0],k|0,g|0,i|0,m|0);f=J[5996];J[5996]=0;if((f|0)==1){break c}J[5996]=0;d=ka(213,b|0,c|0,J[a+4>>2],J[a>>2],d|0,e|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break c}db(l);ab(i);ab(g);ab(k);b=J[a+172>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}Ua=a+176|0;return d|0}J[5996]=0;ca(185);b=J[5996];J[5996]=0;if((b|0)==1){break c}B();}f=Z()|0;break a}f=Z()|0;break a}f=Z()|0;break b}f=Z()|0;db(l);}ab(i);ab(g);ab(k);}a=J[a+172>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(f|0);B();}function fk(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=l|0;m=m|0;n=n|0;o=o|0;var p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;J[c>>2]=a;v=d&512;w=h<<2;while(1){if((u|0)==4){e=K[n+11|0];if(((e&128)>>>7|0?J[n+4>>2]:e&127)>>>0>1){J[c>>2]=mf(Rd(Mb(n),1),qc(n),J[c>>2]);}d=d&176;if((d|0)!=16){if((d|0)==32){a=J[c>>2];}J[b>>2]=a;}}else {a:{b:{switch(H[i+u|0]){case 0:J[b>>2]=J[c>>2];break a;case 1:J[b>>2]=J[c>>2];h=Xa[J[J[g>>2]+44>>2]](g,32)|0;p=J[c>>2];J[c>>2]=p+4;J[p>>2]=h;break a;case 3:h=K[n+11|0];r=h&127;h=(h&128)>>>7|0;if(!(h?J[n+4>>2]:r)){break a}h=J[(h?J[n>>2]:n)>>2];p=J[c>>2];J[c>>2]=p+4;J[p>>2]=h;break a;case 2:if(!v){break a}h=K[m+11|0];if(!((h&128)>>>7|0?J[m+4>>2]:h&127)){break a}J[c>>2]=mf(Mb(m),qc(m),J[c>>2]);break a;case 4:break b;default:break a}}x=J[c>>2];e=e+w|0;h=e;while(1){c:{if(f>>>0<=h>>>0){break c}if(!(Xa[J[J[g>>2]+12>>2]](g,64,J[h>>2])|0)){break c}h=h+4|0;continue}break}if((o|0)>0){p=J[c>>2];q=o;while(1){if(!(!q|e>>>0>=h>>>0)){q=q-1|0;h=h-4|0;s=J[h>>2];r=p+4|0;J[c>>2]=r;J[p>>2]=s;p=r;continue}break}d:{if(!q){s=0;break d}s=Xa[J[J[g>>2]+44>>2]](g,48)|0;p=J[c>>2];}while(1){r=p+4|0;if((q|0)>0){J[p>>2]=s;q=q-1|0;p=r;continue}break}J[c>>2]=r;J[p>>2]=j;}e:{if((e|0)==(h|0)){p=Xa[J[J[g>>2]+44>>2]](g,48)|0;q=J[c>>2];h=q+4|0;J[c>>2]=h;J[q>>2]=p;break e}s=-1;p=K[l+11|0];r=(p&128)>>>7|0;if(r?J[l+4>>2]:p&127){s=H[(r?J[l>>2]:l)|0];}q=0;t=0;while(1){if((e|0)!=(h|0)){r=J[c>>2];f:{if((q|0)!=(s|0)){p=r;r=q;break f}p=r+4|0;J[c>>2]=p;J[r>>2]=k;r=0;t=t+1|0;s=K[l+11|0];if(t>>>0>=((s&128)>>>7|0?J[l+4>>2]:s&127)>>>0){s=q;break f}s=-1;q=((K[l+11|0]&128)>>>7|0?J[l>>2]:l)+t|0;if(K[q|0]==127){break f}s=H[q|0];}h=h-4|0;q=J[h>>2];J[c>>2]=p+4;J[p>>2]=q;q=r+1|0;continue}break}h=J[c>>2];}md(x,h);}u=u+1|0;continue}break}}function jk(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=l|0;m=m|0;n=n|0;o=o|0;var p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;J[c>>2]=a;w=d&512;while(1){if((u|0)==4){e=K[n+11|0];if(((e&128)>>>7|0?J[n+4>>2]:e&127)>>>0>1){J[c>>2]=nf(Td(Mb(n),1),sc(n),J[c>>2]);}d=d&176;if((d|0)!=16){if((d|0)==32){a=J[c>>2];}J[b>>2]=a;}}else {a:{b:{switch(H[i+u|0]){case 0:J[b>>2]=J[c>>2];break a;case 1:J[b>>2]=J[c>>2];p=Xa[J[J[g>>2]+28>>2]](g,32)|0;q=J[c>>2];J[c>>2]=q+1;H[q|0]=p;break a;case 3:p=K[n+11|0];q=(p&128)>>>7|0;if(!(q?J[n+4>>2]:p&127)){break a}p=K[(q?J[n>>2]:n)|0];q=J[c>>2];J[c>>2]=q+1;H[q|0]=p;break a;case 2:if(!w){break a}p=K[m+11|0];if(!((p&128)>>>7|0?J[m+4>>2]:p&127)){break a}J[c>>2]=nf(Mb(m),sc(m),J[c>>2]);break a;case 4:break b;default:break a}}q=J[g+8>>2];x=J[c>>2];e=e+h|0;r=e;while(1){c:{if(f>>>0<=r>>>0){break c}p=H[r|0];if((p|0)>=0){p=(J[q+((p&255)<<2)>>2]&64)!=0;}else {p=0;}if(!p){break c}r=r+1|0;continue}break}p=o;if((p|0)>0){while(1){if(!(!p|e>>>0>=r>>>0)){p=p-1|0;r=r-1|0;q=K[r|0];s=J[c>>2];J[c>>2]=s+1;H[s|0]=q;continue}break}if(p){q=Xa[J[J[g>>2]+28>>2]](g,48)|0;}else {q=0;}while(1){s=J[c>>2];J[c>>2]=s+1;if((p|0)>0){H[s|0]=q;p=p-1|0;continue}break}H[s|0]=j;}d:{if((e|0)==(r|0)){p=Xa[J[J[g>>2]+28>>2]](g,48)|0;q=J[c>>2];J[c>>2]=q+1;H[q|0]=p;break d}q=-1;p=K[l+11|0];s=p&127;p=(p&128)>>>7|0;if(p?J[l+4>>2]:s){q=H[(p?J[l>>2]:l)|0];}p=0;t=0;while(1){if((e|0)==(r|0)){break d}e:{if((p|0)!=(q|0)){s=p;break e}q=J[c>>2];J[c>>2]=q+1;H[q|0]=k;s=0;t=t+1|0;q=K[l+11|0];if(t>>>0>=((q&128)>>>7|0?J[l+4>>2]:q&127)>>>0){q=p;break e}q=-1;p=((K[l+11|0]&128)>>>7|0?J[l>>2]:l)+t|0;if(K[p|0]==127){break e}q=H[p|0];}r=r-1|0;p=K[r|0];v=J[c>>2];J[c>>2]=v+1;H[v|0]=p;p=s+1|0;continue}}vc(x,J[c>>2]);}u=u+1|0;continue}break}}function Fi(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;r=Ua-16|0;Ua=r;j=c;while(1){a:{if((d|0)==(j|0)){j=d;break a}if(!K[j|0]){break a}j=j+1|0;continue}break}J[h>>2]=f;J[e>>2]=c;while(1){b:{c:{d:{if((c|0)==(d|0)|(f|0)==(g|0)){break d}i=J[b+4>>2];J[r+8>>2]=J[b>>2];J[r+12>>2]=i;s=Ua-16|0;Ua=s;v=Xb(s+12|0,J[a+8>>2]);m=j-c|0;k=0;n=0;o=Ua-1040|0;Ua=o;q=J[e>>2];J[o+12>>2]=q;p=f?f:o+16|0;l=f?g-f>>2:256;e:{f:{g:{if(!(!q|!l)){while(1){i=m>>>2|0;if(!(m>>>0>131|i>>>0>=l>>>0)){i=q;break f}t=bg(p,o+12|0,i>>>0<l>>>0?i:l,b);i=J[o+12>>2];if((t|0)==-1){l=0;k=-1;break g}u=(o+16|0)!=(p|0)?t:0;l=l-u|0;p=(u<<2)+p|0;m=i?(m+q|0)-i|0:0;k=k+t|0;if(!i){break g}q=i;if(l){continue}break}break g}i=q;}if(!i){break e}}if(!(!l|!m)){n=i;i=k;while(1){h:{k=qd(p,n,m,b);i:{if(k+2>>>0<=2){j:{switch(k+1|0){case 1:n=0;break i;case 0:break e;default:break j}}J[b>>2]=0;break i}n=k+n|0;J[o+12>>2]=n;i=i+1|0;l=l-1|0;if(l){break h}}k=i;break e}p=p+4|0;m=m-k|0;k=i;if(m){continue}break}break e}n=i;}if(f){J[e>>2]=n;}Ua=o+1040|0;i=J[v>>2];if(i){J[6178]=(i|0)==-1?24816:i;}Ua=s+16|0;k:{l:{m:{n:{if((k|0)==-1){while(1){o:{J[h>>2]=f;if(J[e>>2]==(c|0)){break o}g=1;p:{q:{r:{b=Me(f,c,j-c|0,r+8|0,J[a+8>>2]);switch(b+2|0){case 0:break l;case 2:break p;case 1:break r;default:break q}}J[e>>2]=c;break n}g=b;}c=c+g|0;f=J[h>>2]+4|0;continue}break}J[e>>2]=c;break d}f=J[h>>2]+(k<<2)|0;J[h>>2]=f;if((f|0)==(g|0)){break k}c=J[e>>2];if((d|0)==(j|0)){j=d;continue}if(!Me(f,c,1,b,J[a+8>>2])){break m}}a=2;break c}J[h>>2]=J[h>>2]+4;c=J[e>>2]+1|0;J[e>>2]=c;j=c;while(1){if((d|0)==(j|0)){j=d;break b}if(!K[j|0]){break b}j=j+1|0;continue}}J[e>>2]=c;a=1;break c}c=J[e>>2];}a=(c|0)!=(d|0);}Ua=r+16|0;return a|0}f=J[h>>2];continue}}function nd(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;j=Ua-128|0;Ua=j;J[j+124>>2]=b;J[j+4>>2]=184;b=j+8|0;J[b>>2]=0;J[b+4>>2]=J[j+4>>2];o=b;k=j+16|0;l=(d-c|0)/12|0;a:{b:{if(l>>>0>=101){k=sb(l);if(!k){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break b}tb(o,k);}h=k;b=c;c:{d:{while(1){if((b|0)==(d|0)){e:while(1){f:{J[5996]=0;h=_(186,a|0,j+124|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break f}if((!l|h)==1){J[5996]=0;b=_(186,a|0,j+124|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break c}if(!b){break d}J[f>>2]=J[f>>2]|2;break d}b=J[a>>2];J[5996]=0;p=$(187,b|0)|0;b=J[5996];J[5996]=0;g:{if((b|0)!=1){if(g){break g}J[5996]=0;p=_(188,e|0,p|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break g}}break b}i=q+1|0;s=0;h=k;b=c;while(1){if((b|0)==(d|0)){q=i;if(!s){continue e}J[5996]=0;$(189,a|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){h=k;b=c;if(l+m>>>0<2){continue e}while(1){if((b|0)==(d|0)){continue e}h:{if(K[h|0]!=2){break h}i=K[b+11|0];if((((i&128)>>>7|0?J[b+4>>2]:i&127)|0)==(q|0)){break h}H[h|0]=0;m=m-1|0;}h=h+1|0;b=b+12|0;continue}}break b}i:{if(K[h|0]!=1){break i}r=K[((K[b+11|0]&128)>>>7|0?J[b>>2]:b)+q|0];j:{if(g){break j}J[5996]=0;r=_(188,e|0,r<<24>>24)|0;n=J[5996];J[5996]=0;if((n|0)!=1){break j}break b}k:{if((p&255)==(r&255)){s=1;n=K[b+11|0];if((i|0)!=(((n&128)>>>7|0?J[b+4>>2]:n&127)|0)){break i}H[h|0]=2;m=m+1|0;break k}H[h|0]=0;}l=l-1|0;}h=h+1|0;b=b+12|0;continue}}break}}else {i=K[b+11|0];i=!((i&128)>>>7|0?J[b+4>>2]:i&127);H[h|0]=i?2:1;m=i+m|0;l=l-i|0;h=h+1|0;b=b+12|0;continue}break}break b}l:{m:{while(1){if((c|0)==(d|0)){break m}if(K[k|0]!=2){k=k+1|0;c=c+12|0;continue}break}d=c;break l}J[f>>2]=J[f>>2]|4;}db(o);Ua=j+128|0;return d|0}}a=Z()|0;db(o);da(a|0);}B();}function ld(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;j=Ua-128|0;Ua=j;J[j+124>>2]=b;J[j+4>>2]=184;b=j+8|0;J[b>>2]=0;J[b+4>>2]=J[j+4>>2];o=b;k=j+16|0;l=(d-c|0)/12|0;a:{b:{if(l>>>0>=101){k=sb(l);if(!k){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break b}tb(o,k);}h=k;b=c;c:{d:{while(1){if((b|0)==(d|0)){e:while(1){f:{J[5996]=0;h=_(202,a|0,j+124|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break f}if((!l|h)==1){J[5996]=0;b=_(202,a|0,j+124|0)|0;a=J[5996];J[5996]=0;if((a|0)==1){break c}if(!b){break d}J[f>>2]=J[f>>2]|2;break d}b=J[a>>2];J[5996]=0;p=$(203,b|0)|0;b=J[5996];J[5996]=0;g:{if((b|0)!=1){if(g){break g}J[5996]=0;p=_(204,e|0,p|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){break g}}break b}i=q+1|0;s=0;h=k;b=c;while(1){if((b|0)==(d|0)){q=i;if(!s){continue e}J[5996]=0;$(205,a|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){h=k;b=c;if(l+m>>>0<2){continue e}while(1){if((b|0)==(d|0)){continue e}h:{if(K[h|0]!=2){break h}i=K[b+11|0];if((((i&128)>>>7|0?J[b+4>>2]:i&127)|0)==(q|0)){break h}H[h|0]=0;m=m-1|0;}h=h+1|0;b=b+12|0;continue}}break b}i:{if(K[h|0]!=1){break i}r=J[(q<<2)+((K[b+11|0]&128)>>>7|0?J[b>>2]:b)>>2];j:{if(g){break j}J[5996]=0;r=_(204,e|0,r|0)|0;n=J[5996];J[5996]=0;if((n|0)!=1){break j}break b}k:{if((p|0)==(r|0)){s=1;n=K[b+11|0];if((i|0)!=(((n&128)>>>7|0?J[b+4>>2]:n&127)|0)){break i}H[h|0]=2;m=m+1|0;break k}H[h|0]=0;}l=l-1|0;}h=h+1|0;b=b+12|0;continue}}break}}else {i=K[b+11|0];i=!((i&128)>>>7|0?J[b+4>>2]:i&127);H[h|0]=i?2:1;m=i+m|0;l=l-i|0;h=h+1|0;b=b+12|0;continue}break}break b}l:{m:{while(1){if((c|0)==(d|0)){break m}if(K[k|0]!=2){k=k+1|0;c=c+12|0;continue}break}d=c;break l}J[f>>2]=J[f>>2]|4;}db(o);Ua=j+128|0;return d|0}}a=Z()|0;db(o);da(a|0);}B();}function uk(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0;h=Ua-624|0;Ua=h;J[h+616>>2]=c;J[h+620>>2]=b;J[h+16>>2]=220;i=h+200|0;J[i>>2]=h+208;a=h+16|0;J[i+4>>2]=J[a>>2];j=h+192|0;b=J[e+28>>2];J[j>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;k=$(197,J[h+192>>2])|0;b=J[5996];J[5996]=0;a:{b:{c:{d:{e:{f:{g:{if((b|0)!=1){H[h+191|0]=0;b=J[e+4>>2];J[5996]=0;b=ua(228,h+620|0,c|0,d|0,j|0,b|0,f|0,h+191|0,k|0,i|0,h+196|0,h+608|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break d}if(!b){break e}b=K[3833]|K[3834]<<8|(K[3835]<<16|K[3836]<<24);H[h+183|0]=b;H[h+184|0]=b>>>8;H[h+185|0]=b>>>16;H[h+186|0]=b>>>24;b=K[3830]|K[3831]<<8|(K[3832]<<16|K[3833]<<24);J[h+176>>2]=K[3826]|K[3827]<<8|(K[3828]<<16|K[3829]<<24);J[h+180>>2]=b;J[5996]=0;ga(208,k|0,h+176|0,h+186|0,h+128|0);b=J[5996];J[5996]=0;if((b|0)==1){break g}J[h+4>>2]=184;d=h+8|0;J[d>>2]=0;J[d+4>>2]=J[h+4>>2];e=a;b=J[h+196>>2];a=b-J[i>>2]|0;if((a|0)<393){break f}tb(d,sb((a>>2)+2|0));e=J[d>>2];if(e){break f}J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)==1){break c}break a}c=Z()|0;break b}c=Z()|0;break b}if(K[h+191|0]){H[e|0]=45;e=e+1|0;}c=J[i>>2];while(1){if(b>>>0<=c>>>0){H[e|0]=0;J[h>>2]=g;if((eg(h+16|0,h)|0)!=1){J[5996]=0;ha(222,1730);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break c}db(d);}else {a=h+128|0;H[e|0]=K[(h+176|0)+(Yd(a,a+40|0,J[c>>2])-a>>2)|0];e=e+1|0;c=c+4|0;b=J[h+196>>2];continue}break}}J[5996]=0;a=_(202,h+620|0,h+616|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break d}if(a){J[f>>2]=J[f>>2]|2;}c=J[h+620>>2];a=J[h+192>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}db(i);Ua=h+624|0;return c|0}c=Z()|0;break b}c=Z()|0;db(d);}a=J[h+192>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}db(i);da(c|0);B();}B();}function vj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;e=J[a+4>>2];c=J[a>>2];d=e-c>>2;if(d>>>0<b>>>0){h=Ua-32|0;Ua=h;f=b-d|0;a:{if(f>>>0<=J[a+8>>2]-e>>2>>>0){ff(a,f);break a}g=a+16|0;d=h+12|0;c=Ua-16|0;Ua=c;e=f+(e-J[a>>2]>>2)|0;J[c+12>>2]=e;b:{b=_e();if(e>>>0<=b>>>0){e=J[a+8>>2]-J[a>>2]>>2;if(e>>>0<b>>>1>>>0){J[c+8>>2]=e<<1;b=J[(M[c+8>>2]<M[c+12>>2]?c+12|0:c+8|0)>>2];}Ua=c+16|0;break b}nb();B();}i=J[a+4>>2]-J[a>>2]>>2;e=Ua-16|0;Ua=e;J[d+12>>2]=0;J[d+16>>2]=g;c:{if(!b){c=0;b=0;break c}Ze(e+8|0,J[d+16>>2],b);c=J[e+8>>2];b=J[e+12>>2];}J[d>>2]=c;g=c+(i<<2)|0;J[d+8>>2]=g;J[d+4>>2]=g;J[d+12>>2]=c+(b<<2);Ua=e+16|0;c=Ua-16|0;Ua=c;J[c+4>>2]=J[d+8>>2];b=J[d+8>>2];J[c+12>>2]=d+8;J[c+8>>2]=b+(f<<2);b=J[c+4>>2];while(1){if(J[c+8>>2]!=(b|0)){J[b>>2]=0;b=J[c+4>>2]+4|0;J[c+4>>2]=b;continue}break}J[J[c+12>>2]>>2]=J[c+4>>2];Ua=c+16|0;e=Ua-16|0;Ua=e;J[e+12>>2]=J[a+4>>2];J[e+8>>2]=J[a>>2];J[e+4>>2]=J[d+4>>2];f=J[e+12>>2];i=J[e+4>>2];g=Ua-16|0;Ua=g;b=Ua-32|0;Ua=b;c=Ua-16|0;Ua=c;J[c+12>>2]=J[e+8>>2];J[b+24>>2]=f;J[b+28>>2]=J[c+12>>2];Ua=c+16|0;f=J[b+24>>2];j=J[b+28>>2];c=Ua-16|0;Ua=c;J[c+8>>2]=i;J[c+12>>2]=f;while(1){if((f|0)!=(j|0)){J[J[c+8>>2]-4>>2]=J[f-4>>2];J[c+12>>2]=J[c+12>>2]-4;J[c+8>>2]=J[c+8>>2]-4;f=J[c+12>>2];continue}break}J[b+16>>2]=f;J[b+20>>2]=J[c+8>>2];Ua=c+16|0;c=J[b+16>>2];J[b+12>>2]=J[b+20>>2];J[g+8>>2]=c;J[g+12>>2]=J[b+12>>2];Ua=b+32|0;Ua=g+16|0;J[d+4>>2]=J[g+12>>2];b=J[a>>2];J[a>>2]=J[d+4>>2];J[d+4>>2]=b;b=J[a+4>>2];J[a+4>>2]=J[d+8>>2];J[d+8>>2]=b;b=J[a+8>>2];J[a+8>>2]=J[d+12>>2];J[d+12>>2]=b;J[d>>2]=J[d+4>>2];Ua=e+16|0;b=J[d+4>>2];a=J[d+8>>2];while(1){if((a|0)!=(b|0)){a=a-4|0;J[d+8>>2]=a;continue}break}a=J[d>>2];if(a){bf(J[d+16>>2],a);}}Ua=h+32|0;return}if(b>>>0<d>>>0){af(a,c+(b<<2)|0);}}function Bk(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0;h=Ua-272|0;Ua=h;J[h+264>>2]=c;J[h+268>>2]=b;J[h+16>>2]=220;i=h+152|0;J[i>>2]=h+160;a=h+16|0;J[i+4>>2]=J[a>>2];j=h+144|0;b=J[e+28>>2];J[j>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;k=$(170,J[h+144>>2])|0;b=J[5996];J[5996]=0;a:{b:{c:{d:{e:{f:{g:{if((b|0)!=1){H[h+143|0]=0;b=J[e+4>>2];J[5996]=0;b=ua(221,h+268|0,c|0,d|0,j|0,b|0,f|0,h+143|0,k|0,i|0,h+148|0,h+260|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break d}if(!b){break e}b=K[3833]|K[3834]<<8|(K[3835]<<16|K[3836]<<24);H[h+135|0]=b;H[h+136|0]=b>>>8;H[h+137|0]=b>>>16;H[h+138|0]=b>>>24;b=K[3830]|K[3831]<<8|(K[3832]<<16|K[3833]<<24);J[h+128>>2]=K[3826]|K[3827]<<8|(K[3828]<<16|K[3829]<<24);J[h+132>>2]=b;J[5996]=0;ga(195,k|0,h+128|0,h+138|0,h+118|0);b=J[5996];J[5996]=0;if((b|0)==1){break g}J[h+4>>2]=184;d=h+8|0;J[d>>2]=0;J[d+4>>2]=J[h+4>>2];e=a;b=J[h+148>>2];a=b-J[i>>2]|0;if((a|0)<99){break f}tb(d,sb(a+2|0));e=J[d>>2];if(e){break f}J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)==1){break c}break a}c=Z()|0;break b}c=Z()|0;break b}if(K[h+143|0]){H[e|0]=45;e=e+1|0;}c=J[i>>2];while(1){if(b>>>0<=c>>>0){H[e|0]=0;J[h>>2]=g;if((eg(h+16|0,h)|0)!=1){J[5996]=0;ha(222,1730);a=J[5996];J[5996]=0;if((a|0)!=1){break a}break c}db(d);}else {a=h+118|0;H[e|0]=K[((be(a,a+10|0,K[c|0])-h|0)+h|0)+10|0];e=e+1|0;c=c+1|0;b=J[h+148>>2];continue}break}}J[5996]=0;a=_(186,h+268|0,h+264|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break d}if(a){J[f>>2]=J[f>>2]|2;}c=J[h+268>>2];a=J[h+144>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}db(i);Ua=h+272|0;return c|0}c=Z()|0;break b}c=Z()|0;db(d);}a=J[h+144>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}db(i);da(c|0);B();}B();}function vl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;d=J[d+28>>2];a=Ua-272|0;Ua=a;J[a+264>>2]=c;J[a+268>>2]=b;$d(a+208|0,d,a+224|0,a+223|0,a+222|0);d=a+196|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;b=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,b|0);b=J[5996];J[5996]=0;a:{b:{c:{if((b|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+192>>2]=c;J[a+28>>2]=a+32;J[a+24>>2]=0;H[a+23|0]=1;H[a+22|0]=69;g=K[a+222|0]<<24>>24;i=K[a+223|0]<<24>>24;while(1){d:{J[5996]=0;b=_(186,a+268|0,a+264|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(b){break c}b=K[d+11|0];b=(b&128)>>>7|0?J[d+4>>2]:b&127;if(J[a+192>>2]==(b+c|0)){J[5996]=0;aa(172,d|0,b<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+192>>2]=b+c;}J[5996]=0;b=$(187,J[a+268>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(_d(b,a+23|0,a+22|0,c,a+192|0,i,g,a+208|0,a+32|0,a+28|0,a+24|0,a+224|0)){break c}J[5996]=0;$(189,a+268|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){continue}}break}break b}break b}b=K[a+219|0];e:{if(!((b&128)>>>7|0?J[a+212>>2]:b&127)|!K[a+23|0]){break e}b=J[a+28>>2];if((b-(a+32|0)|0)>159){break e}J[a+28>>2]=b+4;J[b>>2]=J[a+24>>2];}Lf(a,c,J[a+192>>2],e);b=J[a>>2];c=J[a+4>>2];g=J[a+12>>2];J[f+8>>2]=J[a+8>>2];J[f+12>>2]=g;J[f>>2]=b;J[f+4>>2]=c;zb(a+208|0,a+32|0,J[a+28>>2],e);J[5996]=0;b=_(186,a+268|0,a+264|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+268>>2];ab(d);ab(a+208|0);Ua=a+272|0;break a}}b=Z()|0;ab(d);ab(a+208|0);da(b|0);B();}return b|0}function kl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;d=J[d+28>>2];a=Ua-384|0;Ua=a;J[a+376>>2]=c;J[a+380>>2]=b;Xd(a+220|0,d,a+240|0,a+236|0,a+232|0);d=a+208|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;b=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,b|0);b=J[5996];J[5996]=0;a:{b:{c:{if((b|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+204>>2]=c;J[a+28>>2]=a+32;J[a+24>>2]=0;H[a+23|0]=1;H[a+22|0]=69;g=J[a+232>>2];i=J[a+236>>2];while(1){d:{J[5996]=0;b=_(202,a+380|0,a+376|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(b){break c}b=K[d+11|0];b=(b&128)>>>7|0?J[d+4>>2]:b&127;if(J[a+204>>2]==(b+c|0)){J[5996]=0;aa(172,d|0,b<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+204>>2]=b+c;}J[5996]=0;b=$(203,J[a+380>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Wd(b,a+23|0,a+22|0,c,a+204|0,i,g,a+220|0,a+32|0,a+28|0,a+24|0,a+240|0)){break c}J[5996]=0;$(205,a+380|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){continue}}break}break b}break b}b=K[a+231|0];e:{if(!((b&128)>>>7|0?J[a+224>>2]:b&127)|!K[a+23|0]){break e}b=J[a+28>>2];if((b-(a+32|0)|0)>159){break e}J[a+28>>2]=b+4;J[b>>2]=J[a+24>>2];}Lf(a,c,J[a+204>>2],e);b=J[a>>2];c=J[a+4>>2];g=J[a+12>>2];J[f+8>>2]=J[a+8>>2];J[f+12>>2]=g;J[f>>2]=b;J[f+4>>2]=c;zb(a+220|0,a+32|0,J[a+28>>2],e);J[5996]=0;b=_(202,a+380|0,a+376|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+380>>2];ab(d);ab(a+220|0);Ua=a+384|0;break a}}b=Z()|0;ab(d);ab(a+220|0);da(b|0);B();}return b|0}function al(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0;n=b;i=Ua-256|0;Ua=i;J[i+248>>2]=37;J[i+252>>2]=0;b=i+248|0;l=kd(b|1,3264,J[c+4>>2]);j=i+208|0;J[i+204>>2]=j;a=jb();a:{if(l){k=J[c+8>>2];m=i- -64|0;J[m>>2]=g;J[m+4>>2]=h;J[i+56>>2]=e;J[i+60>>2]=f;J[i+48>>2]=k;j=yb(j,30,a,b,i+48|0);break a}J[i+80>>2]=e;J[i+84>>2]=f;J[i+88>>2]=g;J[i+92>>2]=h;j=yb(i+208|0,30,a,i+248|0,i+80|0);}J[i+128>>2]=184;k=i+196|0;J[k>>2]=0;J[k+4>>2]=J[i+128>>2];b=i+208|0;a=b;b:{c:{d:{e:{if((j|0)>=30){a=jb();f:{if(l){j=J[c+8>>2];J[i+16>>2]=g;J[i+20>>2]=h;J[i+8>>2]=e;J[i+12>>2]=f;J[i>>2]=j;j=dc(i+204|0,a,i+248|0,i);break f}J[i+32>>2]=e;J[i+36>>2]=f;J[i+40>>2]=g;J[i+44>>2]=h;j=dc(i+204|0,a,i+248|0,i+32|0);}if((j|0)==-1){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)==1){break d}break e}a=J[i+204>>2];tb(k,a);}g=a+j|0;h=Lb(a,g,J[c+4>>2]);J[i+116>>2]=184;e=i+120|0;J[e>>2]=0;J[e+4>>2]=J[i+116>>2];g:{h:{if((i+208|0)==(a|0)){j=i+128|0;break h}j=sb(j<<1);if(!j){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)!=1){break e}a=Z()|0;break g}tb(e,j);b=a;}a=i+108|0;f=J[c+28>>2];J[a>>2]=f;J[f+4>>2]=J[f+4>>2]+1;J[5996]=0;ma(212,b|0,h|0,g|0,j|0,i+116|0,i+112|0,a|0);b=J[5996];J[5996]=0;i:{if((b|0)!=1){a=J[a>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}J[5996]=0;a=ka(213,n|0,j|0,J[i+116>>2],J[i+112>>2],c|0,d|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break i}db(e);db(k);Ua=i+256|0;break b}a=Z()|0;b=J[i+108>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}break g}a=Z()|0;}db(e);break c}B();}a=Z()|0;}db(k);da(a|0);B();}return a|0}function Rk(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0;n=b;i=Ua-416|0;Ua=i;J[i+408>>2]=37;J[i+412>>2]=0;b=i+408|0;l=kd(b|1,3264,J[c+4>>2]);j=i+368|0;J[i+364>>2]=j;a=jb();a:{if(l){k=J[c+8>>2];m=i- -64|0;J[m>>2]=g;J[m+4>>2]=h;J[i+56>>2]=e;J[i+60>>2]=f;J[i+48>>2]=k;j=yb(j,30,a,b,i+48|0);break a}J[i+80>>2]=e;J[i+84>>2]=f;J[i+88>>2]=g;J[i+92>>2]=h;j=yb(i+368|0,30,a,i+408|0,i+80|0);}J[i+128>>2]=184;k=i+356|0;J[k>>2]=0;J[k+4>>2]=J[i+128>>2];b=i+368|0;a=b;b:{c:{d:{e:{if((j|0)>=30){a=jb();f:{if(l){j=J[c+8>>2];J[i+16>>2]=g;J[i+20>>2]=h;J[i+8>>2]=e;J[i+12>>2]=f;J[i>>2]=j;j=dc(i+364|0,a,i+408|0,i);break f}J[i+32>>2]=e;J[i+36>>2]=f;J[i+40>>2]=g;J[i+44>>2]=h;j=dc(i+364|0,a,i+408|0,i+32|0);}if((j|0)==-1){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)==1){break d}break e}a=J[i+364>>2];tb(k,a);}g=a+j|0;h=Lb(a,g,J[c+4>>2]);J[i+116>>2]=184;e=i+120|0;J[e>>2]=0;J[e+4>>2]=J[i+116>>2];g:{h:{if((i+368|0)==(a|0)){j=i+128|0;break h}j=sb(j<<3);if(!j){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)!=1){break e}a=Z()|0;break g}tb(e,j);b=a;}a=i+108|0;f=J[c+28>>2];J[a>>2]=f;J[f+4>>2]=J[f+4>>2]+1;J[5996]=0;ma(218,b|0,h|0,g|0,j|0,i+116|0,i+112|0,a|0);b=J[5996];J[5996]=0;i:{if((b|0)!=1){a=J[a>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}J[5996]=0;a=ka(219,n|0,j|0,J[i+116>>2],J[i+112>>2],c|0,d|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break i}db(e);db(k);Ua=i+416|0;break b}a=Z()|0;b=J[i+108>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}break g}a=Z()|0;}db(e);break c}B();}a=Z()|0;}db(k);da(a|0);B();}return a|0}function te(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0;H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;j=K[b+8|0]|K[b+9|0]<<8|(K[b+10|0]<<16|K[b+11|0]<<24);e=-29;f=K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24);h=f>>>0<29;a:{f=h?f:f-29|0;if(f>>>0>=29){J[5996]=0;aa(124,a|0,f+(f>>>1|0)|0);e=J[5996];J[5996]=0;if((e|0)==1){break a}d=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);g=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=g-29|0;}i=g>>>0<29;d=i?a+4|0:d;eb(f+d|0,d,i?g:e);e=f+(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))|0;H[a|0]=e;H[a+1|0]=e>>>8;H[a+2|0]=e>>>16;H[a+3|0]=e>>>24;b:{if(!f){break b}e=h?b+4|0:j;h=f&7;c:{if(!h){b=e;break c}g=0;b=e;while(1){H[d|0]=K[b|0];b=b+1|0;d=d+1|0;g=g+1|0;if((h|0)!=(g|0)){continue}break}}if(f>>>0<8){break b}e=e+f|0;while(1){H[d|0]=K[b|0];H[d+1|0]=K[b+1|0];H[d+2|0]=K[b+2|0];H[d+3|0]=K[b+3|0];H[d+4|0]=K[b+4|0];H[d+5|0]=K[b+5|0];H[d+6|0]=K[b+6|0];H[d+7|0]=K[b+7|0];d=d+8|0;b=b+8|0;if((e|0)!=(b|0)){continue}break}}b=J[c>>2];J[5996]=0;_(127,a|0,b|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}return}b=Z()|0;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0>=29){$a(K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24));H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;}da(b|0);B();}function zl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;d=J[d+28>>2];a=Ua-256|0;Ua=a;J[a+248>>2]=c;J[a+252>>2]=b;$d(a+192|0,d,a+208|0,a+207|0,a+206|0);d=a+180|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;b=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,b|0);b=J[5996];J[5996]=0;a:{b:{c:{if((b|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+176>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;H[a+7|0]=1;H[a+6|0]=69;h=K[a+206|0]<<24>>24;i=K[a+207|0]<<24>>24;while(1){d:{J[5996]=0;b=_(186,a+252|0,a+248|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(b){break c}b=K[d+11|0];b=(b&128)>>>7|0?J[d+4>>2]:b&127;if(J[a+176>>2]==(b+c|0)){J[5996]=0;aa(172,d|0,b<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+176>>2]=b+c;}J[5996]=0;b=$(187,J[a+252>>2])|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(_d(b,a+7|0,a+6|0,c,a+176|0,i,h,a+192|0,a+16|0,a+12|0,a+8|0,a+208|0)){break c}J[5996]=0;$(189,a+252|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){continue}}break}break b}break b}b=K[a+203|0];e:{if(!((b&128)>>>7|0?J[a+196>>2]:b&127)|!K[a+7|0]){break e}b=J[a+12>>2];if((b-(a+16|0)|0)>159){break e}J[a+12>>2]=b+4;J[b>>2]=J[a+8>>2];}N[f>>2]=Of(c,J[a+176>>2],e);zb(a+192|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(186,a+252|0,a+248|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+252>>2];ab(d);ab(a+192|0);Ua=a+256|0;break a}}b=Z()|0;ab(d);ab(a+192|0);da(b|0);B();}return b|0}function xl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;d=J[d+28>>2];a=Ua-256|0;Ua=a;J[a+248>>2]=c;J[a+252>>2]=b;$d(a+192|0,d,a+208|0,a+207|0,a+206|0);d=a+180|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;b=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,b|0);b=J[5996];J[5996]=0;a:{b:{c:{if((b|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+176>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;H[a+7|0]=1;H[a+6|0]=69;h=K[a+206|0]<<24>>24;i=K[a+207|0]<<24>>24;while(1){d:{J[5996]=0;b=_(186,a+252|0,a+248|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(b){break c}b=K[d+11|0];b=(b&128)>>>7|0?J[d+4>>2]:b&127;if(J[a+176>>2]==(b+c|0)){J[5996]=0;aa(172,d|0,b<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+176>>2]=b+c;}J[5996]=0;b=$(187,J[a+252>>2])|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(_d(b,a+7|0,a+6|0,c,a+176|0,i,h,a+192|0,a+16|0,a+12|0,a+8|0,a+208|0)){break c}J[5996]=0;$(189,a+252|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){continue}}break}break b}break b}b=K[a+203|0];e:{if(!((b&128)>>>7|0?J[a+196>>2]:b&127)|!K[a+7|0]){break e}b=J[a+12>>2];if((b-(a+16|0)|0)>159){break e}J[a+12>>2]=b+4;J[b>>2]=J[a+8>>2];}O[f>>3]=Mf(c,J[a+176>>2],e);zb(a+192|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(186,a+252|0,a+248|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+252>>2];ab(d);ab(a+192|0);Ua=a+256|0;break a}}b=Z()|0;ab(d);ab(a+192|0);da(b|0);B();}return b|0}function kc(a,b,c,d,e,f,g,h){var i=0,j=0,k=0;i=Ua-16|0;Ua=i;J[i+8>>2]=c;J[i+12>>2]=b;b=J[d+28>>2];J[i+4>>2]=b;J[b+4>>2]=J[b+4>>2]+1;c=0;J[5996]=0;j=$(170,J[i+4>>2])|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[i+4>>2];k=J[b+4>>2]-1|0;J[b+4>>2]=k;if((k|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}J[e>>2]=0;a:{while(1){if(c|(g|0)==(h|0)){break a}b:{if(Ub(i+12|0,i+8|0)){break b}c:{if((Xa[J[J[j>>2]+36>>2]](j,H[g|0],0)|0)==37){if((g+1|0)==(h|0)){break b}c=Xa[J[J[j>>2]+36>>2]](j,H[g+1|0],0)|0;d:{if(!((c|0)==69|(c&255)==48)){b=0;k=1;break d}if((g+2|0)==(h|0)){break b}b=c;c=Xa[J[J[j>>2]+36>>2]](j,H[g+2|0],0)|0;k=2;}J[i+12>>2]=Xa[J[J[a>>2]+36>>2]](a,J[i+12>>2],J[i+8>>2],d,e,f,c,b);g=(g+k|0)+1|0;break c}b=J[j+8>>2];c=H[g|0];if((c|0)>=0){c=J[b+((c&255)<<2)>>2]&1;}else {c=0;}if(c){while(1){e:{g=g+1|0;if((h|0)==(g|0)){g=h;break e}c=H[g|0];if((c|0)>=0){c=J[b+((c&255)<<2)>>2]&1;}else {c=0;}if(c){continue}}break}while(1){k=i+12|0;if(Ub(k,i+8|0)){break c}b=J[i+12>>2];c=J[b+12>>2];f:{if((c|0)==J[b+16>>2]){b=Xa[J[J[b>>2]+36>>2]](b)|0;break f}b=K[c|0];}c=J[j+8>>2];b=b<<24>>24;if((b|0)>=0){b=J[c+((b&255)<<2)>>2]&1;}else {b=0;}if(!b){break c}Ic(k);continue}}b=J[i+12>>2];c=J[b+12>>2];g:{if((c|0)==J[b+16>>2]){b=Xa[J[J[b>>2]+36>>2]](b)|0;break g}b=K[c|0];}if((Xa[J[J[j>>2]+12>>2]](j,b<<24>>24)|0)==(Xa[J[J[j>>2]+12>>2]](j,H[g|0])|0)){g=g+1|0;Ic(i+12|0);break c}J[e>>2]=4;}c=J[e>>2];continue}break}J[e>>2]=4;}if(Ub(i+12|0,i+8|0)){J[e>>2]=J[e>>2]|2;}Ua=i+16|0;return J[i+12>>2]}c=Z()|0;a=J[i+4>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function ml(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;d=J[d+28>>2];a=Ua-368|0;Ua=a;J[a+360>>2]=c;J[a+364>>2]=b;Xd(a+204|0,d,a+224|0,a+220|0,a+216|0);d=a+192|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;b=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,b|0);b=J[5996];J[5996]=0;a:{b:{c:{if((b|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+188>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;H[a+7|0]=1;H[a+6|0]=69;h=J[a+216>>2];i=J[a+220>>2];while(1){d:{J[5996]=0;b=_(202,a+364|0,a+360|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(b){break c}b=K[d+11|0];b=(b&128)>>>7|0?J[d+4>>2]:b&127;if(J[a+188>>2]==(b+c|0)){J[5996]=0;aa(172,d|0,b<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+188>>2]=b+c;}J[5996]=0;b=$(203,J[a+364>>2])|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(Wd(b,a+7|0,a+6|0,c,a+188|0,i,h,a+204|0,a+16|0,a+12|0,a+8|0,a+224|0)){break c}J[5996]=0;$(205,a+364|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){continue}}break}break b}break b}b=K[a+215|0];e:{if(!((b&128)>>>7|0?J[a+208>>2]:b&127)|!K[a+7|0]){break e}b=J[a+12>>2];if((b-(a+16|0)|0)>159){break e}J[a+12>>2]=b+4;J[b>>2]=J[a+8>>2];}N[f>>2]=Of(c,J[a+188>>2],e);zb(a+204|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(202,a+364|0,a+360|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+364>>2];ab(d);ab(a+204|0);Ua=a+368|0;break a}}b=Z()|0;ab(d);ab(a+204|0);da(b|0);B();}return b|0}function ll(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;d=J[d+28>>2];a=Ua-368|0;Ua=a;J[a+360>>2]=c;J[a+364>>2]=b;Xd(a+204|0,d,a+224|0,a+220|0,a+216|0);d=a+192|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;b=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,b|0);b=J[5996];J[5996]=0;a:{b:{c:{if((b|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+188>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;H[a+7|0]=1;H[a+6|0]=69;h=J[a+216>>2];i=J[a+220>>2];while(1){d:{J[5996]=0;b=_(202,a+364|0,a+360|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(b){break c}b=K[d+11|0];b=(b&128)>>>7|0?J[d+4>>2]:b&127;if(J[a+188>>2]==(b+c|0)){J[5996]=0;aa(172,d|0,b<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+188>>2]=b+c;}J[5996]=0;b=$(203,J[a+364>>2])|0;g=J[5996];J[5996]=0;if((g|0)==1){break d}if(Wd(b,a+7|0,a+6|0,c,a+188|0,i,h,a+204|0,a+16|0,a+12|0,a+8|0,a+224|0)){break c}J[5996]=0;$(205,a+364|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){continue}}break}break b}break b}b=K[a+215|0];e:{if(!((b&128)>>>7|0?J[a+208>>2]:b&127)|!K[a+7|0]){break e}b=J[a+12>>2];if((b-(a+16|0)|0)>159){break e}J[a+12>>2]=b+4;J[b>>2]=J[a+8>>2];}O[f>>3]=Mf(c,J[a+188>>2],e);zb(a+204|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(202,a+364|0,a+360|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+364>>2];ab(d);ab(a+204|0);Ua=a+368|0;break a}}b=Z()|0;ab(d);ab(a+204|0);da(b|0);B();}return b|0}function _c(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;a:{b:{if(a-1&a|b>>>0>4294967239){break b}while(1){a=a>>>0<=8?8:a;e=J[5995];f=J[5994];b=b>>>0<=8?8:b+3&-4;c:{if(b>>>0<=127){g=(b>>>3|0)-1|0;break c}d=S(b);g=((b>>>29-d^4)-(d<<2)|0)+110|0;if(b>>>0<=4095){break c}d=((b>>>30-d^2)-(d<<1)|0)+71|0;g=d>>>0>=63?63:d;}c=g&31;if((g&63)>>>0>=32){d=0;c=e>>>c|0;}else {d=e>>>c|0;c=((1<<c)-1&e)<<32-c|f>>>c;}if(c|d){while(1){e=c;d:{if(d|e){f=d-1|0;h=f+1|0;c=f;f=e-1|0;h=(f|0)!=-1?h:c;c=S(d^h);c=(c|0)==32?S(e^f)+32|0:c;f=63-c|0;Wa=0-(c>>>0>63)|0;break d}Wa=0;f=64;}h=f;f=h&31;if((h&63)>>>0>=32){c=0;f=d>>>f|0;}else {c=d>>>f|0;f=((1<<f)-1&d)<<32-f|e>>>f;}d=c;g=g+h|0;h=g<<4;e=J[h+22952>>2];i=h+22944|0;e:{if((e|0)!=(i|0)){c=ye(e,a,b);if(c){break b}c=J[e+4>>2];J[c+8>>2]=J[e+8>>2];J[J[e+8>>2]+4>>2]=c;J[e+8>>2]=i;c=h+22948|0;J[e+4>>2]=J[c>>2];J[c>>2]=e;J[J[e+4>>2]+8>>2]=e;g=g+1|0;c=(d&1)<<31|f>>>1;d=d>>>1|0;break e}c=J[5995];J[5994]=J[5994]&go(-2,-1,g);J[5995]=Wa&c;c=f^1;}if(d|c){continue}break}f=J[5994];e=J[5995];}f:{if(e|f){d=S(e);h=63-((d|0)==32?S(f)+32|0:d)|0;c=h<<4;d=J[c+22952>>2];g:{if(!e&f>>>0<1073741824){break g}g=99;e=c+22944|0;if((e|0)==(d|0)){break g}while(1){if(!g){break g}c=ye(d,a,b);if(c){break b}g=g-1|0;d=J[d+8>>2];if((e|0)!=(d|0)){continue}break}d=e;}if(Cd(b+48|0)){break f}if(!d){break a}e=(h<<4)+22944|0;if((e|0)==(d|0)){break a}while(1){c=ye(d,a,b);if(c){break b}d=J[d+8>>2];if((e|0)!=(d|0)){continue}break}break a}if(!Cd(b+48|0)){break a}}c=0;if(a-1&a){break b}if(b>>>0<=4294967239){continue}break}}return c}return 0}function ql(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;a=Ua-336|0;Ua=a;J[a+328>>2]=c;J[a+332>>2]=b;b=ec(J[d+4>>2]);i=Sc(J[d+28>>2],a+208|0);Rc(a+196|0,J[d+28>>2],a+324|0);d=a+184|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(202,a+332|0,a+328|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+180>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=g+c;}J[5996]=0;g=$(203,J[a+332>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Cc(g,b,c,a+180|0,a+8|0,J[a+324>>2],J[a+200>>2],K[a+207|0],a+16|0,a+12|0,i)){break c}J[5996]=0;$(205,a+332|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+207|0];e:{if(!((g&128)>>>7|0?J[a+200>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}J[f>>2]=Tf(c,J[a+180>>2],e,b);J[f+4>>2]=Wa;zb(a+196|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(202,a+332|0,a+328|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+332>>2];ab(d);ab(a+196|0);Ua=a+336|0;break a}}b=Z()|0;ab(d);ab(a+196|0);da(b|0);B();}return b|0}function ol(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;a=Ua-336|0;Ua=a;J[a+328>>2]=c;J[a+332>>2]=b;b=ec(J[d+4>>2]);i=Sc(J[d+28>>2],a+208|0);Rc(a+196|0,J[d+28>>2],a+324|0);d=a+184|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(202,a+332|0,a+328|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+180>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=g+c;}J[5996]=0;g=$(203,J[a+332>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Cc(g,b,c,a+180|0,a+8|0,J[a+324>>2],J[a+200>>2],K[a+207|0],a+16|0,a+12|0,i)){break c}J[5996]=0;$(205,a+332|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+207|0];e:{if(!((g&128)>>>7|0?J[a+200>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}J[f>>2]=Pf(c,J[a+180>>2],e,b);J[f+4>>2]=Wa;zb(a+196|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(202,a+332|0,a+328|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+332>>2];ab(d);ab(a+196|0);Ua=a+336|0;break a}}b=Z()|0;ab(d);ab(a+196|0);da(b|0);B();}return b|0}function sl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;a=Ua-336|0;Ua=a;J[a+328>>2]=c;J[a+332>>2]=b;b=ec(J[d+4>>2]);i=Sc(J[d+28>>2],a+208|0);Rc(a+196|0,J[d+28>>2],a+324|0);d=a+184|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(202,a+332|0,a+328|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+180>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=g+c;}J[5996]=0;g=$(203,J[a+332>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Cc(g,b,c,a+180|0,a+8|0,J[a+324>>2],J[a+200>>2],K[a+207|0],a+16|0,a+12|0,i)){break c}J[5996]=0;$(205,a+332|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+207|0];e:{if(!((g&128)>>>7|0?J[a+200>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}J[f>>2]=Yf(c,J[a+180>>2],e,b);zb(a+196|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(202,a+332|0,a+328|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+332>>2];ab(d);ab(a+196|0);Ua=a+336|0;break a}}b=Z()|0;ab(d);ab(a+196|0);da(b|0);B();}return b|0}function pl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;a=Ua-336|0;Ua=a;J[a+328>>2]=c;J[a+332>>2]=b;b=ec(J[d+4>>2]);i=Sc(J[d+28>>2],a+208|0);Rc(a+196|0,J[d+28>>2],a+324|0);d=a+184|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(202,a+332|0,a+328|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+180>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=g+c;}J[5996]=0;g=$(203,J[a+332>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Cc(g,b,c,a+180|0,a+8|0,J[a+324>>2],J[a+200>>2],K[a+207|0],a+16|0,a+12|0,i)){break c}J[5996]=0;$(205,a+332|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+207|0];e:{if(!((g&128)>>>7|0?J[a+200>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}I[f>>1]=Sf(c,J[a+180>>2],e,b);zb(a+196|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(202,a+332|0,a+328|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+332>>2];ab(d);ab(a+196|0);Ua=a+336|0;break a}}b=Z()|0;ab(d);ab(a+196|0);da(b|0);B();}return b|0}function Jf(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;a=Ua-336|0;Ua=a;J[a+328>>2]=c;J[a+332>>2]=b;b=ec(J[d+4>>2]);i=Sc(J[d+28>>2],a+208|0);Rc(a+196|0,J[d+28>>2],a+324|0);d=a+184|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(202,a+332|0,a+328|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+180>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+180>>2]=g+c;}J[5996]=0;g=$(203,J[a+332>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Cc(g,b,c,a+180|0,a+8|0,J[a+324>>2],J[a+200>>2],K[a+207|0],a+16|0,a+12|0,i)){break c}J[5996]=0;$(205,a+332|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+207|0];e:{if(!((g&128)>>>7|0?J[a+200>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}J[f>>2]=Qf(c,J[a+180>>2],e,b);zb(a+196|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(202,a+332|0,a+328|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+332>>2];ab(d);ab(a+196|0);Ua=a+336|0;break a}}b=Z()|0;ab(d);ab(a+196|0);da(b|0);B();}return b|0}function Cl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=J[d+4>>2];d=J[d+28>>2];a=Ua-224|0;Ua=a;J[a+216>>2]=c;J[a+220>>2]=b;b=ec(g);Tc(a+200|0,d,a+215|0);d=a+188|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(186,a+220|0,a+216|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+184>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=g+c;}J[5996]=0;g=$(187,J[a+220>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Dc(g,b,c,a+184|0,a+8|0,H[a+215|0],J[a+204>>2],K[a+211|0],a+16|0,a+12|0,12416)){break c}J[5996]=0;$(189,a+220|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+211|0];e:{if(!((g&128)>>>7|0?J[a+204>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}J[f>>2]=Tf(c,J[a+184>>2],e,b);J[f+4>>2]=Wa;zb(a+200|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(186,a+220|0,a+216|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+220>>2];ab(d);ab(a+200|0);Ua=a+224|0;break a}}b=Z()|0;ab(d);ab(a+200|0);da(b|0);B();}return b|0}function Al(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=J[d+4>>2];d=J[d+28>>2];a=Ua-224|0;Ua=a;J[a+216>>2]=c;J[a+220>>2]=b;b=ec(g);Tc(a+200|0,d,a+215|0);d=a+188|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(186,a+220|0,a+216|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+184>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=g+c;}J[5996]=0;g=$(187,J[a+220>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Dc(g,b,c,a+184|0,a+8|0,H[a+215|0],J[a+204>>2],K[a+211|0],a+16|0,a+12|0,12416)){break c}J[5996]=0;$(189,a+220|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+211|0];e:{if(!((g&128)>>>7|0?J[a+204>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}J[f>>2]=Pf(c,J[a+184>>2],e,b);J[f+4>>2]=Wa;zb(a+200|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(186,a+220|0,a+216|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+220>>2];ab(d);ab(a+200|0);Ua=a+224|0;break a}}b=Z()|0;ab(d);ab(a+200|0);da(b|0);B();}return b|0}function Vc(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;a:{if(!a){a=_c(8,b);break a}if(!b){$a(a);a=0;break a}b:{if(b>>>0>4294967239){break b}h=b>>>0<=8?8:b+3&-4;b=h+8|0;c:{d:{k=a-4|0;f=k;e=J[f>>2];c=e+f|0;j=J[c>>2];g=j+c|0;e:{f:{if(J[g-4>>2]!=(j|0)){d=b+f|0;if(d+16>>>0<=g>>>0){e=J[c+4>>2];J[e+8>>2]=J[c+8>>2];J[J[c+8>>2]+4>>2]=e;c=g-d|0;J[d>>2]=c;J[(d+(c&-4)|0)-4>>2]=c|1;e=J[d>>2]-8|0;g:{if(e>>>0<=127){c=(e>>>3|0)-1|0;break g}g=S(e);c=((e>>>29-g^4)-(g<<2)|0)+110|0;if(e>>>0<=4095){break g}c=((e>>>30-g^2)-(g<<1)|0)+71|0;c=c>>>0>=63?63:c;}e=c<<4;J[d+4>>2]=e+22944;e=e+22952|0;J[d+8>>2]=J[e>>2];J[e>>2]=d;J[J[d+8>>2]+4>>2]=d;e=J[5995];d=c&31;if((c&63)>>>0>=32){c=1<<d;g=0;}else {g=1<<d;c=g-1&1>>>32-d;}J[5994]=g|J[5994];J[5995]=c|e;J[f>>2]=b;break d}if(d>>>0>g>>>0){break f}b=J[c+4>>2];J[b+8>>2]=J[c+8>>2];J[J[c+8>>2]+4>>2]=b;b=e+j|0;J[f>>2]=b;break d}if(e>>>0>=b+16>>>0){J[f>>2]=b;J[(f+(b&-4)|0)-4>>2]=b;d=b+f|0;b=e-b|0;J[d>>2]=b;J[(d+(b&-4)|0)-4>>2]=b|1;c=J[d>>2]-8|0;h:{if(c>>>0<=127){b=(c>>>3|0)-1|0;break h}f=S(c);b=((c>>>29-f^4)-(f<<2)|0)+110|0;if(c>>>0<=4095){break h}b=((c>>>30-f^2)-(f<<1)|0)+71|0;b=b>>>0>=63?63:b;}c=b<<4;J[d+4>>2]=c+22944;c=c+22952|0;J[d+8>>2]=J[c>>2];J[c>>2]=d;J[J[d+8>>2]+4>>2]=d;c=J[5995];d=b&31;if((b&63)>>>0>=32){b=1<<d;e=0;}else {e=1<<d;b=e-1&1>>>32-d;}J[5994]=e|J[5994];J[5995]=b|c;d=1;break c}d=1;if(b>>>0<=e>>>0){break e}}d=0;}break c}J[(f+(b&-4)|0)-4>>2]=b;d=1;}if(d){break a}b=_c(8,h);if(!b){break b}i=J[k>>2]-8|0;fb(b,a,h>>>0<i>>>0?h:i);$a(a);i=b;}a=i;}return a}function an(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0;d=Ua-160|0;Ua=d;J[d+72>>2]=8356;J[d+16>>2]=8336;h=d+72|0;c=h;J[c+20>>2]=0;e=d+20|0;J[c+24>>2]=e;J[c+12>>2]=0;J[c+4>>2]=4098;J[c+8>>2]=6;J[c+16>>2]=!e;Sb(c+32|0,0,40);yg(c+28|0);J[d+72>>2]=8316;J[d+16>>2]=8296;J[d+144>>2]=0;J[d+148>>2]=-1;J[e>>2]=7896;yg(e+4|0);J[e+24>>2]=0;J[e+28>>2]=0;J[e+16>>2]=0;J[e+20>>2]=0;J[e+8>>2]=0;J[e+12>>2]=0;J[e>>2]=7960;J[d+60>>2]=0;J[d+64>>2]=0;J[d+52>>2]=0;J[d+56>>2]=0;J[d+68>>2]=16;c=J[J[d+16>>2]-12>>2];J[5996]=0;g=Ca(129)|0;f=J[5996];J[5996]=0;a:{b:{if((f|0)==1){break b}f=c+(d+16|0)|0;c=J[f+28>>2];J[d+12>>2]=c;J[c+4>>2]=J[c+4>>2]+1;J[5996]=0;ea(130,d+156|0,f|0,g|0);c=J[5996];J[5996]=0;c:{if((c|0)==1){break c}c=J[d+156>>2];i=J[c+4>>2]-1|0;J[c+4>>2]=i;if((i|0)==-1){Xa[J[J[c>>2]+8>>2]](c);}c=J[f+24>>2];if(c){f=J[J[c>>2]+8>>2];J[5996]=0;aa(f|0,c|0,g|0);f=J[5996];J[5996]=0;if((f|0)==1){break c}f=J[c+4>>2];J[d+152>>2]=f;J[f+4>>2]=J[f+4>>2]+1;Og(c+4|0,g);c=J[d+152>>2];g=J[c+4>>2]-1|0;J[c+4>>2]=g;if((g|0)==-1){Xa[J[J[c>>2]+8>>2]](c);}}c=J[d+12>>2];g=J[c+4>>2]-1|0;J[c+4>>2]=g;if((g|0)==-1){Xa[J[J[c>>2]+8>>2]](c);}b=J[b>>2];J[5996]=0;b=_(131,d+16|0,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break b}J[5996]=0;aa(132,a|0,e|0);a=J[5996];J[5996]=0;if((a|0)==1){break b}J[b>>2]=8296;J[d+72>>2]=8316;J[e>>2]=7960;if(H[b+47|0]<0){$a(J[d+52>>2]);}Qc(e);Od(h);Ua=d+160|0;return}a=Z()|0;b=J[d+12>>2];e=J[b+4>>2]-1|0;J[b+4>>2]=e;if((e|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}break a}a=Z()|0;}gd(d+16|0);da(a|0);B();}
function Rf(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=J[d+4>>2];d=J[d+28>>2];a=Ua-224|0;Ua=a;J[a+216>>2]=c;J[a+220>>2]=b;b=ec(g);Tc(a+200|0,d,a+215|0);d=a+188|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(186,a+220|0,a+216|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+184>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=g+c;}J[5996]=0;g=$(187,J[a+220>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Dc(g,b,c,a+184|0,a+8|0,H[a+215|0],J[a+204>>2],K[a+211|0],a+16|0,a+12|0,12416)){break c}J[5996]=0;$(189,a+220|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+211|0];e:{if(!((g&128)>>>7|0?J[a+204>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}J[f>>2]=Qf(c,J[a+184>>2],e,b);zb(a+200|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(186,a+220|0,a+216|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+220>>2];ab(d);ab(a+200|0);Ua=a+224|0;break a}}b=Z()|0;ab(d);ab(a+200|0);da(b|0);B();}return b|0}function Dl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=J[d+4>>2];d=J[d+28>>2];a=Ua-224|0;Ua=a;J[a+216>>2]=c;J[a+220>>2]=b;b=ec(g);Tc(a+200|0,d,a+215|0);d=a+188|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(186,a+220|0,a+216|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+184>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=g+c;}J[5996]=0;g=$(187,J[a+220>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Dc(g,b,c,a+184|0,a+8|0,H[a+215|0],J[a+204>>2],K[a+211|0],a+16|0,a+12|0,12416)){break c}J[5996]=0;$(189,a+220|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+211|0];e:{if(!((g&128)>>>7|0?J[a+204>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}J[f>>2]=Yf(c,J[a+184>>2],e,b);zb(a+200|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(186,a+220|0,a+216|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+220>>2];ab(d);ab(a+200|0);Ua=a+224|0;break a}}b=Z()|0;ab(d);ab(a+200|0);da(b|0);B();}return b|0}function Bl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=J[d+4>>2];d=J[d+28>>2];a=Ua-224|0;Ua=a;J[a+216>>2]=c;J[a+220>>2]=b;b=ec(g);Tc(a+200|0,d,a+215|0);d=a+188|0;J[d>>2]=0;J[d+4>>2]=0;J[d+8>>2]=0;c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=c;J[a+12>>2]=a+16;J[a+8>>2]=0;while(1){d:{J[5996]=0;g=_(186,a+220|0,a+216|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(g){break c}g=K[d+11|0];g=(g&128)>>>7|0?J[d+4>>2]:g&127;if(J[a+184>>2]==(g+c|0)){J[5996]=0;aa(172,d|0,g<<1);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?(J[d+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,d|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break b}c=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+184>>2]=g+c;}J[5996]=0;g=$(187,J[a+220>>2])|0;h=J[5996];J[5996]=0;if((h|0)==1){break d}if(Dc(g,b,c,a+184|0,a+8|0,H[a+215|0],J[a+204>>2],K[a+211|0],a+16|0,a+12|0,12416)){break c}J[5996]=0;$(189,a+220|0)|0;g=J[5996];J[5996]=0;if((g|0)!=1){continue}}break}break b}break b}g=K[a+211|0];e:{if(!((g&128)>>>7|0?J[a+204>>2]:g&127)){break e}g=J[a+12>>2];if((g-(a+16|0)|0)>159){break e}J[a+12>>2]=g+4;J[g>>2]=J[a+8>>2];}I[f>>1]=Sf(c,J[a+184>>2],e,b);zb(a+200|0,a+16|0,J[a+12>>2],e);J[5996]=0;b=_(186,a+220|0,a+216|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if(b){J[e>>2]=J[e>>2]|2;}b=J[a+220>>2];ab(d);ab(a+200|0);Ua=a+224|0;break a}}b=Z()|0;ab(d);ab(a+200|0);da(b|0);B();}return b|0}function jc(a,b,c,d,e,f,g,h){var i=0,j=0,k=0;i=Ua-16|0;Ua=i;J[i+8>>2]=c;J[i+12>>2]=b;b=J[d+28>>2];J[i+4>>2]=b;J[b+4>>2]=J[b+4>>2]+1;b=0;J[5996]=0;j=$(197,J[i+4>>2])|0;c=J[5996];J[5996]=0;if((c|0)!=1){c=J[i+4>>2];k=J[c+4>>2]-1|0;J[c+4>>2]=k;if((k|0)==-1){Xa[J[J[c>>2]+8>>2]](c);}J[e>>2]=0;a:{while(1){if(b|(g|0)==(h|0)){break a}b:{if(Tb(i+12|0,i+8|0)){break b}c:{if((Xa[J[J[j>>2]+52>>2]](j,J[g>>2],0)|0)==37){if((g+4|0)==(h|0)){break b}b=Xa[J[J[j>>2]+52>>2]](j,J[g+4>>2],0)|0;d:{if(!((b|0)==69|(b&255)==48)){c=0;k=1;break d}if((g+8|0)==(h|0)){break b}c=b;b=Xa[J[J[j>>2]+52>>2]](j,J[g+8>>2],0)|0;k=2;}J[i+12>>2]=Xa[J[J[a>>2]+36>>2]](a,J[i+12>>2],J[i+8>>2],d,e,f,b,c);g=((k<<2)+g|0)+4|0;break c}if(Xa[J[J[j>>2]+12>>2]](j,1,J[g>>2])|0){while(1){e:{g=g+4|0;if((h|0)==(g|0)){g=h;break e}if(Xa[J[J[j>>2]+12>>2]](j,1,J[g>>2])|0){continue}}break}while(1){k=i+12|0;if(Tb(k,i+8|0)){break c}b=J[i+12>>2];c=J[b+12>>2];f:{if((c|0)==J[b+16>>2]){b=Xa[J[J[b>>2]+36>>2]](b)|0;break f}b=J[c>>2];}if(!(Xa[J[J[j>>2]+12>>2]](j,1,b)|0)){break c}Hc(k);continue}}b=J[i+12>>2];c=J[b+12>>2];g:{if((c|0)==J[b+16>>2]){b=Xa[J[J[b>>2]+36>>2]](b)|0;break g}b=J[c>>2];}if((Xa[J[J[j>>2]+28>>2]](j,b)|0)==(Xa[J[J[j>>2]+28>>2]](j,J[g>>2])|0)){g=g+4|0;Hc(i+12|0);break c}J[e>>2]=4;}b=J[e>>2];continue}break}J[e>>2]=4;}if(Tb(i+12|0,i+8|0)){J[e>>2]=J[e>>2]|2;}Ua=i+16|0;return J[i+12>>2]}c=Z()|0;a=J[i+4>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function cl(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;l=b;f=Ua-208|0;Ua=f;J[f+200>>2]=37;J[f+204>>2]=0;b=f+200|0;h=kd(b|1,5575,J[c+4>>2]);g=f+160|0;J[f+156>>2]=g;a=jb();a:{if(h){i=J[c+8>>2];O[f+40>>3]=e;J[f+32>>2]=i;g=yb(g,30,a,b,f+32|0);break a}O[f+48>>3]=e;g=yb(f+160|0,30,a,f+200|0,f+48|0);}J[f+80>>2]=184;i=f+148|0;J[i>>2]=0;J[i+4>>2]=J[f+80>>2];b=f+160|0;a=b;b:{c:{d:{e:{if((g|0)>=30){a=jb();f:{if(h){g=J[c+8>>2];O[f+8>>3]=e;J[f>>2]=g;g=dc(f+156|0,a,f+200|0,f);break f}O[f+16>>3]=e;g=dc(f+156|0,a,f+200|0,f+16|0);}if((g|0)==-1){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)==1){break d}break e}a=J[f+156>>2];tb(i,a);}k=a+g|0;m=Lb(a,k,J[c+4>>2]);J[f+68>>2]=184;h=f+72|0;J[h>>2]=0;J[h+4>>2]=J[f+68>>2];g:{h:{if((f+160|0)==(a|0)){g=f+80|0;break h}g=sb(g<<1);if(!g){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)!=1){break e}a=Z()|0;break g}tb(h,g);b=a;}a=f+60|0;j=J[c+28>>2];J[a>>2]=j;J[j+4>>2]=J[j+4>>2]+1;J[5996]=0;ma(212,b|0,m|0,k|0,g|0,f+68|0,f- -64|0,a|0);b=J[5996];J[5996]=0;i:{if((b|0)!=1){a=J[a>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}J[5996]=0;a=ka(213,l|0,g|0,J[f+68>>2],J[f+64>>2],c|0,d|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break i}db(h);db(i);Ua=f+208|0;break b}a=Z()|0;b=J[f+60>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}break g}a=Z()|0;}db(h);break c}B();}a=Z()|0;}db(i);da(a|0);B();}return a|0}function Tk(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;l=b;f=Ua-368|0;Ua=f;J[f+360>>2]=37;J[f+364>>2]=0;b=f+360|0;h=kd(b|1,5575,J[c+4>>2]);g=f+320|0;J[f+316>>2]=g;a=jb();a:{if(h){i=J[c+8>>2];O[f+40>>3]=e;J[f+32>>2]=i;g=yb(g,30,a,b,f+32|0);break a}O[f+48>>3]=e;g=yb(f+320|0,30,a,f+360|0,f+48|0);}J[f+80>>2]=184;i=f+308|0;J[i>>2]=0;J[i+4>>2]=J[f+80>>2];b=f+320|0;a=b;b:{c:{d:{e:{if((g|0)>=30){a=jb();f:{if(h){g=J[c+8>>2];O[f+8>>3]=e;J[f>>2]=g;g=dc(f+316|0,a,f+360|0,f);break f}O[f+16>>3]=e;g=dc(f+316|0,a,f+360|0,f+16|0);}if((g|0)==-1){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)==1){break d}break e}a=J[f+316>>2];tb(i,a);}k=a+g|0;m=Lb(a,k,J[c+4>>2]);J[f+68>>2]=184;h=f+72|0;J[h>>2]=0;J[h+4>>2]=J[f+68>>2];g:{h:{if((f+320|0)==(a|0)){g=f+80|0;break h}g=sb(g<<3);if(!g){J[5996]=0;ca(185);a=J[5996];J[5996]=0;if((a|0)!=1){break e}a=Z()|0;break g}tb(h,g);b=a;}a=f+60|0;j=J[c+28>>2];J[a>>2]=j;J[j+4>>2]=J[j+4>>2]+1;J[5996]=0;ma(218,b|0,m|0,k|0,g|0,f+68|0,f- -64|0,a|0);b=J[5996];J[5996]=0;i:{if((b|0)!=1){a=J[a>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}J[5996]=0;a=ka(219,l|0,g|0,J[f+68>>2],J[f+64>>2],c|0,d|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break i}db(h);db(i);Ua=f+368|0;break b}a=Z()|0;b=J[f+60>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}break g}a=Z()|0;}db(h);break c}B();}a=Z()|0;}db(i);da(a|0);B();}return a|0}function Gi(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;n=Ua-16|0;Ua=n;b=c;while(1){a:{if((b|0)==(d|0)){b=d;break a}if(!J[b>>2]){break a}b=b+4|0;continue}break}J[h>>2]=f;J[e>>2]=c;while(1){b:{c:{if(!((c|0)==(d|0)|(f|0)==(g|0))){q=1;r=Ua-16|0;Ua=r;s=Xb(r+12|0,J[a+8>>2]);i=f;j=g-i|0;m=0;o=Ua-16|0;Ua=o;k=J[e>>2];p=b-c>>2;d:{if(!k|!p){break d}j=i?j:0;while(1){l=pe(j>>>0<4?o+12|0:i,J[k>>2]);if((l|0)==-1){m=-1;break d}if(i){if(j>>>0<=3){if(j>>>0<l>>>0){break d}fb(i,o+12|0,l);}j=j-l|0;i=i+l|0;}else {i=0;}if(!J[k>>2]){k=0;break d}m=m+l|0;k=k+4|0;p=p-1|0;if(p){continue}break}}if(i){J[e>>2]=k;}Ua=o+16|0;i=J[s>>2];if(i){J[6178]=(i|0)==-1?24816:i;}Ua=r+16|0;e:{f:{g:{h:{switch(m+1|0){case 0:J[h>>2]=f;while(1){i:{if(J[e>>2]==(c|0)){break i}b=Md(f,J[c>>2],J[a+8>>2]);if((b|0)==-1){break i}f=b+J[h>>2]|0;J[h>>2]=f;c=c+4|0;continue}break}J[e>>2]=c;break g;case 1:break c;default:break h}}f=m+J[h>>2]|0;J[h>>2]=f;if((f|0)==(g|0)){break e}if((b|0)==(d|0)){c=J[e>>2];b=d;continue}b=Md(n+12|0,0,J[a+8>>2]);if((b|0)!=-1){break f}}q=2;break c}c=n+12|0;if(g-J[h>>2]>>>0<b>>>0){break c}while(1){if(b){f=K[c|0];i=J[h>>2];J[h>>2]=i+1;H[i|0]=f;b=b-1|0;c=c+1|0;continue}break}c=J[e>>2]+4|0;J[e>>2]=c;b=c;while(1){if((b|0)==(d|0)){b=d;break b}if(!J[b>>2]){break b}b=b+4|0;continue}}c=J[e>>2];}q=(c|0)!=(d|0);}Ua=n+16|0;return q|0}f=J[h>>2];continue}}function Yk(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;k=Ua-16|0;Ua=k;m=je(J[g>>2]);g=Zd(J[g>>2]);Xa[J[J[g>>2]+20>>2]](k+4|0,g);a:{j=K[k+15|0];b:{if(!((j&128)>>>7|0?J[k+8>>2]:j&127)){J[5996]=0;ga(208,m|0,a|0,c|0,d|0);g=J[5996];J[5996]=0;if((g|0)==1){break b}g=(c-a<<2)+d|0;J[f>>2]=g;break a}J[f>>2]=d;c:{d:{j=a;i=K[j|0];switch(i-43|0){case 0:case 2:break d;default:break c}}J[5996]=0;j=_(216,m|0,i<<24>>24)|0;i=J[5996];J[5996]=0;if((i|0)==1){break b}i=J[f>>2];J[f>>2]=i+4;J[i>>2]=j;j=a+1|0;}if(!(K[j|0]!=48|(c-j|0)<2|(K[j+1|0]|32)!=120)){J[5996]=0;i=_(216,m|0,48)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}h=J[f>>2];J[f>>2]=h+4;J[h>>2]=i;i=H[j+1|0];J[5996]=0;i=_(216,m|0,i|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}h=J[f>>2];J[f>>2]=h+4;J[h>>2]=i;j=j+2|0;}vc(j,c);J[5996]=0;o=$(206,g|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break b}i=0;g=j;while(1){if(c>>>0<=g>>>0){md((j-a<<2)+d|0,J[f>>2]);g=J[f>>2];break a}h=k+4|0;l=(K[h+11|0]&128)>>>7|0;if(!(!K[(l?J[h>>2]:h)+i|0]|H[(l?J[h>>2]:h)+i|0]!=(n|0))){h=J[f>>2];J[f>>2]=h+4;J[h>>2]=o;n=0;l=i;i=K[k+15|0];i=l+(l>>>0<((i&128)>>>7|0?J[k+8>>2]:i&127)-1>>>0)|0;}h=H[g|0];J[5996]=0;h=_(216,m|0,h|0)|0;l=J[5996];J[5996]=0;if((l|0)!=1){l=J[f>>2];J[f>>2]=l+4;J[l>>2]=h;g=g+1|0;n=n+1|0;continue}break}}a=Z()|0;ab(k+4|0);da(a|0);B();}J[e>>2]=(b|0)==(c|0)?g:(b-a<<2)+d|0;ab(k+4|0);Ua=k+16|0;}function gl(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;k=Ua-16|0;Ua=k;m=le(J[g>>2]);g=de(J[g>>2]);Xa[J[J[g>>2]+20>>2]](k+4|0,g);a:{j=K[k+15|0];b:{if(!((j&128)>>>7|0?J[k+8>>2]:j&127)){J[5996]=0;ga(195,m|0,a|0,c|0,d|0);g=J[5996];J[5996]=0;if((g|0)==1){break b}g=(c-a|0)+d|0;J[f>>2]=g;break a}J[f>>2]=d;c:{d:{j=a;i=K[j|0];switch(i-43|0){case 0:case 2:break d;default:break c}}J[5996]=0;j=_(171,m|0,i<<24>>24)|0;i=J[5996];J[5996]=0;if((i|0)==1){break b}i=J[f>>2];J[f>>2]=i+1;H[i|0]=j;j=a+1|0;}if(!(K[j|0]!=48|(c-j|0)<2|(K[j+1|0]|32)!=120)){J[5996]=0;i=_(171,m|0,48)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}h=J[f>>2];J[f>>2]=h+1;H[h|0]=i;i=H[j+1|0];J[5996]=0;i=_(171,m|0,i|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}h=J[f>>2];J[f>>2]=h+1;H[h|0]=i;j=j+2|0;}vc(j,c);J[5996]=0;o=$(193,g|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break b}i=0;g=j;while(1){if(c>>>0<=g>>>0){vc((j-a|0)+d|0,J[f>>2]);g=J[f>>2];break a}h=k+4|0;l=(K[h+11|0]&128)>>>7|0;if(!(!K[(l?J[h>>2]:h)+i|0]|H[(l?J[h>>2]:h)+i|0]!=(n|0))){h=J[f>>2];J[f>>2]=h+1;H[h|0]=o;n=0;l=i;i=K[k+15|0];i=l+(l>>>0<((i&128)>>>7|0?J[k+8>>2]:i&127)-1>>>0)|0;}h=H[g|0];J[5996]=0;h=_(171,m|0,h|0)|0;l=J[5996];J[5996]=0;if((l|0)!=1){l=J[f>>2];J[f>>2]=l+1;H[l|0]=h;g=g+1|0;n=n+1|0;continue}break}}a=Z()|0;ab(k+4|0);da(a|0);B();}J[e>>2]=(b|0)==(c|0)?g:(b-a|0)+d|0;ab(k+4|0);Ua=k+16|0;}function Pe(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0;a=Ua-16|0;Ua=a;J[a+12>>2]=c;J[a+8>>2]=f;J[a+12>>2]=c;J[a+8>>2]=f;a:{b:{c:{while(1){c=J[a+12>>2];if(!(c>>>0>=d>>>0|f>>>0>=g>>>0)){i=H[c|0];j=i&255;d:{if((i|0)>=0){I[f>>1]=j;b=c+1|0;break d}b=2;if(i>>>0<4294967234){break b}if(i>>>0<=4294967263){if((d-c|0)<2){break c}i=K[c+1|0];if((i&192)!=128){break a}I[f>>1]=i&63|j<<6&1984;b=c+2|0;break d}if(i>>>0<=4294967279){if((d-c|0)<3){break c}k=K[c+2|0];i=K[c+1|0];e:{f:{if((j|0)!=237){if((j|0)!=224){break f}if((i&224)==160){break e}break a}if((i&224)==128){break e}break a}if((i&192)!=128){break a}}if((k&192)!=128){break a}I[f>>1]=k&63|((i&63)<<6|j<<12);b=c+3|0;break d}if(i>>>0>4294967284){break b}b=1;if((d-c|0)<4){break a}k=K[c+3|0];i=K[c+2|0];c=K[c+1|0];g:{h:{switch(j-240|0){case 0:if((c+112&255)>>>0>=48){break b}break g;case 4:if((c&240)!=128){break b}break g;default:break h}}if((c&192)!=128){break b}}if((i&192)!=128|(k&192)!=128){break b}if((g-f|0)<4){break a}b=2;j=j&7;if((c<<12&196608|j<<18)>>>0>1114111){break a}b=c<<2;I[f>>1]=(i>>>4&3|(b&192|j<<8|b&60))+16320|55296;J[a+8>>2]=f+2;I[f+2>>1]=i<<6&960|k&63|56320;b=J[a+12>>2]+4|0;}J[a+12>>2]=b;f=J[a+8>>2]+2|0;J[a+8>>2]=f;continue}break}b=c>>>0<d>>>0;break a}b=1;break a}b=2;}J[e>>2]=J[a+12>>2];J[h>>2]=J[a+8>>2];Ua=a+16|0;return b|0}function tl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=Ua-32|0;Ua=g;J[g+28>>2]=b;a:{b:{if(!(H[d+4|0]&1)){J[g>>2]=-1;b=Xa[J[J[a>>2]+16>>2]](a,b,c,d,e,g)|0;c:{switch(J[g>>2]){case 1:H[f|0]=1;break a;case 0:break b;default:break c}}H[f|0]=1;J[e>>2]=4;break a}a=J[d+28>>2];J[g>>2]=a;J[a+4>>2]=J[a+4>>2]+1;J[5996]=0;h=$(197,J[g>>2])|0;a=J[5996];J[5996]=0;d:{e:{f:{g:{if((a|0)!=1){a=J[g>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=J[d+28>>2];J[g>>2]=a;J[a+4>>2]=J[a+4>>2]+1;J[5996]=0;b=$(198,J[g>>2])|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}a=J[g>>2];d=J[a+4>>2]-1|0;J[a+4>>2]=d;if((d|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}J[5996]=0;aa(199,g|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){b=Z()|0;break d}J[5996]=0;aa(200,g|12,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break f}J[5996]=0;d=g+24|0;a=Ba(201,g+28|0,c|0,g|0,d|0,h|0,e|0,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break e}H[f|0]=(a|0)==(g|0);b=J[g+28>>2];while(1){d=ab(d-12|0);if((g|0)!=(d|0)){continue}break}break a}b=Z()|0;a=J[g>>2];c=J[a+4>>2]-1|0;J[a+4>>2]=c;if((c|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}break d}b=Z()|0;a=J[g>>2];c=J[a+4>>2]-1|0;J[a+4>>2]=c;if((c|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}break d}b=Z()|0;ab(g);break d}b=Z()|0;while(1){d=ab(d-12|0);if((g|0)!=(d|0)){continue}break}}da(b|0);B();}H[f|0]=0;}Ua=g+32|0;return b|0}function Hl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=Ua-32|0;Ua=g;J[g+28>>2]=b;a:{b:{if(!(H[d+4|0]&1)){J[g>>2]=-1;b=Xa[J[J[a>>2]+16>>2]](a,b,c,d,e,g)|0;c:{switch(J[g>>2]){case 1:H[f|0]=1;break a;case 0:break b;default:break c}}H[f|0]=1;J[e>>2]=4;break a}a=J[d+28>>2];J[g>>2]=a;J[a+4>>2]=J[a+4>>2]+1;J[5996]=0;h=$(170,J[g>>2])|0;a=J[5996];J[5996]=0;d:{e:{f:{g:{if((a|0)!=1){a=J[g>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=J[d+28>>2];J[g>>2]=a;J[a+4>>2]=J[a+4>>2]+1;J[5996]=0;b=$(180,J[g>>2])|0;a=J[5996];J[5996]=0;if((a|0)==1){break g}a=J[g>>2];d=J[a+4>>2]-1|0;J[a+4>>2]=d;if((d|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}J[5996]=0;aa(181,g|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){b=Z()|0;break d}J[5996]=0;aa(182,g|12,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break f}J[5996]=0;d=g+24|0;a=Ba(183,g+28|0,c|0,g|0,d|0,h|0,e|0,1)|0;b=J[5996];J[5996]=0;if((b|0)==1){break e}H[f|0]=(a|0)==(g|0);b=J[g+28>>2];while(1){d=ab(d-12|0);if((g|0)!=(d|0)){continue}break}break a}b=Z()|0;a=J[g>>2];c=J[a+4>>2]-1|0;J[a+4>>2]=c;if((c|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}break d}b=Z()|0;a=J[g>>2];c=J[a+4>>2]-1|0;J[a+4>>2]=c;if((c|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}break d}b=Z()|0;ab(g);break d}b=Z()|0;while(1){d=ab(d-12|0);if((g|0)!=(d|0)){continue}break}}da(b|0);B();}H[f|0]=0;}Ua=g+32|0;return b|0}function Lm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Ua-32|0;Ua=e;a:{b:{c:{if((c|0)<=0){break c}while(1){h=b+g|0;if(K[h|0]!=41){g=g+1|0;if((c|0)!=(g|0)){continue}break c}break}if(g){break b}}H[a+16|0]=0;H[a|0]=0;break a}if(g>>>0<2147483632){d:{if(g>>>0<=10){H[e+31|0]=g;c=e+20|0;break d}f=(g|15)+1|0;c=cb(f);J[e+28>>2]=f|-2147483648;J[e+20>>2]=c;J[e+24>>2]=g;}i=g&7;if(i){f=0;while(1){H[c|0]=K[b|0];c=c+1|0;b=b+1|0;f=f+1|0;if((i|0)!=(f|0)){continue}break}}if(g>>>0>=8){while(1){H[c|0]=K[b|0];H[c+1|0]=K[b+1|0];H[c+2|0]=K[b+2|0];H[c+3|0]=K[b+3|0];H[c+4|0]=K[b+4|0];H[c+5|0]=K[b+5|0];H[c+6|0]=K[b+6|0];H[c+7|0]=K[b+7|0];c=c+8|0;b=b+8|0;if((h|0)!=(b|0)){continue}break}}H[c|0]=0;f=K[e+31|0];c=f<<24>>24;b=(c|0)<0;e:{f:{g:{f=b?J[e+24>>2]:f;h:{if(!f){break h}b=b?J[e+20>>2]:e+20|0;h=f+b|0;while(1){if(H[K[b|0]+5584|0]<0){break h}b=b+1|0;if((h|0)!=(b|0)){continue}break}if(!(f&1)){break g}}H[a+16|0]=0;H[a|0]=0;break f}J[5996]=0;aa(31,e+8|0,e+20|0);b=J[5996];J[5996]=0;if((b|0)==1){break e}c=J[e+12>>2];b=J[e+8>>2];i:{if((c-b|0)==(d|0)){d=J[e+16>>2];H[a+16|0]=1;J[a+12>>2]=g;J[a+8>>2]=d;J[a+4>>2]=c;J[a>>2]=b;break i}H[a+16|0]=0;H[a|0]=0;if(!b){break i}$a(b);}c=K[e+31|0];}if(c<<24>>24>=0){break a}$a(J[e+20>>2]);break a}a=Z()|0;if(H[e+31|0]<0){$a(J[e+20>>2]);}da(a|0);B();}ub();B();}Ua=e+32|0;}function wk(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0;a=Ua-144|0;Ua=a;J[a+136>>2]=c;J[a+140>>2]=b;J[a+20>>2]=220;b=a+24|0;J[b>>2]=a+32;i=a+20|0;J[b+4>>2]=J[i>>2];j=a+16|0;h=J[e+28>>2];J[j>>2]=h;J[h+4>>2]=J[h+4>>2]+1;J[5996]=0;h=$(170,J[a+16>>2])|0;k=J[5996];J[5996]=0;if((k|0)!=1){a:{H[a+15|0]=0;e=J[e+4>>2];J[5996]=0;c=ua(221,a+140|0,c|0,d|0,j|0,e|0,f|0,a+15|0,h|0,b|0,i|0,a+132|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}b:{c:{if(!c){break c}d:{if((K[g+11|0]&128)>>>7|0){H[J[g>>2]]=0;J[g+4>>2]=0;break d}H[g|0]=0;H[g+11|0]=0;}if(K[a+15|0]){J[5996]=0;c=_(171,h|0,45)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}J[5996]=0;aa(98,g|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break a}}J[5996]=0;d=_(171,h|0,48)|0;c=J[5996];J[5996]=0;if((c|0)==1){break b}e=J[a+20>>2];h=e-1|0;c=J[b>>2];d=d&255;while(1){if(!((d|0)!=K[c|0]|c>>>0>=h>>>0)){c=c+1|0;continue}break}J[5996]=0;ba(227,g|0,c|0,e|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){break c}break a}J[5996]=0;c=_(186,a+140|0,a+136|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}if(c){J[f>>2]=J[f>>2]|2;}e=J[a+140>>2];c=J[a+16>>2];d=J[c+4>>2]-1|0;J[c+4>>2]=d;if((d|0)==-1){Xa[J[J[c>>2]+8>>2]](c);}db(b);Ua=a+144|0;return e|0}}}d=Z()|0;a=J[a+16>>2];c=J[a+4>>2]-1|0;J[a+4>>2]=c;if((c|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}db(b);da(d|0);B();}function ok(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0;a=Ua-448|0;Ua=a;J[a+440>>2]=c;J[a+444>>2]=b;J[a+20>>2]=220;b=a+24|0;J[b>>2]=a+32;i=a+20|0;J[b+4>>2]=J[i>>2];j=a+16|0;h=J[e+28>>2];J[j>>2]=h;J[h+4>>2]=J[h+4>>2]+1;J[5996]=0;h=$(197,J[a+16>>2])|0;k=J[5996];J[5996]=0;if((k|0)!=1){a:{H[a+15|0]=0;e=J[e+4>>2];J[5996]=0;c=ua(228,a+444|0,c|0,d|0,j|0,e|0,f|0,a+15|0,h|0,b|0,i|0,a+432|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}b:{c:{if(!c){break c}d:{if((K[g+11|0]&128)>>>7|0){J[J[g>>2]>>2]=0;J[g+4>>2]=0;break d}J[g>>2]=0;H[g+11|0]=0;}if(K[a+15|0]){J[5996]=0;c=_(216,h|0,45)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}J[5996]=0;aa(232,g|0,c|0);c=J[5996];J[5996]=0;if((c|0)==1){break a}}J[5996]=0;d=_(216,h|0,48)|0;c=J[5996];J[5996]=0;if((c|0)==1){break b}e=J[a+20>>2];h=e-4|0;c=J[b>>2];while(1){if(!((d|0)!=J[c>>2]|c>>>0>=h>>>0)){c=c+4|0;continue}break}J[5996]=0;ba(234,g|0,c|0,e|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){break c}break a}J[5996]=0;c=_(202,a+444|0,a+440|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}if(c){J[f>>2]=J[f>>2]|2;}e=J[a+444>>2];c=J[a+16>>2];d=J[c+4>>2]-1|0;J[c+4>>2]=d;if((d|0)==-1){Xa[J[J[c>>2]+8>>2]](c);}db(b);Ua=a+448|0;return e|0}}}d=Z()|0;a=J[a+16>>2];c=J[a+4>>2]-1|0;J[a+4>>2]=c;if((c|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}db(b);da(d|0);B();}
function Hh(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0;if(Jb(a,J[b+8>>2],e)){if(!(J[b+28>>2]==1|J[b+4>>2]!=(c|0))){J[b+28>>2]=d;}return}a:{if(Jb(a,J[b>>2],e)){if(!(J[b+16>>2]!=(c|0)&J[b+20>>2]!=(c|0))){if((d|0)!=1){break a}J[b+32>>2]=1;return}J[b+32>>2]=d;b:{if(J[b+44>>2]==4){break b}f=a+16|0;h=f+(J[a+12>>2]<<3)|0;d=0;c:{d:{while(1){e:{if(f>>>0>=h>>>0){break e}I[b+52>>1]=0;Fd(J[f>>2],J[f+4>>2],b,c,c,1,e);if(K[b+54|0]){break e}f:{if(!K[b+53|0]){break f}if(K[b+52|0]){if(J[b+24>>2]!=1){d=1;g=1;if(K[a+8|0]&2){break f}}J[b+44>>2]=3;return}d=1;if(!(H[a+8|0]&1)){break d}}f=f+8|0;continue}break}if(!d){break c}}J[b+44>>2]=3;if(!g){break b}break a}J[b+44>>2]=4;if(g){break a}}J[b+20>>2]=c;J[b+40>>2]=J[b+40>>2]+1;if(J[b+36>>2]!=1|J[b+24>>2]!=2){break a}H[b+54|0]=1;return}g=J[a+12>>2];cd(J[a+16>>2],J[a+20>>2],b,c,d,e);f=a+24|0;g=(a+16|0)+(g<<3)|0;if(f>>>0>=g>>>0){break a}a=J[a+8>>2];if(!(!(a&2)&J[b+36>>2]!=1)){while(1){if(K[b+54|0]){break a}cd(J[f>>2],J[f+4>>2],b,c,d,e);f=f+8|0;if(g>>>0>f>>>0){continue}break}break a}if(!(a&1)){while(1){if(K[b+54|0]|J[b+36>>2]==1){break a}cd(J[f>>2],J[f+4>>2],b,c,d,e);f=f+8|0;if(g>>>0>f>>>0){continue}break a}}while(1){if(K[b+54|0]|J[b+36>>2]==1&J[b+24>>2]==1){break a}cd(J[f>>2],J[f+4>>2],b,c,d,e);f=f+8|0;if(g>>>0>f>>>0){continue}break}}}function Qe(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0;a=Ua-16|0;Ua=a;J[a+12>>2]=c;J[a+8>>2]=f;J[a+12>>2]=c;J[a+8>>2]=f;c=J[a+12>>2];a:{while(1){if(c>>>0>=d>>>0){f=0;break a}b:{b=L[c>>1];c:{if(b>>>0<=127){f=1;c=J[a+8>>2];if((g-c|0)<=0){break a}J[a+8>>2]=c+1;H[c|0]=b;break c}if(b>>>0<=2047){c=J[a+8>>2];if((g-c|0)<2){break b}J[a+8>>2]=c+1;H[c|0]=b>>>6|192;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b&63|128;break c}if(b>>>0<=55295){c=J[a+8>>2];if((g-c|0)<3){break b}J[a+8>>2]=c+1;H[c|0]=b>>>12|224;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b>>>6&63|128;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b&63|128;break c}d:{e:{if(b>>>0<=56319){f=1;if((d-c|0)<4){break a}i=L[c+2>>1];if((i&64512)!=56320){break e}if((g-J[a+8>>2]|0)<4){break a}J[a+12>>2]=c+2;c=J[a+8>>2];J[a+8>>2]=c+1;f=c;c=(b>>>6&15)+1|0;H[f|0]=c>>>2|240;f=J[a+8>>2];J[a+8>>2]=f+1;H[f|0]=c<<4&48|b>>>2&15|128;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=i>>>6&15|b<<4&48|128;b=J[a+8>>2];J[a+8>>2]=b+1;H[b|0]=i&63|128;break c}if(b>>>0>=57344){break d}}f=2;break a}c=J[a+8>>2];if((g-c|0)<3){break b}J[a+8>>2]=c+1;H[c|0]=b>>>12|224;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b>>>6&63|128;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b&63|128;}c=J[a+12>>2]+2|0;J[a+12>>2]=c;continue}break}f=1;}J[e>>2]=J[a+12>>2];J[h>>2]=J[a+8>>2];Ua=a+16|0;return f|0}function Yn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;c=J[a+4>>2];d=J[a+8>>2];if(c>>>0<d>>>0){J[c>>2]=J[b>>2];J[c+4>>2]=J[b+4>>2];J[b>>2]=0;J[b+4>>2]=0;e=J[b+28>>2];J[c+24>>2]=J[b+24>>2];J[c+28>>2]=e;e=J[b+20>>2];J[c+16>>2]=J[b+16>>2];J[c+20>>2]=e;e=J[b+12>>2];J[c+8>>2]=J[b+8>>2];J[c+12>>2]=e;J[a+4>>2]=c+32;return}a:{h=J[a>>2];f=c-h>>5;e=f+1|0;if(e>>>0<134217728){d=d-h|0;g=d>>4;g=d>>>0>=2147483616?134217727:e>>>0<g>>>0?g:e;if(g){if(g>>>0>=134217728){break a}e=cb(g<<5);}else {e=0;}d=e+(f<<5)|0;J[d>>2]=J[b>>2];J[d+4>>2]=J[b+4>>2];J[b>>2]=0;J[b+4>>2]=0;f=J[b+28>>2];J[d+24>>2]=J[b+24>>2];J[d+28>>2]=f;f=J[b+20>>2];J[d+16>>2]=J[b+16>>2];J[d+20>>2]=f;f=J[b+12>>2];J[d+8>>2]=J[b+8>>2];J[d+12>>2]=f;f=d+32|0;if((c|0)!=(h|0)){while(1){d=d-32|0;c=c-32|0;J[d>>2]=J[c>>2];J[d+4>>2]=J[c+4>>2];J[c>>2]=0;J[c+4>>2]=0;b=J[c+28>>2];J[d+24>>2]=J[c+24>>2];J[d+28>>2]=b;b=J[c+20>>2];J[d+16>>2]=J[c+16>>2];J[d+20>>2]=b;b=J[c+12>>2];J[d+8>>2]=J[c+8>>2];J[d+12>>2]=b;if((c|0)!=(h|0)){continue}break}}J[a+8>>2]=e+(g<<5);b=J[a>>2];J[a>>2]=d;c=J[a+4>>2];J[a+4>>2]=f;if((b|0)!=(c|0)){while(1){c=c-32|0;a=J[c+4>>2];b:{if(!a){break b}e=J[a+4>>2];J[a+4>>2]=e-1;if(e){break b}Xa[J[J[a>>2]+8>>2]](a);bb(a);}if((b|0)!=(c|0)){continue}break}}if(b){$a(b);}return}nb();B();}Pb();B();}function hg(a,b){var c=0,d=0,e=0,f=0,g=0;a:{b:{c:{d:{e:{f:{c=J[a+4>>2];g:{if((c|0)!=J[a+104>>2]){J[a+4>>2]=c+1;c=K[c|0];break g}c=gb(a);}switch(c-43|0){case 0:case 2:break f;default:break e}}g=(c|0)==45;b=!b;c=J[a+4>>2];h:{if((c|0)!=J[a+104>>2]){J[a+4>>2]=c+1;c=K[c|0];break h}c=gb(a);}d=c-58|0;if(b|d>>>0>4294967285){break d}b=J[a+116>>2];if((b|0)>0|(b|0)>=0){break c}break a}d=c-58|0;}if(d>>>0<=4294967285){if(J[a+116>>2]<0){break a}break b}i:{if(c-48>>>0>=10){break i}while(1){e=(P(e,10)+c|0)-48|0;f=(e|0)<214748364;c=J[a+4>>2];j:{if((c|0)!=J[a+104>>2]){J[a+4>>2]=c+1;c=K[c|0];break j}c=gb(a);}b=c-48|0;if(f&b>>>0<=9){continue}break}f=e>>31;if(b>>>0>=10){break i}while(1){b=c;c=co(e,f,10,0);d=b+c|0;b=Wa;e=d-48|0;d=(c>>>0>d>>>0?b+1|0:b)-(d>>>0<48)|0;f=d;d=e>>>0<2061584302&(d|0)<=21474836|(d|0)<21474836;c=J[a+4>>2];k:{if((c|0)!=J[a+104>>2]){J[a+4>>2]=c+1;c=K[c|0];break k}c=gb(a);}b=c-48|0;if(d&b>>>0<=9){continue}break}if(b>>>0>=10){break i}while(1){b=J[a+4>>2];l:{if((b|0)!=J[a+104>>2]){J[a+4>>2]=b+1;b=K[b|0];break l}b=gb(a);}if(b-48>>>0<10){continue}break}}b=J[a+116>>2];if((b|0)>0|(b|0)>=0){J[a+4>>2]=J[a+4>>2]-1;}Wa=g?0-(((e|0)!=0)+f|0)|0:f;return g?0-e|0:e}J[a+4>>2]=J[a+4>>2]-1;}J[a+4>>2]=J[a+4>>2]-1;}Wa=-2147483648;return 0}function Se(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0;a=Ua-16|0;Ua=a;J[a+12>>2]=c;J[a+8>>2]=f;J[a+12>>2]=c;J[a+8>>2]=f;a:{b:{while(1){b=J[a+12>>2];if(!(d>>>0<=b>>>0|f>>>0>=g>>>0)){i=H[b|0];c=i&255;c:{if((i|0)>=0){i=1;break c}k=2;if(i>>>0<4294967234){break a}if(i>>>0<=4294967263){if((d-b|0)<2){break b}i=K[b+1|0];if((i&192)!=128){break a}c=i&63|c<<6&1984;i=2;break c}if(i>>>0<=4294967279){if((d-b|0)<3){break b}j=K[b+2|0];i=K[b+1|0];d:{e:{if((c|0)!=237){if((c|0)!=224){break e}if((i&224)==160){break d}break a}if((i&224)==128){break d}break a}if((i&192)!=128){break a}}if((j&192)!=128){break a}c=j&63|(c<<12&61440|(i&63)<<6);i=3;break c}if(i>>>0>4294967284){break a}if((d-b|0)<4){break b}l=K[b+3|0];m=K[b+2|0];j=K[b+1|0];f:{g:{switch(c-240|0){case 0:if((j+112&255)>>>0<48){break f}break a;case 4:if((j&240)==128){break f}break a;default:break g}}if((j&192)!=128){break a}}if((m&192)!=128|(l&192)!=128){break a}i=4;c=l&63|(m<<6&4032|(c<<18&1835008|(j&63)<<12));if(c>>>0>1114111){break a}}J[f>>2]=c;J[a+12>>2]=b+i;f=J[a+8>>2]+4|0;J[a+8>>2]=f;continue}break}k=b>>>0<d>>>0;break a}k=1;}J[e>>2]=J[a+12>>2];J[h>>2]=J[a+8>>2];Ua=a+16|0;return k|0}function Wn(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Ua-32|0;Ua=f;J[a+8>>2]=0;J[a+12>>2]=0;J[a+4>>2]=e;J[a>>2]=b;J[a+16>>2]=0;J[a+8>>2]=J[d>>2];J[a+12>>2]=J[d+4>>2];J[a+16>>2]=J[d+8>>2];J[d+8>>2]=0;J[d>>2]=0;J[d+4>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+20>>2]=0;J[a+24>>2]=0;J[a+32>>2]=J[c>>2];J[a+36>>2]=J[c+4>>2];J[a+40>>2]=J[c+8>>2];J[c+8>>2]=0;J[c>>2]=0;J[c+4>>2]=0;J[5996]=0;aa(86,a+44|0,a|0);b=J[5996];J[5996]=0;a:{if((b|0)==1){break a}J[5996]=0;aa(87,a- -64|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}c=0;J[5996]=0;b=$(88,a|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}J[a+80>>2]=b;b=J[a+32>>2];e=J[a+36>>2];if((b|0)==(e|0)){d=0;}else {d=b;while(1){c=J[J[d>>2]+84>>2]+c|0;d=d+8|0;if((e|0)!=(d|0)){continue}break}d=J[J[b>>2]+80>>2];}g=J[a+4>>2];h=J[a>>2];i=J[a+8>>2];j=J[a+12>>2];J[5996]=0;b=ka(89,h|0,d|0,c|0,g|0,e-b>>3,(j-i|0)/12|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[a+84>>2]=b;J[5996]=0;J[f+28>>2]=a;ea(90,f+12|0,a|0,f+28|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}b=K[f+24|0];if(b){Db(J[f+16>>2]);}H[a+88|0]=b^1;Ua=f+32|0;return a|0}c=Z()|0;lb(a+32|0);b=J[a+20>>2];if(b){J[a+24>>2]=b;$a(b);}rb(a+8|0);da(c|0);B();}function Km(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;g=Ua-32|0;Ua=g;d=cb(104);J[d>>2]=7e3;J[d+4>>2]=0;J[d+8>>2]=0;e=J[c+8>>2];J[c+8>>2]=0;f=J[c>>2];h=J[c+4>>2];J[c>>2]=0;J[c+4>>2]=0;J[d+16>>2]=0;J[d+20>>2]=0;J[d+12>>2]=b;J[d+24>>2]=0;J[d+28>>2]=0;J[d+52>>2]=0;i=d+44|0;b=i;J[b>>2]=0;J[b+4>>2]=0;J[d+40>>2]=e;J[d+32>>2]=f;J[d+36>>2]=h;J[5996]=0;f=d+12|0;aa(86,d+56|0,f|0);b=J[5996];J[5996]=0;a:{if((b|0)==1){break a}J[5996]=0;aa(87,d+76|0,f|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}b=0;J[5996]=0;c=$(88,f|0)|0;e=J[5996];J[5996]=0;if((e|0)==1){break a}J[d+92>>2]=c;h=J[d+48>>2];e=J[d+44>>2];if((h|0)==(e|0)){c=0;}else {c=e;while(1){b=J[J[c>>2]+84>>2]+b|0;c=c+8|0;if((h|0)!=(c|0)){continue}break}c=J[J[e>>2]+80>>2];}j=J[d+16>>2];k=J[d+12>>2];l=J[d+20>>2];m=J[d+24>>2];J[5996]=0;b=ka(89,k|0,c|0,b|0,j|0,h-e>>3,(m-l|0)/12|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[d+96>>2]=b;J[5996]=0;J[g+28>>2]=f;ea(90,g+12|0,f|0,g+28|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}b=K[g+24|0];if(b){Db(J[g+16>>2]);}H[d+100|0]=b^1;J[a+4>>2]=d;J[a>>2]=f;Ua=g+32|0;return}b=Z()|0;lb(i);a=J[d+32>>2];if(a){J[d+36>>2]=a;$a(a);}rb(d+20|0);$a(d);da(b|0);B();}function sh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=Ua-32|0;Ua=g;h=1;a:{b:{c:{d:{switch(a|0){case 3:h=24;break c;case 4:case 5:J[g+24>>2]=0;J[g+28>>2]=0;J[g+16>>2]=0;J[g+20>>2]=0;J[g+8>>2]=0;J[g+12>>2]=0;J[g>>2]=0;J[g+4>>2]=0;J[5996]=0;a=nc(g,d,0);b=J[5996];J[5996]=0;if((b|0)==1){h=Z()|0;if(M[g>>2]<29){break a}break b}a=J[a>>2];b=a>>>0<29;h=(b?a:a-29|0)+1|0;if(b){break c}$a(J[g+8>>2]);break c;case 6:case 7:h=39;break c;case 8:case 9:h=27;break c;case 25:h=(P(f,34)|d>>>0>16)+(f>>>0>16?4:3)|0;break c;case 17:h=c;break c;case 14:h=!(Wb(1239,1)&(b^-1))+c|0;break c;case 11:case 12:case 16:case 18:case 19:h=c+1|0;break c;case 10:case 20:h=c+2|0;break c;case 13:case 21:case 22:case 23:h=c+3|0;break c;case 15:h=c+4|0;break c;case 24:J[g+24>>2]=0;J[g+28>>2]=0;J[g+16>>2]=0;J[g+20>>2]=0;J[g+8>>2]=0;J[g+12>>2]=0;J[g>>2]=0;J[g+4>>2]=0;J[5996]=0;a=nc(g,d,0);b=J[5996];J[5996]=0;if((b|0)==1){h=Z()|0;if(M[g>>2]>=29){break b}break a}a=J[a>>2];b=a>>>0<29;h=(c+e|0)+(b?a:a-29|0)|0;if(b){break c}$a(J[g+8>>2]);break c;default:la(2350,1859,280,2003);B();case 0:case 1:break c;case 2:break d}}h=34;}Ua=g+32|0;return h|0}$a(J[g+8>>2]);}da(h|0);B();}function cn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;g=J[a+8>>2];e=J[a+4>>2];if(g-e>>>0>=b>>>0){d=e;h=b&7;if(h){while(1){H[d|0]=K[c|0];d=d+1|0;f=f+1|0;if((h|0)!=(f|0)){continue}break}}b=b+e|0;while(1){H[d|0]=K[c|0];H[d+1|0]=K[c|0];H[d+2|0]=K[c|0];H[d+3|0]=K[c|0];H[d+4|0]=K[c|0];H[d+5|0]=K[c|0];H[d+6|0]=K[c|0];H[d+7|0]=K[c|0];d=d+8|0;if((b|0)!=(d|0)){continue}break}J[a+4>>2]=b;return}d=J[a>>2];f=e-d|0;i=f+b|0;if((i|0)>=0){g=g-d|0;d=g<<1;i=g>>>0>=1073741823?2147483647:d>>>0>i>>>0?d:i;if(i){j=cb(i);}f=f+j|0;d=f;g=b&7;if(g){while(1){H[d|0]=K[c|0];d=d+1|0;h=h+1|0;if((g|0)!=(h|0)){continue}break}}h=b+f|0;while(1){H[d|0]=K[c|0];H[d+1|0]=K[c|0];H[d+2|0]=K[c|0];H[d+3|0]=K[c|0];H[d+4|0]=K[c|0];H[d+5|0]=K[c|0];H[d+6|0]=K[c|0];H[d+7|0]=K[c|0];d=d+8|0;if((h|0)!=(d|0)){continue}break}g=J[a>>2];if((g|0)!=(e|0)){d=(g^-1)+e|0;b=e-g&3;if(b){c=0;while(1){f=f-1|0;e=e-1|0;H[f|0]=K[e|0];c=c+1|0;if((b|0)!=(c|0)){continue}break}}if(d>>>0>=3){while(1){H[f-1|0]=K[e-1|0];H[f-2|0]=K[e-2|0];H[f-3|0]=K[e-3|0];f=f-4|0;e=e-4|0;H[f|0]=K[e|0];if((e|0)!=(g|0)){continue}break}}e=J[a>>2];}J[a+8>>2]=i+j;J[a+4>>2]=h;J[a>>2]=f;if(e){$a(e);}return}nb();B();}function qe(a,b,c,d,e){var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;m=Ua-16|0;Ua=m;g=K[a|0];a:{if(!g){f=a;break a}f=a;b:{while(1){i=g<<24>>24;if(!((i|0)==32|i-9>>>0<5)){break b}g=K[f+1|0];f=f+1|0;if(g){continue}break}break a}c:{g=g&255;switch(g-43|0){case 0:case 2:break c;default:break a}}j=(g|0)==45?-1:0;f=f+1|0;}d:{if(!((c|16)!=16|K[f|0]!=48)){o=1;if((K[f+1|0]&223)==88){f=f+2|0;i=16;break d}f=f+1|0;i=c?c:8;break d}i=c?c:10;}c=0;while(1){e:{g=-48;k=H[f|0];f:{if((k-48&255)>>>0<10){break f}g=-87;if((k-97&255)>>>0<26){break f}g=-55;if((k-65&255)>>>0>25){break e}}n=g+k|0;if((n|0)>=(i|0)){break e}xb(m,i,0,0,0,l,h,0,0);g=1;g:{if(J[m+8>>2]|J[m+12>>2]){break g}p=co(l,h,i,0);k=Wa;if((k|0)==-1&(n^-1)>>>0<p>>>0){break g}h=k;l=n+p|0;h=l>>>0<n>>>0?h+1|0:h;o=1;g=c;}f=f+1|0;c=g;continue}break}if(b){J[b>>2]=o?f:a;}h:{i:{j:{if(c){J[5732]=68;a=d&1;j=a?0:j;l=d;h=e;break j}if((e|0)==(h|0)&d>>>0>l>>>0|e>>>0>h>>>0){break i}a=d&1;}if(!(a|j)){J[5732]=68;a=d;d=a-1|0;e=e-!a|0;break h}if((e|0)==(h|0)&d>>>0>=l>>>0|e>>>0>h>>>0){break i}J[5732]=68;break h}a=j^l;d=a-j|0;b=j>>31;e=(b^h)-((a>>>0<j>>>0)+b|0)|0;}Ua=m+16|0;Wa=e;return d}function gk(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;var k=0;k=Ua-16|0;Ua=k;a:{if(a){a=qf(c);b:{if(b){b=k+4|0;Xa[J[J[a>>2]+44>>2]](b,a);c=J[k+4>>2];H[d|0]=c;H[d+1|0]=c>>>8;H[d+2|0]=c>>>16;H[d+3|0]=c>>>24;Xa[J[J[a>>2]+32>>2]](b,a);break b}b=k+4|0;Xa[J[J[a>>2]+40>>2]](b,a);c=J[k+4>>2];H[d|0]=c;H[d+1|0]=c>>>8;H[d+2|0]=c>>>16;H[d+3|0]=c>>>24;Xa[J[J[a>>2]+28>>2]](b,a);}ac(i,b);ab(b);J[e>>2]=Xa[J[J[a>>2]+12>>2]](a);J[f>>2]=Xa[J[J[a>>2]+16>>2]](a);b=k+4|0;Xa[J[J[a>>2]+20>>2]](b,a);Ab(g,b);ab(b);Xa[J[J[a>>2]+24>>2]](b,a);ac(h,b);ab(b);a=Xa[J[J[a>>2]+36>>2]](a)|0;break a}a=pf(c);c:{if(b){b=k+4|0;Xa[J[J[a>>2]+44>>2]](b,a);c=J[k+4>>2];H[d|0]=c;H[d+1|0]=c>>>8;H[d+2|0]=c>>>16;H[d+3|0]=c>>>24;Xa[J[J[a>>2]+32>>2]](b,a);break c}b=k+4|0;Xa[J[J[a>>2]+40>>2]](b,a);c=J[k+4>>2];H[d|0]=c;H[d+1|0]=c>>>8;H[d+2|0]=c>>>16;H[d+3|0]=c>>>24;Xa[J[J[a>>2]+28>>2]](b,a);}ac(i,b);ab(b);J[e>>2]=Xa[J[J[a>>2]+12>>2]](a);J[f>>2]=Xa[J[J[a>>2]+16>>2]](a);b=k+4|0;Xa[J[J[a>>2]+20>>2]](b,a);Ab(g,b);ab(b);Xa[J[J[a>>2]+24>>2]](b,a);ac(h,b);ab(b);a=Xa[J[J[a>>2]+36>>2]](a)|0;}J[j>>2]=a;Ua=k+16|0;}function fb(a,b,c){var d=0,e=0,f=0;if(c>>>0>=512){Ia(a|0,b|0,c|0);return a}e=a+c|0;a:{if(!((a^b)&3)){b:{if(!(a&3)){c=a;break b}if(!c){c=a;break b}c=a;while(1){H[c|0]=K[b|0];b=b+1|0;c=c+1|0;if(!(c&3)){break b}if(c>>>0<e>>>0){continue}break}}d=e&-4;c:{if(d>>>0<64){break c}f=d+-64|0;if(f>>>0<c>>>0){break c}while(1){J[c>>2]=J[b>>2];J[c+4>>2]=J[b+4>>2];J[c+8>>2]=J[b+8>>2];J[c+12>>2]=J[b+12>>2];J[c+16>>2]=J[b+16>>2];J[c+20>>2]=J[b+20>>2];J[c+24>>2]=J[b+24>>2];J[c+28>>2]=J[b+28>>2];J[c+32>>2]=J[b+32>>2];J[c+36>>2]=J[b+36>>2];J[c+40>>2]=J[b+40>>2];J[c+44>>2]=J[b+44>>2];J[c+48>>2]=J[b+48>>2];J[c+52>>2]=J[b+52>>2];J[c+56>>2]=J[b+56>>2];J[c+60>>2]=J[b+60>>2];b=b- -64|0;c=c- -64|0;if(f>>>0>=c>>>0){continue}break}}if(c>>>0>=d>>>0){break a}while(1){J[c>>2]=J[b>>2];b=b+4|0;c=c+4|0;if(d>>>0>c>>>0){continue}break}break a}if(e>>>0<4){c=a;break a}d=e-4|0;if(d>>>0<a>>>0){c=a;break a}c=a;while(1){H[c|0]=K[b|0];H[c+1|0]=K[b+1|0];H[c+2|0]=K[b+2|0];H[c+3|0]=K[b+3|0];b=b+4|0;c=c+4|0;if(d>>>0>=c>>>0){continue}break}}if(c>>>0<e>>>0){while(1){H[c|0]=K[b|0];b=b+1|0;c=c+1|0;if((e|0)!=(c|0)){continue}break}}return a}function kk(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;var k=0;k=Ua-16|0;Ua=k;a:{if(a){a=tf(c);b:{if(b){b=k+4|0;Xa[J[J[a>>2]+44>>2]](b,a);c=J[k+4>>2];H[d|0]=c;H[d+1|0]=c>>>8;H[d+2|0]=c>>>16;H[d+3|0]=c>>>24;Xa[J[J[a>>2]+32>>2]](b,a);break b}b=k+4|0;Xa[J[J[a>>2]+40>>2]](b,a);c=J[k+4>>2];H[d|0]=c;H[d+1|0]=c>>>8;H[d+2|0]=c>>>16;H[d+3|0]=c>>>24;Xa[J[J[a>>2]+28>>2]](b,a);}Ab(i,b);ab(b);H[e|0]=Xa[J[J[a>>2]+12>>2]](a);H[f|0]=Xa[J[J[a>>2]+16>>2]](a);b=k+4|0;Xa[J[J[a>>2]+20>>2]](b,a);Ab(g,b);ab(b);Xa[J[J[a>>2]+24>>2]](b,a);Ab(h,b);ab(b);a=Xa[J[J[a>>2]+36>>2]](a)|0;break a}a=sf(c);c:{if(b){b=k+4|0;Xa[J[J[a>>2]+44>>2]](b,a);c=J[k+4>>2];H[d|0]=c;H[d+1|0]=c>>>8;H[d+2|0]=c>>>16;H[d+3|0]=c>>>24;Xa[J[J[a>>2]+32>>2]](b,a);break c}b=k+4|0;Xa[J[J[a>>2]+40>>2]](b,a);c=J[k+4>>2];H[d|0]=c;H[d+1|0]=c>>>8;H[d+2|0]=c>>>16;H[d+3|0]=c>>>24;Xa[J[J[a>>2]+28>>2]](b,a);}Ab(i,b);ab(b);H[e|0]=Xa[J[J[a>>2]+12>>2]](a);H[f|0]=Xa[J[J[a>>2]+16>>2]](a);b=k+4|0;Xa[J[J[a>>2]+20>>2]](b,a);Ab(g,b);ab(b);Xa[J[J[a>>2]+24>>2]](b,a);Ab(h,b);ab(b);a=Xa[J[J[a>>2]+36>>2]](a)|0;}J[j>>2]=a;Ua=k+16|0;}function Un(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;e=Ua-32|0;Ua=e;J[a+8>>2]=0;J[a+12>>2]=0;J[a+4>>2]=d;J[a>>2]=b;J[a+16>>2]=0;J[a+20>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;g=a+32|0;b=g;J[b>>2]=0;J[b+4>>2]=0;J[a+40>>2]=0;J[b>>2]=J[c>>2];J[a+36>>2]=J[c+4>>2];J[a+40>>2]=J[c+8>>2];J[c+8>>2]=0;J[c>>2]=0;J[c+4>>2]=0;J[5996]=0;aa(86,a+44|0,a|0);b=J[5996];J[5996]=0;a:{if((b|0)==1){break a}J[5996]=0;aa(87,a- -64|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}d=0;J[5996]=0;b=$(88,a|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[a+80>>2]=b;f=J[a+36>>2];b=J[a+32>>2];if((f|0)==(b|0)){c=0;}else {c=b;while(1){d=J[J[c>>2]+84>>2]+d|0;c=c+8|0;if((f|0)!=(c|0)){continue}break}c=J[J[b>>2]+80>>2];}h=J[a+4>>2];i=J[a>>2];j=J[a+8>>2];k=J[a+12>>2];J[5996]=0;b=ka(89,i|0,c|0,d|0,h|0,f-b>>3,(k-j|0)/12|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[a+84>>2]=b;J[5996]=0;J[e+28>>2]=a;ea(90,e+12|0,a|0,e+28|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}b=K[e+24|0];if(b){Db(J[e+16>>2]);}H[a+88|0]=b^1;Ua=e+32|0;return a|0}c=Z()|0;lb(g);b=J[a+20>>2];if(b){J[a+24>>2]=b;$a(b);}rb(a+8|0);da(c|0);B();}function Dm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;e=Ua-32|0;Ua=e;J[a+8>>2]=0;J[a+12>>2]=0;J[a+4>>2]=d;J[a>>2]=b;J[a+16>>2]=0;J[a+8>>2]=J[c>>2];J[a+12>>2]=J[c+4>>2];J[a+16>>2]=J[c+8>>2];J[c+8>>2]=0;J[c>>2]=0;J[c+4>>2]=0;J[a+36>>2]=0;J[a+40>>2]=0;J[a+28>>2]=0;J[a+32>>2]=0;J[a+20>>2]=0;J[a+24>>2]=0;J[5996]=0;aa(86,a+44|0,a|0);b=J[5996];J[5996]=0;a:{if((b|0)==1){break a}J[5996]=0;aa(87,a- -64|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}d=0;J[5996]=0;b=$(88,a|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[a+80>>2]=b;f=J[a+36>>2];b=J[a+32>>2];if((f|0)==(b|0)){c=0;}else {c=b;while(1){d=J[J[c>>2]+84>>2]+d|0;c=c+8|0;if((f|0)!=(c|0)){continue}break}c=J[J[b>>2]+80>>2];}g=J[a+4>>2];h=J[a>>2];i=J[a+8>>2];j=J[a+12>>2];J[5996]=0;b=ka(89,h|0,c|0,d|0,g|0,f-b>>3,(j-i|0)/12|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[a+84>>2]=b;J[5996]=0;J[e+28>>2]=a;ea(90,e+12|0,a|0,e+28|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}b=K[e+24|0];if(b){Db(J[e+16>>2]);}H[a+88|0]=b^1;Ua=e+32|0;return a|0}c=Z()|0;lb(a+32|0);b=J[a+20>>2];if(b){J[a+24>>2]=b;$a(b);}rb(a+8|0);da(c|0);B();}function Zm(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;d=Ua-16|0;Ua=d;J[5996]=0;f=_(134,d+8|0,a|0)|0;c=J[5996];J[5996]=0;a:{b:{c:{if((c|0)!=1){d:{if(!K[f|0]){break d}c=J[(J[J[a>>2]-12>>2]+a|0)+28>>2];J[d+4>>2]=c;J[c+4>>2]=J[c+4>>2]+1;J[5996]=0;h=$(135,J[d+4>>2])|0;c=J[5996];J[5996]=0;e:{f:{if((c|0)!=1){c=J[d+4>>2];e=J[c+4>>2]-1|0;J[c+4>>2]=e;if((e|0)==-1){Xa[J[J[c>>2]+8>>2]](c);}J[d+4>>2]=J[(J[J[a>>2]-12>>2]+a|0)+24>>2];c=J[J[a>>2]-12>>2];J[5996]=0;c=a+c|0;e=$(136,c|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break f}g=J[d+4>>2];J[5996]=0;b=xa(137,h|0,g|0,c|0,e|0,b|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break f}if(b){break d}b=J[J[a>>2]-12>>2];J[5996]=0;aa(138,a+b|0,5);b=J[5996];J[5996]=0;if((b|0)!=1){break d}b=fa(0)|0;break e}b=fa(0)|0;c=J[d+4>>2];e=J[c+4>>2]-1|0;J[c+4>>2]=e;if((e|0)==-1){Xa[J[J[c>>2]+8>>2]](c);}break e}b=fa(0)|0;}ud(f);break c}ud(f);break b}b=fa(0)|0;}pa(b|0)|0;b=J[J[a>>2]-12>>2];J[5996]=0;ha(139,a+b|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}ra();}Ua=d+16|0;return a|0}a=Z()|0;J[5996]=0;ca(110);b=J[5996];J[5996]=0;if((b|0)!=1){da(a|0);B();}fa(0)|0;Vb();B();}function Sn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;e=Ua-32|0;Ua=e;J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;H[e+4|0]=0;J[e>>2]=a;a:{b:{c:{d:{e:{if(c){if(c>>>0>=357913942){J[5996]=0;ca(47);a=J[5996];J[5996]=0;if((a|0)==1){break c}break a}J[5996]=0;c=P(c,12);g=$(3,c|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break c}J[a+4>>2]=g;J[a>>2]=g;J[a+8>>2]=c+g;J[e+24>>2]=g;H[e+20|0]=0;J[e+8>>2]=a+8;j=b+c|0;J[e+16>>2]=e+28;J[e+12>>2]=e+24;d=g;while(1){J[d+8>>2]=0;J[d>>2]=0;J[d+4>>2]=0;f=J[b>>2];c=J[b+4>>2];if((f|0)!=(c|0)){h=c-f|0;if((h|0)<0){J[5996]=0;J[e+28>>2]=d;ca(84);b=J[5996];J[5996]=0;if((b|0)!=1){break a}c=Z()|0;b=J[d>>2];if(!b){break d}J[d+4>>2]=b;$a(b);break d}J[5996]=0;c=$(3,h|0)|0;i=J[5996];J[5996]=0;if((i|0)==1){break e}J[d+4>>2]=c;J[d>>2]=c;J[d+8>>2]=(h&-8)+c;h=J[b+4>>2];if((h|0)!=(f|0)){while(1){i=J[f+4>>2];J[c>>2]=J[f>>2];J[c+4>>2]=i;c=c+8|0;f=f+8|0;if((h|0)!=(f|0)){continue}break}}J[d+4>>2]=c;}d=d+12|0;b=b+12|0;if((j|0)!=(b|0)){continue}break}J[a+4>>2]=d;}Ua=e+32|0;return a|0}c=Z()|0;J[e+28>>2]=d;}Ed(e+8|0);J[a+4>>2]=g;break b}c=Z()|0;}Nc(e);da(c|0);B();}B();}function pk(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;h=J[b>>2];c=H[b+11|0];J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;b=(c|0)<0?h:b;c=0;h=0;a:{b:{c:{while(1){e=d;g=c;f=h;while(1){c=K[b|0];if(!(c-9>>>0>=5&(c|0)!=32)){b=b+1|0;continue}d=K[c+5584|0];if((d|0)==255){break a}c=K[K[b+1|0]+5584|0];if((c|0)==255){break a}b=b+2|0;h=c|d<<4;if((e|0)!=(f|0)){H[f|0]=h;f=f+1|0;J[a+4>>2]=f;continue}break}i=f-g|0;d=i+1|0;if((d|0)<0){J[5996]=0;ca(8);b=J[5996];J[5996]=0;if((b|0)==1){break c}B();}d:{c=i<<1;d=i>>>0>=1073741823?2147483647:c>>>0>d>>>0?c:d;e:{if(!d){j=0;break e}J[5996]=0;j=$(3,d|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break d}}c=i+j|0;H[c|0]=h;d=d+j|0;h=c+1|0;if((e|0)!=(g|0)){k=(g^-1)+f|0;f=0;i=i&3;if(i){while(1){c=c-1|0;e=e-1|0;H[c|0]=K[e|0];f=f+1|0;if((i|0)!=(f|0)){continue}break}}if(k>>>0>=3){while(1){H[c-1|0]=K[e-1|0];H[c-2|0]=K[e-2|0];H[c-3|0]=K[e-3|0];c=c-4|0;e=e-4|0;H[c|0]=K[e|0];if((e|0)!=(g|0)){continue}break}}c=j;}J[a+8>>2]=d;J[a+4>>2]=h;J[a>>2]=c;if(!g){continue}$a(g);continue}break}b=Z()|0;break b}b=Z()|0;g=J[a>>2];}if(g){J[a+4>>2]=g;$a(g);}da(b|0);B();}}function vd(a,b,c,d,e,f){var g=0,h=0;H[a|0]=0;H[a+1|0]=0;H[a+2|0]=0;H[a+3|0]=0;H[a+4|0]=0;H[a+5|0]=0;H[a+6|0]=0;H[a+7|0]=0;H[a+24|0]=0;H[a+25|0]=0;H[a+26|0]=0;H[a+27|0]=0;H[a+28|0]=0;H[a+29|0]=0;H[a+30|0]=0;H[a+31|0]=0;H[a+16|0]=0;H[a+17|0]=0;H[a+18|0]=0;H[a+19|0]=0;H[a+20|0]=0;H[a+21|0]=0;H[a+22|0]=0;H[a+23|0]=0;H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;H[a+12|0]=0;H[a+13|0]=0;H[a+14|0]=0;H[a+15|0]=0;J[5996]=0;g=_(127,a|0,130)|0;h=J[5996];J[5996]=0;if((h|0)!=1){a:{b=J[b>>2];J[5996]=0;b=nc(g,b,b>>31);g=J[5996];J[5996]=0;if((g|0)==1){break a}c=J[c>>2];J[5996]=0;b=_(127,b|0,c|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}c=J[d>>2];J[5996]=0;b=_(127,b|0,c|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[5996]=0;b=_(19,b|0,e|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}c=J[f>>2];J[5996]=0;_(127,b|0,c|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}return}}b=Z()|0;if((K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))>>>0>=29){$a(K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24));H[a+8|0]=0;H[a+9|0]=0;H[a+10|0]=0;H[a+11|0]=0;}da(b|0);B();}function _d(a,b,c,d,e,f,g,h,i,j,k,l){a:{b:{if((a|0)==(f|0)){if(!K[b|0]){break a}f=0;H[b|0]=0;a=J[e>>2];J[e>>2]=a+1;H[a|0]=46;a=K[h+11|0];if(!((a&128)>>>7|0?J[h+4>>2]:a&127)){break b}a=J[j>>2];if((a-i|0)>159){break b}b=J[k>>2];J[j>>2]=a+4;J[a>>2]=b;return 0}c:{if((a|0)!=(g|0)){break c}f=K[h+11|0];if(!((f&128)>>>7|0?J[h+4>>2]:f&127)){break c}if(!K[b|0]){break a}f=0;a=J[j>>2];if((a-i|0)>159){break b}b=J[k>>2];J[j>>2]=a+4;J[a>>2]=b;J[k>>2]=0;return 0}f=-1;g=be(l,l+32|0,a)-l|0;if((g|0)>31){break b}a=H[g+12416|0];d:{e:{switch((g&-2)-22|0){case 2:b=J[e>>2];if((b|0)!=(d|0)){d=H[b-1|0];c=H[c|0];if(((d-97>>>0<26?d&95:d)|0)!=((c-97>>>0<26?c&95:c)|0)){break b}}J[e>>2]=b+1;H[b|0]=a;return 0;case 0:H[c|0]=80;break d;default:break e}}d=a-97>>>0<26?a&95:a;if((d|0)!=H[c|0]){break d}H[c|0]=d-65>>>0<26?d|32:d;if(!K[b|0]){break d}H[b|0]=0;b=K[h+11|0];if(!((b&128)>>>7|0?J[h+4>>2]:b&127)){break d}b=J[j>>2];if((b-i|0)>159){break d}c=J[k>>2];J[j>>2]=b+4;J[b>>2]=c;}b=J[e>>2];J[e>>2]=b+1;H[b|0]=a;f=0;if((g|0)>21){break b}J[k>>2]=J[k>>2]+1;}return f}return -1}function Wd(a,b,c,d,e,f,g,h,i,j,k,l){a:{b:{if((a|0)==(f|0)){if(!K[b|0]){break a}f=0;H[b|0]=0;a=J[e>>2];J[e>>2]=a+1;H[a|0]=46;a=K[h+11|0];if(!((a&128)>>>7|0?J[h+4>>2]:a&127)){break b}a=J[j>>2];if((a-i|0)>159){break b}b=J[k>>2];J[j>>2]=a+4;J[a>>2]=b;return 0}c:{if((a|0)!=(g|0)){break c}f=K[h+11|0];if(!((f&128)>>>7|0?J[h+4>>2]:f&127)){break c}if(!K[b|0]){break a}f=0;a=J[j>>2];if((a-i|0)>159){break b}b=J[k>>2];J[j>>2]=a+4;J[a>>2]=b;J[k>>2]=0;return 0}f=-1;g=Yd(l,l+128|0,a)-l|0;if((g|0)>124){break b}a=H[(g>>2)+12416|0];d:{e:{l=g&-5;if((l|0)!=88){if((l|0)!=96){break e}b=J[e>>2];if((b|0)!=(d|0)){d=H[b-1|0];c=H[c|0];if(((d-97>>>0<26?d&95:d)|0)!=((c-97>>>0<26?c&95:c)|0)){break b}}J[e>>2]=b+1;H[b|0]=a;return 0}H[c|0]=80;break d}d=a-97>>>0<26?a&95:a;if((d|0)!=H[c|0]){break d}H[c|0]=d-65>>>0<26?d|32:d;if(!K[b|0]){break d}H[b|0]=0;b=K[h+11|0];if(!((b&128)>>>7|0?J[h+4>>2]:b&127)){break d}b=J[j>>2];if((b-i|0)>159){break d}c=J[k>>2];J[j>>2]=b+4;J[b>>2]=c;}b=J[e>>2];J[e>>2]=b+1;H[b|0]=a;f=0;if((g|0)>84){break b}J[k>>2]=J[k>>2]+1;}return f}return -1}function Tl(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;if((c|0)!=1){l=Ua-1040|0;Ua=l;q=J[5732];a:{b:{g=l+16|0;n=L[((c>>>0<=153?c:0)<<1)+21296>>1]+19372|0;b=J[J[6178]+20>>2];if(b){h=J[b+4>>2];d=J[b>>2];f=J[d>>2]+1794895138|0;i=wc(J[d+8>>2],f);j=wc(J[d+12>>2],f);e=wc(J[d+16>>2],f);c:{if(h>>>2>>>0<=i>>>0){break c}b=h-(i<<2)|0;if((e|j)&3|(b>>>0<=j>>>0|b>>>0<=e>>>0)){break c}r=e>>>2|0;s=j>>>2|0;while(1){m=i>>>1|0;j=m+o|0;e=j<<1;b=d+(e+s<<2)|0;p=wc(J[b>>2],f);b=wc(J[b+4>>2],f);if(b>>>0>=h>>>0|h-b>>>0<=p>>>0|K[d+(b+p|0)|0]){break c}b=Uc(n,b+d|0);if(!b){b=d+(e+r<<2)|0;e=wc(J[b>>2],f);b=wc(J[b+4>>2],f);if(b>>>0>=h>>>0|e>>>0>=h-b>>>0){break c}k=K[d+(b+e|0)|0]?0:b+d|0;break c}if((i|0)==1){break c}b=(b|0)<0;i=b?m:i-m|0;o=b?o:j;continue}}}k=k?k:n;b=Gb(k);d:{if(b>>>0>=1024){fb(g,k,1023);H[g+1023|0]=0;b=68;break d}fb(g,k,b+1|0);b=0;}if(b){if((b|0)!=28){break b}b=5575;}else {b=g;}break a}za();B();}if(!K[b|0]){J[l>>2]=c;od(g,1024,2507,l);b=g;}J[5732]=q;Kb(a,b);Ua=l+1040|0;return}Kb(a,1694);}function li(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;f=Ua-32|0;Ua=f;J[f+28>>2]=d;J[f+24>>2]=d;H[f+20|0]=0;J[f+8>>2]=a;J[f+16>>2]=f+28;J[f+12>>2]=f+24;a:{b:{c:{if((b|0)!=(c|0)){while(1){J[d+8>>2]=0;J[d>>2]=0;J[d+4>>2]=0;a=J[b+4>>2];e=J[b>>2];if((a|0)!=(e|0)){e=a-e|0;if((e|0)<0){J[5996]=0;ca(8);a=J[5996];J[5996]=0;if((a|0)==1){break c}B();}J[5996]=0;a=$(3,e|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break b}J[d+4>>2]=a;J[d>>2]=a;J[d+8>>2]=a+e;e=J[b>>2];g=J[b+4>>2];d:{if((e|0)==(g|0)){break d}j=(e^-1)+g|0;h=0;i=g-e&7;if(i){while(1){H[a|0]=K[e|0];a=a+1|0;e=e+1|0;h=h+1|0;if((i|0)!=(h|0)){continue}break}}if(j>>>0<7){break d}while(1){H[a|0]=K[e|0];H[a+1|0]=K[e+1|0];H[a+2|0]=K[e+2|0];H[a+3|0]=K[e+3|0];H[a+4|0]=K[e+4|0];H[a+5|0]=K[e+5|0];H[a+6|0]=K[e+6|0];H[a+7|0]=K[e+7|0];a=a+8|0;e=e+8|0;if((g|0)!=(e|0)){continue}break}}J[d+4>>2]=a;}d=d+12|0;J[f+28>>2]=d;b=b+12|0;if((c|0)!=(b|0)){continue}break}}Ua=f+32|0;return d|0}a=Z()|0;b=J[d>>2];if(!b){break a}J[d+4>>2]=b;$a(b);break a}a=Z()|0;}Ed(f+8|0);da(a|0);B();}function zd(a,b){var c=0,d=0,e=0;c=(a|0)==(b|0);H[b+12|0]=c;a:{if(c){break a}while(1){d=J[b+8>>2];if(K[d+12|0]){break a}b:{c=J[d+8>>2];e=J[c>>2];if((e|0)==(d|0)){e=J[c+4>>2];if(!(!e|K[e+12|0])){break b}c:{if(J[d>>2]==(b|0)){b=d;break c}b=J[d+4>>2];a=J[b>>2];J[d+4>>2]=a;if(a){J[a+8>>2]=d;c=J[d+8>>2];}J[b+8>>2]=c;a=J[d+8>>2];J[((J[a>>2]!=(d|0))<<2)+a>>2]=b;J[b>>2]=d;J[d+8>>2]=b;c=J[b+8>>2];d=J[c>>2];}H[b+12|0]=1;H[c+12|0]=0;a=J[d+4>>2];J[c>>2]=a;if(a){J[a+8>>2]=c;}J[d+8>>2]=J[c+8>>2];a=J[c+8>>2];J[((J[a>>2]!=(c|0))<<2)+a>>2]=d;J[d+4>>2]=c;J[c+8>>2]=d;return}if(!(K[e+12|0]|!e)){break b}d:{if(J[d>>2]!=(b|0)){b=d;break d}a=J[b+4>>2];J[d>>2]=a;if(a){J[a+8>>2]=d;c=J[d+8>>2];}J[b+8>>2]=c;a=J[d+8>>2];J[((J[a>>2]!=(d|0))<<2)+a>>2]=b;J[b+4>>2]=d;J[d+8>>2]=b;c=J[b+8>>2];}H[b+12|0]=1;H[c+12|0]=0;a=J[c+4>>2];b=J[a>>2];J[c+4>>2]=b;if(b){J[b+8>>2]=c;}J[a+8>>2]=J[c+8>>2];b=J[c+8>>2];J[((J[b>>2]!=(c|0))<<2)+b>>2]=a;J[a>>2]=c;J[c+8>>2]=a;break a}H[d+12|0]=1;H[c+12|0]=(a|0)==(c|0);H[e+12|0]=1;b=c;if((a|0)!=(c|0)){continue}break}}}function Tn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;a:{b:{c:{d:{e:{f:{e=J[b+4>>2];d=J[b>>2];if((e|0)!=(d|0)){d=e-d|0;if((d|0)<0){J[5996]=0;ca(85);b=J[5996];J[5996]=0;if((b|0)==1){break f}break a}J[5996]=0;e=$(3,d|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break f}J[a+4>>2]=e;J[a>>2]=e;J[a+8>>2]=(d&-8)+e;d=J[b>>2];b=J[b+4>>2];if((d|0)!=(b|0)){while(1){O[e>>3]=O[d>>3];e=e+8|0;d=d+8|0;if((b|0)!=(d|0)){continue}break}}J[a+4>>2]=e;}J[a+12>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;b=J[c+4>>2];e=J[c>>2];if((b|0)==(e|0)){break d}b=b-e|0;if((b|0)>=0){break e}J[5996]=0;ca(85);b=J[5996];J[5996]=0;if((b|0)!=1){break a}break c}d=Z()|0;break b}J[5996]=0;e=$(3,b|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break c}J[a+16>>2]=e;J[a+12>>2]=e;J[a+20>>2]=(b&-8)+e;d=J[c>>2];b=J[c+4>>2];if((d|0)!=(b|0)){while(1){O[e>>3]=O[d>>3];e=e+8|0;d=d+8|0;if((b|0)!=(d|0)){continue}break}}J[a+16>>2]=e;}return a|0}d=Z()|0;b=J[a+12>>2];if(!b){break b}J[a+16>>2]=b;$a(b);}b=J[a>>2];if(b){J[a+4>>2]=b;$a(b);}da(d|0);B();}B();}function Tm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=Ua-32|0;Ua=d;J[a+8>>2]=0;J[a+12>>2]=0;J[a+4>>2]=c;J[a>>2]=b;J[a+16>>2]=0;J[a+20>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;f=a+32|0;J[f>>2]=0;J[f+4>>2]=0;J[a+40>>2]=0;J[5996]=0;aa(86,a+44|0,a|0);b=J[5996];J[5996]=0;a:{if((b|0)==1){break a}J[5996]=0;aa(87,a- -64|0,a|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}b=0;J[5996]=0;c=$(88,a|0)|0;e=J[5996];J[5996]=0;if((e|0)==1){break a}J[a+80>>2]=c;e=J[a+32>>2];g=J[a+36>>2];if((e|0)==(g|0)){c=0;}else {c=e;while(1){b=J[J[c>>2]+84>>2]+b|0;c=c+8|0;if((g|0)!=(c|0)){continue}break}c=J[J[e>>2]+80>>2];}h=J[a+4>>2];i=J[a>>2];j=J[a+8>>2];k=J[a+12>>2];J[5996]=0;b=ka(89,i|0,c|0,b|0,h|0,g-e>>3,(k-j|0)/12|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[a+84>>2]=b;J[5996]=0;J[d+28>>2]=a;ea(90,d+12|0,a|0,d+28|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}b=K[d+24|0];if(b){Db(J[d+16>>2]);}H[a+88|0]=b^1;Ua=d+32|0;return a|0}c=Z()|0;lb(f);b=J[a+20>>2];if(b){J[a+24>>2]=b;$a(b);}rb(a+8|0);da(c|0);B();}
function Pn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;a:{if(c){if(c>>>0>=536870912){J[5996]=0;ca(84);b=J[5996];J[5996]=0;if((b|0)==1){break a}B();}J[5996]=0;e=c<<3;d=$(3,e|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break a}J[a+4>>2]=d;J[a>>2]=d;J[a+8>>2]=d+e;f=c-1&536870911;g=c&7;b:{if(!g){c=b;break b}c=b;while(1){i=J[c+4>>2];J[d>>2]=J[c>>2];J[d+4>>2]=i;d=d+8|0;c=c+8|0;h=h+1|0;if((h|0)!=(g|0)){continue}break}}if(f>>>0>=7){b=b+e|0;while(1){e=J[c+4>>2];J[d>>2]=J[c>>2];J[d+4>>2]=e;e=J[c+12>>2];J[d+8>>2]=J[c+8>>2];J[d+12>>2]=e;e=J[c+20>>2];J[d+16>>2]=J[c+16>>2];J[d+20>>2]=e;e=J[c+28>>2];J[d+24>>2]=J[c+24>>2];J[d+28>>2]=e;e=J[c+36>>2];J[d+32>>2]=J[c+32>>2];J[d+36>>2]=e;e=J[c+44>>2];J[d+40>>2]=J[c+40>>2];J[d+44>>2]=e;e=J[c+52>>2];J[d+48>>2]=J[c+48>>2];J[d+52>>2]=e;e=J[c+60>>2];J[d+56>>2]=J[c+56>>2];J[d+60>>2]=e;d=d- -64|0;c=c- -64|0;if((b|0)!=(c|0)){continue}break}}J[a+4>>2]=d;}return a|0}c=Z()|0;b=J[a>>2];if(b){J[a+4>>2]=b;$a(b);}da(c|0);B();}function ge(a,b,c,d){var e=0,f=0,g=0,h=0;g=Ua-32|0;Ua=g;e=d&2147483647;h=e;f=e-1006698496|0;e=e-1140785152|0;a:{if((f|0)==(e|0)&0|e>>>0>f>>>0){e=c<<4|b>>>28;c=d<<4|c>>>28;b=b&268435455;if((b|0)==134217728&(a|0)!=0|b>>>0>134217728){f=c+1073741824|0;e=e+1|0;f=e?f:f+1|0;break a}f=c+1073741824|0;if(a|(b|0)!=134217728){break a}a=e&1;e=a+e|0;f=a>>>0>e>>>0?f+1|0:f;break a}if(!(!c&(h|0)==2147418112?!(a|b):h>>>0<2147418112)){a=d<<4|c>>>28;e=c<<4|b>>>28;f=a&524287|2146959360;break a}e=0;f=2146435072;if(h>>>0>1140785151){break a}f=0;h=h>>>16|0;if(h>>>0<15249){break a}e=d&65535|65536;Cb(g+16|0,a,b,c,e,h-15233|0);xc(g,a,b,c,e,15361-h|0);b=J[g+8>>2];e=b<<4;b=J[g+12>>2]<<4|b>>>28;c=J[g>>2];f=J[g+4>>2];h=f;e=f>>>28|e;f=b;a=h&268435455;b=c|(J[g+16>>2]|J[g+24>>2]|(J[g+20>>2]|J[g+28>>2]))!=0;if((a|0)==134217728&(b|0)!=0|a>>>0>134217728){e=e+1|0;f=e?f:f+1|0;break a}if(b|(a|0)!=134217728){break a}a=e;e=e+(e&1)|0;f=a>>>0>e>>>0?f+1|0:f;}Ua=g+32|0;x(0,e|0);x(1,d&-2147483648|f);return +z()}function pn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=Ua-16|0;Ua=d;J[d+12>>2]=b;if(b>>>0<2147483632){a:{if(((K[a+11|0]&128)>>>7|0?(J[a+8>>2]&2147483647)-1|0:10)>>>0>=b>>>0){break a}b=K[a+11|0];J[d+8>>2]=(b&128)>>>7|0?J[a+4>>2]:b&127;c=J[(M[d+12>>2]<M[d+8>>2]?d+8|0:d+12|0)>>2];if(c>>>0>=11){c=c+16&-16;e=c-1|0;c=(e|0)==11?c:e;}else {c=10;}if((c|0)==(((K[a+11|0]&128)>>>7|0?(J[a+8>>2]&2147483647)-1|0:10)|0)){break a}f=Ua-16|0;Ua=f;b=K[a+11|0];e=(b&128)>>>7|0?J[a+4>>2]:b&127;b:{c:{i=c>>>0<11;d:{if(i){j=1;g=c+1|0;h=J[a>>2];c=e;b=a;break d}g=c+1|0;e:{if(c>>>0>((K[a+11|0]&128)>>>7|0?(J[a+8>>2]&2147483647)-1|0:10)>>>0){Gc(f+8|0,g);break e}J[5996]=0;aa(289,f+8|0,g|0);b=J[5996];J[5996]=0;if((b|0)==1){break c}}g=J[f+12>>2];c=K[a+11|0];b=(c&128)>>>7|0;j=b;h=b?J[a>>2]:a;c=b?J[a+4>>2]:c&127;b=J[f+8>>2];}b=gc(b,h,c+1|0);if(j){$a(h);}if(!i){J[a+8>>2]=g|-2147483648;J[a+4>>2]=e;J[a>>2]=b;break b}H[a+11|0]=e;break b}pa(fa(0)|0)|0;ra();}Ua=f+16|0;}Ua=d+16|0;return}ub();B();}function Cd(a){var b=0,c=0,d=0,e=0,f=0;d=J[5726];c=a+7&-8;b=d+c|0;a:{b:{if(b>>>0<=d>>>0?c:0){break b}if(b>>>0>Ya()<<16>>>0){if(!(Qa(b|0)|0)){break b}}J[5726]=b;break a}J[5732]=48;d=-1;}if((d|0)!=-1){a=a+d|0;J[a-4>>2]=16;c=a-16|0;J[c>>2]=16;b=J[5992];if(b){f=J[b+8>>2];}else {f=0;}c:{d:{if((f|0)==(d|0)){e=d-(J[d-4>>2]&-2)|0;f=J[e-4>>2];J[b+8>>2]=a;a=e-(f&-2)|0;b=-16;if(!(H[(a+J[a>>2]|0)-4|0]&1)){break d}b=J[a+4>>2];J[b+8>>2]=J[a+8>>2];J[J[a+8>>2]+4>>2]=b;b=c-a|0;J[a>>2]=b;break c}J[d+12>>2]=16;J[d>>2]=16;J[d+8>>2]=a;J[d+4>>2]=b;J[5992]=d;b=16;}a=b+d|0;b=c-a|0;J[a>>2]=b;}J[((b&-4)+a|0)-4>>2]=b|1;c=J[a>>2]-8|0;e:{if(c>>>0<=127){b=(c>>>3|0)-1|0;break e}e=S(c);b=((c>>>29-e^4)-(e<<2)|0)+110|0;if(c>>>0<=4095){break e}b=((c>>>30-e^2)-(e<<1)|0)+71|0;b=b>>>0>=63?63:b;}c=b<<4;J[a+4>>2]=c+22944;c=c+22952|0;J[a+8>>2]=J[c>>2];J[c>>2]=a;J[J[a+8>>2]+4>>2]=a;c=J[5994];e=J[5995];a=b&31;if((b&63)>>>0>=32){b=1<<a;f=0;}else {f=1<<a;b=f-1&1>>>32-a;}J[5994]=f|c;J[5995]=b|e;}return (d|0)!=-1}function Te(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;a=Ua-16|0;Ua=a;J[a+12>>2]=c;J[a+8>>2]=f;J[a+12>>2]=c;J[a+8>>2]=f;b=J[a+12>>2];a:{while(1){if(b>>>0>=d>>>0){c=0;break a}c=2;b=J[b>>2];if(b>>>0>1114111|(b&-2048)==55296){break a}b:{c:{if(b>>>0<=127){c=1;f=J[a+8>>2];if((g-f|0)<=0){break a}J[a+8>>2]=f+1;H[f|0]=b;break c}if(b>>>0<=2047){c=J[a+8>>2];if((g-c|0)<2){break b}J[a+8>>2]=c+1;H[c|0]=b>>>6|192;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b&63|128;break c}c=J[a+8>>2];f=g-c|0;if(b>>>0<=65535){if((f|0)<3){break b}J[a+8>>2]=c+1;H[c|0]=b>>>12|224;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b>>>6&63|128;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b&63|128;break c}if((f|0)<4){break b}J[a+8>>2]=c+1;H[c|0]=b>>>18|240;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b>>>12&63|128;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b>>>6&63|128;c=J[a+8>>2];J[a+8>>2]=c+1;H[c|0]=b&63|128;}b=J[a+12>>2]+4|0;J[a+12>>2]=b;continue}break}c=1;}J[e>>2]=J[a+12>>2];J[h>>2]=J[a+8>>2];Ua=a+16|0;return c|0}function Yg(a){var b=0,c=0,d=0,e=0,f=0;J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;a:{b:{c:{d:{e:{f:{c=J[6141];d=J[6142];if((c|0)!=(d|0)){e=d-c|0;if((e|0)<0){J[5996]=0;ca(85);b=J[5996];J[5996]=0;if((b|0)==1){break f}break a}J[5996]=0;b=$(3,e|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break f}J[a+4>>2]=b;J[a>>2]=b;J[a+8>>2]=(e&-8)+b;while(1){O[b>>3]=O[c>>3];b=b+8|0;c=c+8|0;if((d|0)!=(c|0)){continue}break}J[a+4>>2]=b;}J[a+12>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;c=J[6144];d=J[6145];if((c|0)==(d|0)){break d}e=d-c|0;if((e|0)>=0){break e}J[5996]=0;ca(85);b=J[5996];J[5996]=0;if((b|0)!=1){break a}break c}c=Z()|0;break b}J[5996]=0;b=$(3,e|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break c}J[a+16>>2]=b;J[a+12>>2]=b;J[a+20>>2]=(e&-8)+b;while(1){O[b>>3]=O[c>>3];b=b+8|0;c=c+8|0;if((d|0)!=(c|0)){continue}break}J[a+16>>2]=b;}return a}c=Z()|0;b=J[a+12>>2];if(!b){break b}J[a+16>>2]=b;$a(b);}b=J[a>>2];if(b){J[a+4>>2]=b;$a(b);}da(c|0);B();}B();}function Oe(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;b=0;a=c;while(1){a:{if(a>>>0>=d>>>0|b>>>0>=e>>>0){break a}g=1;f=H[a|0];b:{if((f|0)>=0){break b}if(f>>>0<4294967234){break a}if(f>>>0<=4294967263){if((d-a|0)<2){break a}g=2;if((K[a+1|0]&192)!=128){break a}break b}g=f&255;if(f>>>0<=4294967279){if((d-a|0)<3){break a}h=K[a+2|0];f=K[a+1|0];c:{d:{if((g|0)!=237){if((g|0)!=224){break d}if((f&224)==160){break c}break a}if((f&224)!=128){break a}break c}if((f&192)!=128){break a}}g=3;if((h&192)!=128){break a}break b}if((d-a|0)<4|f>>>0>4294967284|e-b>>>0<2){break a}h=K[a+3|0];i=K[a+2|0];f=K[a+1|0];e:{f:{switch(g-240|0){case 0:if((f+112&255)>>>0>=48){break a}break e;case 4:if((f&240)!=128){break a}break e;default:break f}}if((f&192)!=128){break a}}if((i&192)!=128|(h&192)!=128|(g<<18&1835008|(f&48)<<12)>>>0>1114111){break a}b=b+1|0;g=4;}b=b+1|0;a=a+g|0;continue}break}return a-c|0}function gh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;c=Ua-32|0;Ua=c;J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;H[c+4|0]=0;J[c>>2]=a;e=J[b+4>>2];f=J[b>>2];g=e-f|0;d=(g|0)/12|0;a:{b:{c:{if((e|0)!=(f|0)){if(d>>>0>=357913942){J[5996]=0;ca(41);a=J[5996];J[5996]=0;if((a|0)==1){break c}B();}J[5996]=0;e=$(3,g|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break c}J[a+4>>2]=e;J[a>>2]=e;J[a+8>>2]=e+P(d,12);f=J[b+4>>2];b=J[b>>2];J[c+28>>2]=e;J[c+24>>2]=e;H[c+20|0]=0;J[c+8>>2]=a+8;J[c+16>>2]=c+28;J[c+12>>2]=c+24;d:{if((b|0)==(f|0)){d=e;break d}d=e;while(1){e:{if(H[b+11|0]>=0){g=J[b+4>>2];J[d>>2]=J[b>>2];J[d+4>>2]=g;J[d+8>>2]=J[b+8>>2];break e}g=J[b+4>>2];h=J[b>>2];J[5996]=0;ea(40,d|0,h|0,g|0);d=J[5996];J[5996]=0;if((d|0)==1){break b}d=J[c+28>>2];}d=d+12|0;J[c+28>>2]=d;b=b+12|0;if((f|0)!=(b|0)){continue}break}}J[a+4>>2]=d;}Ua=c+32|0;return a|0}b=Z()|0;break a}b=Z()|0;Wg(c+8|0);J[a+4>>2]=e;}Vg(c);da(b|0);B();}function Re(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;a=c;while(1){a:{if(e>>>0<=i>>>0|a>>>0>=d>>>0){break a}f=1;b=H[a|0];b:{if((b|0)>=0){break b}if(b>>>0<4294967234){break a}if(b>>>0<=4294967263){if((d-a|0)<2){break a}f=2;if((K[a+1|0]&192)!=128){break a}break b}g=b&255;if(b>>>0<=4294967279){if((d-a|0)<3){break a}h=K[a+2|0];b=K[a+1|0];c:{d:{if((g|0)!=237){if((g|0)!=224){break d}if((b&224)==160){break c}break a}if((b&224)!=128){break a}break c}if((b&192)!=128){break a}}f=3;if((h&192)!=128){break a}break b}if((d-a|0)<4|b>>>0>4294967284){break a}f=K[a+3|0];h=K[a+2|0];b=K[a+1|0];e:{f:{switch(g-240|0){case 0:if((b+112&255)>>>0>=48){break a}break e;case 4:if((b&240)!=128){break a}break e;default:break f}}if((b&192)!=128){break a}}if((h&192)!=128|(f&192)!=128){break a}f=4;if((g<<18&1835008|(b&48)<<12)>>>0>1114111){break a}}i=i+1|0;a=a+f|0;continue}break}return a-c|0}function zk(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;var k=0,l=0;k=Ua-16|0;Ua=k;l=j;a:{if(a){j=k+4|0;a=tf(b);Xa[J[J[a>>2]+44>>2]](j,a);b=J[k+4>>2];H[c|0]=b;H[c+1|0]=b>>>8;H[c+2|0]=b>>>16;H[c+3|0]=b>>>24;Xa[J[J[a>>2]+32>>2]](j,a);Ab(i,j);ab(j);Xa[J[J[a>>2]+28>>2]](j,a);Ab(h,j);ab(j);H[d|0]=Xa[J[J[a>>2]+12>>2]](a);H[e|0]=Xa[J[J[a>>2]+16>>2]](a);Xa[J[J[a>>2]+20>>2]](j,a);Ab(f,j);ab(j);Xa[J[J[a>>2]+24>>2]](j,a);Ab(g,j);ab(k+4|0);a=Xa[J[J[a>>2]+36>>2]](a)|0;break a}j=k+4|0;a=sf(b);Xa[J[J[a>>2]+44>>2]](j,a);b=J[k+4>>2];H[c|0]=b;H[c+1|0]=b>>>8;H[c+2|0]=b>>>16;H[c+3|0]=b>>>24;Xa[J[J[a>>2]+32>>2]](j,a);Ab(i,j);ab(j);Xa[J[J[a>>2]+28>>2]](j,a);Ab(h,j);ab(j);H[d|0]=Xa[J[J[a>>2]+12>>2]](a);H[e|0]=Xa[J[J[a>>2]+16>>2]](a);Xa[J[J[a>>2]+20>>2]](j,a);Ab(f,j);ab(j);Xa[J[J[a>>2]+24>>2]](j,a);Ab(g,j);ab(k+4|0);a=Xa[J[J[a>>2]+36>>2]](a)|0;}J[l>>2]=a;Ua=k+16|0;}function sk(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;var k=0,l=0;k=Ua-16|0;Ua=k;l=j;a:{if(a){j=k+4|0;a=qf(b);Xa[J[J[a>>2]+44>>2]](j,a);b=J[k+4>>2];H[c|0]=b;H[c+1|0]=b>>>8;H[c+2|0]=b>>>16;H[c+3|0]=b>>>24;Xa[J[J[a>>2]+32>>2]](j,a);ac(i,j);ab(j);Xa[J[J[a>>2]+28>>2]](j,a);ac(h,j);ab(j);J[d>>2]=Xa[J[J[a>>2]+12>>2]](a);J[e>>2]=Xa[J[J[a>>2]+16>>2]](a);Xa[J[J[a>>2]+20>>2]](j,a);Ab(f,j);ab(j);Xa[J[J[a>>2]+24>>2]](j,a);ac(g,j);ab(j);a=Xa[J[J[a>>2]+36>>2]](a)|0;break a}j=k+4|0;a=pf(b);Xa[J[J[a>>2]+44>>2]](j,a);b=J[k+4>>2];H[c|0]=b;H[c+1|0]=b>>>8;H[c+2|0]=b>>>16;H[c+3|0]=b>>>24;Xa[J[J[a>>2]+32>>2]](j,a);ac(i,j);ab(j);Xa[J[J[a>>2]+28>>2]](j,a);ac(h,j);ab(j);J[d>>2]=Xa[J[J[a>>2]+12>>2]](a);J[e>>2]=Xa[J[J[a>>2]+16>>2]](a);Xa[J[J[a>>2]+20>>2]](j,a);Ab(f,j);ab(j);Xa[J[J[a>>2]+24>>2]](j,a);ac(g,j);ab(j);a=Xa[J[J[a>>2]+36>>2]](a)|0;}J[l>>2]=a;Ua=k+16|0;}function gb(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;b=J[a+112>>2];d=J[a+116>>2];g=(b|d)!=0;h=b;c=J[a+4>>2];f=J[a+44>>2];b=c-f|0;i=b;e=b+J[a+120>>2]|0;b=J[a+124>>2]+(b>>31)|0;a:{b=e>>>0<i>>>0?b+1|0:b;if(!(((b|0)>=(d|0)&e>>>0>=h>>>0|(b|0)>(d|0))&g)){d=Ua-16|0;Ua=d;c=-1;b:{if(Dg(a)){break b}if((Xa[J[a+32>>2]](a,d+15|0,1)|0)!=1){break b}c=K[d+15|0];}Ua=d+16|0;d=c;if((c|0)>=0){break a}f=J[a+44>>2];c=J[a+4>>2];}J[a+112>>2]=-1;J[a+116>>2]=-1;J[a+104>>2]=c;d=f-c|0;c=d+e|0;b=(d>>31)+b|0;J[a+120>>2]=c;J[a+124>>2]=c>>>0<d>>>0?b+1|0:b;return -1}c=e+1|0;b=c?b:b+1|0;h=J[a+4>>2];f=J[a+8>>2];e=J[a+116>>2];i=e;g=J[a+112>>2];c:{if(!(e|g)){break c}e=g-c|0;g=i-(b+(c>>>0>g>>>0)|0)|0;j=f-h|0;i=j>>31;if((g|0)>=(i|0)&e>>>0>=j>>>0|(g|0)>(i|0)){break c}f=e+h|0;}J[a+104>>2]=f;e=J[a+44>>2];f=e-h|0;c=f+c|0;b=(f>>31)+b|0;J[a+120>>2]=c;J[a+124>>2]=c>>>0<f>>>0?b+1|0:b;if(e>>>0>=h>>>0){H[h-1|0]=d;}return d}function $l(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;g=Ua-16|0;Ua=g;a:{b:{if((b|0)!=-1){i=J[a+8>>2];j=J[a+12>>2];d=J[a+24>>2];if((d|0)==J[a+28>>2]){e=-1;if(!(K[a+48|0]&16)){break a}k=J[a+44>>2];h=J[a+20>>2];J[5996]=0;c=a+32|0;aa(98,c|0,0);f=J[5996];J[5996]=0;if((f|0)==1){break b}f=(K[c+11|0]&128)>>>7|0?(J[c+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,c|0,f|0);f=J[5996];J[5996]=0;if((f|0)==1){break b}c=(K[c+11|0]&128)>>>7|0?J[c>>2]:c;e=K[a+43|0];J[a+28>>2]=c+((e&128)>>>7|0?J[a+36>>2]:e&127);J[a+20>>2]=c;J[a+24>>2]=c;J[a+24>>2]=J[a+24>>2]+(d-h|0);J[a+44>>2]=J[a+20>>2]+(k-h|0);d=J[a+24>>2];}J[g+12>>2]=d+1;d=a+44|0;c=g+12|0;c=J[(M[c>>2]<M[d>>2]?d:c)>>2];J[a+44>>2]=c;if(K[a+48|0]&8){d=a+32|0;d=(K[d+11|0]&128)>>>7|0?J[d>>2]:d;J[a+16>>2]=c;J[a+12>>2]=d+(j-i|0);J[a+8>>2]=d;}e=vg(a,b<<24>>24);break a}e=(b|0)!=-1?b:0;break a}pa(fa(0)|0)|0;ra();}Ua=g+16|0;return e|0}function Vf(a,b,c,d){var e=0,f=0,g=0,h=0;g=Ua-32|0;Ua=g;f=d&2147483647;e=f-1065418752|0;h=f-1082064896|0;a:{if((e|0)==(h|0)&0|e>>>0<h>>>0){f=(d&33554431)<<7|c>>>25;e=0;h=e;c=c&33554431;if(!(!e&(c|0)==16777216?!(a|b):!e&c>>>0<16777216)){e=f+1073741825|0;break a}e=f+1073741824|0;if(c^16777216|a|(b|h)){break a}e=(f&1)+e|0;break a}if(!(!c&(f|0)==2147418112?!(a|b):f>>>0<2147418112)){e=((d&33554431)<<7|c>>>25)&4194303|2143289344;break a}e=2139095040;if(f>>>0>1082064895){break a}e=0;f=f>>>16|0;if(f>>>0<16145){break a}e=d&65535|65536;Cb(g+16|0,a,b,c,e,f-16129|0);xc(g,a,b,c,e,16257-f|0);a=J[g+8>>2];e=(J[g+12>>2]&33554431)<<7|a>>>25;c=J[g>>2]|(J[g+16>>2]|J[g+24>>2]|(J[g+20>>2]|J[g+28>>2]))!=0;f=J[g+4>>2];b=0;a=a&33554431;if(!(!b&(a|0)==16777216?!(c|f):!b&a>>>0<16777216)){e=e+1|0;break a}if(a^16777216|c|(b|f)){break a}e=(e&1)+e|0;}Ua=g+32|0;return x(2,d&-2147483648|e),C()}function eo(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{if(b){if(!c){break j}break i}Wa=0;a=(a>>>0)/(c>>>0)|0;break a}if(!a){break h}break g}if(!(c-1&c)){break f}f=(S(c)+33|0)-S(b)|0;g=0-f|0;break d}Wa=0;a=(b>>>0)/0|0;break a}d=32-S(b)|0;if(d>>>0<31){break e}break c}if((c|0)==1){break b}f=c?31-S(c-1^c)|0:32;c=f&31;if((f&63)>>>0>=32){a=b>>>c|0;}else {d=b>>>c|0;a=((1<<c)-1&b)<<32-c|a>>>c;}Wa=d;break a}f=d+1|0;g=63-d|0;}d=f&63;e=d&31;if(d>>>0>=32){d=0;h=b>>>e|0;}else {d=b>>>e|0;h=((1<<e)-1&b)<<32-e|a>>>e;}g=g&63;e=g&31;if(g>>>0>=32){b=a<<e;a=0;}else {b=(1<<e)-1&a>>>32-e|b<<e;a=a<<e;}if(f){g=c-1|0;l=(g|0)==-1?-1:0;while(1){i=d<<1|h>>>31;d=h<<1|b>>>31;e=l-(i+(d>>>0>g>>>0)|0)>>31;j=c&e;h=d-j|0;d=i-(d>>>0<j>>>0)|0;b=b<<1|a>>>31;a=k|a<<1;k=e&1;f=f-1|0;if(f){continue}break}}Wa=b<<1|a>>>31;a=k|a<<1;break a}a=0;b=0;}Wa=b;}return a}function _l(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;i=J[b+44>>2];j=J[b+24>>2];if(i>>>0<j>>>0){J[b+44>>2]=j;i=j;}m=-1;n=-1;o=f&24;a:{if(!o|(e|0)==1&(o|0)==24){break a}if(i){g=b+32|0;g=i-((K[g+11|0]&128)>>>7|0?J[g>>2]:g)|0;k=g>>31;}b:{c:{switch(e|0){case 1:if(f&8){h=J[b+12>>2]-J[b+8>>2]|0;l=h>>31;break b}h=j-J[b+20>>2]|0;l=h>>31;break b;case 0:break b;case 2:break c;default:break a}}h=g;l=k;}d=d+l|0;c=c+h|0;d=h>>>0>c>>>0?d+1|0:d;if((d|0)<0|(c>>>0>g>>>0&(d|0)>=(k|0)|(d|0)>(k|0))){break a}e=f&8;d:{if(!(c|d)){break d}if(J[b+12>>2]?0:e){break a}if(!(f&16)){break d}if(!j){break a}}if(e){e=J[b+8>>2];J[b+16>>2]=i;J[b+12>>2]=c+e;J[b+8>>2]=e;}if(f&16){e=J[b+20>>2];J[b+28>>2]=J[b+28>>2];J[b+20>>2]=e;J[b+24>>2]=e;J[b+24>>2]=c+J[b+24>>2];}m=c;n=d;}J[a+8>>2]=m;J[a+12>>2]=n;J[a>>2]=0;J[a+4>>2]=0;}function fe(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;b=a;a:{if(b&3){while(1){c=K[b|0];if(!c|(c|0)==61){break a}b=b+1|0;if(b&3){continue}break}}c=J[b>>2];b:{if((c^-1)&c-16843009&-2139062144){break b}while(1){if((c^1027423549)-16843009&(c^-1)&-2139062144){break b}c=J[b+4>>2];b=b+4|0;if(!(c-16843009&(c^-1)&-2139062144)){continue}break}}while(1){c=b;d=K[b|0];if((d|0)!=61){b=b+1|0;if(d){continue}}break}b=c;}if((a|0)==(b|0)){return 0}f=b-a|0;c:{if(K[f+a|0]){break c}e=J[6181];if(!e){break c}b=J[e>>2];if(!b){break c}while(1){d:{g=a;c=b;h=f;d=0;e:{if(!f){break e}d=K[a|0];if(d){f:{while(1){i=K[c|0];if((i|0)!=(d|0)|!i){break f}h=h-1|0;if(!h){break f}c=c+1|0;d=K[g+1|0];g=g+1|0;if(d){continue}break}d=0;}}else {d=0;}d=d-K[c|0]|0;}if(!d){b=b+f|0;if(K[b|0]==61){break d}}b=J[e+4>>2];e=e+4|0;if(b){continue}break c}break}j=b+1|0;}return j}function Ob(a,b){a=a|0;b=b|0;var c=0,d=0;d=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);a:{b:{c:{if(b>>>0<=28){if(d>>>0<29){break c}b=K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24);fb(a+4|0,b,d-29|0);$a(b);b=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))-29|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;return}if(d>>>0>=29){c=Vc(K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24),b);H[a+8|0]=c;H[a+9|0]=c>>>8;H[a+10|0]=c>>>16;H[a+11|0]=c>>>24;if(!c){break b}H[a+4|0]=b;H[a+5|0]=b>>>8;H[a+6|0]=b>>>16;H[a+7|0]=b>>>24;return}c=sb(b);if(!c){break a}c=fb(c,a+4|0,d);H[a+4|0]=b;H[a+5|0]=b>>>8;H[a+6|0]=b>>>16;H[a+7|0]=b>>>24;H[a+8|0]=c;H[a+9|0]=c>>>8;H[a+10|0]=c>>>16;H[a+11|0]=c>>>24;b=d+29|0;H[a|0]=b;H[a+1|0]=b>>>8;H[a+2|0]=b>>>16;H[a+3|0]=b>>>24;}return}la(1370,2249,181,1040);B();}la(1357,2249,185,1040);B();}function pd(a,b,c,d){var e=0,f=0,g=0;e=Ua-160|0;Ua=e;f=b?a:e+158|0;J[e+148>>2]=f;a=-1;g=b-1|0;J[e+152>>2]=b>>>0>=g>>>0?g:0;e=Sb(e,0,144);J[e+76>>2]=-1;J[e+36>>2]=179;J[e+80>>2]=-1;J[e+44>>2]=e+159;J[e+84>>2]=e+148;a:{if((b|0)<0){J[5732]=61;break a}H[f|0]=0;f=0;b=Ua-208|0;Ua=b;J[b+204>>2]=d;a=b+160|0;Sb(a,0,40);J[b+200>>2]=J[b+204>>2];b:{if((Kg(0,c,b+200|0,b+80|0,a)|0)<0){a=-1;break b}d=J[e+76>>2]>=0;g=J[e>>2];J[e>>2]=g&-33;c:{d:{e:{if(!J[e+48>>2]){J[e+48>>2]=80;J[e+28>>2]=0;J[e+16>>2]=0;J[e+20>>2]=0;f=J[e+44>>2];J[e+44>>2]=b;break e}if(J[e+16>>2]){break d}}a=-1;if(Be(e)){break c}}a=Kg(e,c,b+200|0,b+80|0,b+160|0);}c=a;if(f){Xa[J[e+36>>2]](e,0,0)|0;J[e+48>>2]=0;J[e+44>>2]=f;J[e+28>>2]=0;a=J[e+20>>2];J[e+16>>2]=0;J[e+20>>2]=0;c=a?c:-1;}a=J[e>>2];J[e>>2]=a|g&32;a=a&32?-1:c;if(!d){break b}}Ua=b+208|0;}Ua=e+160|0;return a}function Ck(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0;h=Ua-416|0;Ua=h;d=h+416|0;J[h+12>>2]=d;c=Ua-144|0;Ua=c;J[c+28>>2]=c+132;i=c+32|0;yf(J[a+8>>2],i,c+28|0,e,f,g);J[c+16>>2]=0;J[c+20>>2]=0;J[c+12>>2]=i;e=h+16|0;g=J[h+12>>2]-e>>2;f=Ua-16|0;Ua=f;a=Xb(f+12|0,J[a+8>>2]);g=bg(e,c+12|0,g,c+16|0);a=J[a>>2];if(a){J[6178]=(a|0)==-1?24816:a;}Ua=f+16|0;if((g|0)==-1){xf(2472);B();}J[h+12>>2]=e+(g<<2);Ua=c+144|0;c=Ua-16|0;Ua=c;a=Ua-32|0;Ua=a;f=Ua-16|0;Ua=f;J[f+12>>2]=J[h+12>>2];J[a+24>>2]=e;J[a+28>>2]=J[f+12>>2];Ua=f+16|0;f=J[a+24>>2];g=J[a+28>>2];e=Ua-16|0;Ua=e;J[e+12>>2]=b;while(1){if((f|0)!=(g|0)){pg(e+12|0,J[f>>2]);f=f+4|0;continue}break}J[a+16>>2]=g;J[a+20>>2]=J[e+12>>2];Ua=e+16|0;b=J[a+16>>2];J[a+12>>2]=J[a+20>>2];J[c+8>>2]=b;J[c+12>>2]=J[a+12>>2];Ua=a+32|0;Ua=c+16|0;Ua=d;return J[c+12>>2]}function Kc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0;e=Ua-32|0;Ua=e;h=e+32|0;c=h;d=e+21|0;f=c-d|0;a:{if((f|0)<=9){i=f;f=P(32-S(b|1)|0,1233)>>>12|0;g=61;if((i|0)<((M[(f<<2)+21616>>2]<=b>>>0)+f|0)){break a}}b:{if(b>>>0<=999999){if(b>>>0<=9999){if(b>>>0<=99){if(b>>>0<=9){H[d|0]=b+48;c=d+1|0;break b}c=uc(d,b);break b}if(b>>>0<=999){c=(b>>>0)/100|0;H[d|0]=c+48;c=uc(d+1|0,P(c,-100)+b|0);break b}c=Kd(d,b);break b}if(b>>>0<=99999){c=(b>>>0)/1e4|0;H[d|0]=c+48;c=Kd(d+1|0,P(c,-1e4)+b|0);break b}c=Jd(d,b);break b}if(b>>>0<=99999999){if(b>>>0<=9999999){c=(b>>>0)/1e6|0;H[d|0]=c+48;c=Jd(d+1|0,P(c,-1e6)+b|0);break b}c=Id(d,b);break b}if(b>>>0<=999999999){c=(b>>>0)/1e8|0;H[d|0]=c+48;c=Id(d+1|0,P(c,-1e8)+b|0);break b}c=(b>>>0)/1e8|0;c=Id(uc(d,c),P(c,-1e8)+b|0);}g=0;}J[e+16>>2]=g;J[e+12>>2]=c;td(a,d,J[e+12>>2]);Ua=h;}function ye(a,b,c){var d=0,e=0,f=0,g=0;d=a+4|0;e=(d+b|0)-1&0-b;b=J[a>>2];if(e+c>>>0<=(b+a|0)-4>>>0){f=J[a+4>>2];J[f+8>>2]=J[a+8>>2];J[J[a+8>>2]+4>>2]=f;if((d|0)!=(e|0)){e=e-d|0;f=a-(J[a-4>>2]&-2)|0;d=e+J[f>>2]|0;J[f>>2]=d;J[(f+(d&-4)|0)-4>>2]=d;a=a+e|0;b=b-e|0;J[a>>2]=b;}a:{if(c+24>>>0<=b>>>0){d=(a+c|0)+8|0;b=(b-c|0)-8|0;J[d>>2]=b;J[(d+(b&-4)|0)-4>>2]=b|1;e=J[d>>2]-8|0;b:{if(e>>>0<=127){b=(e>>>3|0)-1|0;break b}f=S(e);b=((e>>>29-f^4)-(f<<2)|0)+110|0;if(e>>>0<=4095){break b}b=((e>>>30-f^2)-(f<<1)|0)+71|0;b=b>>>0>=63?63:b;}e=b<<4;J[d+4>>2]=e+22944;e=e+22952|0;J[d+8>>2]=J[e>>2];J[e>>2]=d;J[J[d+8>>2]+4>>2]=d;e=J[5994];f=J[5995];d=b&31;if((b&63)>>>0>=32){b=1<<d;d=0;}else {g=1<<d;b=g-1&1>>>32-d;d=g;}J[5994]=d|e;J[5995]=b|f;b=c+8|0;J[a>>2]=b;J[((b&-4)+a|0)-4>>2]=b;break a}J[(a+b|0)-4>>2]=b;}a=a+4|0;}else {a=0;}return a}function $m(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;a:{b:{c:{d=J[a>>2];f=(J[a+4>>2]-d|0)/12|0;c=f+1|0;if(c>>>0<357913942){d=(J[a+8>>2]-d|0)/12|0;g=d<<1;d=d>>>0>=178956970?357913941:c>>>0<g>>>0?g:c;if(d){if(d>>>0>=357913942){break c}e=cb(P(d,12));}c=P(f,12)+e|0;f=J[b+4>>2];J[c>>2]=J[b>>2];J[c+4>>2]=f;J[c+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;e=P(d,12)+e|0;d=c+12|0;b=J[a+4>>2];f=J[a>>2];if((b|0)==(f|0)){break b}while(1){b=b-12|0;g=J[b+4>>2];c=c-12|0;J[c>>2]=J[b>>2];J[c+4>>2]=g;J[c+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;if((b|0)!=(f|0)){continue}break}J[a+8>>2]=e;e=J[a+4>>2];J[a+4>>2]=d;b=J[a>>2];J[a>>2]=c;if((b|0)==(e|0)){break a}while(1){a=e-12|0;if(H[e-1|0]<0){$a(J[a>>2]);}e=a;if((a|0)!=(b|0)){continue}break}break a}nb();B();}Pb();B();}J[a+8>>2]=e;J[a+4>>2]=d;J[a>>2]=c;}if(b){$a(b);}}function Lf(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;i=Ua-32|0;Ua=i;a:{b:{c:{if((b|0)!=(c|0)){k=J[5732];J[5732]=0;g=Ua-16|0;Ua=g;jb();f=Ua-16|0;Ua=f;e=Ua-16|0;Ua=e;ee(e,b,i+28|0,2);h=J[e>>2];j=J[e+4>>2];b=f;f=J[e+12>>2];J[b+8>>2]=J[e+8>>2];J[b+12>>2]=f;J[b>>2]=h;J[b+4>>2]=j;Ua=e+16|0;f=J[b>>2];h=J[b+4>>2];e=g;g=J[b+12>>2];J[e+8>>2]=J[b+8>>2];J[e+12>>2]=g;J[e>>2]=f;J[e+4>>2]=h;Ua=b+16|0;g=J[e>>2];f=J[e+4>>2];h=J[e+12>>2];b=i;J[b+16>>2]=J[e+8>>2];J[b+20>>2]=h;J[b+8>>2]=g;J[b+12>>2]=f;Ua=e+16|0;e=J[b+16>>2];f=J[b+20>>2];g=J[b+8>>2];h=J[b+12>>2];j=J[5732];if(!j){break c}if(J[b+28>>2]!=(c|0)){break b}l=g;m=h;n=e;o=f;if((j|0)!=68){break a}break b}J[d>>2]=4;break a}J[5732]=k;if(J[i+28>>2]==(c|0)){break a}}J[d>>2]=4;g=l;h=m;e=n;f=o;}J[a>>2]=g;J[a+4>>2]=h;J[a+8>>2]=e;J[a+12>>2]=f;Ua=i+32|0;}function Gm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;f=J[a+4>>2];e=J[a+8>>2];if(f>>>0<e>>>0){J[f>>2]=b;J[f+8>>2]=c;J[f+12>>2]=c>>31;b=J[d+4>>2];J[f+16>>2]=J[d>>2];J[f+20>>2]=b;J[a+4>>2]=f+24;return}a:{i=J[a>>2];g=(f-i|0)/24|0;h=g+1|0;if(h>>>0<178956971){j=P(g,24);e=(e-i|0)/24|0;g=e<<1;g=e>>>0>=89478485?178956970:g>>>0>h>>>0?g:h;if(g){if(g>>>0>=178956971){break a}h=cb(P(g,24));}else {h=0;}e=j+h|0;J[e+8>>2]=c;J[e+12>>2]=c>>31;J[e>>2]=b;b=J[d+4>>2];J[e+16>>2]=J[d>>2];J[e+20>>2]=b;b=e+24|0;if((f|0)!=(i|0)){while(1){f=f-24|0;d=J[f+4>>2];e=e-24|0;J[e>>2]=J[f>>2];J[e+4>>2]=d;c=J[f+20>>2];J[e+16>>2]=J[f+16>>2];J[e+20>>2]=c;c=J[f+12>>2];J[e+8>>2]=J[f+8>>2];J[e+12>>2]=c;if((f|0)!=(i|0)){continue}break}f=J[a>>2];}J[a+8>>2]=h+P(g,24);J[a+4>>2]=b;J[a>>2]=e;if(f){$a(f);}return}nb();B();}Pb();B();}function _k(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0;f=Ua-32|0;Ua=f;J[f+28>>2]=b;a:{if(!(H[c+4|0]&1)){c=Xa[J[J[a>>2]+24>>2]](a,b,c,d,e)|0;break a}d=f+16|0;a=J[c+28>>2];J[d>>2]=a;J[a+4>>2]=J[a+4>>2]+1;J[5996]=0;a=$(198,J[f+16>>2])|0;b=J[5996];J[5996]=0;b:{if((b|0)!=1){b=J[d>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}c:{if(e){Xa[J[J[a>>2]+24>>2]](d,a);break c}Xa[J[J[a>>2]+28>>2]](f+16|0,a);}J[f+12>>2]=Mb(f+16|0);while(1){a=f+16|0;c=qc(a);b=J[f+12>>2];if((c|0)==(b|0)){c=J[f+28>>2];ab(a);break a}a=J[b>>2];J[5996]=0;_(214,f+28|0,a|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){J[f+12>>2]=J[f+12>>2]+4;continue}break}c=Z()|0;ab(f+16|0);break b}c=Z()|0;a=J[f+16>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}}da(c|0);B();}Ua=f+32|0;return c|0}function il(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0;f=Ua-32|0;Ua=f;J[f+28>>2]=b;a:{if(!(H[c+4|0]&1)){c=Xa[J[J[a>>2]+24>>2]](a,b,c,d,e)|0;break a}d=f+16|0;a=J[c+28>>2];J[d>>2]=a;J[a+4>>2]=J[a+4>>2]+1;J[5996]=0;a=$(180,J[f+16>>2])|0;b=J[5996];J[5996]=0;b:{if((b|0)!=1){b=J[d>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}c:{if(e){Xa[J[J[a>>2]+24>>2]](d,a);break c}Xa[J[J[a>>2]+28>>2]](f+16|0,a);}J[f+12>>2]=Mb(f+16|0);while(1){a=f+16|0;c=sc(a);b=J[f+12>>2];if((c|0)==(b|0)){c=J[f+28>>2];ab(a);break a}a=H[b|0];J[5996]=0;_(210,f+28|0,a|0)|0;a=J[5996];J[5996]=0;if((a|0)!=1){J[f+12>>2]=J[f+12>>2]+1;continue}break}c=Z()|0;ab(f+16|0);break b}c=Z()|0;a=J[f+16>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}}da(c|0);B();}Ua=f+32|0;return c|0}function $n(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0;f=Ua-32|0;Ua=f;J[f+24>>2]=d;H[f+20|0]=0;J[f+8>>2]=a;J[f+16>>2]=f+28;J[f+12>>2]=f+24;a:{b:{c:{if((b|0)!=(c|0)){while(1){J[d+8>>2]=0;J[d>>2]=0;J[d+4>>2]=0;a=J[b+4>>2];e=J[b>>2];if((a|0)!=(e|0)){e=a-e|0;if((e|0)<0){J[5996]=0;J[f+28>>2]=d;ca(84);a=J[5996];J[5996]=0;if((a|0)==1){break c}B();}J[5996]=0;a=$(3,e|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break b}J[d+4>>2]=a;J[d>>2]=a;J[d+8>>2]=(e&-8)+a;e=J[b>>2];g=J[b+4>>2];if((e|0)!=(g|0)){while(1){h=J[e+4>>2];J[a>>2]=J[e>>2];J[a+4>>2]=h;a=a+8|0;e=e+8|0;if((g|0)!=(e|0)){continue}break}}J[d+4>>2]=a;}d=d+12|0;b=b+12|0;if((c|0)!=(b|0)){continue}break}}Ua=f+32|0;return d|0}a=Z()|0;b=J[d>>2];if(!b){break a}J[d+4>>2]=b;$a(b);break a}a=Z()|0;J[f+28>>2]=d;}Ed(f+8|0);da(a|0);B();}function Fm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;f=J[a+4>>2];e=J[a+8>>2];if(f>>>0<e>>>0){J[f>>2]=b;J[f+16>>2]=d;J[f+20>>2]=d>>31;J[f+8>>2]=c;J[f+12>>2]=c>>31;J[a+4>>2]=f+24;return}a:{i=J[a>>2];g=(f-i|0)/24|0;h=g+1|0;if(h>>>0<178956971){j=P(g,24);e=(e-i|0)/24|0;g=e<<1;g=e>>>0>=89478485?178956970:g>>>0>h>>>0?g:h;if(g){if(g>>>0>=178956971){break a}h=cb(P(g,24));}else {h=0;}e=j+h|0;J[e+16>>2]=d;J[e+20>>2]=d>>31;J[e+8>>2]=c;J[e+12>>2]=c>>31;J[e>>2]=b;b=e+24|0;if((f|0)!=(i|0)){while(1){f=f-24|0;d=J[f+4>>2];e=e-24|0;J[e>>2]=J[f>>2];J[e+4>>2]=d;c=J[f+20>>2];J[e+16>>2]=J[f+16>>2];J[e+20>>2]=c;c=J[f+12>>2];J[e+8>>2]=J[f+8>>2];J[e+12>>2]=c;if((f|0)!=(i|0)){continue}break}f=J[a>>2];}J[a+8>>2]=h+P(g,24);J[a+4>>2]=b;J[a>>2]=e;if(f){$a(f);}return}nb();B();}Pb();B();}function Lc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;g=d;d=Gb(d);i=Ua-16|0;Ua=i;J[i+12>>2]=c;c=a;a:{b:{e=J[a+4>>2];a=K[a+11|0];h=(a&128)>>>7|0?e:a&127;if(h>>>0>=b>>>0){e=h-b|0;J[i+8>>2]=e;a=i+8|0;f=i+12|0;a=J[(M[a>>2]<M[f>>2]?a:f)>>2];f=(K[c+11|0]&128)>>>7|0?(J[c+8>>2]&2147483647)-1|0:10;if(a+(f-h|0)>>>0>=d>>>0){f=(K[c+11|0]&128)>>>7|0?J[c>>2]:c;c:{if((a|0)==(d|0)){a=d;break c}if((a|0)==(e|0)){a=e;break c}j=e-a|0;e=b+f|0;if(a>>>0>d>>>0){break b}d:{if(f+h>>>0<=g>>>0|e>>>0>=g>>>0){break d}if(a+e>>>0<=g>>>0){g=(d-a|0)+g|0;break d}oc(e,g,a);e=d-a|0;g=d+g|0;b=a+b|0;a=0;d=e;}e=b+f|0;oc(e+d|0,a+e|0,j);}oc(b+f|0,g,d);sd(c,f,(d+h|0)-a|0);break a}dd(c,f,d+h-(a+f)|0,h,b,a,d,g);break a}ue();B();}b=oc(e,g,d);oc(b+d|0,a+b|0,j);sd(c,f,(d+h|0)-a|0);}Ua=i+16|0;}function nk(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;h=Ua-16|0;Ua=h;d=K[a+11|0];e=d&127;d=(d&128)>>>7|0;e=d?J[a+4>>2]:e;d=d?(J[a+8>>2]&2147483647)-1|0:1;f=c-b>>2;a:{if(!f){break a}b:{g=K[a+11|0];i=(g&128)>>>7|0?J[a>>2]:a;if(i>>>0<=b>>>0){g=(((g&128)>>>7|0?J[a+4>>2]:g&127)<<2)+i>>>0>=b>>>0;}else {g=0;}if(!g){if(d-e>>>0<f>>>0){of(a,d,(e-d|0)+f|0,e,e);}d=(e<<2)+((K[a+11|0]&128)>>>7|0?J[a>>2]:a)|0;while(1){if((b|0)==(c|0)){break b}J[d>>2]=J[b>>2];b=b+4|0;d=d+4|0;continue}}b=ag(h+4|0,b,c);c=K[b+11|0];f=(c&128)>>>7|0;d=f?J[b>>2]:b;e=J[b+4>>2];J[5996]=0;ba(235,a|0,d|0,(f?e:c&127)|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){ab(b);break a}a=Z()|0;ab(b);da(a|0);B();}J[d>>2]=0;b=e+f|0;c:{if((K[a+11|0]&128)>>>7|0){J[a+4>>2]=b;break c}H[a+11|0]=b;}}Ua=h+16|0;return a|0}function rm(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;J[a+4>>2]=b;H[a|0]=0;b=J[J[b>>2]-12>>2]+b|0;if(!J[b+16>>2]){b=J[b+72>>2];if(b){a:{e=Ua-16|0;Ua=e;b:{c:{if(!J[(b+J[J[b>>2]-12>>2]|0)+24>>2]){break c}J[5996]=0;d=_(134,e+8|0,b|0)|0;c=J[5996];J[5996]=0;d:{if((c|0)!=1){e:{if(!K[d|0]){break e}c=J[(b+J[J[b>>2]-12>>2]|0)+24>>2];J[5996]=0;c=$(169,c|0)|0;f=J[5996];J[5996]=0;if((f|0)!=1){if((c|0)!=-1){break e}c=J[J[b>>2]-12>>2];J[5996]=0;aa(138,b+c|0,1);c=J[5996];J[5996]=0;if((c|0)!=1){break e}}c=fa(0)|0;ud(d);break d}ud(d);break c}c=fa(0)|0;}pa(c|0)|0;d=J[J[b>>2]-12>>2];J[5996]=0;ha(139,b+d|0);b=J[5996];J[5996]=0;if((b|0)==1){break b}ra();}Ua=e+16|0;break a}a=Z()|0;J[5996]=0;ca(110);b=J[5996];J[5996]=0;if((b|0)!=1){da(a|0);B();}fa(0)|0;Vb();B();}}H[a|0]=1;}return a|0}function Pm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;d=Ua-32|0;Ua=d;a:{b:{c:{if((c|0)<=0){break c}while(1){if(K[b+e|0]!=41){e=e+1|0;if((c|0)!=(e|0)){continue}break c}break}if(e){break b}}H[a+16|0]=0;H[a|0]=0;break a}d:{e:{if(e>>>0<=17){if(e>>>0>10){break e}H[d+31|0]=e;c=d+20|0;break d}H[a+16|0]=0;H[a|0]=0;break a}f=(e|15)+1|0;c=cb(f);J[d+28>>2]=f|-2147483648;J[d+20>>2]=c;J[d+24>>2]=e;}H[fb(c,b,e)+e|0]=0;c=J[d+20>>2];b=K[d+27|0]|K[d+28|0]<<8|(K[d+29|0]<<16|K[d+30|0]<<24);H[d+15|0]=b;H[d+16|0]=b>>>8;H[d+17|0]=b>>>16;H[d+18|0]=b>>>24;J[d+12>>2]=J[d+24>>2];f=K[d+31|0];J[a>>2]=c;J[a+4>>2]=J[d+12>>2];b=K[d+15|0]|K[d+16|0]<<8|(K[d+17|0]<<16|K[d+18|0]<<24);H[a+7|0]=b;H[a+8|0]=b>>>8;H[a+9|0]=b>>>16;H[a+10|0]=b>>>24;H[a+16|0]=1;J[a+12>>2]=e;H[a+11|0]=f;}Ua=d+32|0;}function Ac(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;g=Ua-16|0;Ua=g;a:{b:{c:{if(!a){break c}i=J[e+12>>2];j=c-b|0;if((j|0)>0){if((Xa[J[J[a>>2]+48>>2]](a,b,j)|0)!=(j|0)){break c}}b=d-b|0;b=(b|0)<(i|0)?i-b|0:0;if((b|0)>0){if(b>>>0>=2147483632){break a}d:{if(b>>>0>=11){i=(b|15)+1|0;h=cb(i);J[g+12>>2]=i|-2147483648;J[g+4>>2]=h;J[g+8>>2]=b;break d}H[g+15|0]=b;h=g+4|0;}H[Sb(h,f,b)+b|0]=0;f=J[J[a>>2]+48>>2];J[5996]=0;f=ba(f|0,a|0,(H[g+15|0]<0?J[g+4>>2]:g+4|0)|0,b|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break b}if(H[g+15|0]<0){$a(J[g+4>>2]);}h=0;if((b|0)!=(f|0)){break c}}b=d-c|0;if((b|0)>0){if((Xa[J[J[a>>2]+48>>2]](a,c,b)|0)!=(b|0)){break c}}J[e+12>>2]=0;h=a;}Ua=g+16|0;return h|0}a=Z()|0;if(H[g+15|0]<0){$a(J[g+4>>2]);}da(a|0);B();}ub();B();}function vk(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;h=Ua-16|0;Ua=h;d=K[a+11|0];e=d&127;d=(d&128)>>>7|0;e=d?J[a+4>>2]:e;d=d?(J[a+8>>2]&2147483647)-1|0:10;f=c-b|0;a:{if(!f){break a}b:{g=K[a+11|0];i=(g&128)>>>7|0?J[a>>2]:a;if(i>>>0<=b>>>0){g=((g&128)>>>7|0?J[a+4>>2]:g&127)+i>>>0>=b>>>0;}else {g=0;}if(!g){if(d-e>>>0<f>>>0){Sd(a,d,(e-d|0)+f|0,e,e);}d=e+((K[a+11|0]&128)>>>7|0?J[a>>2]:a)|0;while(1){if((b|0)==(c|0)){break b}H[d|0]=K[b|0];b=b+1|0;d=d+1|0;continue}}b=td(h+4|0,b,c);c=K[b+11|0];f=(c&128)>>>7|0;d=f?J[b>>2]:b;e=J[b+4>>2];J[5996]=0;ba(100,a|0,d|0,(f?e:c&127)|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){ab(b);break a}a=Z()|0;ab(b);da(a|0);B();}H[d|0]=0;b=e+f|0;c:{if((K[a+11|0]&128)>>>7|0){J[a+4>>2]=b;break c}H[a+11|0]=b;}}Ua=h+16|0;return a|0}function eb(a,b,c){var d=0,e=0;a:{if((a|0)==(b|0)){break a}e=a+c|0;if(b-e>>>0<=0-(c<<1)>>>0){return fb(a,b,c)}d=(a^b)&3;b:{c:{if(a>>>0<b>>>0){if(d){d=a;break b}if(!(a&3)){d=a;break c}d=a;while(1){if(!c){break a}H[d|0]=K[b|0];b=b+1|0;c=c-1|0;d=d+1|0;if(d&3){continue}break}break c}d:{if(d){break d}if(e&3){while(1){if(!c){break a}c=c-1|0;d=c+a|0;H[d|0]=K[b+c|0];if(d&3){continue}break}}if(c>>>0<=3){break d}while(1){c=c-4|0;J[c+a>>2]=J[b+c>>2];if(c>>>0>3){continue}break}}if(!c){break a}while(1){c=c-1|0;H[c+a|0]=K[b+c|0];if(c){continue}break}break a}if(c>>>0<=3){break b}while(1){J[d>>2]=J[b>>2];b=b+4|0;d=d+4|0;c=c-4|0;if(c>>>0>3){continue}break}}if(!c){break a}while(1){H[d|0]=K[b|0];d=d+1|0;b=b+1|0;c=c-1|0;if(c){continue}break}}return a}function Ig(a,b,c){a:{switch(b-9|0){case 0:b=J[c>>2];J[c>>2]=b+4;J[a>>2]=J[b>>2];return;case 6:b=J[c>>2];J[c>>2]=b+4;b=I[b>>1];J[a>>2]=b;J[a+4>>2]=b>>31;return;case 7:b=J[c>>2];J[c>>2]=b+4;J[a>>2]=L[b>>1];J[a+4>>2]=0;return;case 8:b=J[c>>2];J[c>>2]=b+4;b=H[b|0];J[a>>2]=b;J[a+4>>2]=b>>31;return;case 9:b=J[c>>2];J[c>>2]=b+4;J[a>>2]=K[b|0];J[a+4>>2]=0;return;case 16:b=J[c>>2]+7&-8;J[c>>2]=b+8;O[a>>3]=O[b>>3];return;case 17:Fg(a,c);default:return;case 1:case 4:case 14:b=J[c>>2];J[c>>2]=b+4;b=J[b>>2];J[a>>2]=b;J[a+4>>2]=b>>31;return;case 2:case 5:case 11:case 15:b=J[c>>2];J[c>>2]=b+4;J[a>>2]=J[b>>2];J[a+4>>2]=0;return;case 3:case 10:case 12:case 13:break a}}b=J[c>>2]+7&-8;J[c>>2]=b+8;c=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=c;}function Xd(a,b,c,d,e){var f=0,g=0;f=Ua-16|0;Ua=f;J[f+12>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;b=$(197,J[f+12>>2])|0;g=J[5996];J[5996]=0;a:{if((g|0)==1){break a}J[5996]=0;ga(208,b|0,12416,12448,c|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}J[5996]=0;b=$(198,J[f+12>>2])|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[5996]=0;c=$(209,b|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break a}J[d>>2]=c;J[5996]=0;c=$(206,b|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}J[e>>2]=c;J[5996]=0;aa(207,a|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break a}a=J[f+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}Ua=f+16|0;return}c=Z()|0;a=J[f+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function $d(a,b,c,d,e){var f=0,g=0;f=Ua-16|0;Ua=f;J[f+12>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;b=$(170,J[f+12>>2])|0;g=J[5996];J[5996]=0;a:{if((g|0)==1){break a}J[5996]=0;ga(195,b|0,12416,12448,c|0);b=J[5996];J[5996]=0;if((b|0)==1){break a}J[5996]=0;b=$(180,J[f+12>>2])|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}J[5996]=0;c=$(196,b|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break a}H[d|0]=c;J[5996]=0;c=$(193,b|0)|0;d=J[5996];J[5996]=0;if((d|0)==1){break a}H[e|0]=c;J[5996]=0;aa(194,a|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break a}a=J[f+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}Ua=f+16|0;return}c=Z()|0;a=J[f+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function jg(a,b,c,d,e,f){var g=0;g=Ua-80|0;Ua=g;a:{if((f|0)>=16384){ob(g+32|0,b,c,d,e,0,0,0,2147352576);d=J[g+40>>2];e=J[g+44>>2];b=J[g+32>>2];c=J[g+36>>2];if(f>>>0<32767){f=f-16383|0;break a}ob(g+16|0,b,c,d,e,0,0,0,2147352576);f=((f|0)>=49149?49149:f)-32766|0;d=J[g+24>>2];e=J[g+28>>2];b=J[g+16>>2];c=J[g+20>>2];break a}if((f|0)>-16383){break a}ob(g- -64|0,b,c,d,e,0,0,0,7471104);d=J[g+72>>2];e=J[g+76>>2];b=J[g+64>>2];c=J[g+68>>2];if(f>>>0>4294934644){f=f+16269|0;break a}ob(g+48|0,b,c,d,e,0,0,0,7471104);f=((f|0)<=-48920?-48920:f)+32538|0;d=J[g+56>>2];e=J[g+60>>2];b=J[g+48>>2];c=J[g+52>>2];}ob(g,b,c,d,e,0,0,0,f+16383<<16);b=J[g+12>>2];J[a+8>>2]=J[g+8>>2];J[a+12>>2]=b;b=J[g+4>>2];J[a>>2]=J[g>>2];J[a+4>>2]=b;Ua=g+80|0;}function cc(a,b,c,d,e){var f=0,g=0,h=0,i=0;h=Ua-16|0;Ua=h;J[h+12>>2]=b;b=0;g=6;a:{b:{if(Ub(a,h+12|0)){break b}g=J[a>>2];f=J[g+12>>2];c:{if((f|0)==J[g+16>>2]){f=Xa[J[J[g>>2]+36>>2]](g)|0;break c}f=K[f|0];}g=4;i=J[d+8>>2];f=f<<24>>24;if((f|0)>=0){i=(J[((f&255)<<2)+i>>2]&64)!=0;}else {i=0;}if(!i){break b}b=Xa[J[J[d>>2]+36>>2]](d,f,0)|0;while(1){d:{b=b-48|0;f=Ic(a);if(Ub(f,h+12|0)|(e|0)<2){break d}g=J[f>>2];f=J[g+12>>2];e:{if((f|0)==J[g+16>>2]){g=Xa[J[J[g>>2]+36>>2]](g)|0;break e}g=K[f|0];}f=J[d+8>>2];g=g<<24>>24;if((g|0)>=0){f=(J[f+((g&255)<<2)>>2]&64)!=0;}else {f=0;}if(!f){break a}e=e-1|0;b=(Xa[J[J[d>>2]+36>>2]](d,g,0)|0)+P(b,10)|0;continue}break}g=2;if(!Ub(f,h+12|0)){break a}}J[c>>2]=J[c>>2]|g;}Ua=h+16|0;return b}function Wb(a,b){a=a|0;b=b|0;var c=0,d=0;a:{if((b|0)>0){d=a+b|0;while(1){b=1;b:{c:{switch(K[a|0]-66|0){default:a=Rb(8);J[5996]=0;b=_(17,a|0,2064)|0;c=J[5996];J[5996]=0;if((c|0)==1){break a}na(b|0,22528,7);B();case 20:b=2;break b;case 9:b=4;break b;case 21:b=8;break b;case 56:b=16;break b;case 45:b=32;break b;case 44:b=64;break b;case 34:b=128;break b;case 51:b=256;break b;case 35:b=512;break b;case 36:b=1024;break b;case 49:b=2048;break b;case 43:b=4096;break b;case 54:b=8192;break b;case 37:b=16384;break b;case 38:b=32768;break b;case 39:b=65536;break b;case 40:b=131072;break b;case 0:break b;case 41:break c}}b=262144;}c=b|c;a=a+1|0;if(d>>>0>a>>>0){continue}break}}return c|0}b=Z()|0;ic(a);da(b|0);B();}function Sb(a,b,c){var d=0,e=0,f=0,g=0;a:{if(!c){break a}H[a|0]=b;d=a+c|0;H[d-1|0]=b;if(c>>>0<3){break a}H[a+2|0]=b;H[a+1|0]=b;H[d-3|0]=b;H[d-2|0]=b;if(c>>>0<7){break a}H[a+3|0]=b;H[d-4|0]=b;if(c>>>0<9){break a}d=0-a&3;e=d+a|0;b=P(b&255,16843009);J[e>>2]=b;d=c-d&-4;c=d+e|0;J[c-4>>2]=b;if(d>>>0<9){break a}J[e+8>>2]=b;J[e+4>>2]=b;J[c-8>>2]=b;J[c-12>>2]=b;if(d>>>0<25){break a}J[e+24>>2]=b;J[e+20>>2]=b;J[e+16>>2]=b;J[e+12>>2]=b;J[c-16>>2]=b;J[c-20>>2]=b;J[c-24>>2]=b;J[c-28>>2]=b;g=e&4|24;c=d-g|0;if(c>>>0<32){break a}d=co(b,0,1,1);f=Wa;b=e+g|0;while(1){J[b+24>>2]=d;J[b+28>>2]=f;J[b+16>>2]=d;J[b+20>>2]=f;J[b+8>>2]=d;J[b+12>>2]=f;J[b>>2]=d;J[b+4>>2]=f;b=b+32|0;c=c-32|0;if(c>>>0>31){continue}break}}return a}function re(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;a:{d=J[a+4>>2];h=J[a>>2];f=d-h>>3;c=f+1|0;if(c>>>0<536870912){g=J[a+8>>2]-h|0;e=g>>2;c=g>>>0>=2147483640?536870911:c>>>0<e>>>0?e:c;if(c>>>0>=536870912){break a}e=f<<3;f=c<<3;g=cb(f);c=e+g|0;J[c>>2]=J[b>>2];J[c+4>>2]=J[b+4>>2];J[b>>2]=0;J[b+4>>2]=0;e=c+8|0;if((d|0)!=(h|0)){while(1){c=c-8|0;d=d-8|0;J[c>>2]=J[d>>2];J[c+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;if((d|0)!=(h|0)){continue}break}}J[a+8>>2]=f+g;b=J[a>>2];J[a>>2]=c;d=J[a+4>>2];J[a+4>>2]=e;if((b|0)!=(d|0)){while(1){d=d-8|0;a=J[d+4>>2];b:{if(!a){break b}c=J[a+4>>2];J[a+4>>2]=c-1;if(c){break b}Xa[J[J[a>>2]+8>>2]](a);bb(a);}if((b|0)!=(d|0)){continue}break}}if(b){$a(b);}return}nb();B();}Pb();B();}function jb(){var a=0,b=0,c=0,d=0;if(K[25008]){return J[6251]}c=Ua-32|0;Ua=c;a:{b:{while(1){b=c+8|0;d=dg(a,1<<a&2147483647?3538:5575);J[b+(a<<2)>>2]=d;if((d|0)==-1){break b}a=a+1|0;if((a|0)!=6){continue}break}a=19324;if(!Eb(b,19324,24)){break a}a=19348;if(!Eb(b,19348,24)){break a}a=0;if(!K[24780]){while(1){J[(a<<2)+24732>>2]=dg(a,5575);a=a+1|0;if((a|0)!=6){continue}break}H[24780]=1;J[6189]=J[6183];}a=24732;b=c+8|0;if(!Eb(b,24732,24)){break a}a=24756;if(!Eb(b,24756,24)){break a}a=sb(24);if(!a){break b}b=J[c+12>>2];J[a>>2]=J[c+8>>2];J[a+4>>2]=b;b=J[c+28>>2];J[a+16>>2]=J[c+24>>2];J[a+20>>2]=b;b=J[c+20>>2];J[a+8>>2]=J[c+16>>2];J[a+12>>2]=b;break a}a=0;}Ua=c+32|0;H[25008]=1;J[6251]=a;return a}function Fe(a,b){var c=0,d=0,e=0,f=0;c=Ua+-64|0;Ua=c;d=J[a>>2];e=J[d-4>>2];f=J[d-8>>2];J[c+28>>2]=0;J[c+32>>2]=0;J[c+36>>2]=0;J[c+40>>2]=0;J[c+44>>2]=0;J[c+48>>2]=0;J[c+52>>2]=0;J[c+56>>2]=0;d=0;H[c+59|0]=0;H[c+60|0]=0;H[c+61|0]=0;H[c+62|0]=0;J[c+20>>2]=0;J[c+24>>2]=0;J[c+16>>2]=22056;J[c+12>>2]=a;J[c+8>>2]=b;a=a+f|0;a:{if(Jb(e,b,0)){J[c+56>>2]=1;Xa[J[J[e>>2]+20>>2]](e,c+8|0,a,a,1,0);d=J[c+32>>2]==1?a:0;break a}Xa[J[J[e>>2]+24>>2]](e,c+8|0,a,1,0);b:{switch(J[c+44>>2]){case 0:d=J[c+48>>2]==1?J[c+36>>2]==1?J[c+40>>2]==1?J[c+28>>2]:0:0:0;break a;case 1:break b;default:break a}}if(J[c+32>>2]!=1){if(J[c+48>>2]|J[c+36>>2]!=1|J[c+40>>2]!=1){break a}}d=J[c+24>>2];}Ua=c- -64|0;return d}function dg(a,b){var c=0,d=0,e=0;a:{if(K[b|0]){break a}b=fe(3169);if(K[b|0]?b:0){break a}b=fe(P(a,12)+9024|0);if(K[b|0]?b:0){break a}b=fe(3321);if(K[b|0]?b:0){break a}b=3845;}b:{while(1){d=K[b+c|0];if(!(!d|(d|0)==47)){d=23;c=c+1|0;if((c|0)!=23){continue}break b}break}d=c;}e=3845;c:{d:{c=K[b|0];e:{f:{if(!(K[b+d|0]|(c|0)==46)){e=b;if((c|0)!=67){break f}}if(!K[e+1|0]){break e}}if(!Uc(e,3845)){break e}if(Uc(e,2764)){break d}}if(!a){c=9096;if(K[e+1|0]==46){break c}}return 0}c=J[6182];if(c){while(1){if(!Uc(e,c+8|0)){break c}c=J[c+32>>2];if(c){continue}break}}c=sb(36);if(c){J[c+4>>2]=20;J[c>>2]=8992;b=c+8|0;fb(b,e,d);H[b+d|0]=0;J[c+32>>2]=J[6182];J[6182]=c;}c=a|c?c:9096;}return c}function $a(a){var b=0,c=0,d=0,e=0,f=0;if(a){b=a-4|0;e=J[b>>2];d=e;c=b;f=J[a-8>>2];a=f&-2;if((a|0)!=(f|0)){c=b-a|0;f=J[c+4>>2];J[f+8>>2]=J[c+8>>2];J[J[c+8>>2]+4>>2]=f;d=a+d|0;}a=b+e|0;b=J[a>>2];if((b|0)!=J[(a+b|0)-4>>2]){e=J[a+4>>2];J[e+8>>2]=J[a+8>>2];J[J[a+8>>2]+4>>2]=e;d=b+d|0;}J[c>>2]=d;J[((d&-4)+c|0)-4>>2]=d|1;b=J[c>>2]-8|0;a:{if(b>>>0<=127){a=(b>>>3|0)-1|0;break a}d=S(b);a=((b>>>29-d^4)-(d<<2)|0)+110|0;if(b>>>0<=4095){break a}a=((b>>>30-d^2)-(d<<1)|0)+71|0;a=a>>>0>=63?63:a;}b=a<<4;J[c+4>>2]=b+22944;b=b+22952|0;J[c+8>>2]=J[b>>2];J[b>>2]=c;J[J[c+8>>2]+4>>2]=c;b=J[5994];d=J[5995];c=a&31;if((a&63)>>>0>=32){a=1<<c;e=0;}else {e=1<<c;a=e-1&1>>>32-c;}J[5994]=e|b;J[5995]=a|d;}}function Dc(a,b,c,d,e,f,g,h,i,j,k){var l=0,m=0,n=0;a:{b:{l=J[d>>2];if((l|0)!=(c|0)){break b}m=43;n=a&255;if((n|0)!=K[k+24|0]){m=45;if(K[k+25|0]!=(n|0)){break b}}J[d>>2]=c+1;H[c|0]=m;break a}c:{if(!(!((h&128)>>>7|0?g:h&127)|(a|0)!=(f|0))){h=0;a=J[j>>2];if((a-i|0)>159){break c}b=J[e>>2];J[j>>2]=a+4;J[a>>2]=b;break a}h=-1;a=be(k,k+26|0,a)-k|0;if((a|0)>23){break c}d:{e:{switch(b-8|0){case 0:case 2:if((a|0)<(b|0)){break d}break c;case 1:break d;default:break e}}if((b|0)!=16|(a|0)<22){break d}if((c|0)==(l|0)|(l-c|0)>2|K[l-1|0]!=48){break c}J[e>>2]=0;J[d>>2]=l+1;H[l|0]=K[a+12416|0];return 0}J[d>>2]=l+1;H[l|0]=K[a+12416|0];J[e>>2]=J[e>>2]+1;h=0;}return h}J[e>>2]=0;return 0}function Cc(a,b,c,d,e,f,g,h,i,j,k){var l=0,m=0;a:{b:{l=J[d>>2];if((l|0)!=(c|0)){break b}m=43;if(J[k+96>>2]!=(a|0)){m=45;if(J[k+100>>2]!=(a|0)){break b}}J[d>>2]=c+1;H[c|0]=m;break a}c:{if(!(!((h&128)>>>7|0?g:h&127)|(a|0)!=(f|0))){h=0;a=J[j>>2];if((a-i|0)>159){break c}b=J[e>>2];J[j>>2]=a+4;J[a>>2]=b;break a}h=-1;f=Yd(k,k+104|0,a)-k|0;if((f|0)>92){break c}a=f>>2;d:{e:{switch(b-8|0){case 0:case 2:if((a|0)<(b|0)){break d}break c;case 1:break d;default:break e}}if((b|0)!=16|(f|0)<88){break d}if((c|0)==(l|0)|(l-c|0)>2|K[l-1|0]!=48){break c}J[e>>2]=0;J[d>>2]=l+1;H[l|0]=K[a+12416|0];return 0}J[d>>2]=l+1;H[l|0]=K[a+12416|0];J[e>>2]=J[e>>2]+1;h=0;}return h}J[e>>2]=0;return 0}function mc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;c=J[a+4>>2];d=J[a+8>>2];if(c>>>0<d>>>0){J[c>>2]=b;J[a+4>>2]=c+4;return}a:{b:{c:{g=J[a>>2];e=c-g>>2;f=e+1|0;if(f>>>0<1073741824){h=e<<2;d=d-g|0;e=d>>1;d=d>>>0>=2147483644?1073741823:f>>>0<e>>>0?e:f;if(d){if(d>>>0>=1073741824){break c}e=cb(d<<2);}else {e=0;}f=h+e|0;J[f>>2]=b;b=e+(d<<2)|0;d=f+4|0;if((c|0)==(g|0)){break b}while(1){c=c-4|0;e=J[c>>2];J[c>>2]=0;f=f-4|0;J[f>>2]=e;if((c|0)!=(g|0)){continue}break}J[a+8>>2]=b;b=J[a+4>>2];J[a+4>>2]=d;c=J[a>>2];J[a>>2]=f;if((b|0)==(c|0)){break a}while(1){b=b-4|0;ad(b);if((b|0)!=(c|0)){continue}break}break a}nb();B();}Pb();B();}J[a+8>>2]=b;J[a+4>>2]=d;J[a>>2]=f;}if(c){$a(c);}}function bn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;a:{if(b>>>0>=256){a=Rb(8);J[5996]=0;b=_(91,a|0,2394)|0;c=J[5996];J[5996]=0;if((c|0)!=1){break a}b=Z()|0;ic(a);da(b|0);B();}c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=c-29|0;f=c>>>0<29?c:e;d=f+1|0;if(d>>>0>(c>>>0<=28?28:K[a+4|0]|K[a+5|0]<<8|(K[a+6|0]<<16|K[a+7|0]<<24))>>>0){Ob(a,d+(d>>>1|0)|0);c=K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24);e=c-29|0;}g=c>>>0<29;d=(g?a+4|0:K[a+8|0]|K[a+9|0]<<8|(K[a+10|0]<<16|K[a+11|0]<<24))+f|0;eb(d+1|0,d,(g?c:e)-f|0);c=(K[a|0]|K[a+1|0]<<8|(K[a+2|0]<<16|K[a+3|0]<<24))+1|0;H[a|0]=c;H[a+1|0]=c>>>8;H[a+2|0]=c>>>16;H[a+3|0]=c>>>24;H[d|0]=b;return a|0}na(b|0,22664,92);B();}function Wk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;g=Ua-256|0;Ua=g;J[g+248>>2]=37;J[g+252>>2]=0;h=g+248|0;rc(h|1,2055,1,J[c+4>>2]);i=jb();J[g>>2]=e;J[g+4>>2]=f;a=g+224|0;e=yb(a,24,i,h,g)+a|0;i=Lb(a,e,J[c+4>>2]);f=g+20|0;h=J[c+28>>2];J[f>>2]=h;J[h+4>>2]=J[h+4>>2]+1;J[5996]=0;h=g+32|0;ma(215,a|0,i|0,e|0,h|0,g+28|0,g+24|0,f|0);a=J[5996];J[5996]=0;a:{if((a|0)!=1){a=J[f>>2];e=J[a+4>>2]-1|0;J[a+4>>2]=e;if((e|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=Bc(b,h,J[g+28>>2],J[g+24>>2],c,d);Ua=g+256|0;break a}c=Z()|0;a=J[g+20>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}return a|0}function Uk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;g=Ua-256|0;Ua=g;J[g+248>>2]=37;J[g+252>>2]=0;h=g+248|0;rc(h|1,2055,0,J[c+4>>2]);i=jb();J[g>>2]=e;J[g+4>>2]=f;a=g+224|0;e=yb(a,24,i,h,g)+a|0;i=Lb(a,e,J[c+4>>2]);f=g+20|0;h=J[c+28>>2];J[f>>2]=h;J[h+4>>2]=J[h+4>>2]+1;J[5996]=0;h=g+32|0;ma(215,a|0,i|0,e|0,h|0,g+28|0,g+24|0,f|0);a=J[5996];J[5996]=0;a:{if((a|0)!=1){a=J[f>>2];e=J[a+4>>2]-1|0;J[a+4>>2]=e;if((e|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=Bc(b,h,J[g+28>>2],J[g+24>>2],c,d);Ua=g+256|0;break a}c=Z()|0;a=J[g+20>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}return a|0}function fl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;g=Ua-112|0;Ua=g;J[g+104>>2]=37;J[g+108>>2]=0;h=g+104|0;rc(h|1,2055,1,J[c+4>>2]);i=jb();J[g>>2]=e;J[g+4>>2]=f;a=g+80|0;e=yb(a,24,i,h,g)+a|0;i=Lb(a,e,J[c+4>>2]);f=g+20|0;h=J[c+28>>2];J[f>>2]=h;J[h+4>>2]=J[h+4>>2]+1;J[5996]=0;h=g+32|0;ma(211,a|0,i|0,e|0,h|0,g+28|0,g+24|0,f|0);a=J[5996];J[5996]=0;a:{if((a|0)!=1){a=J[f>>2];e=J[a+4>>2]-1|0;J[a+4>>2]=e;if((e|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=Ac(b,h,J[g+28>>2],J[g+24>>2],c,d);Ua=g+112|0;break a}c=Z()|0;a=J[g+20>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}return a|0}function dl(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;g=Ua-112|0;Ua=g;J[g+104>>2]=37;J[g+108>>2]=0;h=g+104|0;rc(h|1,2055,0,J[c+4>>2]);i=jb();J[g>>2]=e;J[g+4>>2]=f;a=g+80|0;e=yb(a,24,i,h,g)+a|0;i=Lb(a,e,J[c+4>>2]);f=g+20|0;h=J[c+28>>2];J[f>>2]=h;J[h+4>>2]=J[h+4>>2]+1;J[5996]=0;h=g+32|0;ma(211,a|0,i|0,e|0,h|0,g+28|0,g+24|0,f|0);a=J[5996];J[5996]=0;a:{if((a|0)!=1){a=J[f>>2];e=J[a+4>>2]-1|0;J[a+4>>2]=e;if((e|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=Ac(b,h,J[g+28>>2],J[g+24>>2],c,d);Ua=g+112|0;break a}c=Z()|0;a=J[g+20>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}return a|0}function Fh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0;if(Jb(a,J[b+8>>2],f)){Hd(b,c,d,e);return}g=K[b+53|0];i=J[a+12>>2];H[b+53|0]=0;h=K[b+52|0];H[b+52|0]=0;Fd(J[a+16>>2],J[a+20>>2],b,c,d,e,f);j=K[b+52|0];h=(h|j)!=0;k=K[b+53|0];l=(g|k)!=0;g=a+24|0;i=(a+16|0)+(i<<3)|0;a:{if(g>>>0>=i>>>0){break a}while(1){if(K[b+54|0]){break a}b:{if(j){if(J[b+24>>2]==1){break a}if(K[a+8|0]&2){break b}break a}if(!k){break b}if(!(H[a+8|0]&1)){break a}}I[b+52>>1]=0;Fd(J[g>>2],J[g+4>>2],b,c,d,e,f);k=K[b+53|0];l=(k|l)!=0;j=K[b+52|0];h=(j|h)!=0;g=g+8|0;if(i>>>0>g>>>0){continue}break}}H[b+53|0]=l;H[b+52|0]=h;}function bc(a,b,c,d,e){var f=0,g=0,h=0,i=0;h=Ua-16|0;Ua=h;J[h+12>>2]=b;b=0;g=6;a:{b:{if(Tb(a,h+12|0)){break b}g=4;f=J[a>>2];i=J[f+12>>2];c:{if((i|0)==J[f+16>>2]){f=Xa[J[J[f>>2]+36>>2]](f)|0;break c}f=J[i>>2];}if(!(Xa[J[J[d>>2]+12>>2]](d,64,f)|0)){break b}b=Xa[J[J[d>>2]+52>>2]](d,f,0)|0;while(1){d:{b=b-48|0;f=Hc(a);if(Tb(f,h+12|0)|(e|0)<2){break d}g=J[f>>2];f=J[g+12>>2];e:{if((f|0)==J[g+16>>2]){g=Xa[J[J[g>>2]+36>>2]](g)|0;break e}g=J[f>>2];}if(!(Xa[J[J[d>>2]+12>>2]](d,64,g)|0)){break a}e=e-1|0;b=(Xa[J[J[d>>2]+52>>2]](d,g,0)|0)+P(b,10)|0;continue}break}g=2;if(!Tb(f,h+12|0)){break a}}J[c>>2]=J[c>>2]|g;}Ua=h+16|0;return b}function qd(a,b,c,d){var e=0,f=0,g=0,h=0;g=d?d:24720;d=J[g>>2];a:{b:{c:{if(!b){if(d){break c}return 0}e=-2;if(!c){break b}d:{if(d){e=c;break d}d=K[b|0];f=d<<24>>24;if((f|0)>=0){if(a){J[a>>2]=d;}return (f|0)!=0}if(!J[J[6178]>>2]){e=1;if(!a){break b}J[a>>2]=f&57343;return 1}d=d-194|0;if(d>>>0>50){break c}d=J[(d<<2)+12208>>2];e=c-1|0;if(!e){break a}b=b+1|0;}f=K[b|0];h=f>>>3|0;if((h-16|(d>>26)+h)>>>0>7){break c}while(1){e=e-1|0;d=f-128|d<<6;if((d|0)>=0){J[g>>2]=0;if(a){J[a>>2]=d;}return c-e|0}if(!e){break a}b=b+1|0;f=K[b|0];if((f&192)==128){continue}break}}J[g>>2]=0;J[5732]=25;e=-1;}return e}J[g>>2]=d;return -2}function Zk(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=Ua-144|0;Ua=f;J[f+136>>2]=37;J[f+140>>2]=0;h=f+136|0;rc(h|1,2096,1,J[c+4>>2]);g=jb();J[f>>2]=e;a=f+123|0;e=yb(a,13,g,h,f)+a|0;i=Lb(a,e,J[c+4>>2]);h=f+4|0;g=J[c+28>>2];J[h>>2]=g;J[g+4>>2]=J[g+4>>2]+1;J[5996]=0;g=f+16|0;ma(215,a|0,i|0,e|0,g|0,f+12|0,f+8|0,h|0);a=J[5996];J[5996]=0;a:{if((a|0)!=1){a=J[h>>2];e=J[a+4>>2]-1|0;J[a+4>>2]=e;if((e|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=Bc(b,g,J[f+12>>2],J[f+8>>2],c,d);Ua=f+144|0;break a}c=Z()|0;a=J[f+4>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}return a|0}function Vk(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=Ua-144|0;Ua=f;J[f+136>>2]=37;J[f+140>>2]=0;h=f+136|0;rc(h|1,2096,0,J[c+4>>2]);g=jb();J[f>>2]=e;a=f+123|0;e=yb(a,13,g,h,f)+a|0;i=Lb(a,e,J[c+4>>2]);h=f+4|0;g=J[c+28>>2];J[h>>2]=g;J[g+4>>2]=J[g+4>>2]+1;J[5996]=0;g=f+16|0;ma(215,a|0,i|0,e|0,g|0,f+12|0,f+8|0,h|0);a=J[5996];J[5996]=0;a:{if((a|0)!=1){a=J[h>>2];e=J[a+4>>2]-1|0;J[a+4>>2]=e;if((e|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=Bc(b,g,J[f+12>>2],J[f+8>>2],c,d);Ua=f+144|0;break a}c=Z()|0;a=J[f+4>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}return a|0}function hl(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=Ua+-64|0;Ua=f;J[f+56>>2]=37;J[f+60>>2]=0;h=f+56|0;rc(h|1,2096,1,J[c+4>>2]);g=jb();J[f>>2]=e;a=f+43|0;e=yb(a,13,g,h,f)+a|0;i=Lb(a,e,J[c+4>>2]);h=f+4|0;g=J[c+28>>2];J[h>>2]=g;J[g+4>>2]=J[g+4>>2]+1;J[5996]=0;g=f+16|0;ma(211,a|0,i|0,e|0,g|0,f+12|0,f+8|0,h|0);a=J[5996];J[5996]=0;a:{if((a|0)!=1){a=J[h>>2];e=J[a+4>>2]-1|0;J[a+4>>2]=e;if((e|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=Ac(b,g,J[f+12>>2],J[f+8>>2],c,d);Ua=f- -64|0;break a}c=Z()|0;a=J[f+4>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}return a|0}function el(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=Ua+-64|0;Ua=f;J[f+56>>2]=37;J[f+60>>2]=0;h=f+56|0;rc(h|1,2096,0,J[c+4>>2]);g=jb();J[f>>2]=e;a=f+43|0;e=yb(a,13,g,h,f)+a|0;i=Lb(a,e,J[c+4>>2]);h=f+4|0;g=J[c+28>>2];J[h>>2]=g;J[g+4>>2]=J[g+4>>2]+1;J[5996]=0;g=f+16|0;ma(211,a|0,i|0,e|0,g|0,f+12|0,f+8|0,h|0);a=J[5996];J[5996]=0;a:{if((a|0)!=1){a=J[h>>2];e=J[a+4>>2]-1|0;J[a+4>>2]=e;if((e|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}a=Ac(b,g,J[f+12>>2],J[f+8>>2],c,d);Ua=f- -64|0;break a}c=Z()|0;a=J[f+4>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}return a|0}function jh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;J[c>>2]=0;a:{e=J[b+4>>2];if(!e){break a}f=J[b>>2];b:{c:{d:{while(1){d=H[f|0];g=J[c>>2];if((d|0)<((g?48:49)|0)|(d|0)>57){break d}d=(d+P(g,10)|0)-48|0;J[c>>2]=d>>>0>=65535?65535:d;e=e-1|0;J[b+4>>2]=e;f=f+1|0;J[b>>2]=f;if(e){continue}break}if(J[c>>2]){break c}break a}if(!g){break a}if((d|0)==64){break b}}J[a>>2]=0;J[a+4>>2]=0;J[a+48>>2]=0;J[a+52>>2]=0;J[a+40>>2]=0;J[a+44>>2]=0;J[a+32>>2]=0;J[a+36>>2]=0;J[a+24>>2]=0;J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;J[a+8>>2]=0;J[a+12>>2]=0;return}J[b+4>>2]=e-1;J[b>>2]=f+1;Bd(a,b);return}J[c>>2]=1;Bd(a,b);}function yc(a,b,c,d,e,f,g,h){var i=0,j=0,k=0,l=0;j=1;i=d&2147483647;l=i;k=(i|0)==2147418112;a:{if(k&!c?a|b:k&(c|0)!=0|i>>>0>2147418112){break a}i=h&2147483647;if(!g&(i|0)==2147418112?e|f:(i|0)==2147418112&(g|0)!=0|i>>>0>2147418112){break a}if(!(a|e|(c|g)|(b|f|(i|l)))){return 0}j=d&h;if((j|0)>0|(j|0)>=0){j=-1;if((c|0)==(g|0)&(d|0)==(h|0)?(b|0)==(f|0)&a>>>0<e>>>0|b>>>0<f>>>0:c>>>0<g>>>0&(d|0)<=(h|0)|(d|0)<(h|0)){break a}return (a^e|c^g|(b^f|d^h))!=0}j=-1;if((c|0)==(g|0)&(d|0)==(h|0)?(b|0)==(f|0)&a>>>0>e>>>0|b>>>0>f>>>0:c>>>0>g>>>0&(d|0)>=(h|0)|(d|0)>(h|0)){break a}j=(a^e|c^g|(b^f|d^h))!=0;}return j}function _n(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;a:{b:{e=J[a+4>>2];f=J[a>>2];d=e-f>>2;c:{if(d>>>0<b>>>0){g=b-d|0;c=J[a+8>>2];if(g>>>0<=c-e>>2>>>0){b=a;a=g<<2;J[b+4>>2]=Sb(e,0,a)+a;return}if(b>>>0>=1073741824){break b}c=c-f|0;h=c>>1;b=c>>>0>=2147483644?1073741823:b>>>0<h>>>0?h:b;if(b>>>0>=1073741824){break a}c=b<<2;b=cb(c);c=b+c|0;b=b+(d<<2)|0;d=g<<2;d=Sb(b,0,d)+d|0;if((e|0)!=(f|0)){while(1){b=b-4|0;e=e-4|0;J[b>>2]=J[e>>2];if((e|0)!=(f|0)){continue}break}}J[a+8>>2]=c;J[a+4>>2]=d;J[a>>2]=b;if(!f){break c}$a(f);return}if(b>>>0>=d>>>0){break c}J[a+4>>2]=(b<<2)+f;}return}nb();B();}Pb();B();}function Qk(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0;a=Ua-208|0;Ua=a;g=jb();J[a>>2]=e;e=a+176|0;h=yb(e,20,g,1937,a);g=h+e|0;i=Lb(e,g,J[c+4>>2]);f=J[c+28>>2];J[a+12>>2]=f;J[f+4>>2]=J[f+4>>2]+1;J[5996]=0;j=$(197,J[a+12>>2])|0;f=J[5996];J[5996]=0;if((f|0)!=1){f=J[a+12>>2];k=J[f+4>>2]-1|0;J[f+4>>2]=k;if((k|0)==-1){Xa[J[J[f>>2]+8>>2]](f);}f=e;e=a+16|0;Xa[J[J[j>>2]+48>>2]](j,f,g,e)|0;f=b;b=e+(h<<2)|0;b=Bc(f,e,(g|0)==(i|0)?b:(a+(i-a<<2)|0)-688|0,b,c,d);Ua=a+208|0;return b|0}c=Z()|0;a=J[a+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function Rb(a){var b=0,c=0,d=0,e=0,f=0;f=a+27&-4;a=f;b=a>>>0<=1?1:a;a=b;c=a+15&-16;a=a>>>0<c>>>0?c:a;if(a&15){a=0;}else {a=_c(16,a);}if(!a){a:{c=0;a=J[6705];if(!a){J[6705]=26844;I[13423]=125;I[13422]=128;a=J[6705];}d=(b+3>>>2|0)+1|0;while(1){b=0;b:{if(!a|(a|0)==27344){a=b;}else {b=L[a+2>>1];e=d+(b>>>0>d>>>0?b-d&3:0)|0;if(e>>>0<b>>>0){c=b-e|0;I[a+2>>1]=c;a=((c&65535)<<2)+a|0;I[a+2>>1]=e;I[a>>1]=0;a=a+4|0;break a}if(b>>>0<d>>>0){break b}b=L[a>>1];c:{if(!c){J[6705]=(b<<2)+26832;break c}I[c>>1]=b;}I[a>>1]=0;a=a+4|0;}break a}c=a;a=(L[a>>1]<<2)+26832|0;continue}}}if(!a){Vb();B();}return Sb(a,0,f)+24|0}function $k(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0;a=Ua-96|0;Ua=a;g=jb();J[a>>2]=e;e=a- -64|0;h=yb(e,20,g,1937,a);g=h+e|0;i=Lb(e,g,J[c+4>>2]);f=J[c+28>>2];J[a+12>>2]=f;J[f+4>>2]=J[f+4>>2]+1;J[5996]=0;j=$(170,J[a+12>>2])|0;f=J[5996];J[5996]=0;if((f|0)!=1){f=J[a+12>>2];k=J[f+4>>2]-1|0;J[f+4>>2]=k;if((k|0)==-1){Xa[J[J[f>>2]+8>>2]](f);}f=e;e=a+16|0;Xa[J[J[j>>2]+32>>2]](j,f,g,e)|0;f=b;b=e+h|0;b=Ac(f,e,(g|0)==(i|0)?b:(a+(i-a|0)|0)-48|0,b,c,d);Ua=a+96|0;return b|0}c=Z()|0;a=J[a+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function He(a,b,c,d,e,f,g,h){var i=0,j=0,k=0,l=0;i=Ua-16|0;Ua=i;if(1073741806-b>>>0>=c>>>0){k=(K[a+11|0]&128)>>>7|0?J[a>>2]:a;j=i+4|0;l=j;if(b>>>0<=536870886){J[i+12>>2]=b<<1;J[i+4>>2]=b+c;c=J[(M[j>>2]<M[i+12>>2]?i+12|0:j)>>2];if(c>>>0>=2){j=c+4&-4;c=j-1|0;c=(c|0)==2?j:c;}else {c=1;}c=c+1|0;}else {c=1073741807;}Fc(l,c);c=J[i+4>>2];if(e){tc(c,k,e);}if(g){tc(c+(e<<2)|0,h,g);}j=e+f|0;h=d-j|0;if((d|0)!=(j|0)){d=e<<2;tc((d+c|0)+(g<<2)|0,(d+k|0)+(f<<2)|0,h);}if((b|0)!=1){$a(k);}J[a>>2]=c;J[a+8>>2]=J[i+8>>2]|-2147483648;b=a;a=h+(e+g|0)|0;J[b+4>>2]=a;J[c+(a<<2)>>2]=0;Ua=i+16|0;return}ub();B();}function Ad(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;e=c-b|0;if(e>>>0<2147483632){a:{if(e>>>0<=10){H[a+11|0]=e;d=a;break a}f=(e|15)+1|0;d=cb(f);J[a+8>>2]=f|-2147483648;J[a>>2]=d;J[a+4>>2]=e;}b:{if((b|0)==(c|0)){break b}f=(b^-1)+c|0;g=e&7;if(g){e=0;while(1){H[d|0]=K[b|0];d=d+1|0;b=b+1|0;e=e+1|0;if((g|0)!=(e|0)){continue}break}}if(f>>>0<7){break b}while(1){H[d|0]=K[b|0];H[d+1|0]=K[b+1|0];H[d+2|0]=K[b+2|0];H[d+3|0]=K[b+3|0];H[d+4|0]=K[b+4|0];H[d+5|0]=K[b+5|0];H[d+6|0]=K[b+6|0];H[d+7|0]=K[b+7|0];d=d+8|0;b=b+8|0;if((c|0)!=(b|0)){continue}break}}H[d|0]=0;return a|0}ub();B();}function $c(a,b,c,d){var e=0,f=0,g=0;e=Ua-32|0;Ua=e;if(c>>>0<2147483632){a:{b:{if(c>>>0>=11){g=(c|15)+1|0;f=cb(g);J[e+16>>2]=g|-2147483648;J[e+8>>2]=f;J[e+12>>2]=c;break b}H[e+19|0]=c;f=e+8|0;if(!c){break a}}f=fb(f,b,c)+c|0;}H[f|0]=0;J[5996]=0;aa(31,e+20|0,e+8|0);b=J[5996];J[5996]=0;c:{d:{if((b|0)!=1){if(H[e+19|0]<0){$a(J[e+8>>2]);}c=J[e+24>>2];b=J[e+20>>2];if((c-b|0)!=(d|0)){break d}J[a+4>>2]=c;J[a>>2]=b;J[a+8>>2]=J[e+28>>2];break c}a=Z()|0;if(H[e+19|0]<0){$a(J[e+8>>2]);}da(a|0);B();}J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;if(!b){break c}$a(b);}Ua=e+32|0;return}ub();B();}function dd(a,b,c,d,e,f,g,h){var i=0,j=0,k=0,l=0;i=Ua-16|0;Ua=i;if(2147483630-b>>>0>=c>>>0){k=(K[a+11|0]&128)>>>7|0?J[a>>2]:a;j=i+4|0;l=j;if(b>>>0<=1073741798){J[i+12>>2]=b<<1;J[i+4>>2]=b+c;c=J[(M[j>>2]<M[i+12>>2]?i+12|0:j)>>2];if(c>>>0>=11){j=c+16&-16;c=j-1|0;c=(c|0)==11?j:c;}else {c=10;}c=c+1|0;}else {c=2147483631;}Gc(l,c);c=J[i+4>>2];if(e){gc(c,k,e);}if(g){gc(c+e|0,h,g);}j=e+f|0;h=d-j|0;if((d|0)!=(j|0)){gc((c+e|0)+g|0,(e+k|0)+f|0,h);}if((b|0)!=10){$a(k);}J[a>>2]=c;J[a+8>>2]=J[i+8>>2]|-2147483648;b=a;a=h+(e+g|0)|0;J[b+4>>2]=a;H[a+c|0]=0;Ua=i+16|0;return}ub();B();}function Bc(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;i=Ua-16|0;Ua=i;a:{b:{if(!a){break b}g=J[e+12>>2];h=c-b|0;if((h|0)>0){h=h>>>2|0;if((Xa[J[J[a>>2]+48>>2]](a,b,h)|0)!=(h|0)){break b}}b=d-b>>2;g=(b|0)<(g|0)?g-b|0:0;if((g|0)>0){b=Hf(i+4|0,g,f);f=(K[b+11|0]&128)>>>7|0?J[b>>2]:b;J[5996]=0;f=ba(217,a|0,f|0,g|0)|0;h=J[5996];J[5996]=0;if((h|0)==1){break a}ab(b);if((f|0)!=(g|0)){break b}}b=d-c|0;if((b|0)>0){b=b>>>2|0;if((Xa[J[J[a>>2]+48>>2]](a,c,b)|0)!=(b|0)){break b}}J[e+12>>2]=0;j=a;}Ua=i+16|0;return j|0}a=Z()|0;ab(b);da(a|0);B();}function Mh(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;if(Jb(a,J[b+8>>2],e)){if(!(J[b+28>>2]==1|J[b+4>>2]!=(c|0))){J[b+28>>2]=d;}return}a:{if(Jb(a,J[b>>2],e)){if(!(J[b+16>>2]!=(c|0)&J[b+20>>2]!=(c|0))){if((d|0)!=1){break a}J[b+32>>2]=1;return}J[b+32>>2]=d;b:{if(J[b+44>>2]==4){break b}I[b+52>>1]=0;a=J[a+8>>2];Xa[J[J[a>>2]+20>>2]](a,b,c,c,1,e);if(K[b+53|0]){J[b+44>>2]=3;if(!K[b+52|0]){break b}break a}J[b+44>>2]=4;}J[b+20>>2]=c;J[b+40>>2]=J[b+40>>2]+1;if(J[b+36>>2]!=1|J[b+24>>2]!=2){break a}H[b+54|0]=1;return}a=J[a+8>>2];Xa[J[J[a>>2]+24>>2]](a,b,c,d,e);}}function pb(a){var b=0,c=0,d=0,e=0;e=Ua-16|0;Ua=e;b=e+4|0;J[b+4>>2]=190;J[b>>2]=a;J[b+8>>2]=0;d=Ua-16|0;Ua=d;if(J[a>>2]!=-1){a:{c=d+12|0;J[c>>2]=b;b=d+8|0;J[b>>2]=c;while(1){c=J[a>>2];if((c|0)==1){continue}break}b:{if(!c){J[a>>2]=1;b=J[J[b>>2]>>2];J[5996]=0;ha(191,b|0);b=J[5996];J[5996]=0;if((b|0)==1){break b}J[a>>2]=-1;}break a}pa(fa(0)|0)|0;J[a>>2]=0;J[5996]=0;ca(192);a=J[5996];J[5996]=0;c:{if((a|0)==1){a=Z()|0;J[5996]=0;ca(110);b=J[5996];J[5996]=0;if((b|0)!=1){break c}fa(0)|0;Vb();}B();}da(a|0);B();}}Ua=d+16|0;Ua=e+16|0;return J[a+4>>2]-1|0}function Dk(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;c=Ua-128|0;Ua=c;J[c+12>>2]=c+116;d=J[a+8>>2];a=c+16|0;yf(d,a,c+12|0,e,f,g);e=Ua-16|0;Ua=e;g=Ua-32|0;Ua=g;d=Ua-16|0;Ua=d;J[d+12>>2]=J[c+12>>2];J[g+24>>2]=a;J[g+28>>2]=J[d+12>>2];Ua=d+16|0;f=J[g+24>>2];a=J[g+28>>2];d=Ua-16|0;Ua=d;J[d+12>>2]=b;while(1){if((a|0)!=(f|0)){sg(d+12|0,H[f|0]);f=f+1|0;continue}break}J[g+16>>2]=a;J[g+20>>2]=J[d+12>>2];Ua=d+16|0;a=J[g+16>>2];J[g+12>>2]=J[g+20>>2];J[e+8>>2]=a;J[e+12>>2]=J[g+12>>2];Ua=g+32|0;Ua=e+16|0;Ua=c+128|0;return J[e+12>>2]}function Sm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;J[5996]=0;e=$(3,24)|0;f=J[5996];J[5996]=0;a:{if((f|0)!=1){J[a+4>>2]=e;J[a>>2]=e;f=e+24|0;J[a+8>>2]=f;J[e>>2]=J[b>>2];J[e+4>>2]=J[b+4>>2];J[b>>2]=0;J[b+4>>2]=0;J[a+4>>2]=e+8;J[e+8>>2]=J[c>>2];J[e+12>>2]=J[c+4>>2];J[c>>2]=0;J[c+4>>2]=0;b=e+16|0;J[a+4>>2]=b;if(b>>>0<f>>>0){J[b>>2]=J[d>>2];J[b+4>>2]=J[d+4>>2];J[d>>2]=0;J[d+4>>2]=0;J[a+4>>2]=b+8;break a}J[5996]=0;aa(162,a|0,d|0);b=J[5996];J[5996]=0;if((b|0)!=1){break a}}b=Z()|0;lb(a);da(b|0);B();}}function Rm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;d=Ua-16|0;Ua=d;J[a>>2]=7e3;J[a+4>>2]=0;J[a+8>>2]=0;J[d+4>>2]=J[c>>2];J[d+8>>2]=J[c+4>>2];J[d+12>>2]=J[c+8>>2];J[c+8>>2]=0;J[c>>2]=0;J[c+4>>2]=0;J[5996]=0;ia(64,a+12|0,b|0,d+4|0,0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[d+4>>2];if(b){c=J[d+8>>2];if((b|0)!=(c|0)){while(1){c=c-8|0;e=J[c+4>>2];a:{if(!e){break a}f=J[e+4>>2];J[e+4>>2]=f-1;if(f){break a}Xa[J[J[e>>2]+8>>2]](e);bb(e);}if((b|0)!=(c|0)){continue}break}b=J[d+4>>2];}$a(b);}Ua=d+16|0;return a|0}a=Z()|0;lb(d+4|0);da(a|0);B();}function fc(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;e=Ua-16|0;Ua=e;A(+b);g=v(1)|0;c=v(0)|0;d=g&2147483647;f=d+-1048576|0;a:{if((f|0)==2145386495|f>>>0<2145386495){h=c<<28;c=(d&15)<<28|c>>>4;d=(d>>>4|0)+1006632960|0;break a}if((d|0)==2146435072|d>>>0>2146435072){h=c<<28;c=(g&15)<<28|c>>>4;d=g>>>4|2147418112;break a}if(!(c|d)){c=0;d=0;break a}f=c;c=d?S(d):S(c)+32|0;Cb(e,f,d,0,0,c+49|0);i=J[e>>2];h=J[e+4>>2];f=15372-c<<16;c=J[e+8>>2];d=f|J[e+12>>2]^65536;}J[a>>2]=i;J[a+4>>2]=h;J[a+8>>2]=c;J[a+12>>2]=g&-2147483648|d;Ua=e+16|0;}function hm(a){a=a|0;var b=0,c=0,d=0,e=0;c=J[a+76>>2];if((c|0)==-1){c=a;d=Ua-16|0;Ua=d;a=J[a+28>>2];J[d+12>>2]=a;J[a+4>>2]=J[a+4>>2]+1;J[5996]=0;a=$(170,J[d+12>>2])|0;b=J[5996];J[5996]=0;a:{b:{if((b|0)==1){break b}J[5996]=0;a=_(171,a|0,32)|0;b=J[5996];J[5996]=0;if((b|0)==1){break b}b=J[d+12>>2];e=J[b+4>>2]-1|0;J[b+4>>2]=e;if((e|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}Ua=d+16|0;break a}b=Z()|0;a=J[d+12>>2];c=J[a+4>>2]-1|0;J[a+4>>2]=c;if((c|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(b|0);B();}b=c;c=a;J[b+76>>2]=a;}return c<<24>>24}function ch(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;c=J[a+4>>2];d=J[a+8>>2];if(c>>>0<d>>>0){J[c>>2]=b;J[a+4>>2]=c+4;return}a:{g=J[a>>2];e=c-g>>2;f=e+1|0;if(f>>>0<1073741824){h=e<<2;d=d-g|0;e=d>>1;e=d>>>0>=2147483644?1073741823:e>>>0>f>>>0?e:f;if(e){if(e>>>0>=1073741824){break a}f=cb(e<<2);}else {f=0;}d=h+f|0;J[d>>2]=b;b=d+4|0;if((c|0)!=(g|0)){while(1){d=d-4|0;c=c-4|0;J[d>>2]=J[c>>2];if((c|0)!=(g|0)){continue}break}c=J[a>>2];}J[a+8>>2]=f+(e<<2);J[a+4>>2]=b;J[a>>2]=d;if(c){$a(c);}return}nb();B();}Pb();B();}function Hm(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0;e=Ua-16|0;Ua=e;f=cb(104);J[f>>2]=7e3;J[f+4>>2]=0;J[f+8>>2]=0;J[e+4>>2]=J[c>>2];J[e+8>>2]=J[c+4>>2];J[e+12>>2]=J[c+8>>2];J[c+8>>2]=0;J[c>>2]=0;J[c+4>>2]=0;J[5996]=0;g=ia(163,f+12|0,b|0,e+4|0,d|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){d=J[e+4>>2];if(d){b=J[e+8>>2];if((d|0)!=(b|0)){while(1){c=b-12|0;if(H[b-1|0]<0){$a(J[c>>2]);}b=c;if((c|0)!=(d|0)){continue}break}}$a(d);}J[a+4>>2]=f;J[a>>2]=g;Ua=e+16|0;return}a=Z()|0;rb(e+4|0);$a(f);da(a|0);B();}function Yf(a,b,c,d){var e=0,f=0,g=0;e=Ua-16|0;Ua=e;a:{b:{if((a|0)!=(b|0)){c:{g=J[5732];J[5732]=0;jb();a=Uf(a,e+12|0,d);d=Wa;d:{f=J[5732];if(f){if(J[e+12>>2]!=(b|0)){break c}if((f|0)!=68){break d}J[c>>2]=4;b=2147483647;if(!!a&(d|0)>=0|(d|0)>0){break a}break b}J[5732]=g;if(J[e+12>>2]==(b|0)){break d}break c}if((d|0)<0&a>>>0<=2147483647|(d|0)<-1){J[c>>2]=4;break b}if((d|0)>=0&a>>>0>=2147483648|(d|0)>0){J[c>>2]=4;b=2147483647;break a}b=a;break a}}J[c>>2]=4;b=0;break a}b=-2147483648;}Ua=e+16|0;return b}function xc(a,b,c,d,e,f){var g=0,h=0,i=0,j=0;a:{if(f&64){c=f+-64|0;b=c&31;if((c&63)>>>0>=32){c=0;b=e>>>b|0;}else {c=e>>>b|0;b=((1<<b)-1&e)<<32-b|d>>>b;}d=0;e=0;break a}if(!f){break a}i=d;h=64-f|0;g=h&31;if((h&63)>>>0>=32){h=d<<g;j=0;}else {h=(1<<g)-1&i>>>32-g|e<<g;j=i<<g;}i=b;b=f&31;if((f&63)>>>0>=32){g=0;b=c>>>b|0;}else {g=c>>>b|0;b=((1<<b)-1&c)<<32-b|i>>>b;}b=j|b;c=g|h;g=d;d=f&31;if((f&63)>>>0>=32){h=0;d=e>>>d|0;}else {h=e>>>d|0;d=((1<<d)-1&e)<<32-d|g>>>d;}e=h;}J[a>>2]=b;J[a+4>>2]=c;J[a+8>>2]=d;J[a+12>>2]=e;}function Rc(a,b,c){var d=0,e=0,f=0;d=Ua-16|0;Ua=d;J[d+12>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;b=$(198,J[d+12>>2])|0;e=J[5996];J[5996]=0;a:{if((e|0)==1){break a}J[5996]=0;e=$(206,b|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break a}J[c>>2]=e;J[5996]=0;aa(207,a|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break a}a=J[d+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}Ua=d+16|0;return}c=Z()|0;a=J[d+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function Tc(a,b,c){var d=0,e=0,f=0;d=Ua-16|0;Ua=d;J[d+12>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;b=$(180,J[d+12>>2])|0;e=J[5996];J[5996]=0;a:{if((e|0)==1){break a}J[5996]=0;e=$(193,b|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break a}H[c|0]=e;J[5996]=0;aa(194,a|0,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break a}a=J[d+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}Ua=d+16|0;return}c=Z()|0;a=J[d+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function sj(a){if(K[25148]){return J[6286]}if(!K[26240]){H[26240]=1;}ib(25952,18680);ib(25964,18712);ib(25976,18748);ib(25988,18772);ib(26e3,18796);ib(26012,18812);ib(26024,18832);ib(26036,18852);ib(26048,18880);ib(26060,18920);ib(26072,18952);ib(26084,18988);ib(26096,19024);ib(26108,19040);ib(26120,19056);ib(26132,19072);ib(26144,18796);ib(26156,19088);ib(26168,19104);ib(26180,19120);ib(26192,19136);ib(26204,19152);ib(26216,19168);ib(26228,19184);H[25148]=1;J[6286]=25952;return 25952}function qn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0;f=Gb(c);a:{d=K[a+11|0];e=d&127;d=(d&128)>>>7|0;e=d?J[a+4>>2]:e;if(e>>>0>=b>>>0){d=d?(J[a+8>>2]&2147483647)-1|0:10;if(d-e>>>0>=f>>>0){if(!f){break a}d=(K[a+11|0]&128)>>>7|0?J[a>>2]:a;h=d+b|0;if((b|0)!=(e|0)){g=b+d|0;oc(g+f|0,g,e-b|0);c=(c>>>0>=g>>>0?d+e>>>0>c>>>0?f:0:0)+c|0;}oc(h,c,f);b=f+e|0;b:{if((K[a+11|0]&128)>>>7|0){J[a+4>>2]=b;break b}H[a+11|0]=b;}H[b+d|0]=0;break a}dd(a,d,(f+e|0)-d|0,e,b,0,f,c);break a}ue();B();}return a|0}function hh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;e=J[a+4>>2];if((e|0)!=J[a+8>>2]){J[e>>2]=b;J[a+4>>2]=e+4;return}a:{g=J[a>>2];f=e-g|0;c=f>>2;d=c+1|0;if(d>>>0<1073741824){h=c<<2;c=f>>1;c=f>>>0>=2147483644?1073741823:c>>>0>d>>>0?c:d;if(c){if(c>>>0>=1073741824){break a}f=cb(c<<2);}else {f=0;}d=h+f|0;J[d>>2]=b;b=d+4|0;if((e|0)!=(g|0)){while(1){d=d-4|0;e=e-4|0;J[d>>2]=J[e>>2];if((e|0)!=(g|0)){continue}break}}J[a+8>>2]=f+(c<<2);J[a+4>>2]=b;J[a>>2]=d;if(g){$a(g);}return}nb();B();}Pb();B();}function Cb(a,b,c,d,e,f){var g=0,h=0,i=0;a:{if(f&64){e=f+-64|0;f=b;d=e&31;if((e&63)>>>0>=32){e=f<<d;d=0;}else {e=(1<<d)-1&f>>>32-d|c<<d;d=f<<d;}b=0;c=0;break a}if(!f){break a}h=d;g=f&31;if((f&63)>>>0>=32){i=d<<g;h=0;}else {i=(1<<g)-1&h>>>32-g|e<<g;h=h<<g;}g=b;e=64-f|0;d=e&31;if((e&63)>>>0>=32){e=0;d=c>>>d|0;}else {e=c>>>d|0;d=((1<<d)-1&c)<<32-d|g>>>d;}d=h|d;e=e|i;h=b;g=f&31;if((f&63)>>>0>=32){i=b<<g;b=0;}else {i=(1<<g)-1&h>>>32-g|c<<g;b=h<<g;}c=i;}J[a>>2]=b;J[a+4>>2]=c;J[a+8>>2]=d;J[a+12>>2]=e;}function vn(a){a=a|0;var b=0,c=0,d=0,e=0;e=J[a+44>>2];if(e){b=e;d=J[a+48>>2];if((b|0)!=(d|0)){while(1){d=d-8|0;c=J[d+4>>2];a:{if(!c){break a}b=J[c+4>>2];J[c+4>>2]=b-1;if(b){break a}Xa[J[J[c>>2]+8>>2]](c);bb(c);}if((d|0)!=(e|0)){continue}break}b=J[a+44>>2];}J[a+48>>2]=e;$a(b);}b=J[a+32>>2];if(b){J[a+36>>2]=b;$a(b);}c=J[a+20>>2];if(c){d=c;b=J[a+24>>2];if((c|0)!=(b|0)){while(1){e=b-12|0;if(H[b-1|0]<0){$a(J[e>>2]);}b=e;if((c|0)!=(b|0)){continue}break}d=J[a+20>>2];}J[a+24>>2]=c;$a(d);}}function Sl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=Ua-16|0;Ua=e;J[e>>2]=c;J[e+4>>2]=d;J[e+8>>2]=c;J[e+12>>2]=d;c=Ua-32|0;Ua=c;b=Kb(c+8|0,b);J[5996]=0;d=c+20|0;ea(174,d|0,e|0,b|0);f=J[5996];J[5996]=0;a:{b:{c:{if((f|0)!=1){J[5996]=0;a=_(175,a|0,d|0)|0;f=J[5996];J[5996]=0;if((f|0)==1){break c}ab(d);ab(b);J[a>>2]=21872;b=J[e+4>>2];J[a+8>>2]=J[e>>2];J[a+12>>2]=b;Ua=c+32|0;break a}a=Z()|0;break b}a=Z()|0;ab(c+20|0);}ab(b);da(a|0);B();}J[a>>2]=8492;Ua=e+16|0;return a|0}function ej(a){if(K[25140]){return J[6284]}if(!K[25936]){H[25936]=1;}hb(25648,1065);hb(25660,1056);hb(25672,2204);hb(25684,2058);hb(25696,1135);hb(25708,2381);hb(25720,1073);hb(25732,1297);hb(25744,1802);hb(25756,1785);hb(25768,1793);hb(25780,1812);hb(25792,2024);hb(25804,2543);hb(25816,1837);hb(25828,1683);hb(25840,1135);hb(25852,1965);hb(25864,2051);hb(25876,2280);hb(25888,1924);hb(25900,1386);hb(25912,1263);hb(25924,2539);H[25140]=1;J[6284]=25648;return 25648}function of(a,b,c,d,e){var f=0,g=0,h=0,i=0;f=Ua-16|0;Ua=f;if(1073741807-b>>>0>=c>>>0){h=(K[a+11|0]&128)>>>7|0?J[a>>2]:a;g=f+4|0;i=g;if(b>>>0<=536870886){J[f+12>>2]=b<<1;J[f+4>>2]=b+c;c=J[(M[g>>2]<M[f+12>>2]?f+12|0:g)>>2];if(c>>>0>=2){g=c+4&-4;c=g-1|0;c=(c|0)==2?g:c;}else {c=1;}c=c+1|0;}else {c=1073741807;}Fc(i,c);c=J[f+4>>2];if(e){tc(c,h,e);}if((d|0)!=(e|0)){g=e<<2;tc(g+c|0,g+h|0,d-e|0);}if((b|0)!=1){$a(h);}J[a>>2]=c;J[a+8>>2]=J[f+8>>2]|-2147483648;Ua=f+16|0;return}ub();B();}function Sd(a,b,c,d,e){var f=0,g=0,h=0,i=0;f=Ua-16|0;Ua=f;if(2147483631-b>>>0>=c>>>0){h=(K[a+11|0]&128)>>>7|0?J[a>>2]:a;g=f+4|0;i=g;if(b>>>0<=1073741798){J[f+12>>2]=b<<1;J[f+4>>2]=b+c;c=J[(M[g>>2]<M[f+12>>2]?f+12|0:g)>>2];if(c>>>0>=11){g=c+16&-16;c=g-1|0;c=(c|0)==11?g:c;}else {c=10;}c=c+1|0;}else {c=2147483631;}Gc(i,c);c=J[f+4>>2];if(e){gc(c,h,e);}if((d|0)!=(e|0)){gc(c+e|0,e+h|0,d-e|0);}if((b|0)!=10){$a(h);}J[a>>2]=c;J[a+8>>2]=J[f+8>>2]|-2147483648;Ua=f+16|0;return}ub();B();}function wm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0;e=Ua-16|0;Ua=e;while(1){a:{if((c|0)<=(f|0)){break a}g=J[a+16>>2];d=J[a+12>>2];b:{if(g>>>0>d>>>0){J[e+12>>2]=2147483647;J[e+8>>2]=g-d;J[e+4>>2]=c-f;h=b;g=d;b=e+4|0;d=e+8|0;b=J[b>>2]<J[d>>2]?b:d;d=e+12|0;d=J[(J[b>>2]<J[d>>2]?b:d)>>2];b=gc(h,g,d);J[a+12>>2]=J[a+12>>2]+d;b=b+d|0;break b}d=Xa[J[J[a>>2]+40>>2]](a)|0;if((d|0)==-1){break a}H[b|0]=d<<24>>24;d=1;b=b+1|0;}f=d+f|0;continue}break}Ua=e+16|0;return f|0}function fh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;e=cb(56);a:{b:{if((c|0)==(d|0)){d=0;c=0;break b}f=d-c|0;if((f|0)<0){J[5996]=0;ca(8);a=J[5996];J[5996]=0;if((a|0)==1){break a}B();}J[5996]=0;d=$(3,f|0)|0;g=J[5996];J[5996]=0;if((g|0)==1){break a}c=fb(d,c,f)+f|0;}J[e+4>>2]=0;J[e+8>>2]=0;J[e>>2]=b;J[e+40>>2]=0;J[e+44>>2]=0;J[e+28>>2]=d;J[e+12>>2]=0;J[e+16>>2]=0;J[e+20>>2]=0;J[e+24>>2]=0;J[e+36>>2]=c;J[e+32>>2]=c;mc(a,e);return e|0}a=Z()|0;$a(e);da(a|0);B();}function Zb(a,b,c){var d=0,e=0;d=(c|0)!=0;a:{b:{c:{if(!(a&3)|!c){break c}e=b&255;while(1){if((e|0)==K[a|0]){break b}c=c-1|0;d=(c|0)!=0;a=a+1|0;if(!(a&3)){break c}if(c){continue}break}}if(!d){break a}d=b&255;if(!((d|0)==K[a|0]|c>>>0<4)){d=P(d,16843009);while(1){e=d^J[a>>2];if((e^-1)&e-16843009&-2139062144){break b}a=a+4|0;c=c-4|0;if(c>>>0>3){continue}break}}if(!c){break a}}b=b&255;while(1){if((b|0)==K[a|0]){return a}a=a+1|0;c=c-1|0;if(c){continue}break}}return 0}function ck(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0;a:{if(!((K[f+11|0]&128)>>>7|0)){b=J[f+4>>2];J[a>>2]=J[f>>2];J[a+4>>2]=b;J[a+8>>2]=J[f+8>>2];break a}e=J[f>>2];d=Ua-16|0;Ua=d;b:{c:{c=J[f+4>>2];d:{if(c>>>0<2){H[a+11|0]=c;break d}if(c>>>0>=1073741808){break c}g=d+8|0;if(c>>>0>=2){f=c+4&-4;b=f-1|0;b=(b|0)==2?f:b;}else {b=1;}Fc(g,b+1|0);b=J[d+8>>2];J[a>>2]=b;J[a+8>>2]=J[d+12>>2]|-2147483648;J[a+4>>2]=c;a=b;}tc(a,e,c+1|0);Ua=d+16|0;break b}ub();B();}}}function ud(a){var b=0,c=0;a:{b=J[a+4>>2];b=J[J[b>>2]-12>>2]+b|0;b:{if(!J[b+24>>2]|J[b+16>>2]|!(K[b+5|0]&32)){break b}if((Ha()|0)>0){break b}b=J[a+4>>2];b=J[(J[J[b>>2]-12>>2]+b|0)+24>>2];J[5996]=0;b=$(169,b|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){if((b|0)!=-1){break b}a=J[a+4>>2];b=J[J[a>>2]-12>>2];J[5996]=0;aa(138,a+b|0,1);a=J[5996];J[5996]=0;if((a|0)!=1){break b}}pa(fa(0)|0)|0;J[5996]=0;ca(110);a=J[5996];J[5996]=0;if((a|0)==1){break a}}return}fa(0)|0;Vb();B();}function Sf(a,b,c,d){var e=0,f=0,g=0,h=0;e=Ua-16|0;Ua=e;a:{b:{if((a|0)!=(b|0)){c:{d:{f=K[a|0];if((f|0)!=45){break d}a=a+1|0;if((b|0)!=(a|0)){break d}break c}h=J[5732];J[5732]=0;jb();a=ae(a,e+12|0,d);d=Wa;g=J[5732];e:{if(g){if(J[e+12>>2]!=(b|0)){break c}if(!d&a>>>0>65535|d|(g|0)==68){break e}break b}J[5732]=h;if(J[e+12>>2]!=(b|0)){break c}if(!d&a>>>0<65536){break b}}J[c>>2]=4;a=65535;break a}}J[c>>2]=4;a=0;break a}a=(f|0)==45?0-a|0:a;}Ua=e+16|0;return a&65535}function jf(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;e=Ua-16|0;Ua=e;d=K[a+11|0];c=d<<24>>24;c=(c|0)<0;d=c?J[a+4>>2]:d;a:{if(!d){break a}c=c?J[a>>2]:a;g=K[c|0];f=g-9&255;if(f>>>0<24&(8388639>>>f&1)){break a}f=K[(c+d|0)-1|0]-9|0;if((f&255)>>>0<24&(8388639>>>f&1)){break a}if((g|0)==45|(Gb(c)|0)!=(d|0)){break a}J[e+12>>2]=0;J[5732]=0;a=hf(H[a+11|0]<0?J[a>>2]:a,e+12|0,10);c=Wa;if(b){J[b>>2]=a;J[b+4>>2]=c;}a=J[e+12>>2];if(!a|K[a|0]){break a}h=!J[5732];}Ua=e+16|0;return h}function Pf(a,b,c,d){var e=0,f=0,g=0,h=0;e=Ua-16|0;Ua=e;a:{if((a|0)!=(b|0)){b:{c:{f=K[a|0];if((f|0)!=45){break c}a=a+1|0;if((b|0)!=(a|0)){break c}break b}h=J[5732];J[5732]=0;jb();a=ae(a,e+12|0,d);d=Wa;d:{g=J[5732];if(g){if(J[e+12>>2]!=(b|0)){break b}if((g|0)!=68){break d}J[c>>2]=4;a=-1;b=-1;break a}J[5732]=h;if(J[e+12>>2]==(b|0)){break d}break b}b=a;c=(f|0)==45;a=c?0-b|0:b;b=c?0-(d+((b|0)!=0)|0)|0:d;break a}}J[c>>2]=4;a=0;b=0;}Ua=e+16|0;Wa=b;return a}function Qm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=Ua-16|0;Ua=d;J[a>>2]=7e3;J[a+4>>2]=0;J[a+8>>2]=0;J[d+4>>2]=J[c>>2];J[d+8>>2]=J[c+4>>2];J[d+12>>2]=J[c+8>>2];J[c+8>>2]=0;J[c>>2]=0;J[c+4>>2]=0;J[5996]=0;ia(163,a+12|0,b|0,d+4|0,0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){e=J[d+4>>2];if(e){b=J[d+8>>2];if((e|0)!=(b|0)){while(1){c=b-12|0;if(H[b-1|0]<0){$a(J[c>>2]);}b=c;if((c|0)!=(e|0)){continue}break}}$a(e);}Ua=d+16|0;return a|0}a=Z()|0;rb(d+4|0);da(a|0);B();}function hd(a,b){var c=0,d=0,e=0,f=0,g=0;e=Ua-16|0;Ua=e;d=K[a+11|0];c=d<<24>>24;c=(c|0)<0;d=c?J[a+4>>2]:d;a:{if(!d){break a}c=c?J[a>>2]:a;f=K[c|0]-9&255;if(f>>>0<24&(8388639>>>f&1)){break a}f=K[(c+d|0)-1|0]-9|0;if((f&255)>>>0<24&(8388639>>>f&1)){break a}if((Gb(c)|0)!=(d|0)){break a}J[e+12>>2]=0;J[5732]=0;a=kf(H[a+11|0]<0?J[a>>2]:a,e+12|0,10);c=Wa;if(b){J[b>>2]=a;J[b+4>>2]=c;}a=J[e+12>>2];if(!a|K[a|0]){break a}g=!J[5732];}Ua=e+16|0;return g}function Sc(a,b){var c=0,d=0;c=Ua-16|0;Ua=c;J[c+12>>2]=a;J[a+4>>2]=J[a+4>>2]+1;J[5996]=0;a=$(197,J[c+12>>2])|0;d=J[5996];J[5996]=0;a:{b:{if((d|0)==1){break b}J[5996]=0;ga(208,a|0,12416,12442,b|0);a=J[5996];J[5996]=0;if((a|0)==1){break b}a=J[c+12>>2];d=J[a+4>>2]-1|0;J[a+4>>2]=d;if((d|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}Ua=c+16|0;break a}d=Z()|0;a=J[c+12>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(d|0);B();}return b}function Nk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=Ua-16|0;Ua=g;J[g+12>>2]=b;b=J[d+28>>2];J[g+8>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;h=$(170,J[g+8>>2])|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[g+8>>2];d=J[b+4>>2]-1|0;J[b+4>>2]=d;if((d|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}Ef(a,f+24|0,g+12|0,c,e,h);Ua=g+16|0;return J[g+12>>2]}c=Z()|0;a=J[g+8>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function Mk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=Ua-16|0;Ua=g;J[g+12>>2]=b;b=J[d+28>>2];J[g+8>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;h=$(170,J[g+8>>2])|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[g+8>>2];d=J[b+4>>2]-1|0;J[b+4>>2]=d;if((d|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}Df(a,f+16|0,g+12|0,c,e,h);Ua=g+16|0;return J[g+12>>2]}c=Z()|0;a=J[g+8>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function Hk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=Ua-16|0;Ua=g;J[g+12>>2]=b;b=J[d+28>>2];J[g+8>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;h=$(197,J[g+8>>2])|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[g+8>>2];d=J[b+4>>2]-1|0;J[b+4>>2]=d;if((d|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}Bf(a,f+24|0,g+12|0,c,e,h);Ua=g+16|0;return J[g+12>>2]}c=Z()|0;a=J[g+8>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function Gk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=Ua-16|0;Ua=g;J[g+12>>2]=b;b=J[d+28>>2];J[g+8>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;h=$(197,J[g+8>>2])|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[g+8>>2];d=J[b+4>>2]-1|0;J[b+4>>2]=d;if((d|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}Af(a,f+16|0,g+12|0,c,e,h);Ua=g+16|0;return J[g+12>>2]}c=Z()|0;a=J[g+8>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function pe(a,b){a:{if(a){if(b>>>0<=127){break a}b:{if(!J[J[6178]>>2]){if((b&-128)==57216){break a}break b}if(b>>>0<=2047){H[a+1|0]=b&63|128;H[a|0]=b>>>6|192;return 2}if(!((b&-8192)!=57344&b>>>0>=55296)){H[a+2|0]=b&63|128;H[a|0]=b>>>12|224;H[a+1|0]=b>>>6&63|128;return 3}if(b-65536>>>0<=1048575){H[a+3|0]=b&63|128;H[a|0]=b>>>18|240;H[a+2|0]=b>>>6&63|128;H[a+1|0]=b>>>12&63|128;return 4}}J[5732]=25;a=-1;}else {a=1;}return a}H[a|0]=b;return 1}function ic(a){var b=0,c=0,d=0,e=0,f=0;a:{d=a-24|0;a=d;if(a>>>0<27344&a>>>0>=26832){b=a-4|0;e=J[6705];c=e;while(1){a=c;if(!(!a|(a|0)==27344)){c=L[a+2>>1];if((a+(c<<2)|0)==(b|0)){I[a+2>>1]=c+L[d-2>>1];break a}if((a|0)==((L[b+2>>1]<<2)+b|0)){c=d-2|0;I[c>>1]=L[a+2>>1]+L[c>>1];if(!f){J[6705]=b;I[b>>1]=L[a>>1];break a}I[f>>1]=b-26832>>>2;break a}else {c=(L[a>>1]<<2)+26832|0;f=a;continue}}break}I[b>>1]=e-26832>>>2;J[6705]=b;break a}$a(d);}}function Rg(a,b,c,d,e){var f=0,g=0,h=0;h=-1;g=d&2147483647;f=(g|0)==2147418112;a:{if(f&!c?a|b:f&(c|0)!=0|g>>>0>2147418112){break a}f=e&2147483647;if(((f|0)==2147418112&0|f>>>0>2147418112)&(f|0)!=2147418112){break a}if(!(a|c|(f|g|b))){return 0}f=d&e;if((f|0)>0|(f|0)>=0){if(((c|0)!=0|(d|0)!=(e|0))&(d|0)<(e|0)){break a}return (a|c|(d^e|b))!=0}if(!c&(d|0)==(e|0)?a|b:(c|0)!=0&(d|0)>=(e|0)|(d|0)>(e|0)){break a}h=(a|c|(d^e|b))!=0;}return h}function Lk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0;a=Ua-16|0;Ua=a;J[a+12>>2]=b;b=J[d+28>>2];J[a+8>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;g=$(170,J[a+8>>2])|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[a+8>>2];d=J[b+4>>2]-1|0;J[b+4>>2]=d;if((d|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}Cf(f+20|0,a+12|0,c,e,g);Ua=a+16|0;return J[a+12>>2]}c=Z()|0;a=J[a+8>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function Fk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0;a=Ua-16|0;Ua=a;J[a+12>>2]=b;b=J[d+28>>2];J[a+8>>2]=b;J[b+4>>2]=J[b+4>>2]+1;J[5996]=0;g=$(197,J[a+8>>2])|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=J[a+8>>2];d=J[b+4>>2]-1|0;J[b+4>>2]=d;if((d|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}zf(f+20|0,a+12|0,c,e,g);Ua=a+16|0;return J[a+12>>2]}c=Z()|0;a=J[a+8>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}function Hf(a,b,c){var d=0,e=0,f=0,g=0,h=0;e=a;g=Ua-16|0;Ua=g;a:{if(b>>>0<1073741808){b:{if(b>>>0<2){H[e+11|0]=b;break b}h=g+8|0;if(b>>>0>=2){f=b+4&-4;d=f-1|0;d=(d|0)==2?f:d;}else {d=1;}Fc(h,d+1|0);d=J[g+8>>2];J[e>>2]=d;J[e+8>>2]=J[g+12>>2]|-2147483648;J[e+4>>2]=b;e=d;}f=Ua-16|0;Ua=f;J[f+12>>2]=c;c=e;d=b;while(1){if(d){J[c>>2]=J[f+12>>2];d=d-1|0;c=c+4|0;continue}break}Ua=f+16|0;J[(b<<2)+e>>2]=0;Ua=g+16|0;break a}ub();B();}return a}function xb(a,b,c,d,e,f,g,h,i){var j=0,k=0,l=0,m=0;i=co(b,c,h,i);h=Wa;e=co(d,e,f,g);i=e+i|0;d=Wa+h|0;h=e>>>0>i>>>0?d+1|0:d;j=g;e=0;k=c;d=0;c=co(g,e,c,d);g=c+i|0;i=Wa+h|0;l=g;c=c>>>0>g>>>0?i+1|0:i;g=co(f,0,b,0);h=Wa;i=0;d=co(f,i,k,d);h=h+d|0;f=Wa+i|0;f=d>>>0>h>>>0?f+1|0:f;i=f+l|0;d=c;f=f>>>0>i>>>0?d+1|0:d;b=co(b,m,j,e)+h|0;e=Wa;e=b>>>0<h>>>0?e+1|0:e;h=e+i|0;i=f;J[a+8>>2]=h;J[a+12>>2]=e>>>0>h>>>0?i+1|0:i;J[a>>2]=g;J[a+4>>2]=b;}function Qf(a,b,c,d){var e=0,f=0,g=0,h=0;e=Ua-16|0;Ua=e;a:{b:{if((a|0)!=(b|0)){c:{d:{f=K[a|0];if((f|0)!=45){break d}a=a+1|0;if((b|0)!=(a|0)){break d}break c}h=J[5732];J[5732]=0;jb();a=ae(a,e+12|0,d);d=Wa;g=J[5732];e:{if(g){if(J[e+12>>2]!=(b|0)){break c}if((g|0)==68|d){break e}break b}J[5732]=h;if(J[e+12>>2]!=(b|0)){break c}if(!d){break b}}J[c>>2]=4;a=-1;break a}}J[c>>2]=4;a=0;break a}a=(f|0)==45?0-a|0:a;}Ua=e+16|0;return a}function ie(a,b){a=a|0;b=b|0;var c=0,d=0;a:{d=K[a+11|0];c=d&127;d=(d&128)>>>7|0;c=d?J[a+4>>2]:c;if(c>>>0<b>>>0){b=b-c|0;if(b){d=d?(J[a+8>>2]&2147483647)-1|0:10;c=K[a+11|0];c=(c&128)>>>7|0?J[a+4>>2]:c&127;if(d-c>>>0<b>>>0){Sd(a,d,c+(b-d|0)|0,c,c);}d=(K[a+11|0]&128)>>>7|0?J[a>>2]:a;og(d+c|0,b,0);b=b+c|0;b:{if((K[a+11|0]&128)>>>7|0){J[a+4>>2]=b;break b}H[a+11|0]=b;}H[b+d|0]=0;}break a}sd(a,(K[a+11|0]&128)>>>7|0?J[a>>2]:a,b);}}function qb(a,b,c){var d=0,e=0,f=0;e=Ua-16|0;Ua=e;J[b+4>>2]=J[b+4>>2]+1;f=a+8|0;d=e+12|0;J[d>>2]=b;a:{b=J[a+12>>2];a=J[a+8>>2];if(b-a>>2>>>0<=c>>>0){J[5996]=0;aa(274,f|0,c+1|0);a=J[5996];J[5996]=0;if((a|0)==1){break a}a=J[f>>2];}a=(c<<2)+a|0;b=J[a>>2];if(b){a=J[b+4>>2]-1|0;J[b+4>>2]=a;if((a|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}a=J[f>>2]+(c<<2)|0;}b=J[d>>2];J[d>>2]=0;J[a>>2]=b;$e(d);Ua=e+16|0;return}a=Z()|0;$e(d);da(a|0);B();}function Im(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;d=Ua-16|0;Ua=d;a:{b:{c:{if((b|0)!=(c|0)){c=c-b|0;if((c|0)<18){break c}}H[a+12|0]=0;H[a|0]=0;break b}if(c>>>0>=2147483632){break a}d:{if(c>>>0<=10){H[d+15|0]=c;e=d+4|0;break d}f=(c|15)+1|0;e=cb(f);J[d+12>>2]=f|-2147483648;J[d+4>>2]=e;J[d+8>>2]=c;}H[fb(e,b,c)+c|0]=0;J[a+8>>2]=J[d+12>>2];b=J[d+8>>2];J[a>>2]=J[d+4>>2];J[a+4>>2]=b;H[a+12|0]=1;}Ua=d+16|0;return}ub();B();}function Uh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;e=Ua-16|0;Ua=e;a:{f=J[b>>2];if(f){d=K[c+11|0];if((d&128)>>>7|0?J[c+4>>2]:d&127){Sg(c,5570);f=J[b>>2];}d=e+4|0;b=J[b+4>>2];Xa[J[J[b>>2]+24>>2]](d,b,f);J[5996]=0;_(290,c|0,d|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}ab(d);}b=J[c+4>>2];J[a>>2]=J[c>>2];J[a+4>>2]=b;J[a+8>>2]=J[c+8>>2];J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;Ua=e+16|0;return}a=Z()|0;ab(e+4|0);da(a|0);B();}function Fb(a){var b=0,c=0,d=0;b=J[a+40>>2];if(b){J[a+44>>2]=b;$a(b);}c=J[a+28>>2];if(c){d=c;b=J[a+32>>2];if((c|0)!=(b|0)){while(1){d=b-12|0;if(H[b-1|0]<0){$a(J[d>>2]);}b=d;if((c|0)!=(b|0)){continue}break}d=J[a+28>>2];}J[a+32>>2]=c;$a(d);}b=J[a+16>>2];if(b){J[a+20>>2]=b;$a(b);}c=J[a+4>>2];if(c){b=c;d=J[a+8>>2];if((b|0)!=(d|0)){while(1){d=Fb(d-56|0);if((c|0)!=(d|0)){continue}break}b=J[a+4>>2];}J[a+8>>2]=c;$a(b);}return a}function zb(a,b,c,d){var e=0,f=0,g=0;a:{e=K[a+11|0];if(!((e&128)>>>7|0?J[a+4>>2]:e&127)|(c-b|0)<5){break a}md(b,c);e=c-4|0;c=(K[a+11|0]&128)>>>7|0?J[a>>2]:a;f=J[a+4>>2];a=K[a+11|0];g=c+((a&128)>>>7|0?f:a&127)|0;b:{while(1){c:{a=H[c|0];f=a-127|0;if(b>>>0>=e>>>0){break c}if((a|0)!=J[b>>2]&(f&255)>>>0>=130){break b}b=b+4|0;c=((g-c|0)>1)+c|0;continue}break}if((f&255)>>>0<130|a>>>0>J[e>>2]-1>>>0){break a}}J[d>>2]=4;}}function Xc(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0;d=J[a>>2];if(d){b=d;c=J[a+4>>2];if((b|0)!=(c|0)){while(1){f=c-12|0;e=J[f>>2];if(e){b=e;g=c-8|0;c=J[g>>2];if((b|0)!=(c|0)){while(1){c=c-32|0;b=J[c+4>>2];a:{if(!b){break a}h=J[b+4>>2];J[b+4>>2]=h-1;if(h){break a}Xa[J[J[b>>2]+8>>2]](b);bb(b);}if((c|0)!=(e|0)){continue}break}b=J[f>>2];}J[g>>2]=e;$a(b);}c=f;if((d|0)!=(c|0)){continue}break}b=J[a>>2];}J[a+4>>2]=d;$a(b);}}function td(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0;d=a;g=Ua-16|0;Ua=g;a:{f=c-b|0;if(f>>>0<2147483632){b:{if(f>>>0<11){H[d+11|0]=f;break b}i=g+8|0;if(f>>>0>=11){h=f+16&-16;e=h-1|0;e=(e|0)==11?h:e;}else {e=10;}Gc(i,e+1|0);e=J[g+8>>2];J[d>>2]=e;J[d+8>>2]=J[g+12>>2]|-2147483648;J[d+4>>2]=f;d=e;}while(1){if((b|0)!=(c|0)){H[d|0]=K[b|0];d=d+1|0;b=b+1|0;continue}break}H[d|0]=0;Ua=g+16|0;break a}ub();B();}return a}function ag(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0;d=a;g=Ua-16|0;Ua=g;a:{f=c-b>>2;if(f>>>0<1073741808){b:{if(f>>>0<2){H[d+11|0]=f;break b}i=g+8|0;if(f>>>0>=2){h=f+4&-4;e=h-1|0;e=(e|0)==2?h:e;}else {e=1;}Fc(i,e+1|0);e=J[g+8>>2];J[d>>2]=e;J[d+8>>2]=J[g+12>>2]|-2147483648;J[d+4>>2]=f;d=e;}while(1){if((b|0)!=(c|0)){J[d>>2]=J[b>>2];d=d+4|0;b=b+4|0;continue}break}J[d>>2]=0;Ua=g+16|0;break a}ub();B();}return a}
function pm(a,b){a=a|0;b=b|0;var c=0,d=0;b=!J[a+24>>2]|(J[a+16>>2]|b);J[a+16>>2]=b;if(b&J[a+20>>2]){a=Ua-16|0;Ua=a;c=Rb(16);a=a+8|0;b=Ua-16|0;Ua=b;if(!K[24716]){H[24716]=1;}J[b+12>>2]=22908;J[b+8>>2]=1;d=J[b+12>>2];J[a>>2]=J[b+8>>2];J[a+4>>2]=d;Ua=b+16|0;b=J[a+4>>2];a=J[a>>2];J[5996]=0;a=Ja(176,c|0,1821,a|0,b|0)|0;b=J[5996];J[5996]=0;if((b|0)!=1){na(a|0,8576,177);B();}a=Z()|0;ic(c);da(a|0);B();}}function tm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0;e=Ua-16|0;Ua=e;while(1){a:{if((c|0)<=(f|0)){break a}d=J[a+24>>2];g=J[a+28>>2];if(d>>>0>=g>>>0){if((Xa[J[J[a>>2]+52>>2]](a,K[b|0])|0)==-1){break a}f=f+1|0;b=b+1|0;}else {J[e+12>>2]=g-d;J[e+8>>2]=c-f;h=d;d=e+8|0;g=e+12|0;d=J[(J[d>>2]<J[g>>2]?d:g)>>2];gc(h,b,d);J[a+24>>2]=d+J[a+24>>2];f=d+f|0;b=b+d|0;}continue}break}Ua=e+16|0;return f|0}function go(a,b,c){var d=0,e=0,f=0,g=0;g=c&63;f=g;e=f&31;if(f>>>0>=32){f=-1>>>e|0;}else {d=-1>>>e|0;f=d|(1<<e)-1<<32-e;}f=f&a;d=b&d;e=g&31;if(g>>>0>=32){d=f<<e;g=0;}else {d=(1<<e)-1&f>>>32-e|d<<e;g=f<<e;}f=d;e=0-c&63;d=e&31;if(e>>>0>=32){d=-1<<d;c=0;}else {c=-1<<d;d=c|(1<<d)-1&-1>>>32-d;}a=c&a;b=b&d;d=e&31;if(e>>>0>=32){c=0;a=b>>>d|0;}else {c=b>>>d|0;a=((1<<d)-1&b)<<32-d|a>>>d;}a=a|g;Wa=c|f;return a}
function wb(a,b,c){var d=0,e=0,f=0;if(!(K[a|0]&32)){a:{d=b;b=a;a=J[b+16>>2];b:{if(!a){if(Be(b)){break b}a=J[b+16>>2];}f=J[b+20>>2];if(a-f>>>0<c>>>0){Xa[J[b+36>>2]](b,d,c)|0;break a}c:{if(J[b+80>>2]<0){break c}a=c;while(1){e=a;if(!a){break c}a=a-1|0;if(K[d+a|0]!=10){continue}break}if(Xa[J[b+36>>2]](b,d,e)>>>0<e>>>0){break b}d=d+e|0;c=c-e|0;f=J[b+20>>2];}fb(f,d,c);J[b+20>>2]=J[b+20>>2]+c;}}}}function am(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;e=J[a+44>>2];c=J[a+24>>2];if(e>>>0<c>>>0){J[a+44>>2]=c;e=c;}c=J[a+12>>2];f=J[a+8>>2];d=-1;a:{if(c>>>0<=f>>>0){break a}if((b|0)==-1){J[a+16>>2]=e;J[a+12>>2]=c-1;J[a+8>>2]=f;return ((b|0)!=-1?b:0)|0}g=b<<24>>24;if(!(J[a+48>>2]&16)){d=-1;if((g|0)!=H[c-1|0]){break a}}J[a+16>>2]=e;J[a+12>>2]=c-1;J[a+8>>2]=f;H[J[a+12>>2]]=g;d=b;}return d|0}function Yh(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0,f=0;f=Ua-16|0;Ua=f;d=K[b+11|0];d=(d&128)>>>7|0?J[b+4>>2]:d&127;while(1){a:{e=(K[b+11|0]&128)>>>7|0?J[b>>2]:b;O[f>>3]=c;e=od(e,d+1|0,2314,f);b:{if((e|0)>=0){if(d>>>0>=e>>>0){break a}d=e;break b}d=d<<1|1;}ie(b,d);continue}break}ie(b,e);d=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=d;J[a+8>>2]=J[b+8>>2];J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;Ua=f+16|0;}function Of(a,b,c){var d=0,e=0,f=Q(0),g=0,h=Q(0);e=Ua-16|0;Ua=e;a:{b:{c:{if((a|0)!=(b|0)){g=J[5732];J[5732]=0;jb();d=Ua-16|0;Ua=d;ee(d,a,e+12|0,0);f=Vf(J[d>>2],J[d+4>>2],J[d+8>>2],J[d+12>>2]);Ua=d+16|0;a=J[5732];if(!a){break c}if(J[e+12>>2]!=(b|0)){break b}h=f;if((a|0)!=68){break a}break b}J[c>>2]=4;break a}J[5732]=g;if(J[e+12>>2]==(b|0)){break a}}J[c>>2]=4;f=h;}Ua=e+16|0;return f}function Mf(a,b,c){var d=0,e=0,f=0,g=0,h=0;e=Ua-16|0;Ua=e;a:{b:{c:{if((a|0)!=(b|0)){g=J[5732];J[5732]=0;jb();d=Ua-16|0;Ua=d;ee(d,a,e+12|0,1);f=ge(J[d>>2],J[d+4>>2],J[d+8>>2],J[d+12>>2]);Ua=d+16|0;a=J[5732];if(!a){break c}if(J[e+12>>2]!=(b|0)){break b}h=f;if((a|0)!=68){break a}break b}J[c>>2]=4;break a}J[5732]=g;if(J[e+12>>2]==(b|0)){break a}}J[c>>2]=4;f=h;}Ua=e+16|0;return f}function mk(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;e=(K[a+11|0]&128)>>>7|0?(J[a+8>>2]&2147483647)-1|0:1;f=K[a+11|0];d=f;d=(d&128)>>>7|0?J[a+4>>2]:d&127;a:{if(e-d>>>0>=c>>>0){if(!c){break a}e=(f&128)>>>7|0?J[a>>2]:a;tc(e+(d<<2)|0,b,c);b=c+d|0;b:{if((K[a+11|0]&128)>>>7|0){J[a+4>>2]=b;break b}H[a+11|0]=b;}J[e+(b<<2)>>2]=0;return a|0}He(a,e,d+(c-e|0)|0,d,d,0,c,b);}return a|0}function Bi(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0;while(1){a:{if((c|0)==(d|0)|e>>>0<=i>>>0){break a}g=1;h=Ua-16|0;Ua=h;f=Xb(h+12|0,J[a+8>>2]);j=qd(0,c,d-c|0,b?b:24840);f=J[f>>2];if(f){J[6178]=(f|0)==-1?24816:f;}Ua=h+16|0;b:{switch(j+2|0){default:g=j;break;case 0:case 1:break a;case 2:break b}}i=i+1|0;k=g+k|0;c=c+g|0;continue}break}return k|0}function kd(a,b,c){var d=0,e=0;if(c&2048){H[a|0]=43;a=a+1|0;}if(c&1024){H[a|0]=35;a=a+1|0;}d=c&260;if((d|0)!=260){H[a|0]=46;H[a+1|0]=42;a=a+2|0;}c=c&16384;while(1){e=K[b|0];if(e){H[a|0]=e;a=a+1|0;b=b+1|0;continue}break}a:{b:{if((d|0)!=256){if((d|0)!=4){break b}b=c?70:102;break a}b=c?69:101;break a}b=c?65:97;if((d|0)==260){break a}b=c?71:103;}H[a|0]=b;return (d|0)!=260}function ve(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;e=(K[a+11|0]&128)>>>7|0?(J[a+8>>2]&2147483647)-1|0:10;f=K[a+11|0];d=f;d=(d&128)>>>7|0?J[a+4>>2]:d&127;a:{if(e-d>>>0>=c>>>0){if(!c){break a}e=(f&128)>>>7|0?J[a>>2]:a;gc(e+d|0,b,c);b=c+d|0;b:{if((K[a+11|0]&128)>>>7|0){J[a+4>>2]=b;break b}H[a+11|0]=b;}H[b+e|0]=0;return a|0}dd(a,e,d+(c-e|0)|0,d,d,0,c,b);}return a|0}function Gh(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;if(Jb(a,J[b+8>>2],e)){if(!(J[b+28>>2]==1|J[b+4>>2]!=(c|0))){J[b+28>>2]=d;}return}a:{if(!Jb(a,J[b>>2],e)){break a}if(!(J[b+16>>2]!=(c|0)&J[b+20>>2]!=(c|0))){if((d|0)!=1){break a}J[b+32>>2]=1;return}J[b+20>>2]=c;J[b+32>>2]=d;J[b+40>>2]=J[b+40>>2]+1;if(!(J[b+36>>2]!=1|J[b+24>>2]!=2)){H[b+54|0]=1;}J[b+44>>2]=4;}}function uf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;e=Ua-16|0;Ua=e;i=J[b>>2];d=J[c>>2];g=J[a>>2];f=d-g|0;f=f>>>0>=2147483647?-1:(d|0)==(g|0)?4:f<<1;d=J[a+4>>2]==220;h=Vc(d?0:g,f);if(h){if(!d){J[a>>2]=0;}J[e+4>>2]=184;d=e+8|0;J[d>>2]=h;J[d+4>>2]=J[e+4>>2];a=rf(a,d);db(d);J[b>>2]=J[a>>2]+(i-g|0);J[c>>2]=J[a>>2]+(f&-4);Ua=e+16|0;return}ce();B();}function gn(a,b){a=a|0;b=+b;var c=0,d=0,e=0;d=Ua-16|0;Ua=d;c=d+4|0;J[c>>2]=0;J[c+4>>2]=0;J[c+8>>2]=0;e=(K[c+11|0]&128)>>>7|0?(J[c+8>>2]&2147483647)-1|0:10;J[5996]=0;aa(172,c|0,e|0);e=J[5996];J[5996]=0;if((e|0)==1){a=Z()|0;ab(c);da(a|0);B();}J[5996]=0;Pa(120,a|0,c|0,+b);a=J[5996];J[5996]=0;if((a|0)!=1){ab(c);Ua=d+16|0;return}a=Z()|0;ab(d+4|0);da(a|0);B();}function fd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;c=K[a+11|0];d=c<<24>>24;f=J[b+4>>2];d=(d|0)<0;c=d?J[a+4>>2]:c;a:{if(f>>>0<c+2>>>0){break a}e=J[b>>2];g=c+e|0;if(K[g|0]!=40|K[(e+f|0)-1|0]!=41){break a}if(c){a=d?J[a>>2]:a;d=c+a|0;while(1){if(K[a|0]!=K[e|0]){return 0}e=e+1|0;a=a+1|0;if((d|0)!=(a|0)){continue}break}}J[b+4>>2]=(f-c|0)-2;h=1;J[b>>2]=g+1;}return h}function Tf(a,b,c,d){var e=0,f=0,g=0;e=Ua-16|0;Ua=e;a:{if((a|0)!=(b|0)){g=J[5732];J[5732]=0;jb();a=Uf(a,e+12|0,d);d=Wa;f=J[5732];b:{if(f){if(J[e+12>>2]!=(b|0)){break b}if((f|0)!=68){break a}J[c>>2]=4;b=!!a&(d|0)>=0|(d|0)>0;a=b?-1:0;d=b?2147483647:-2147483648;break a}J[5732]=g;if(J[e+12>>2]==(b|0)){break a}}}J[c>>2]=4;a=0;d=0;}Ua=e+16|0;Wa=d;return a}function Ol(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0;e=J[a+84>>2];f=J[e>>2];d=J[e+4>>2];h=J[a+28>>2];g=J[a+20>>2]-h|0;g=d>>>0<g>>>0?d:g;if(g){fb(f,h,g);f=g+J[e>>2]|0;J[e>>2]=f;d=J[e+4>>2]-g|0;J[e+4>>2]=d;}d=c>>>0>d>>>0?d:c;if(d){fb(f,b,d);f=d+J[e>>2]|0;J[e>>2]=f;J[e+4>>2]=J[e+4>>2]-d;}H[f|0]=0;b=J[a+44>>2];J[a+28>>2]=b;J[a+20>>2]=b;return c|0}function xk(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;e=Ua-16|0;Ua=e;i=J[b>>2];g=J[a>>2];d=J[c>>2]-g|0;f=d<<1;f=d>>>0>=2147483647?-1:f>>>0<=1?1:f;d=J[a+4>>2]==220;h=Vc(d?0:g,f);if(h){if(!d){J[a>>2]=0;}J[e+4>>2]=184;d=e+8|0;J[d>>2]=h;J[d+4>>2]=J[e+4>>2];a=rf(a,d);db(d);J[b>>2]=J[a>>2]+(i-g|0);J[c>>2]=f+J[a>>2];Ua=e+16|0;return}ce();B();}function Hd(a,b,c,d){H[a+53|0]=1;a:{if(J[a+4>>2]!=(c|0)){break a}H[a+52|0]=1;c=J[a+16>>2];b:{if(!c){J[a+36>>2]=1;J[a+24>>2]=d;J[a+16>>2]=b;if((d|0)!=1){break a}if(J[a+48>>2]==1){break b}break a}if((b|0)==(c|0)){c=J[a+24>>2];if((c|0)==2){J[a+24>>2]=d;c=d;}if(J[a+48>>2]!=1){break a}if((c|0)==1){break b}break a}J[a+36>>2]=J[a+36>>2]+1;}H[a+54|0]=1;}}function Oh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=Ua+-64|0;Ua=d;e=1;a:{if(Jb(a,b,0)){break a}e=0;if(!b){break a}b=Fe(b,22104);e=0;if(!b){break a}Sb(d+12|0,0,52);J[d+56>>2]=1;J[d+20>>2]=-1;J[d+16>>2]=a;J[d+8>>2]=b;Xa[J[J[b>>2]+28>>2]](b,d+8|0,J[c>>2],1);a=J[d+32>>2];if((a|0)==1){J[c>>2]=J[d+24>>2];}e=(a|0)==1;}a=e;Ua=d- -64|0;return a|0}function tj(a){if(K[25132]){return J[6282]}if(!K[25640]){H[25640]=1;}ib(25472,18340);ib(25484,18368);ib(25496,18396);ib(25508,18428);ib(25520,18468);ib(25532,18504);ib(25544,18532);ib(25556,18568);ib(25568,18584);ib(25580,18600);ib(25592,18616);ib(25604,18632);ib(25616,18648);ib(25628,18664);H[25132]=1;J[6282]=25472;return 25472}function en(a){a=a|0;var b=0,c=0;b=J[a+80>>2];a:{if(!b|M[a+84>>2]>3600){break a}if(Wb(3557,1)&(b^-1)){break a}b=J[a+80>>2];if(!b|M[a+84>>2]>3600|(J[a+52>>2]+J[a+44>>2]>>>0>201|M[a+68>>2]>100)){break a}if(Wb(2049,1)&(b^-1)){break a}b=J[a+80>>2];if(Wb(2165,1)&(b^-1)|K[a+88|0]){break a}a=J[a+80>>2];c=!(Wb(1681,1)&(a^-1));}return c|0}function Zc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;e=Ua-16|0;Ua=e;a:{b:{if(c>>>0<11){H[a+11|0]=c;break b}if(c>>>0>=2147483632){break a}g=e+8|0;if(c>>>0>=11){f=c+16&-16;d=f-1|0;d=(d|0)==11?f:d;}else {d=10;}Gc(g,d+1|0);d=J[e+8>>2];J[a>>2]=d;J[a+8>>2]=J[e+12>>2]|-2147483648;J[a+4>>2]=c;a=d;}gc(a,b,c+1|0);Ua=e+16|0;return}ub();B();}function ib(a,b){var c=0,d=0,e=0,f=0;a:{c=We(b);d=(K[a+11|0]&128)>>>7|0?(J[a+8>>2]&2147483647)-1|0:1;if(c>>>0<=d>>>0){b=eb((K[a+11|0]&128)>>>7|0?J[a>>2]:a,b,c<<2);b:{if((K[a+11|0]&128)>>>7|0){J[a+4>>2]=c;break b}H[a+11|0]=c;}J[(c<<2)+b>>2]=0;break a}e=a;f=J[a+4>>2];a=K[a+11|0];a=(a&128)>>>7|0?f:a&127;He(e,d,c-d|0,a,0,a,c,b);}}function Qg(a){var b=0,c=0,d=0;d=J[a>>2];if(d){b=J[a+4>>2];c=d;if((b|0)!=(c|0)){while(1){c=b-32|0;if((K[c|0]|K[c+1|0]<<8|(K[c+2|0]<<16|K[c+3|0]<<24))>>>0>=29){b=b-24|0;$a(K[b|0]|K[b+1|0]<<8|(K[b+2|0]<<16|K[b+3|0]<<24));H[b|0]=0;H[b+1|0]=0;H[b+2|0]=0;H[b+3|0]=0;}b=c;if((d|0)!=(b|0)){continue}break}c=J[a>>2];}J[a+4>>2]=d;$a(c);}}function Ei(a,b){a=a|0;b=b|0;var c=0,d=0;H[a+6|0]=0;I[a+4>>1]=0;J[a>>2]=1;c=J[b>>2];d=J[b+4>>2];J[a+20>>2]=0;J[a+12>>2]=0;J[a+16>>2]=0;J[a+8>>2]=(d-c|0)+1;c=cb(12);J[a+16>>2]=c;J[a+12>>2]=c;d=c+12|0;J[a+20>>2]=d;J[c>>2]=J[b>>2];J[c+4>>2]=J[b+4>>2];J[c+8>>2]=J[b+8>>2];J[b+8>>2]=0;J[b>>2]=0;J[b+4>>2]=0;J[a+16>>2]=d;return a|0}function dh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;var e=0,f=0,g=0,h=0;e=cb(56);f=J[c+8>>2];J[c+8>>2]=0;g=J[c>>2];h=J[c+4>>2];J[c>>2]=0;J[c+4>>2]=0;J[e+16>>2]=0;J[e+20>>2]=0;J[e+12>>2]=f;J[e+4>>2]=g;J[e+8>>2]=h;J[e>>2]=b;J[e+24>>2]=0;J[e+28>>2]=0;J[e+32>>2]=0;J[e+36>>2]=0;J[e+40>>2]=0;J[e+44>>2]=0;O[e+48>>3]=d;mc(a,e);return e|0}function fj(a){if(K[25124]){return J[6280]}if(!K[25464]){H[25464]=1;}hb(25296,1114);hb(25308,1121);hb(25320,1087);hb(25332,1095);hb(25344,1078);hb(25356,1128);hb(25368,1105);hb(25380,1961);hb(25392,1999);hb(25404,2336);hb(25416,2493);hb(25428,1273);hb(25440,2172);hb(25452,1390);H[25124]=1;J[6280]=25296;return 25296}function zc(a,b){var c=0,d=0,e=0,f=0,g=0;a:{c=We(b);e=Ua-16|0;Ua=e;if(c>>>0<1073741808){b:{if(c>>>0<2){H[a+11|0]=c;break b}g=e+8|0;if(c>>>0>=2){f=c+4&-4;d=f-1|0;d=(d|0)==2?f:d;}else {d=1;}Fc(g,d+1|0);d=J[e+8>>2];J[a>>2]=d;J[a+8>>2]=J[e+12>>2]|-2147483648;J[a+4>>2]=c;a=d;}J[tc(a,b,c)+(c<<2)>>2]=0;Ua=e+16|0;break a}ub();B();}}function dc(a,b,c,d){var e=0,f=0,g=0,h=0;e=Ua-16|0;Ua=e;J[e+12>>2]=d;g=Xb(e+8|0,b);b=Ua-16|0;Ua=b;d=J[e+12>>2];J[b+12>>2]=d;J[b+8>>2]=d;f=-1;d=pd(0,0,c,d);a:{if((d|0)<0){break a}h=a;d=d+1|0;a=sb(d);J[h>>2]=a;if(!a){break a}f=pd(a,d,c,J[b+12>>2]);}Ua=b+16|0;a=J[g>>2];if(a){J[6178]=(a|0)==-1?24816:a;}Ua=e+16|0;return f}function bh(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0,f=0,g=0;d=cb(56);e=J[b+8>>2];J[b+8>>2]=0;f=J[b>>2];g=J[b+4>>2];J[b>>2]=0;J[b+4>>2]=0;J[d+16>>2]=0;J[d+20>>2]=0;J[d+12>>2]=e;J[d+4>>2]=f;J[d+8>>2]=g;J[d>>2]=12;J[d+24>>2]=0;J[d+28>>2]=0;J[d+32>>2]=0;J[d+36>>2]=0;J[d+40>>2]=0;J[d+44>>2]=0;O[d+48>>3]=c;mc(a,d);return d|0}function xe(a){var b=0;b=1;a:{if((a|0)>=1024){b=898846567431158e293;if(a>>>0<2047){a=a-1023|0;break a}b=Infinity;a=((a|0)>=3069?3069:a)-2046|0;break a}if((a|0)>-1023){break a}b=2004168360008973e-307;if(a>>>0>4294965304){a=a+969|0;break a}b=0;a=((a|0)<=-2960?-2960:a)+1938|0;}x(0,0);x(1,a+1023<<20);return b*+z()}function xd(a){var b=0,c=0,d=0,e=0;if(a){xd(J[a>>2]);xd(J[a+4>>2]);d=J[a+40>>2];if(d){b=d;c=J[a+44>>2];if((b|0)!=(c|0)){while(1){c=c-32|0;b=J[c+4>>2];a:{if(!b){break a}e=J[b+4>>2];J[b+4>>2]=e-1;if(e){break a}Xa[J[J[b>>2]+8>>2]](b);bb(b);}if((d|0)!=(c|0)){continue}break}b=J[a+40>>2];}J[a+44>>2]=d;$a(b);}$a(a);}}function Di(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0;g=Ua-16|0;Ua=g;J[e>>2]=c;b=g+12|0;a=Md(b,0,J[a+8>>2]);f=2;a:{if(a+1>>>0<2){break a}c=a-1|0;f=1;if(c>>>0>d-J[e>>2]>>>0){break a}while(1){if(c){a=K[b|0];d=J[e>>2];J[e>>2]=d+1;H[d|0]=a;c=c-1|0;b=b+1|0;continue}break}f=0;}a=f;Ua=g+16|0;return a|0}function rc(a,b,c,d){var e=0;a:{if(!(d&2048)){break a}e=d&74;if(!c|((e|0)==8|(e|0)==64)){break a}H[a|0]=43;a=a+1|0;}if(d&512){H[a|0]=35;a=a+1|0;}while(1){e=K[b|0];if(e){H[a|0]=e;a=a+1|0;b=b+1|0;continue}break}e=d&74;b=111;b:{if((e|0)==64){break b}b=d&16384?88:120;if((e|0)==8){break b}b=c?100:117;}H[a|0]=b;}function ad(a){var b=0,c=0,d=0;b=J[a>>2];J[a>>2]=0;if(b){a=J[b+28>>2];if(a){J[b+32>>2]=a;$a(a);}c=J[b+16>>2];if(c){a=c;d=J[b+20>>2];if((a|0)!=(d|0)){while(1){a=d-12|0;if(H[d-1|0]<0){$a(J[a>>2]);}d=a;if((a|0)!=(c|0)){continue}break}a=J[b+16>>2];}J[b+20>>2]=c;$a(a);}a=J[b+4>>2];if(a){J[b+8>>2]=a;$a(a);}$a(b);}}function Om(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;J[a+8>>2]=0;J[a>>2]=0;J[a+4>>2]=0;J[5996]=0;c=$(3,12)|0;d=J[5996];J[5996]=0;if((d|0)!=1){J[a>>2]=c;d=c+12|0;J[a+8>>2]=d;J[c+8>>2]=J[b+8>>2];e=J[b+4>>2];J[c>>2]=J[b>>2];J[c+4>>2]=e;J[b>>2]=0;J[b+4>>2]=0;J[b+8>>2]=0;J[a+4>>2]=d;return}b=Z()|0;rb(a);da(b|0);B();}function Jk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=Ua-32|0;Ua=g;h=J[3163];J[g+24>>2]=J[3162];J[g+28>>2]=h;h=J[3161];J[g+16>>2]=J[3160];J[g+20>>2]=h;h=J[3159];J[g+8>>2]=J[3158];J[g+12>>2]=h;h=J[3157];J[g>>2]=J[3156];J[g+4>>2]=h;h=a;a=g+32|0;b=jc(h,b,c,d,e,f,g,a);Ua=a;return b|0}function bm(a){a=a|0;var b=0,c=0,d=0,e=0;c=J[a+44>>2];b=J[a+24>>2];if(c>>>0<b>>>0){J[a+44>>2]=b;c=b;}d=-1;a:{if(!(K[a+48|0]&8)){break a}b=J[a+16>>2];if(b>>>0<c>>>0){e=J[a+8>>2];b=J[a+12>>2];J[a+16>>2]=c;J[a+12>>2]=b;J[a+8>>2]=e;b=J[a+16>>2];}a=J[a+12>>2];if(a>>>0>=b>>>0){break a}d=K[a|0];}return d|0}function Ih(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;if(Jb(a,J[b+8>>2],0)){Gd(b,c,d);return}f=J[a+12>>2];Ee(J[a+16>>2],J[a+20>>2],b,c,d);e=a+24|0;a=(a+16|0)+(f<<3)|0;a:{if(e>>>0>=a>>>0){break a}while(1){Ee(J[e>>2],J[e+4>>2],b,c,d);if(K[b+54|0]){break a}e=e+8|0;if(a>>>0>e>>>0){continue}break}}}function vb(a,b){var c=0,d=0,e=0,f=0,g=0;d=K[a+11|0];c=d<<24>>24;c=(c|0)<0;e=c?J[a+4>>2]:d;f=J[b+4>>2];if(e>>>0<=f>>>0){d=J[b>>2];if(e){a=c?J[a>>2]:a;g=e+a|0;c=d;while(1){if(K[a|0]!=K[c|0]){return 0}c=c+1|0;a=a+1|0;if((g|0)!=(a|0)){continue}break}}J[b+4>>2]=f-e;J[b>>2]=d+e;a=1;}else {a=0;}return a}function Gb(a){var b=0,c=0,d=0;a:{b:{b=a;if(!(b&3)){break b}if(!K[b|0]){return 0}while(1){b=b+1|0;if(!(b&3)){break b}if(K[b|0]){continue}break}break a}while(1){c=b;b=b+4|0;d=J[c>>2];if(!((d^-1)&d-16843009&-2139062144)){continue}break}while(1){b=c;c=b+1|0;if(K[b|0]){continue}break}}return b-a|0}function Eb(a,b,c){var d=0,e=0;a:{b:{if(c>>>0>=4){if((a|b)&3){break b}while(1){if(J[a>>2]!=J[b>>2]){break b}b=b+4|0;a=a+4|0;c=c-4|0;if(c>>>0>3){continue}break}}if(!c){break a}}while(1){d=K[a|0];e=K[b|0];if((d|0)==(e|0)){b=b+1|0;a=a+1|0;c=c-1|0;if(c){continue}break a}break}return d-e|0}return 0}function qk(a,b){a=a|0;b=b|0;var c=0,d=0;a:{b:{c=K[a+11|0];c:{d:{if((c&128)>>>7|0){d=(J[a+8>>2]&2147483647)-1|0;c=J[a+4>>2];if((d|0)==(c|0)){break d}break c}d=1;c=c&127;if((c|0)!=1){break b}}of(a,d,1,d,d);c=d;}d=J[a>>2];J[a+4>>2]=c+1;break a}H[a+11|0]=c+1;d=a;}a=(c<<2)+d|0;J[a>>2]=b;J[a+4>>2]=0;}function Nb(a,b){var c=0,d=0,e=0,f=0;d=Ua-16|0;Ua=d;a:{if(!b){b=0;break a}c=b>>31;e=(c^b)-c|0;c=S(e);Cb(d,e,0,0,0,c+81|0);e=0+J[d+8>>2]|0;c=(J[d+12>>2]^65536)+(16414-c<<16)|0;c=e>>>0<f>>>0?c+1|0:c;f=b&-2147483648|c;c=J[d+4>>2];b=J[d>>2];}J[a>>2]=b;J[a+4>>2]=c;J[a+8>>2]=e;J[a+12>>2]=f;Ua=d+16|0;}function mf(a,b,c){var d=0,e=0,f=0;e=Ua-16|0;Ua=e;d=Ua-32|0;Ua=d;f=Ua-16|0;Ua=f;J[f+12>>2]=b;J[d+24>>2]=a;J[d+28>>2]=J[f+12>>2];Ua=f+16|0;me(d+16|0,J[d+24>>2],J[d+28>>2],c);a=Rd(a,J[d+16>>2]-a>>2);J[d+12>>2]=J[d+20>>2];J[e+8>>2]=a;J[e+12>>2]=J[d+12>>2];Ua=d+32|0;Ua=e+16|0;return J[e+12>>2]}function ee(a,b,c,d){var e=0,f=0,g=0,h=0;e=Ua-160|0;Ua=e;J[e+60>>2]=b;J[e+20>>2]=b;J[e+24>>2]=-1;f=e+16|0;Yb(f,0,0);ig(e,f,d,1);d=J[e+8>>2];g=J[e+12>>2];f=J[e>>2];h=J[e+4>>2];if(c){J[c>>2]=((J[e+20>>2]+J[e+136>>2]|0)-J[e+60>>2]|0)+b;}J[a+8>>2]=d;J[a+12>>2]=g;J[a>>2]=f;J[a+4>>2]=h;Ua=e+160|0;}function nf(a,b,c){var d=0,e=0,f=0;e=Ua-16|0;Ua=e;d=Ua-32|0;Ua=d;f=Ua-16|0;Ua=f;J[f+12>>2]=b;J[d+24>>2]=a;J[d+28>>2]=J[f+12>>2];Ua=f+16|0;me(d+16|0,J[d+24>>2],J[d+28>>2],c);a=Td(a,J[d+16>>2]-a|0);J[d+12>>2]=J[d+20>>2];J[e+8>>2]=a;J[e+12>>2]=J[d+12>>2];Ua=d+32|0;Ua=e+16|0;return J[e+12>>2]}function rn(a,b){a=a|0;b=b|0;var c=0,d=0;a:{b:{c=K[a+11|0];c:{d:{if((c&128)>>>7|0){d=(J[a+8>>2]&2147483647)-1|0;c=J[a+4>>2];if((d|0)==(c|0)){break d}break c}d=10;c=c&127;if((c|0)!=10){break b}}Sd(a,d,1,d,d);c=d;}d=J[a>>2];J[a+4>>2]=c+1;break a}H[a+11|0]=c+1;d=a;}a=d+c|0;H[a|0]=b;H[a+1|0]=0;}function Nl(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0;h=(e-d|0)+b|0;a:{while(1){if((d|0)!=(e|0)){a=-1;if((b|0)==(c|0)){break a}f=H[b|0];g=H[d|0];if((f|0)<(g|0)){break a}if((f|0)>(g|0)){return 1}else {d=d+1|0;b=b+1|0;continue}}break}a=(c|0)!=(h|0);}return a|0}function oe(a){a=a|0;var b=0,c=0;J[a>>2]=8512;J[5996]=0;aa(133,a|0,0);b=J[5996];J[5996]=0;if((b|0)!=1){b=J[a+28>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}$a(J[a+32>>2]);$a(J[a+36>>2]);$a(J[a+48>>2]);$a(J[a+60>>2]);return a|0}fa(0)|0;Vb();B();}function Jc(a,b,c){var d=0,e=0,f=0;a:{if(!b){d=a;break a}while(1){d=eo(a,b,10);e=Wa;a=co(d,e,246,0)+a|0;c=c-1|0;H[c|0]=a|48;f=b>>>0>9;a=d;b=e;if(f){continue}break}}if(d){while(1){c=c-1|0;a=(d>>>0)/10|0;H[c|0]=P(a,246)+d|48;b=d>>>0>9;d=a;if(b){continue}break}}return c}function _b(a){var b=0,c=0,d=0,e=0;d=J[a>>2];if(d){b=d;c=J[a+4>>2];if((b|0)!=(c|0)){while(1){c=c-32|0;b=J[c+4>>2];a:{if(!b){break a}e=J[b+4>>2];J[b+4>>2]=e-1;if(e){break a}Xa[J[J[b>>2]+8>>2]](b);bb(b);}if((d|0)!=(c|0)){continue}break}b=J[a>>2];}J[a+4>>2]=d;$a(b);}}function lb(a){var b=0,c=0,d=0,e=0;d=J[a>>2];if(d){b=d;c=J[a+4>>2];if((b|0)!=(c|0)){while(1){c=c-8|0;b=J[c+4>>2];a:{if(!b){break a}e=J[b+4>>2];J[b+4>>2]=e-1;if(e){break a}Xa[J[J[b>>2]+8>>2]](b);bb(b);}if((d|0)!=(c|0)){continue}break}b=J[a>>2];}J[a+4>>2]=d;$a(b);}}function Ec(a,b){var c=0,d=0,e=0,f=0;c=Ua-16|0;Ua=c;a:{if(!b){b=0;break a}d=b;b=S(b);Cb(c,d,0,0,0,b+81|0);d=0+J[c+8>>2]|0;b=(J[c+12>>2]^65536)+(16414-b<<16)|0;f=e>>>0>d>>>0?b+1|0:b;e=J[c+4>>2];b=J[c>>2];}J[a>>2]=b;J[a+4>>2]=e;J[a+8>>2]=d;J[a+12>>2]=f;Ua=c+16|0;}function _m(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=J[b+28>>2];J[a>>2]=d;J[d+4>>2]=J[d+4>>2]+1;Og(b+28|0,c);J[5996]=0;aa(133,b|0,1);b=J[5996];J[5996]=0;if((b|0)==1){c=Z()|0;a=J[a>>2];b=J[a+4>>2]-1|0;J[a+4>>2]=b;if((b|0)==-1){Xa[J[J[a>>2]+8>>2]](a);}da(c|0);B();}}function Kl(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0;a:{while(1){if((d|0)!=(e|0)){a=-1;if((b|0)==(c|0)){break a}f=J[b>>2];g=J[d>>2];if((f|0)<(g|0)){break a}if((f|0)>(g|0)){return 1}else {d=d+4|0;b=b+4|0;continue}}break}a=(b|0)!=(c|0);}return a|0}function Ie(a){a=a|0;var b=0,c=0,d=0,e=0;J[a>>2]=12664;e=a+8|0;while(1){b=J[a+8>>2];if(J[a+12>>2]-b>>2>>>0>c>>>0){b=J[b+(c<<2)>>2];if(b){d=J[b+4>>2]-1|0;J[b+4>>2]=d;if((d|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}}c=c+1|0;continue}break}ab(a+152|0);gf(e);return a|0}function Nc(a){var b=0,c=0,d=0,e=0,f=0;a:{if(K[a+4|0]){break a}e=J[a>>2];b=J[e>>2];if(!b){break a}c=b;d=J[e+4>>2];if((d|0)!=(b|0)){while(1){c=d-12|0;f=J[c>>2];if(f){J[d-8>>2]=f;$a(f);}d=c;if((d|0)!=(b|0)){continue}break}c=J[J[a>>2]>>2];}J[e+4>>2]=b;$a(c);}}function Dg(a){var b=0,c=0;b=J[a+72>>2];J[a+72>>2]=b-1|b;if(J[a+20>>2]!=J[a+28>>2]){Xa[J[a+36>>2]](a,0,0)|0;}J[a+28>>2]=0;J[a+16>>2]=0;J[a+20>>2]=0;b=J[a>>2];if(b&4){J[a>>2]=b|32;return -1}c=J[a+44>>2]+J[a+48>>2]|0;J[a+8>>2]=c;J[a+4>>2]=c;return b<<27>>31}function hb(a,b){var c=0,d=0,e=0,f=0;a:{c=Gb(b);d=(K[a+11|0]&128)>>>7|0?(J[a+8>>2]&2147483647)-1|0:10;if(c>>>0<=d>>>0){sd(a,oc((K[a+11|0]&128)>>>7|0?J[a>>2]:a,b,c),c);break a}e=a;f=J[a+4>>2];a=K[a+11|0];a=(a&128)>>>7|0?f:a&127;dd(e,d,c-d|0,a,0,a,c,b);}}function Yb(a,b,c){var d=0,e=0,f=0,g=0;J[a+112>>2]=b;J[a+116>>2]=c;e=J[a+4>>2];d=J[a+44>>2]-e|0;J[a+120>>2]=d;J[a+124>>2]=d>>31;d=J[a+8>>2];a:{if(!(b|c)){break a}f=d-e|0;g=f>>31;if((c|0)>=(g|0)&b>>>0>=f>>>0|(c|0)>(g|0)){break a}d=b+e|0;}J[a+104>>2]=d;}function Lg(a,b){var c=0,d=0,e=0;A(+a);d=v(1)|0;e=v(0)|0;c=d>>>20&2047;if((c|0)!=2047){if(!c){if(a==0){c=0;}else {a=Lg(a*0x10000000000000000,b);c=J[b>>2]+-64|0;}J[b>>2]=c;return a}J[b>>2]=c-1022;x(0,e|0);x(1,d&-2146435073|1071644672);a=+z();}return a}function Vg(a){var b=0,c=0,d=0,e=0;a:{if(K[a+4|0]){break a}e=J[a>>2];b=J[e>>2];if(!b){break a}c=b;d=J[e+4>>2];if((b|0)!=(d|0)){while(1){c=d-12|0;if(H[d-1|0]<0){$a(J[c>>2]);}d=c;if((d|0)!=(b|0)){continue}break}c=J[J[a>>2]>>2];}J[e+4>>2]=b;$a(c);}}function ff(a,b){var c=0,d=0;d=Ua-16|0;Ua=d;c=d+4|0;J[c>>2]=a;a=J[a+4>>2];J[c+4>>2]=a;J[c+8>>2]=a+(b<<2);b=J[c+4>>2];a=J[c+8>>2];while(1){if((a|0)==(b|0)){J[J[c>>2]+4>>2]=J[c+4>>2];Ua=d+16|0;}else {J[b>>2]=0;b=b+4|0;J[c+4>>2]=b;continue}break}}function Vb(){var a=0;a=J[5728];J[5996]=0;ca(a|0);a=J[5996];J[5996]=0;a:{if((a|0)!=1){J[5996]=0;ca(291);a=J[5996];J[5996]=0;if((a|0)!=1){break a}}pa(fa(0)|0)|0;J[5996]=0;ca(291);a=J[5996];J[5996]=0;if((a|0)!=1){break a}fa(0)|0;Vb();}B();}function Ag(a,b,c,d){var e=0,f=0;e=Ua-32|0;Ua=e;f=Ua-16|0;Ua=f;J[f+12>>2]=c;J[e+24>>2]=b;J[e+28>>2]=J[f+12>>2];Ua=f+16|0;me(e+16|0,J[e+24>>2],J[e+28>>2],d);b=J[e+16>>2];J[e+12>>2]=J[e+20>>2];J[a>>2]=b;J[a+4>>2]=J[e+12>>2];Ua=e+32|0;}function Lb(a,b,c){c=c&176;if((c|0)==32){return b}a:{if((c|0)!=16){break a}b:{c:{c=K[a|0];switch(c-43|0){case 0:case 2:break c;default:break b}}return a+1|0}if((c|0)!=48|(b-a|0)<2|(K[a+1|0]|32)!=120){break a}a=a+2|0;}return a}function Ym(a,b){a=a|0;b=b|0;var c=0,d=0;c=J[b+48>>2];if(c&16){d=J[b+44>>2];c=J[b+24>>2];if(d>>>0<c>>>0){J[b+44>>2]=c;d=c;}td(a,J[b+20>>2],d);return}if(c&8){td(a,J[b+8>>2],J[b+16>>2]);return}J[a>>2]=0;J[a+4>>2]=0;J[a+8>>2]=0;}function Rh(a){a=a|0;var b=0,c=0;a:{b:{if(!a){break b}b=a-24|0;c=J[b>>2]-1|0;J[b>>2]=c;if(K[b+13|0]|c){break b}b=J[b+8>>2];if(b){J[5996]=0;$(b|0,a|0)|0;b=J[5996];J[5996]=0;if((b|0)==1){break a}}ic(a);}return}fa(0)|0;Vb();B();}function Eg(a,b,c){var d=0,e=0,f=0,g=0;d=Ua-16|0;Ua=d;b=b-a>>2;while(1){if(b){J[d+12>>2]=a;e=b>>>1|0;J[d+12>>2]=J[d+12>>2]+(e<<2);f=J[d+12>>2];g=M[f>>2]<c>>>0;a=g?f+4|0:a;b=g?(e^-1)+b|0:e;continue}break}Ua=d+16|0;return a}function Kb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;c=Gb(b);if(c>>>0<2147483632){a:{if(c>>>0<=10){H[a+11|0]=c;d=a;break a}e=(c|15)+1|0;d=cb(e);J[a+8>>2]=e|-2147483648;J[a>>2]=d;J[a+4>>2]=c;}H[eb(d,b,c)+c|0]=0;return a|0}ub();B();}function Ik(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;g=Xa[J[J[a+8>>2]+20>>2]](a+8|0)|0;h=K[g+11|0];i=a;j=b;b=(h&128)>>>7|0;a=b?J[g>>2]:g;return jc(i,j,c,d,e,f,a,a+((b?J[g+4>>2]:h&127)<<2)|0)|0}function Qn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;a:{if(K[b|0]!=47){while(1){if((c|0)==(d|0)){e=Wb(b,c);b=0;break a}d=d+1|0;if(K[d+b|0]!=47){continue}break}}e=Wb(b,d);b=Wb((b+d|0)+1|0,(d^-1)+c|0);}J[a+4>>2]=b;J[a>>2]=e;}function co(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0;e=c>>>16|0;f=a>>>16|0;j=P(e,f);g=c&65535;h=a&65535;i=P(g,h);f=(i>>>16|0)+P(f,g)|0;e=(f&65535)+P(e,h)|0;Wa=(P(b,c)+j|0)+P(a,d)+(f>>>16)+(e>>>16)|0;return i&65535|e<<16}function Ok(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;g=Xa[J[J[a+8>>2]+20>>2]](a+8|0)|0;h=K[g+11|0];i=a;j=b;b=(h&128)>>>7|0;a=b?J[g>>2]:g;return kc(i,j,c,d,e,f,a,a+(b?J[g+4>>2]:h&127)|0)|0}function pg(a,b){a=a|0;b=b|0;var c=0,d=0;c=J[a>>2];a:{if(!c){break a}d=J[c+24>>2];b:{if((d|0)==J[c+28>>2]){b=Xa[J[J[c>>2]+52>>2]](c,b)|0;break b}J[c+24>>2]=d+4;J[d>>2]=b;}if((b|0)!=-1){break a}J[a>>2]=0;}return a|0}function Jm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;d=cb(104);J[d>>2]=7e3;J[d+4>>2]=0;J[d+8>>2]=0;J[5996]=0;b=ba(143,d+12|0,b|0,c|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){a=Z()|0;$a(d);da(a|0);B();}J[a+4>>2]=d;J[a>>2]=b;}function Gd(a,b,c){var d=0;d=J[a+16>>2];if(!d){J[a+36>>2]=1;J[a+24>>2]=c;J[a+16>>2]=b;return}a:{if((b|0)==(d|0)){if(J[a+24>>2]!=2){break a}J[a+24>>2]=c;return}H[a+54|0]=1;J[a+24>>2]=2;J[a+36>>2]=J[a+36>>2]+1;}}function Ed(a){var b=0,c=0,d=0;a:{if(K[a+12|0]){break a}b=J[J[a+8>>2]>>2];d=J[J[a+4>>2]>>2];if((b|0)==(d|0)){break a}while(1){a=b-12|0;c=J[a>>2];if(c){J[b-8>>2]=c;$a(c);}b=a;if((a|0)!=(d|0)){continue}break}}}function yf(a,b,c,d,e,f){var g=0;g=Ua-16|0;Ua=g;H[g+15|0]=0;H[g+14|0]=f;H[g+13|0]=e;H[g+12|0]=37;if(f){e=K[g+13|0];H[g+13|0]=K[g+14|0];H[g+14|0]=e;}J[c>>2]=(Ta(b|0,J[c>>2]-b|0,g+12|0,d|0,a|0)|0)+b;Ua=g+16|0;}function Bb(a,b,c,d,e){var f=0;f=Ua-256|0;Ua=f;if(!(e&73728|(c|0)<=(d|0))){d=c-d|0;c=d>>>0<256;Sb(f,b&255,c?d:256);if(!c){while(1){wb(a,f,256);d=d-256|0;if(d>>>0>255){continue}break}}wb(a,f,d);}Ua=f+256|0;}function Wc(a){var b=0,c=0,d=0,e=0;b=J[a>>2];if(b){c=b;d=J[a+4>>2];if((d|0)!=(b|0)){while(1){c=d-12|0;e=J[c>>2];if(e){J[d-8>>2]=e;$a(e);}d=c;if((d|0)!=(b|0)){continue}break}c=J[a>>2];}J[a+4>>2]=b;$a(c);}}function wi(a){a=a|0;var b=0,c=0,d=0;a=J[6019];if(a){b=a;c=J[6020];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6019];}J[6020]=a;$a(b);}}function ph(a){a=a|0;var b=0,c=0,d=0;a=J[6049];if(a){b=a;c=J[6050];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6049];}J[6050]=a;$a(b);}}function on(a){a=a|0;var b=0,c=0,d=0;a=J[6151];if(a){b=a;c=J[6152];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6151];}J[6152]=a;$a(b);}}function oh(a){a=a|0;var b=0,c=0,d=0;a=J[6055];if(a){b=a;c=J[6056];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6055];}J[6056]=a;$a(b);}}function nn(a){a=a|0;var b=0,c=0,d=0;a=J[6157];if(a){b=a;c=J[6158];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6157];}J[6158]=a;$a(b);}}function nh(a){a=a|0;var b=0,c=0,d=0;a=J[6061];if(a){b=a;c=J[6062];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6061];}J[6062]=a;$a(b);}}function mn(a){a=a|0;var b=0,c=0,d=0;a=J[6163];if(a){b=a;c=J[6164];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6163];}J[6164]=a;$a(b);}}function mh(a){a=a|0;var b=0,c=0,d=0;a=J[6067];if(a){b=a;c=J[6068];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6067];}J[6068]=a;$a(b);}}function ln(a){a=a|0;var b=0,c=0,d=0;a=J[6169];if(a){b=a;c=J[6170];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6169];}J[6170]=a;$a(b);}}function lh(a){a=a|0;var b=0,c=0,d=0;a=J[6073];if(a){b=a;c=J[6074];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6073];}J[6074]=a;$a(b);}}function kn(a){a=a|0;var b=0,c=0,d=0;a=J[6175];if(a){b=a;c=J[6176];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6175];}J[6176]=a;$a(b);}}function ci(a){a=a|0;var b=0,c=0,d=0;a=J[6025];if(a){b=a;c=J[6026];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6025];}J[6026]=a;$a(b);}}function Zh(a){a=a|0;var b=0,c=0,d=0;a=J[6031];if(a){b=a;c=J[6032];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6031];}J[6032]=a;$a(b);}}function Rn(a){a=a|0;var b=0,c=0,d=0;a=J[6081];if(a){b=a;c=J[6082];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6081];}J[6082]=a;$a(b);}}function Qh(a){a=a|0;var b=0,c=0,d=0;a=J[6037];if(a){b=a;c=J[6038];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6037];}J[6038]=a;$a(b);}}function On(a){a=a|0;var b=0,c=0,d=0;a=J[6085];if(a){b=a;c=J[6086];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6085];}J[6086]=a;$a(b);}}function Nn(a){a=a|0;var b=0,c=0,d=0;a=J[6089];if(a){b=a;c=J[6090];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6089];}J[6090]=a;$a(b);}}function Mn(a){a=a|0;var b=0,c=0,d=0;a=J[6093];if(a){b=a;c=J[6094];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6093];}J[6094]=a;$a(b);}}function Ln(a){a=a|0;var b=0,c=0,d=0;a=J[6097];if(a){b=a;c=J[6098];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6097];}J[6098]=a;$a(b);}}function Kn(a){a=a|0;var b=0,c=0,d=0;a=J[6101];if(a){b=a;c=J[6102];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6101];}J[6102]=a;$a(b);}}function Jn(a){a=a|0;var b=0,c=0,d=0;a=J[6105];if(a){b=a;c=J[6106];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6105];}J[6106]=a;$a(b);}}function Jh(a){a=a|0;var b=0,c=0,d=0;a=J[6043];if(a){b=a;c=J[6044];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6043];}J[6044]=a;$a(b);}}function Jg(a){var b=0,c=0,d=0;d=J[a>>2];while(1){c=H[d|0];if(c-48>>>0<10){d=d+1|0;J[a>>2]=d;if(b>>>0<=214748364){c=c-48|0;b=P(b,10);b=(c|0)>(b^2147483647)?-1:c+b|0;}else {b=-1;}continue}break}return b}function In(a){a=a|0;var b=0,c=0,d=0;a=J[6109];if(a){b=a;c=J[6110];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6109];}J[6110]=a;$a(b);}}function Hn(a){a=a|0;var b=0,c=0,d=0;a=J[6113];if(a){b=a;c=J[6114];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6113];}J[6114]=a;$a(b);}}function Gn(a){a=a|0;var b=0,c=0,d=0;a=J[6117];if(a){b=a;c=J[6118];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6117];}J[6118]=a;$a(b);}}function Fn(a){a=a|0;var b=0,c=0,d=0;a=J[6121];if(a){b=a;c=J[6122];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6121];}J[6122]=a;$a(b);}}function En(a){a=a|0;var b=0,c=0,d=0;a=J[6125];if(a){b=a;c=J[6126];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6125];}J[6126]=a;$a(b);}}function Dn(a){a=a|0;var b=0,c=0,d=0;a=J[6129];if(a){b=a;c=J[6130];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6129];}J[6130]=a;$a(b);}}function Cn(a){a=a|0;var b=0,c=0,d=0;a=J[6133];if(a){b=a;c=J[6134];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6133];}J[6134]=a;$a(b);}}function Bn(a){a=a|0;var b=0,c=0,d=0;a=J[6137];if(a){b=a;c=J[6138];if((c|0)!=(a|0)){while(1){b=c-12|0;d=J[b>>2];if(d){J[c-8>>2]=d;$a(d);}c=b;if((c|0)!=(a|0)){continue}break}b=J[6137];}J[6138]=a;$a(b);}}function Wg(a){var b=0,c=0;a:{if(K[a+12|0]){break a}b=J[J[a+8>>2]>>2];c=J[J[a+4>>2]>>2];if((b|0)==(c|0)){break a}while(1){a=b-12|0;if(H[b-1|0]<0){$a(J[a>>2]);}b=a;if((a|0)!=(c|0)){continue}break}}}function lc(a,b){var c=0;b=pb(b);c=J[a+12>>2];a=J[a+8>>2];if(b>>>0<c-a>>2>>>0){c=J[a+(b<<2)>>2]!=0;}else {c=0;}if(!c){a=Rb(4);J[a>>2]=22892;J[a>>2]=22736;na(a|0,22872,173);B();}return J[a+(b<<2)>>2]}function rb(a){var b=0,c=0,d=0;b=J[a>>2];if(b){c=b;d=J[a+4>>2];if((b|0)!=(d|0)){while(1){c=d-12|0;if(H[d-1|0]<0){$a(J[c>>2]);}d=c;if((d|0)!=(b|0)){continue}break}c=J[a>>2];}J[a+4>>2]=b;$a(c);}}function gg(a,b,c,d){a:{if(!a){break a}b:{switch(b+2|0){case 0:H[a|0]=c;return;case 1:I[a>>1]=c;return;case 2:case 3:J[a>>2]=c;return;case 5:break b;default:break a}}J[a>>2]=c;J[a+4>>2]=d;}}function Be(a){var b=0;b=J[a+72>>2];J[a+72>>2]=b-1|b;b=J[a>>2];if(b&8){J[a>>2]=b|32;return -1}J[a+4>>2]=0;J[a+8>>2]=0;b=J[a+44>>2];J[a+28>>2]=b;J[a+20>>2]=b;J[a+16>>2]=b+J[a+48>>2];return 0}function he(a,b,c,d,e,f,g,h,i){var j=0;j=Ua-16|0;Ua=j;Hb(j,b,c,d,e,f,g,h,i^-2147483648);d=J[j>>2];c=J[j+4>>2];b=J[j+12>>2];J[a+8>>2]=J[j+8>>2];J[a+12>>2]=b;J[a>>2]=d;J[a+4>>2]=c;Ua=j+16|0;}function cb(a){a=a|0;var b=0;a=a>>>0<=1?1:a;a:{while(1){b=sb(a);if(b){break a}b=J[6704];if(b){Xa[b|0]();continue}break}a=Rb(4);J[a>>2]=22892;J[a>>2]=22364;na(a|0,22448,5);B();}return b|0}function Uc(a,b){var c=0,d=0;c=K[a|0];d=K[b|0];a:{if(!c|(c|0)!=(d|0)){break a}while(1){d=K[b+1|0];c=K[a+1|0];if(!c){break a}b=b+1|0;a=a+1|0;if((c|0)==(d|0)){continue}break}}return c-d|0}function Pl(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;e=J[a+84>>2];d=c+256|0;f=Zb(e,0,d);d=f?f-e|0:d;c=c>>>0>d>>>0?d:c;fb(b,e,c);b=e+d|0;J[a+84>>2]=b;J[a+8>>2]=b;J[a+4>>2]=c+e;return c|0}function Pk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=Ua-16|0;Ua=g;J[g+8>>2]=624576549;J[g+12>>2]=1394948685;h=a;a=g+16|0;b=kc(h,b,c,d,e,f,g+8|0,a);Ua=a;return b|0}function xi(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;while(1){if((b|0)!=(c|0)){a=J[b>>2];if(a>>>0<=127){a=J[(a<<2)+12736>>2];}else {a=0;}J[d>>2]=a;d=d+4|0;b=b+4|0;continue}break}return c|0}function rg(a){var b=0,c=0;b=J[a>>2];if(b){c=J[b+12>>2];a:{if((c|0)==J[b+16>>2]){b=Xa[J[J[b>>2]+36>>2]](b)|0;break a}b=J[c>>2];}if((b|0)!=-1){return !J[a>>2]}J[a>>2]=0;}return 1}function xg(a){var b=0,c=0;b=J[a>>2];if(b){c=J[b+12>>2];a:{if((c|0)==J[b+16>>2]){b=Xa[J[J[b>>2]+36>>2]](b)|0;break a}b=K[c|0];}if((b|0)!=-1){return !J[a>>2]}J[a>>2]=0;}return 1}function Ug(a){var b=0,c=0,d=0;b=J[a>>2];if(b){d=b;c=J[a+4>>2];if((c|0)!=(b|0)){while(1){c=c-12|0;Db(J[c+4>>2]);if((b|0)!=(c|0)){continue}break}d=J[a>>2];}J[a+4>>2]=b;$a(d);}}function Nm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=cb(104);J[5996]=0;b=ba(147,d|0,b|0,c|0)|0;c=J[5996];J[5996]=0;if((c|0)==1){a=Z()|0;$a(d);da(a|0);B();}J[a+4>>2]=b;J[a>>2]=b+12;}function ui(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a:{while(1){if((c|0)==(d|0)){break a}a=J[c>>2];if(!(a>>>0>127|!(J[(a<<2)+12736>>2]&b))){c=c+4|0;continue}break}d=c;}return d|0}function vi(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;while(1){a:{if((c|0)!=(d|0)){a=J[c>>2];if(a>>>0>127|!(J[(a<<2)+12736>>2]&b)){break a}}else {c=d;}return c|0}c=c+4|0;continue}}function Ci(a){a=a|0;var b=0,c=0;b=Ua-16|0;Ua=b;c=J[Xb(b+12|0,J[a+8>>2])>>2];if(c){J[6178]=(c|0)==-1?24816:c;}Ua=b+16|0;a=J[a+8>>2];if(!a){return 1}return (Le(a)|0)==1|0}function yd(a){var b=0,c=0;if(a){yd(J[a>>2]);yd(J[a+4>>2]);b=J[a+28>>2];a:{if(!b){break a}c=J[b+4>>2];J[b+4>>2]=c-1;if(c){break a}Xa[J[J[b>>2]+8>>2]](b);bb(b);}$a(a);}}function wj(a){a=a|0;var b=0,c=0;b=Ua-16|0;Ua=b;if(_e()>>>0<=29){nb();B();}Ze(b+8|0,a+16|0,30);c=J[b+8>>2];J[a+4>>2]=c;J[a>>2]=c;J[a+8>>2]=(J[b+12>>2]<<2)+c;Ua=b+16|0;}function Oc(a){var b=0,c=0,d=0;b=J[a>>2];if(b){d=b;c=J[a+4>>2];if((c|0)!=(b|0)){while(1){c=Fb(c-56|0);if((c|0)!=(b|0)){continue}break}d=J[a>>2];}J[a+4>>2]=b;$a(d);}}function kh(a){a=a|0;var b=0,c=0;a=J[6076];if(a){c=a;b=J[6077];if((b|0)!=(a|0)){while(1){b=b-4|0;ad(b);if((a|0)!=(b|0)){continue}break}c=J[6076];}J[6077]=a;$a(c);}}function Dh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=Ua-16|0;Ua=d;J[d+12>>2]=J[c>>2];a=Xa[J[J[a>>2]+16>>2]](a,b,d+12|0)|0;if(a){J[c>>2]=J[d+12>>2];}Ua=d+16|0;return a|0}function Il(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;a=0;while(1){if((b|0)!=(c|0)){a=J[b>>2]+(a<<4)|0;d=a&-268435456;a=(d|d>>>24)^a;b=b+4|0;continue}break}return a|0}function zi(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;a=Ua-16|0;Ua=a;J[a+12>>2]=e;J[a+8>>2]=d-c;Ua=a+16|0;b=a+8|0;a=a+12|0;return J[(M[b>>2]<M[a>>2]?b:a)>>2]}function yb(a,b,c,d,e){var f=0;f=Ua-16|0;Ua=f;J[f+12>>2]=e;c=Xb(f+8|0,c);b=pd(a,b,d,J[f+12>>2]);a=J[c>>2];if(a){J[6178]=(a|0)==-1?24816:a;}Ua=f+16|0;return b}function Ll(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;a=0;while(1){if((b|0)!=(c|0)){a=H[b|0]+(a<<4)|0;d=a&-268435456;a=(d|d>>>24)^a;b=b+1|0;continue}break}return a|0}function Mm(a,b){a=a|0;b=b|0;var c=0;c=J[a+4>>2];if(c>>>0<M[a+8>>2]){J[c>>2]=J[b>>2];J[c+4>>2]=J[b+4>>2];J[b>>2]=0;J[b+4>>2]=0;J[a+4>>2]=c+8;return}re(a,b);}function tb(a,b){var c=0;c=J[a>>2];J[a>>2]=b;a:{if(c){a=J[a+4>>2];J[5996]=0;ha(a|0,c|0);a=J[5996];J[5996]=0;if((a|0)==1){break a}}return}fa(0)|0;Vb();B();}function Kf(a,b,c){var d=0;d=Ua-16|0;Ua=d;J[d+12>>2]=c;b=Xb(d+8|0,b);c=fg(a,1937,J[d+12>>2]);a=J[b>>2];if(a){J[6178]=(a|0)==-1?24816:a;}Ua=d+16|0;return c}function si(a,b,c){a=a|0;b=b|0;c=c|0;while(1){if((b|0)!=(c|0)){a=J[b>>2];if(a>>>0<=127){a=J[(a<<2)+11184>>2];}J[b>>2]=a;b=b+4|0;continue}break}return c|0}function yg(a){var b=0,c=0;J[5996]=0;c=Ca(168)|0;b=J[5996];J[5996]=0;if((b|0)!=1){b=a;a=J[c>>2];J[b>>2]=a;J[a+4>>2]=J[a+4>>2]+1;return}fa(0)|0;Vb();B();}function qi(a,b,c){a=a|0;b=b|0;c=c|0;while(1){if((b|0)!=(c|0)){a=J[b>>2];if(a>>>0<=127){a=J[(a<<2)+9648>>2];}J[b>>2]=a;b=b+4|0;continue}break}return c|0}function qc(a){var b=0,c=0,d=0;b=Ua-16|0;Ua=b;c=K[a+11|0];d=(c&128)>>>7|0;J[b+12>>2]=(d?J[a>>2]:a)+((d?J[a+4>>2]:c&127)<<2);Ua=b+16|0;return J[b+12>>2]}function ni(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;while(1){if((b|0)!=(c|0)){a=J[b>>2];H[e|0]=a>>>0<128?a:d;e=e+1|0;b=b+4|0;continue}break}return c|0}function Og(a,b){var c=0,d=0;c=J[b>>2];J[c+4>>2]=J[c+4>>2]+1;c=J[a>>2];d=J[c+4>>2]-1|0;J[c+4>>2]=d;if((d|0)==-1){Xa[J[J[c>>2]+8>>2]](c);}J[a>>2]=J[b>>2];}function md(a,b){var c=0;a:{if((a|0)==(b|0)){break a}while(1){b=b-4|0;if(b>>>0<=a>>>0){break a}c=J[a>>2];J[a>>2]=J[b>>2];J[b>>2]=c;a=a+4|0;continue}}}function Wh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=Ua-16|0;Ua=d;Xa[J[J[a>>2]+12>>2]](d+8|0,a,b);Ua=d+16|0;return J[d+12>>2]==J[c+4>>2]&J[d+8>>2]==J[c>>2]}function xf(a){a=a|0;var b=0,c=0;b=Rb(8);J[5996]=0;a=_(91,b|0,a|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){na(a|0,22664,92);B();}a=Z()|0;ic(b);da(a|0);B();}function ji(a,b,c){a=a|0;b=b|0;c=c|0;while(1){if((b|0)!=(c|0)){a=H[b|0];if((a|0)>=0){a=J[(a<<2)+11184>>2];}H[b|0]=a;b=b+1|0;continue}break}return c|0}function ei(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;while(1){if((b|0)!=(c|0)){a=H[b|0];H[e|0]=(a|0)<0?d:a;e=e+1|0;b=b+1|0;continue}break}return c|0}function hi(a,b,c){a=a|0;b=b|0;c=c|0;while(1){if((b|0)!=(c|0)){a=H[b|0];if((a|0)>=0){a=J[(a<<2)+9648>>2];}H[b|0]=a;b=b+1|0;continue}break}return c|0}function Nh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(Jb(a,J[b+8>>2],f)){Hd(b,c,d,e);return}a=J[a+8>>2];Xa[J[J[a>>2]+20>>2]](a,b,c,d,e,f);}function sc(a){var b=0,c=0,d=0;b=Ua-16|0;Ua=b;c=K[a+11|0];d=(c&128)>>>7|0;J[b+12>>2]=(d?J[a>>2]:a)+(d?J[a+4>>2]:c&127);Ua=b+16|0;return J[b+12>>2]}function Rl(a,b){a=a|0;b=b|0;var c=0,d=0;c=J[a+40>>2];while(1){if(c){c=c-1|0;d=c<<2;Xa[J[J[a+32>>2]+d>>2]](b,a,J[d+J[a+36>>2]>>2]);continue}break}}function vc(a,b){var c=0;a:{if((a|0)==(b|0)){break a}while(1){b=b-1|0;if(b>>>0<=a>>>0){break a}c=K[a|0];H[a|0]=K[b|0];H[b|0]=c;a=a+1|0;continue}}}function _e(){var a=0,b=0;a=Ua-16|0;Ua=a;J[a+12>>2]=1073741823;J[a+8>>2]=2147483647;Ua=a+16|0;b=a+8|0;a=a+12|0;return J[(M[b>>2]<M[a>>2]?b:a)>>2]}function ac(a,b){var c=0;if((K[a+11|0]&128)>>>7|0){$a(J[a>>2]);}c=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=c;J[a+8>>2]=J[b+8>>2];H[b+11|0]=0;J[b>>2]=0;}function Ud(a,b){var c=0;if(!((K[b+11|0]&128)>>>7|0)){c=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=c;J[a+8>>2]=J[b+8>>2];return}Zc(a,J[b>>2],J[b+4>>2]);}function rj(a){if(K[25164]){return J[6290]}if(!K[26312]){H[26312]=1;}ib(26288,19200);ib(26300,19212);H[25164]=1;J[6290]=26288;return 26288}function Ab(a,b){var c=0;if((K[a+11|0]&128)>>>7|0){$a(J[a>>2]);}c=J[b+4>>2];J[a>>2]=J[b>>2];J[a+4>>2]=c;J[a+8>>2]=J[b+8>>2];H[b+11|0]=0;H[b|0]=0;}function ue(){var a=0,b=0,c=0;b=Rb(8);J[5996]=0;a=$(125,b|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){na(a|0,22632,7);B();}a=Z()|0;ic(b);da(a|0);B();}function dj(a){if(K[25156]){return J[6288]}if(!K[26280]){H[26280]=1;}hb(26256,3116);hb(26268,3113);H[25156]=1;J[6288]=26256;return 26256}function If(a){var b=0,c=0;b=Rb(8);J[5996]=0;a=_(6,b|0,a|0)|0;c=J[5996];J[5996]=0;if((c|0)!=1){na(a|0,22580,7);B();}a=Z()|0;ic(b);da(a|0);B();}function Ee(a,b,c,d,e){var f=0;f=c;c=0;a:{if(!d){break a}c=b>>8;if(!(b&1)){break a}c=J[c+J[d>>2]>>2];}Xa[J[J[a>>2]+28>>2]](a,f,c+d|0,b&2?e:2);}function og(a,b,c){var d=0;d=Ua-16|0;Ua=d;H[d+15|0]=c;c=a;while(1){if(b){H[c|0]=K[d+15|0];b=b-1|0;c=c+1|0;continue}break}Ua=d+16|0;return a}function Le(a){var b=0,c=0;b=Ua-16|0;Ua=b;a=Xb(b+12|0,a);c=J[J[6178]>>2]?4:1;a=J[a>>2];if(a){J[6178]=(a|0)==-1?24816:a;}Ua=b+16|0;return c}function vg(a,b){var c=0;c=J[a+24>>2];if((c|0)==J[a+28>>2]){return Xa[J[J[a>>2]+52>>2]](a,b&255)|0}J[a+24>>2]=c+1;H[c|0]=b;return b&255}function Me(a,b,c,d,e){var f=0;f=Ua-16|0;Ua=f;e=Xb(f+12|0,e);b=qd(a,b,c,d);a=J[e>>2];if(a){J[6178]=(a|0)==-1?24816:a;}Ua=f+16|0;return b}function Qc(a){a=a|0;var b=0,c=0;J[a>>2]=7896;b=J[a+4>>2];c=J[b+4>>2]-1|0;J[b+4>>2]=c;if((c|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}return a|0}function bi(){var a=0;if(K[25032]){return J[6257]}a=J[Pg()>>2];J[6256]=a;J[a+4>>2]=J[a+4>>2]+1;H[25032]=1;J[6257]=25024;return 25024}function nl(a){if(H[24063]<0){$a(J[6013]);}if(H[24051]<0){$a(J[6010]);}if(H[24039]<0){$a(J[6007]);}if(H[24027]<0){$a(J[6004]);}}function mm(a){a=a|0;var b=0;b=J[a+12>>2];a:{if((b|0)==J[a+16>>2]){a=Xa[J[J[a>>2]+36>>2]](a)|0;break a}a=K[b|0];}return a<<24>>24}function pi(a,b,c,d){b=b|0;c=c|0;d=d|0;while(1){if((b|0)!=(c|0)){J[d>>2]=H[b|0];d=d+4|0;b=b+1|0;continue}break}return c|0}function gd(a){a=a|0;J[a+56>>2]=8316;J[a>>2]=8296;J[a+4>>2]=7960;if(H[a+47|0]<0){$a(J[a+36>>2]);}Qc(a+4|0);Od(a+56|0);return a|0}function Md(a,b,c){var d=0;d=Ua-16|0;Ua=d;c=Xb(d+12|0,c);b=pe(a,b);a=J[c>>2];if(a){J[6178]=(a|0)==-1?24816:a;}Ua=d+16|0;return b}function Df(a,b,c,d,e,f){a=Xa[J[J[a+8>>2]+4>>2]](a+8|0)|0;a=nd(c,d,a,a+288|0,f,e,0)-a|0;if((a|0)<=287){J[b>>2]=((a|0)/12|0)%12;}}function Af(a,b,c,d,e,f){a=Xa[J[J[a+8>>2]+4>>2]](a+8|0)|0;a=ld(c,d,a,a+288|0,f,e,0)-a|0;if((a|0)<=287){J[b>>2]=((a|0)/12|0)%12;}}function um(a){a=a|0;var b=0;if((Xa[J[J[a>>2]+36>>2]](a)|0)!=-1){b=a;a=J[a+12>>2];J[b+12>>2]=a+1;a=K[a|0];}else {a=-1;}return a|0}function gi(a,b,c,d){b=b|0;c=c|0;d=d|0;while(1){if((b|0)!=(c|0)){H[d|0]=K[b|0];d=d+1|0;b=b+1|0;continue}break}return c|0}function bb(a){var b=0,c=0;a:{b=a+8|0;if(J[b>>2]){c=b;b=J[b>>2]-1|0;J[c>>2]=b;if((b|0)!=-1){break a}}Xa[J[J[a>>2]+16>>2]](a);}}function Lh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;if(Jb(a,J[b+8>>2],0)){Gd(b,c,d);return}a=J[a+8>>2];Xa[J[J[a>>2]+28>>2]](a,b,c,d);}function Ef(a,b,c,d,e,f){a=Xa[J[J[a+8>>2]>>2]](a+8|0)|0;a=nd(c,d,a,a+168|0,f,e,0)-a|0;if((a|0)<=167){J[b>>2]=((a|0)/12|0)%7;}}function Bf(a,b,c,d,e,f){a=Xa[J[J[a+8>>2]>>2]](a+8|0)|0;a=ld(c,d,a,a+168|0,f,e,0)-a|0;if((a|0)<=167){J[b>>2]=((a|0)/12|0)%7;}}function me(a,b,c,d){var e=0,f=0;e=Ua-16|0;Ua=e;f=b;b=c-b|0;J[e+12>>2]=eb(d,f,b)+b;J[a>>2]=c;J[a+4>>2]=J[e+12>>2];Ua=e+16|0;}function dm(a){a=a|0;var b=0;b=J[a+12>>2];a:{if((b|0)==J[a+16>>2]){a=Xa[J[J[a>>2]+36>>2]](a)|0;break a}a=J[b>>2];}return a|0}function mb(a){var b=0;a:{a=J[a+4>>2];if(!a){break a}b=J[a+4>>2];J[a+4>>2]=b-1;if(b){break a}Xa[J[J[a>>2]+8>>2]](a);bb(a);}}function Th(a,b){a=a|0;b=b|0;var c=0;c=a;a=K[b+11|0];return ve(c,(a&128)>>>7|0?J[b>>2]:b,(a&128)>>>7|0?J[b+4>>2]:a&127)|0}function qg(a){var b=0;b=J[a+12>>2];if((b|0)==J[a+16>>2]){return Xa[J[J[a>>2]+40>>2]](a)|0}J[a+12>>2]=b+4;return J[b>>2]}function wg(a){var b=0;b=J[a+12>>2];if((b|0)==J[a+16>>2]){return Xa[J[J[a>>2]+40>>2]](a)|0}J[a+12>>2]=b+1;return K[b|0]}function Fg(a,b){a=a|0;b=b|0;var c=0;c=b;b=J[b>>2]+7&-8;J[c>>2]=b+16;O[a>>3]=ge(J[b>>2],J[b+4>>2],J[b+8>>2],J[b+12>>2]);}function be(a,b,c){c=c&255;while(1){a:{if((a|0)!=(b|0)){if((c|0)!=K[a|0]){break a}}else {a=b;}return a}a=a+1|0;continue}}function El(a){a=a|0;var b=0,c=0;c=J[a+4>>2];b=J[a>>2];a=J[a+8>>2];b=b+(a>>1)|0;if(a&1){c=J[c+J[b>>2]>>2];}Xa[c|0](b);}function kg(a,b,c,d,e,f,g,h,i){J[a>>2]=b;J[a+4>>2]=c;J[a+8>>2]=d;J[a+12>>2]=e&65535|(i>>>16&32768|e>>>16&32767)<<16;}function $e(a){var b=0;b=J[a>>2];J[a>>2]=0;if(b){a=J[b+4>>2]-1|0;J[b+4>>2]=a;if((a|0)==-1){Xa[J[J[b>>2]+8>>2]](b);}}}function sg(a,b){a=a|0;b=b|0;var c=0;c=J[a>>2];a:{if(!c){break a}if((vg(c,b)|0)!=-1){break a}J[a>>2]=0;}return a|0}function Yd(a,b,c){while(1){a:{if((a|0)!=(b|0)){if(J[a>>2]!=(c|0)){break a}}else {a=b;}return a}a=a+4|0;continue}}function Fd(a,b,c,d,e,f,g){var h=0;h=b>>8;if(b&1){h=J[J[e>>2]+h>>2];}Xa[J[J[a>>2]+20>>2]](a,c,d,e+h|0,b&2?f:2,g);}function Ld(a,b){var c=0,d=0;c=Gb(b);d=cb(c+13|0);J[d+8>>2]=0;J[d+4>>2]=c;J[d>>2]=c;J[a>>2]=fb(d+12|0,b,c+1|0);}function Jb(a,b,c){if(!c){return J[a+4>>2]==J[b+4>>2]}if((a|0)==(b|0)){return 1}return !Uc(J[a+4>>2],J[b+4>>2])}function zm(a,b,c,d,e,f){a=a|0;J[a+8>>2]=-1;J[a+12>>2]=-1;J[a>>2]=0;J[a+4>>2]=0;}function _h(a,b){a=a|0;b=b|0;J[a>>2]=22892;J[a>>2]=22500;Ld(a+4|0,(K[b+11|0]&128)>>>7|0?J[b>>2]:b);return a|0}function Rd(a,b){var c=0;c=Ua-16|0;Ua=c;J[c+12>>2]=a;a=c+12|0;J[a>>2]=J[a>>2]+(b<<2);Ua=c+16|0;return J[a>>2]}function zf(a,b,c,d,e){b=bc(b,c,d,e,4);if(!(K[d|0]&4)){J[a>>2]=((b|0)<69?b+2e3|0:(b|0)<100?b+1900|0:b)-1900;}}function Mb(a){var b=0;b=Ua-16|0;Ua=b;J[b+12>>2]=(K[a+11|0]&128)>>>7|0?J[a>>2]:a;Ua=b+16|0;return J[b+12>>2]}function Cf(a,b,c,d,e){b=cc(b,c,d,e,4);if(!(K[d|0]&4)){J[a>>2]=((b|0)<69?b+2e3|0:(b|0)<100?b+1900|0:b)-1900;}}function cd(a,b,c,d,e,f){var g=0;g=b>>8;if(b&1){g=J[J[d>>2]+g>>2];}Xa[J[J[a>>2]+24>>2]](a,c,d+g|0,b&2?e:2,f);}function Ke(a,b,c,d,e,f,g,h){c=c|0;e=e|0;f=f|0;h=h|0;J[e>>2]=c;J[h>>2]=f;return 3}function Td(a,b){var c=0;c=Ua-16|0;Ua=c;J[c+12>>2]=a;a=c+12|0;J[a>>2]=J[a>>2]+b;Ua=c+16|0;return J[a>>2]}function ec(a){a:{a=a&74;if(a){if((a|0)==64){return 8}if((a|0)!=8){break a}return 16}return 0}return 10}function Xb(a,b){var c=0;c=J[6178];if(b){J[6178]=(b|0)==-1?24816:b;}J[a>>2]=(c|0)==24816?-1:c;return a}function Ze(a,b,c){a:{if(!(K[b+120|0]|c>>>0>30)){H[b+120|0]=1;break a}b=$f(c);}J[a+4>>2]=c;J[a>>2]=b;}function af(a,b){J[a+4>>2];J[a+4>>2]=b;}function Yl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Xa[J[J[b>>2]+16>>2]](a,b,J[c+8>>2],J[c+12>>2],0,d);}function Mc(a){var b=0;b=J[a+12>>2];if(b){J[a+16>>2]=b;$a(b);}b=J[a>>2];if(b){J[a+4>>2]=b;$a(b);}}function Eh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(Jb(a,J[b+8>>2],f)){Hd(b,c,d,e);}}function xm(a,b,c,d){a=a|0;J[a+8>>2]=-1;J[a+12>>2]=-1;J[a>>2]=0;J[a+4>>2]=0;}function gm(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return Xa[J[J[a>>2]+24>>2]](a,b,c,d,e)|0}function We(a){var b=0,c=0;c=a;while(1){b=c;c=b+4|0;if(J[b>>2]){continue}break}return b-a>>2}function Je(a){a=a|0;var b=0;J[a>>2]=12684;b=J[a+8>>2];if(!(!b|!K[a+12|0])){$a(b);}return a|0}function Pb(){var a=0;a=Rb(4);J[a>>2]=22892;J[a>>2]=22364;J[a>>2]=22384;na(a|0,22460,5);B();}function sd(a,b,c){a:{if((K[a+11|0]&128)>>>7|0){J[a+4>>2]=c;break a}H[a+11|0]=c;}H[b+c|0]=0;}function od(a,b,c,d){var e=0;e=Ua-16|0;Ua=e;J[e+12>>2]=d;a=pd(a,b,c,d);Ua=e+16|0;return a}function eg(a,b){var c=0;c=Ua-16|0;Ua=c;J[c+12>>2]=b;a=fg(a,2310,b);Ua=c+16|0;return a}function cg(a){if((a|0)!=0&(a|0)!=19324&(a|0)!=19348&(a|0)!=24732&(a|0)!=24756){$a(a);}}function yk(a,b){a=a|0;b=b|0;var c=0;c=wg(J[b>>2]);J[a+4>>2]=J[b>>2];H[a|0]=c<<24>>24;}function wf(a,b){a=a|0;b=b|0;b=Ua-16|0;Ua=b;H[a+11|0]=1;H[og(a,1,45)+1|0]=0;Ua=b+16|0;}function tc(a,b,c){var d=0;d=Ua-16|0;Ua=d;Ag(d+8|0,b,(c<<2)+b|0,a);Ua=d+16|0;return a}function ki(a,b){b=b|0;if((b|0)>=0){b=J[((b&255)<<2)+11184>>2];}return b<<24>>24}function Xn(a){a=a|0;a=J[6144];if(a){J[6145]=a;$a(a);}a=J[6141];if(a){J[6142]=a;$a(a);}}function Bg(a,b,c){var d=0;d=Ua-16|0;Ua=d;Ag(d+8|0,a,b,c);Ua=d+16|0;return J[d+12>>2]}function ii(a,b){b=b|0;if((b|0)>=0){b=J[((b&255)<<2)+9648>>2];}return b<<24>>24}function De(a){var b=0;a=J[a>>2]-12|0;b=J[a+8>>2]-1|0;J[a+8>>2]=b;if((b|0)<0){$a(a);}}function Db(a){if(a){Db(J[a>>2]);Db(J[a+4>>2]);if(H[a+27|0]<0){$a(J[a+16>>2]);}$a(a);}}function ij(a){a=a|0;a=26312;while(1){a=ab(a-12|0);if((a|0)!=26288){continue}break}}function hj(a){a=a|0;a=26240;while(1){a=ab(a-12|0);if((a|0)!=25952){continue}break}}function gj(a){a=a|0;a=25640;while(1){a=ab(a-12|0);if((a|0)!=25472){continue}break}}function Wi(a){a=a|0;a=26280;while(1){a=ab(a-12|0);if((a|0)!=26256){continue}break}}function Vi(a){a=a|0;a=25936;while(1){a=ab(a-12|0);if((a|0)!=25648){continue}break}}function Ui(a){a=a|0;a=25464;while(1){a=ab(a-12|0);if((a|0)!=25296){continue}break}}function Ne(a){a=a|0;J[a>>2]=13768;if(J[a+8>>2]!=(jb()|0)){cg(J[a+8>>2]);}return a|0}function rf(a,b){var c=0;c=J[b>>2];J[b>>2]=0;tb(a,c);J[a+4>>2]=J[b+4>>2];return a}function cf(a){var b=0;b=J[a>>2];if(J[b>>2]){df(b);a=J[a>>2];bf(a+16|0,J[a>>2]);}}function yi(a,b,c){b=b|0;c=c|0;return (J[(c<<2)+12736>>2]&b)!=0&c>>>0<=127}function uh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;Xa[a|0](b,c,d,e,f);}function Vd(a,b){a=a|0;b=b|0;J[a>>2]=22892;J[a>>2]=22480;Ld(a+4|0,b);return a|0}function Tg(a,b){a=a|0;b=b|0;J[a>>2]=22892;J[a>>2]=22500;Ld(a+4|0,b);return a|0}function th(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return Xa[a|0](b,c,d,e)|0}function rk(a,b){a=a|0;b=b|0;var c=0;c=qg(J[b>>2]);J[a+4>>2]=J[b>>2];J[a>>2]=c;}function Yj(){J[6593]=0;J[6592]=22008;J[6592]=14144;J[6592]=13768;J[6594]=jb();}function fo(a){var b=0;while(1){if(a){a=a-1&a;b=b+1|0;continue}break}return b}function ce(){var a=0;a=Rb(4);J[a>>2]=22892;J[a>>2]=22364;na(a|0,22448,5);B();}function Kh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;if(Jb(a,J[b+8>>2],0)){Gd(b,c,d);}}function Kd(a,b){var c=0;c=a;a=(b>>>0)/100|0;return uc(uc(c,a),P(a,-100)+b|0)}function Jd(a,b){var c=0;c=a;a=(b>>>0)/1e4|0;return Kd(uc(c,a),P(a,-1e4)+b|0)}function Id(a,b){var c=0;c=a;a=(b>>>0)/1e6|0;return Jd(uc(c,a),P(a,-1e6)+b|0)}function yl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Xa[J[J[a>>2]+32>>2]](a,b,c,d)|0;}function rl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Xa[J[J[a>>2]+48>>2]](a,b,c,d)|0;}function gf(a){var b=0,c=0;b=Ua-16|0;Ua=b;c=b+12|0;J[c>>2]=a;cf(c);Ua=b+16|0;}function ti(a,b){b=b|0;if(b>>>0<=127){b=J[(b<<2)+11184>>2];}return b|0}function Vh(a,b,c){a=a|0;b=b|0;c=c|0;return J[b+4>>2]==(a|0)&J[b>>2]==(c|0)}function Cj(){J[6651]=0;J[6650]=22008;J[6650]=14144;Ye(26608);J[6650]=16704;}function Aj(){J[6655]=0;J[6654]=22008;J[6654]=14144;Ye(26624);J[6654]=16860;}function ri(a,b){b=b|0;if(b>>>0<=127){b=J[(b<<2)+9648>>2];}return b|0}function qj(a){if(!K[25260]){zc(25248,14004);H[25260]=1;}return 25248}function oj(a){if(!K[25292]){zc(25280,14088);H[25292]=1;}return 25280}function mj(a){if(!K[25196]){zc(25184,13932);H[25196]=1;}return 25184}function kj(a){if(!K[25228]){zc(25216,13968);H[25228]=1;}return 25216}function fm(a,b,c){a=a|0;b=b|0;c=c|0;return Xa[J[J[a>>2]+12>>2]](a,b,c)|0}function cm(a,b,c){a=a|0;b=b|0;c=c|0;return Xa[J[J[a>>2]+48>>2]](a,b,c)|0}function cj(a){if(!K[25244]){Kb(25232,2743);H[25244]=1;}return 25232}function aj(a){if(!K[25276]){Kb(25264,1928);H[25276]=1;}return 25264}function _i(a){if(!K[25180]){Kb(25168,1139);H[25180]=1;}return 25168}function Yi(a){if(!K[25212]){Kb(25200,2881);H[25212]=1;}return 25200}function Pc(a,b,c,d,e){c=c|0;e=e|0;J[e>>2]=c;return 3}function pc(a,b){a=a|0;H[a|0]=2;H[a+1|0]=3;H[a+2|0]=0;H[a+3|0]=4;}function om(a){a=a|0;J[a+16>>2]=J[a+16>>2]|1;if(H[a+20|0]&1){Aa();B();}}function vh(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;Xa[a|0](b,c,d,e);}function Pd(a){a=a|0;if(J[a+8>>2]!=(jb()|0)){cg(J[a+8>>2]);}return a|0}function xh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Xa[a|0](b,c,d)|0}function dk(a,b,c,d,e,f){a=a|0;f=f|0;Ud(a,f);}function wc(a,b){return b?a<<24|(a&65280)<<8|(a>>>8&65280|a>>>24):a}function oi(a,b,c){b=b|0;c=c|0;return (b>>>0<128?b:c)<<24>>24}function Gc(a,b){a=a|0;b=b|0;var c=0;c=cb(b);J[a+4>>2]=b;J[a>>2]=c;}function bf(a,b){a:{if((a|0)==(b|0)){H[b+120|0]=0;break a}$a(b);}}function Fl(a){a=a|0;var b=0;b=J[6259]+1|0;J[6259]=b;J[a+4>>2]=b;}function tg(a,b){a=a|0;b=b|0;return Xa[J[J[a>>2]+28>>2]](a,b)|0}function Xk(a,b){a=a|0;b=b|0;a=Vd(a,b);J[a>>2]=22548;return a|0}function Vl(a,b){a=a|0;b=b|0;return Xa[J[J[a>>2]+44>>2]](a,b)|0}function Gl(a,b){a=a|0;b=b|0;return Xa[J[J[a>>2]+12>>2]](a,b)|0}function Ch(a){a=a|0;if(!a){return 0}return (Fe(a,22200)|0)!=0|0}function Ai(a){a=a|0;a=J[a+8>>2];if(!a){return 1}return Le(a)|0}function em(a,b){a=a|0;b=b|0;if(!J[5996]){J[5996]=a;J[5997]=b;}}function Qb(a,b){a=a|0;J[a>>2]=0;J[a+4>>2]=0;J[a+8>>2]=0;}function ab(a){if((K[a+11|0]&128)>>>7|0){$a(J[a>>2]);}return a}function $f(a){if(a>>>0>=1073741824){Pb();B();}return cb(a<<2)}function wh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Xa[a|0](b,c,d);}function ng(a){a=a|0;J[a>>2]=7960;ab(a+32|0);return Qc(a)|0}function fi(a,b,c){b=b|0;c=c|0;return ((b|0)<0?c:b)|0}function Xm(a){a=a|0;a=Vd(a,2284);J[a>>2]=22600;return a|0}function Xh(a,b,c){a=a|0;b=b|0;c=c|0;J[a+4>>2]=b;J[a>>2]=c;}function Cm(a){a=a|0;a=Tg(a,1241);J[a>>2]=22684;return a|0}function Ve(a){a=a|0;J[a>>2]=13856;ab(a+16|0);return a|0}function Ue(a){a=a|0;J[a>>2]=13816;ab(a+12|0);return a|0}function we(a){a=a|0;J[a>>2]=22500;De(a+4|0);return a|0}function Ff(a){a=a|0;J[a>>2]=22480;De(a+4|0);return a|0}function uc(a,b){b=(b<<1)+21664|0;return Bg(b,b+2|0,a)}function lm(a){a=a|0;return ke(J[J[a>>2]-12>>2]+a|0)|0}function _f(a,b){a=a|0;b=b|0;Xa[J[J[b>>2]+24>>2]](a,b);}function Zf(a,b){a=a|0;b=b|0;Xa[J[J[b>>2]+28>>2]](a,b);}function Xl(a){a=a|0;return gd(J[J[a>>2]-12>>2]+a|0)|0}function Wf(a,b){a=a|0;b=b|0;Xa[J[J[b>>2]+20>>2]](a,b);}function Sh(a){a=a|0;if(a){a=a-24|0;J[a>>2]=J[a>>2]+1;}}function Ml(a,b,c,d){a=a|0;c=c|0;d=d|0;Ad(a,c,d);}function Jl(a,b,c,d){a=a|0;c=c|0;d=d|0;ag(a,c,d);}function Fc(a,b){var c=0;c=$f(b);J[a+4>>2]=b;J[a>>2]=c;}function qm(a){a=a|0;return Xa[J[J[a>>2]+24>>2]](a)|0}function kf(a,b,c){a=qe(a,b,c,0,-2147483648);return a}function Xf(a){a=a|0;return Xa[J[J[a>>2]+16>>2]](a)|0}function Nf(a){a=a|0;return Xa[J[J[a>>2]+12>>2]](a)|0}function Sg(a,b){a=a|0;b=b|0;return ve(a,b,Gb(b))|0}function Ub(a,b){a=a|0;b=b|0;return xg(a)^xg(b)^1}function Tb(a,b){a=a|0;b=b|0;return rg(a)^rg(b)^1}function wl(a){if(H[24003]<0){$a(J[5998]);}}function jm(a){a=a|0;a=Ua-a&-16;Ua=a;return a|0}function Mg(a,b){if(!a){return 0}return pe(a,b)}function Am(a,b,c){a=a|0;return a|0}function nc(a,b,c){return Oa(18,a|0,b|0,c|0)|0}function lf(a,b,c){return -1}function km(a){a=a|0;ug(J[J[a>>2]-12>>2]+a|0);}function hf(a,b,c){a=qe(a,b,c,-1,-1);return a}function Wl(a){a=a|0;mg(J[J[a>>2]-12>>2]+a|0);}function bd(a,b,c,d){Ma(152,a|0,b|0,c|0,d|0);}function Ae(a,b,c,d){La(155,a|0,b|0,c|0,d|0);}function wn(a){a=a|0;J[a>>2]=7e3;return a|0}function uj(a){a=a|0;Xa[J[J[a>>2]+4>>2]](a);}function Ic(a){a=a|0;wg(J[a>>2]);return a|0}function Hc(a){a=a|0;qg(J[a>>2]);return a|0}function zj(a){a=a|0;qb(a,26616,pb(24916));}function yj(a){a=a|0;qb(a,26632,pb(24988));}function xj(a){a=a|0;qb(a,26640,pb(24996));}function bk(a){a=a|0;qb(a,26320,pb(24844));}function ak(a){a=a|0;qb(a,26328,pb(24852));}function _j(a){a=a|0;qb(a,26352,pb(25040));}function Zj(a){a=a|0;qb(a,26360,pb(25056));}function Xj(a){a=a|0;qb(a,26368,pb(25064));}function Wj(a){a=a|0;qb(a,26384,pb(25072));}function Vj(a){a=a|0;qb(a,26392,pb(25088));}function Uj(a){a=a|0;qb(a,26400,pb(25080));}function Tj(a){a=a|0;qb(a,26408,pb(25096));}function Sj(a){a=a|0;qb(a,26416,pb(25104));}function Rj(a){a=a|0;qb(a,26440,pb(25112));}function Qj(a){a=a|0;qb(a,26472,pb(24860));}function Pj(a){a=a|0;qb(a,26480,pb(24868));}function Oj(a){a=a|0;qb(a,26488,pb(24876));}function Nj(a){a=a|0;qb(a,26496,pb(24884));}function Mj(a){a=a|0;qb(a,26504,pb(24924));}function Lj(a){a=a|0;qb(a,26512,pb(24932));}function Kj(a){a=a|0;qb(a,26520,pb(24940));}function Jj(a){a=a|0;qb(a,26528,pb(24948));}function Ij(a){a=a|0;qb(a,26536,pb(24956));}function Hj(a){a=a|0;qb(a,26544,pb(24964));}function Gj(a){a=a|0;qb(a,26552,pb(24972));}function Fj(a){a=a|0;qb(a,26560,pb(24980));}function Ej(a){a=a|0;qb(a,26568,pb(24892));}function Dj(a){a=a|0;qb(a,26584,pb(24900));}function Bj(a){a=a|0;qb(a,26600,pb(24908));}function $j(a){a=a|0;qb(a,26336,pb(25048));}function le(a){a=a|0;return lc(a,25048)|0}function ke(a){a=a|0;Od(a+4|0);return a|0}function je(a){a=a|0;return lc(a,25040)|0}function im(a){a=a|0;return lc(a,24876)|0}function gc(a,b,c){Bg(b,b+c|0,a);return a}function de(a){a=a|0;return lc(a,25104)|0}function Zd(a){a=a|0;return lc(a,25112)|0}function Qi(a,b){a=a|0;b=b|0;Ud(a,b+16|0);}function Ki(a,b){a=a|0;b=b|0;Ud(a,b+12|0);}function Pi(a,b){a=a|0;zc(a,13888);}function Oi(a,b){a=a|0;zc(a,13908);}function zg(a,b){b=b|0;return b|0}function vf(a,b){a=a|0;Hf(a,1,45);}function ae(a,b,c){a=hf(a,b,c);return a}function Uf(a,b,c){a=kf(a,b,c);return a}function Ji(a,b){a=a|0;Kb(a,2331);}function Ii(a,b){a=a|0;Kb(a,2350);}function id(a){return 2147483647}function Ri(a){a=a|0;return J[a+12>>2]}function sb(a){a=a|0;return _c(8,a)|0}function Si(a){a=a|0;return J[a+8>>2]}function Cg(a,b){return -1}function Ce(a){a=a|0;return J[a+4>>2]}function $h(a,b){return 0}function Mi(a){a=a|0;return H[a+8|0]}function Li(a){a=a|0;return H[a+9|0]}function oc(a,b,c){return eb(a,b,c)}function lg(a){a=a|0;return we(a)|0}function ef(a){if(!K[a+4|0]){cf(a);}}function tf(a){return lc(a,24932)}function sf(a){return lc(a,24924)}function qf(a){return lc(a,24948)}function pf(a){return lc(a,24940)}function zh(a){return 2176}function yh(a){return 1304}function Ul(a){return 2042}function Bh(a){return 1969}function Ah(a){return 2524}function jd(a){return 127}function $b(a){a=a|0;return a|0}function ug(a){a=a|0;$a(ke(a));}function rd(a){a=a|0;$a(we(a));}function pj(a){ab(25248);}function nj(a){ab(25280);}function mi(a){a=a|0;$a(Je(a));}function mg(a){a=a|0;$a(gd(a));}function lj(a){ab(25184);}function jj(a){ab(25216);}function di(a){a=a|0;$a(Ie(a));}function bj(a){ab(25232);}function Zl(a){a=a|0;$a(ng(a));}function Zi(a){ab(25168);}function Xi(a){ab(25200);}function Xe(a){a=a|0;$a(Pd(a));}function Ti(a){a=a|0;$a(Ve(a));}function Ql(a){a=a|0;$a(oe(a));}function Ni(a){a=a|0;$a(Ue(a));}function Hi(a){a=a|0;$a(Ne(a));}function Dd(a){a=a|0;$a(Ff(a));}function Bm(a){a=a|0;$a(Qc(a));}function $i(a){ab(25264);}function vm(a){return -1}function ed(a){return 4}function Qd(a){return 1}function Ib(a){return 0}function Gf(a){return 2}function ne(a,b){}function df(a){af(a,J[a>>2]);}function Ye(a){J[a>>2]=jb();}function ub(){If(2284);B();}function nb(){If(1687);B();}function kb(a){a=a|0;$a(a);}function ym(a){a=a|0;Va=a;}function sm(){return Ua|0}function nm(a){a=a|0;Ua=a;}function ai(a){B();}function db(a){tb(a,0);}function Ph(){Ge();B();}function Ge(){za();B();}function Od(a){oe(a);}function Nd(a){}
// EMSCRIPTEN_END_FUNCS
e=K;p();var Xa=c([null,wl,ub,cb,nl,$b,Xk,Ff,nb,Ei,wi,nb,li,ci,Zh,Qh,Jh,Vd,rh,qh,ph,oh,nh,mh,lh,kh,jh,ih,hh,Bd,Kb,pk,gh,mc,nb,Pb,fh,eh,dh,ch,Zc,nb,bh,un,la,_g,ao,nb,$n,_n,$g,bo,nb,Zn,Wb,Yn,nb,hc,Xn,nb,Wn,Zg,nb,Vn,Un,Tn,Sn,Rn,Qn,Pn,On,Nn,Mn,Ln,Kn,Jn,In,Hn,Gn,Fn,En,Dn,Cn,Bn,nb,nb,An,zn,yn,sh,xn,Tg,we,nb,nb,nb,nb,Sg,rn,qn,ve,pn,sn,on,nn,mn,ln,kn,ue,tn,ra,ze,nb,hn,Lc,Kc,gn,fn,en,an,Yh,nb,dn,nb,Ob,Xm,cn,bn,se,Pg,_m,Zm,Ym,Rl,rm,im,hm,gm,pm,om,Vm,Um,nb,Tm,re,Sm,Rm,Qm,Pm,Om,Nm,Mm,Lm,Km,Ad,Jm,Im,$m,Hm,Gm,Fm,Em,re,Dm,Kc,Gg,Fg,Cm,bi,qm,le,tg,ie,$b,Uh,_h,Sl,lg,Pl,Ol,de,_f,Zf,nd,kb,ce,Ub,mm,Gl,Ic,Fl,El,Aa,Xf,Wf,yl,Nf,je,Zd,_f,Zf,ld,Tb,dm,tg,Hc,Xf,Wf,rl,Nf,sg,gl,bl,Ac,pg,Yk,Vl,cm,Sk,Bc,Nd,Ak,xf,zk,yk,xk,uf,vk,tk,sk,fm,rk,qk,uf,nk,mk,kk,jk,gk,fk,bk,ak,$j,_j,Zj,Yj,Xj,Wj,Vj,Uj,Tj,Sj,Rj,Qj,Pj,Oj,Nj,Mj,Lj,Kj,Jj,Ij,Hj,Gj,Fj,Ej,Dj,Cj,Bj,Aj,zj,yj,xj,wj,vj,gj,hj,ij,pj,nj,lj,jj,Ui,Vi,Wi,bj,$i,Zi,Xi,Gc,Th,Ge,wn,kb,vn,$h,kb,Qc,Bm,ne,Am,zm,xm,Ib,Ib,wm,vm,um,Cg,tm,Cg,ng,Zl,_l,Yl,bm,am,$l,gd,mg,Xl,Wl,ke,ug,lm,km,$b,kb,Ul,Xh,Wh,Vh,Tl,rd,Ce,oe,Ql,Ie,di,uj,Je,mi,ki,ji,ii,hi,zg,gi,fi,ei,Ne,Hi,Gi,Fi,Di,Ci,Ib,Bi,Ai,Ue,Ni,Mi,Li,Ki,Ji,Ii,Ve,Ti,Si,Ri,Qi,Pi,Oi,$b,kb,kb,yi,xi,vi,ui,ti,si,ri,qi,zg,pi,oi,ni,kb,Ke,Ke,Pc,Qd,Qd,zi,Qd,kb,Qe,Pe,Pc,Ib,Ib,Oe,ed,kb,Qe,Pe,Pc,Ib,Ib,Oe,ed,kb,Te,Se,Pc,Ib,Ib,Re,ed,kb,Te,Se,Pc,Ib,Ib,Re,ed,$b,kb,Nl,Ml,Ll,$b,kb,Kl,Jl,Il,kb,Hl,Dl,Cl,Bl,Rf,Rf,Al,zl,xl,vl,ul,kb,tl,sl,ql,pl,Jf,Jf,ol,ml,ll,kl,jl,kb,il,hl,fl,el,dl,cl,al,$k,kb,_k,Zk,Wk,Vk,Uk,Tk,Rk,Qk,$b,kb,Gf,Pk,Ok,Nk,Mk,Lk,Kk,fj,ej,dj,cj,aj,_i,Yi,$b,kb,Gf,Jk,Ik,Hk,Gk,Fk,Ek,tj,sj,rj,qj,oj,mj,kj,Pd,Xe,Dk,Pd,Xe,Ck,kb,jd,jd,Qb,Qb,Qb,wf,Ib,pc,pc,kb,jd,jd,Qb,Qb,Qb,wf,Ib,pc,pc,kb,id,id,Qb,Qb,Qb,vf,Ib,pc,pc,kb,id,id,Qb,Qb,Qb,vf,Ib,pc,pc,kb,Bk,wk,kb,uk,ok,kb,lk,ik,kb,hk,ek,kb,lf,dk,ne,kb,lf,ck,ne,lg,rd,$b,ai,Ph,za,$b,kb,Nd,Nd,Oh,Fh,Hh,Ih,kb,Ah,kb,zh,Dd,Ce,rd,Dd,Dd,rd,kb,yh,kb,Eh,Gh,Kh,kb,Nh,Mh,Lh,kb,Bh]);function Ya(){return G.byteLength/65536|0}return {"Y":ah,"Z":kb,"_":sb,"$":jn,"aa":Wm,"ba":Xa,"ca":em,"da":ym,"ea":sm,"fa":nm,"ga":jm,"ha":Rh,"ia":Sh,"ja":Dh,"ka":Ch,"la":xh,"ma":wh,"na":vh,"oa":vh,"pa":uh,"qa":th}}return Za(_a)}
// EMSCRIPTEN_END_ASM


)(info);},instantiate:function(binary,info){return {then:function(ok){var module=new WebAssembly.Module(binary);ok({"instance":new WebAssembly.Instance(module,info)});}}},RuntimeError:Error};wasmBinary=[];if(typeof WebAssembly!="object"){abort("no native wasm support detected");}var wasmMemory;var ABORT=false;function assert(condition,text){if(!condition){abort(text);}}var HEAP8,HEAPU8,HEAP32,HEAPU32;function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=new Int16Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=new Uint16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=new Float32Array(b);Module["HEAPF64"]=new Float64Array(b);}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;assert(INITIAL_MEMORY>=65536,"INITIAL_MEMORY should be larger than STACK_SIZE, was "+INITIAL_MEMORY+"! (STACK_SIZE="+65536+")");if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"];}else {wasmMemory=new WebAssembly.Memory({"initial":INITIAL_MEMORY/65536,"maximum":INITIAL_MEMORY/65536});}updateMemoryViews();INITIAL_MEMORY=wasmMemory.buffer.byteLength;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){callRuntimeCallbacks(__ATINIT__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnInit(cb){__ATINIT__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}what="Aborted("+what+")";err(what);ABORT=true;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}var wasmBinaryFile;wasmBinaryFile="bindings.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}var binary=tryParseAsDataURI(file);if(binary){return binary}throw "sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)"}function instantiateSync(file,info){var module;var binary=getBinarySync(file);module=new WebAssembly.Module(binary);var instance=new WebAssembly.Instance(module,info);return [instance,module]}function createWasm(){var info={"a":wasmImports};function receiveInstance(instance,module){var exports=instance.exports;wasmExports=exports;wasmTable=wasmExports["ba"];addOnInit(wasmExports["Y"]);removeRunDependency();return exports}addRunDependency();if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err(`Module.instantiateWasm callback failed with error: ${e}`);readyPromiseReject(e);}}var result=instantiateSync(wasmBinaryFile,info);return receiveInstance(result[0])}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module);}};var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}return str};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";var ___assert_fail=(condition,filename,line,func)=>{abort(`Assertion failed: ${UTF8ToString(condition)}, at: `+[filename?UTF8ToString(filename):"unknown filename",line,func?UTF8ToString(func):"unknown function"]);};var exceptionCaught=[];var uncaughtExceptionCount=0;var ___cxa_begin_catch=ptr=>{var info=new ExceptionInfo(ptr);if(!info.get_caught()){info.set_caught(true);uncaughtExceptionCount--;}info.set_rethrown(false);exceptionCaught.push(info);___cxa_increment_exception_refcount(info.excPtr);return info.get_exception_ptr()};var exceptionLast=0;var ___cxa_end_catch=()=>{_setThrew(0,0);var info=exceptionCaught.pop();___cxa_decrement_exception_refcount(info.excPtr);exceptionLast=0;};function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type;};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor;};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught;};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown;};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr;};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr};}var ___resumeException=ptr=>{if(!exceptionLast){exceptionLast=ptr;}throw exceptionLast};var findMatchingCatch=args=>{var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}for(var arg in args){var caughtType=args[arg];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown};var ___cxa_find_matching_catch_2=()=>findMatchingCatch([]);var ___cxa_find_matching_catch_3=arg0=>findMatchingCatch([arg0]);var ___cxa_find_matching_catch_4=(arg0,arg1)=>findMatchingCatch([arg0,arg1]);var ___cxa_rethrow=()=>{var info=exceptionCaught.pop();if(!info){abort("no exception to throw");}var ptr=info.excPtr;if(!info.get_rethrown()){exceptionCaught.push(info);info.set_rethrown(true);info.set_caught(false);uncaughtExceptionCount++;}exceptionLast=ptr;throw exceptionLast};var ___cxa_throw=(ptr,type,destructor)=>{var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast};var ___cxa_uncaught_exceptions=()=>uncaughtExceptionCount;var _abort=()=>{abort("");};var _emscripten_memcpy_big=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var abortOnCannotGrowMemory=requestedSize=>{abort("OOM");};var _emscripten_resize_heap=requestedSize=>{HEAPU8.length;abortOnCannotGrowMemory();};var ENV={};var getExecutableName=()=>thisProgram||"./this.program";var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x];}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`);}getEnvStrings.strings=strings;}return getEnvStrings.strings};var stringToAscii=(str,buffer)=>{for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i);}HEAP8[buffer>>0]=0;};var _environ_get=(__environ,environ_buf)=>{var bufSize=0;getEnvStrings().forEach((string,i)=>{var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>2]=ptr;stringToAscii(string,ptr);bufSize+=string.length+1;});return 0};var _environ_sizes_get=(penviron_count,penviron_buf_size)=>{var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(string=>bufSize+=string.length+1);HEAPU32[penviron_buf_size>>2]=bufSize;return 0};var _llvm_eh_typeid_for=type=>type;var isLeapYear=year=>year%4===0&&(year%100!==0||year%400===0);var arraySum=(array,index)=>{var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum};var MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];var addDays=(date,days)=>{var newDate=new Date(date.getTime());while(days>0){var leap=isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1);}else {newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1);}}else {newDate.setDate(newDate.getDate()+days);return newDate}}return newDate};var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++;}else if(c<=2047){len+=2;}else if(c>=55296&&c<=57343){len+=4;++i;}else {len+=3;}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}else {if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}}heap[outIdx]=0;return outIdx-startIdx};function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var writeArrayToMemory=(array,buffer)=>{HEAP8.set(array,buffer);};var _strftime=(s,maxsize,format,tm)=>{var tm_zone=HEAPU32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule]);}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value=="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str;}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate());}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}return thisDate.getFullYear()}return thisDate.getFullYear()-1}var EXPANSION_RULES_2={"%a":date=>WEEKDAYS[date.tm_wday].substring(0,3),"%A":date=>WEEKDAYS[date.tm_wday],"%b":date=>MONTHS[date.tm_mon].substring(0,3),"%B":date=>MONTHS[date.tm_mon],"%C":date=>{var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":date=>leadingNulls(date.tm_mday,2),"%e":date=>leadingSomething(date.tm_mday,2," "),"%g":date=>getWeekBasedYear(date).toString().substring(2),"%G":date=>getWeekBasedYear(date),"%H":date=>leadingNulls(date.tm_hour,2),"%I":date=>{var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":date=>leadingNulls(date.tm_mday+arraySum(isLeapYear(date.tm_year+1900)?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR,date.tm_mon-1),3),"%m":date=>leadingNulls(date.tm_mon+1,2),"%M":date=>leadingNulls(date.tm_min,2),"%n":()=>"\n","%p":date=>{if(date.tm_hour>=0&&date.tm_hour<12){return "AM"}return "PM"},"%S":date=>leadingNulls(date.tm_sec,2),"%t":()=>"\t","%u":date=>date.tm_wday||7,"%U":date=>{var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},"%V":date=>{var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++;}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&isLeapYear(date.tm_year%400-1)){val++;}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!isLeapYear(date.tm_year)))val=1;}return leadingNulls(val,2)},"%w":date=>date.tm_wday,"%W":date=>{var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},"%y":date=>(date.tm_year+1900).toString().substring(2),"%Y":date=>date.tm_year+1900,"%z":date=>{var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return (ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":date=>date.tm_zone,"%%":()=>"%"};pattern=pattern.replace(/%%/g,"\0\0");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date));}}pattern=pattern.replace(/\0\0/g,"%");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1};var _strftime_l=(s,maxsize,format,tm,loc)=>_strftime(s,maxsize,format,tm);var wasmTableMirror=[];var getWasmTableEntry=funcPtr=>{var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr);}return func};var getCFunc=ident=>{var func=Module["_"+ident];return func};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={"string":str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str);}return ret},"array":arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string"){return UTF8ToString(ret)}if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i]);}else {cArgs[i]=args[i];}}}var ret=func.apply(null,cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret};var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type==="number"||type==="boolean");var numericRet=returnType!=="string";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return function(){return ccall(ident,returnType,argTypes,arguments)}};var wasmImports={p:___assert_fail,t:___cxa_begin_catch,v:___cxa_end_catch,b:___cxa_find_matching_catch_2,j:___cxa_find_matching_catch_3,V:___cxa_find_matching_catch_4,E:___cxa_rethrow,r:___cxa_throw,L:___cxa_uncaught_exceptions,h:___resumeException,D:_abort,M:_emscripten_memcpy_big,U:_emscripten_resize_heap,J:_environ_get,K:_environ_sizes_get,G:invoke_i,d:invoke_ii,u:invoke_iiddi,c:invoke_iii,W:invoke_iiid,f:invoke_iiii,C:invoke_iiiid,m:invoke_iiiii,B:invoke_iiiiii,o:invoke_iiiiiii,F:invoke_iiiiiiii,y:invoke_iiiiiiiiiiii,N:invoke_iiij,S:invoke_iij,g:invoke_v,l:invoke_vi,H:invoke_vid,e:invoke_vii,T:invoke_viid,i:invoke_viii,I:invoke_viiidi,k:invoke_viiii,z:invoke_viiiid,n:invoke_viiiidi,s:invoke_viiiii,q:invoke_viiiiiii,w:invoke_viiiiiiiiii,x:invoke_viiiiiiiiiiiiiii,O:invoke_viiij,P:invoke_viij,R:invoke_vij,Q:invoke_viji,A:_llvm_eh_typeid_for,a:wasmMemory,X:_strftime_l};var wasmExports=createWasm();wasmExports["Y"];wasmExports["__errno_location"];wasmExports["__cxa_free_exception"];Module["_free"]=wasmExports["Z"];Module["_malloc"]=wasmExports["_"];Module["_miniscript_compile"]=wasmExports["$"];Module["_miniscript_analyze"]=wasmExports["aa"];var _setThrew=wasmExports["ca"];var setTempRet0=wasmExports["da"];var stackSave=wasmExports["ea"];var stackRestore=wasmExports["fa"];var stackAlloc=wasmExports["ga"];var ___cxa_decrement_exception_refcount=wasmExports["ha"];var ___cxa_increment_exception_refcount=wasmExports["ia"];var ___cxa_can_catch=wasmExports["ja"];var ___cxa_is_pointer_type=wasmExports["ka"];var dynCall_iij=Module["dynCall_iij"]=wasmExports["la"];var dynCall_vij=Module["dynCall_vij"]=wasmExports["ma"];var dynCall_viji=Module["dynCall_viji"]=wasmExports["na"];var dynCall_viij=Module["dynCall_viij"]=wasmExports["oa"];var dynCall_viiij=Module["dynCall_viiij"]=wasmExports["pa"];var dynCall_iiij=Module["dynCall_iiij"]=wasmExports["qa"];function invoke_v(index){var sp=stackSave();try{getWasmTableEntry(index)();}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_ii(index,a1){var sp=stackSave();try{return getWasmTableEntry(index)(a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iii(index,a1,a2){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiii(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viii(index,a1,a2,a3){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vii(index,a1,a2){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiid(index,a1,a2,a3,a4){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiid(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiii(index,a1,a2,a3,a4){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiddi(index,a1,a2,a3,a4){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiidi(index,a1,a2,a3,a4,a5){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiidi(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiid(index,a1,a2,a3,a4,a5){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vid(index,a1,a2){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_i(index){var sp=stackSave();try{return getWasmTableEntry(index)()}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vi(index,a1){var sp=stackSave();try{getWasmTableEntry(index)(a1);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viid(index,a1,a2,a3){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iij(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iij(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vij(index,a1,a2,a3){var sp=stackSave();try{dynCall_vij(index,a1,a2,a3);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viji(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viji(index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viij(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viij(index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiij(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viiij(index,a1,a2,a3,a4,a5);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiij(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_iiij(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function intArrayFromBase64(s){try{var decoded=atob(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}Module["cwrap"]=cwrap;Module["UTF8ToString"]=UTF8ToString;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else {doRun();}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}run();


  return moduleArg
}

);
})();
module.exports = Module;
});

// Initial author: Pieter Wuille ( https://github.com/sipa/miniscript/blob/master/index.html)
const Module = bindings();

const em_miniscript_compile = Module.cwrap('miniscript_compile', 'none', [
  'string',
  'number',
  'number',
  'number',
  'number',
  'number',
  'number'
]);
const em_miniscript_analyze = Module.cwrap('miniscript_analyze', 'none', [
  'string',
  'number',
  'number',
  'number',
  'number'
]);

const cleanAsm = asm =>
  asm
    .trim()
    .replace(/\n/g, ' ')
    .replace(/ +(?= )/g, '');

/**
 * @typedef {Object} CompilePolicyResult
 * @property {string} miniscript - The compiled miniscript expression.
 * @property {string} asm - The compiled miniscript as Bitcoin asm code.
 * @property {boolean} issane - Whether the miniscript is sane at the top level.
 * @property {boolean} issanesublevel - Whether the miniscript is sane at the sublevel.
 */

/**
 * @typedef {Object} CompileMiniscriptResult
 * @property {string} asm - The Bitcoin asm code of the compiled miniscript expression.
 * @property {boolean} issane - Whether the miniscript is sane at the top level.
 * @property {boolean} issanesublevel - Whether the miniscript is sane at the sublevel.
 */


/**
 * Compiles a miniscript policy into a miniscript expression (if possible).
 * @Function
 *
 * @param {string} policy - The miniscript policy to compile.
 * @returns {CompilePolicyResult}
 */
const compilePolicy = policy => {
  const miniscript = Module._malloc(10000);
  const cost = Module._malloc(500);
  const asm = Module._malloc(100000);
  const issane = Module._malloc(10);
  const issanesublevel = Module._malloc(10);
  em_miniscript_compile(
    policy,
    miniscript,
    10000,
    cost,
    500,
    asm,
    100000,
    issane,
    10,
    issanesublevel,
    10
  );
  const result = {
    miniscript: Module.UTF8ToString(miniscript),
    asm: cleanAsm(Module.UTF8ToString(asm)),
    issane: Module.UTF8ToString(issane) === 'true' ? true : false,
    issanesublevel:
      Module.UTF8ToString(issanesublevel) === 'true' ? true : false
  };
  Module._free(miniscript);
  Module._free(cost);
  Module._free(asm);
  Module._free(issane);
  Module._free(issanesublevel);

  return result;
};

/**
 * Compiles a miniscript expression and returns its asm code.
 * @Function
 *
 * @param {string} miniscript - A miniscript expression.
 * @returns {CompileMiniscriptResult}
 */
const compileMiniscript = miniscript => {
  const analysis = Module._malloc(50000);
  const asm = Module._malloc(100000);
  const issane = Module._malloc(10);
  const issanesublevel = Module._malloc(10);
  em_miniscript_analyze(
    miniscript,
    analysis,
    50000,
    asm,
    100000,
    issane,
    10,
    issanesublevel,
    10
  );
  const result_asm = Module.UTF8ToString(asm);
  const result_issane = Module.UTF8ToString(issane);
  const result_issanesublebel = Module.UTF8ToString(issanesublevel);
  Module._free(analysis);
  Module._free(asm);
  Module._free(issane);
  Module._free(issanesublevel);

  return {
    asm: cleanAsm(result_asm),
    issane: result_issane === 'true' ? true : false,
    issanesublevel: result_issanesublebel === 'true' ? true : false
  };
};

// Copyright (c) 2022 Jose-Luis Landabaso - https://bitcoinerlab.com

/**
 * @typedef {Object} Solution
 * @property {number} nSequence - the maximum nSequence time of all the sat() or dsat() expressions in the solution.
 * @property {number} nLockTime - the maximum nLockTime of all the sat() or dsat() expressions in the solution.
 * @property {string} asm - the resulting witness after combining all the sat() or dsat() expressions.
 */

/**
 * @typedef {Object} Satisfactions
 * @property {Solution[]} sats - An array of {@link Solution} objects representing the sat() expressions.
 * @property {Solution[]} dsats - An array of {@link Solution} objects representing the dsat() expressions.
 * @see {@link Solution}
 */

/**
 * @typedef {Object} SatisfierResult
 * @property {Solution[]} nonMalleableSats - An array of {@link Solution} objects representing the non-malleable sat() expressions.
 * @property {Solution[]} malleableSats - An array of {@link Solution} objects representing the malleable sat() expressions.
 * @property {Solution[]} unknownSats - An array of {@link Solution} objects representing the sat() expressions that contain some of the `unknown` pieces of information.
 * @see {@link Solution}
 */


/**
 * Computes the weight units (WU) of a witness.
 * @param {string} asm - the witness to compute the WU of.
 * @returns {number} the weight units (WU) of the witness.
 */
function witnessWU(asm) {
  // Split the witness string into an array of substrings
  // a miniscipt witness is either, <sig..., <sha256..., <hash256...,
  // <ripemd160..., <hash160...,  <... (for pubkeys) 0 or 1
  const substrings = asm.split(' ');

  // Initialize the sum to 0
  let wu = 0;

  // Iterate over the array of substrings
  for (const substring of substrings) {
    if (substring === '') ;
    // Check if the substring starts with "<sig"
    else if (substring.startsWith('<sig')) {
      //https://en.bitcoin.it/wiki/BIP_0137
      //Signatures are either 73, 72, or 71 bytes long
      //Also https://bitcoin.stackexchange.com/a/77192/89665
      wu += 74; //73 + push op code
    }
    //
    // preimages:
    else if (
      substring.startsWith('<sha256_preimage(') ||
      substring.startsWith('<hash256_preimage(') ||
      substring.startsWith('<ripemd160_preimage(') ||
      substring.startsWith('<hash160_preimage(') ||
      substring.startsWith('<random_preimage()>')
    ) {
      //any preimage is checked against <32> with SIZE <32> EQUALVERIFY:
      //See the miniscript Translation table:
      //https://bitcoin.sipa.be/miniscript/
      //SIZE <32> EQUALVERIFY {SHA256,RIPEMD,160,HASH160,HASH256} <h> EQUAL
      wu += 33; //32 + push op code
    }
    // Pub keys
    else if (substring.startsWith('<')) {
      //https://en.bitcoin.it/wiki/BIP_0137
      //Compressed public keys are 33 bytes
      wu += 34; //33 + push op code
    } else if (substring === '1' || substring === '0') {
      wu += 1;
    } else {
      throw new Error(`Invalid witness substring ${substring}`);
    }
  }

  // Return the final wu
  return wu;
}

/**
 * Performs a malleability analysis on an array of sat() solutions.
 * @param {Solution[]} sats - the array of sat() solutions to perform the analysis on.
 * @returns {Object} An object with two keys:
 *   - `nonMalleableSats`: an array of {@link Solution} objects representing the non-malleable sat() expressions.
 *   - `malleableSats`: an array of {@link Solution} objects representing the malleable sat() expressions.
 * @see {@link Solution}
 */
function malleabilityAnalysis(sats) {
  sats = sats
    .map(sat => {
      //Deep copy the objects so that this function is pure
      //(does not mutate sats)
      sat = { ...sat };
      //Extract the signatures used in this witness as an array
      sat.signatures = sat.asm.split(' ').filter(op => {
        return op.startsWith('<sig');
      });
      //A non-zero solution without a signature is malleable, and a solution
      //without signature is unacceptable anyway
      if (sat.signatures.length === 0) {
        sat.dontuse = true;
      }
      //<random_preimage()> is a dissatisfaction for a preimage. It is
      //interchangable for any 32 bytes random number and thus, it is malleable.
      if (sat.asm.includes('<random_preimage()>')) {
        sat.dontuse = true;
      }
      return sat;
    })
    // Sort sats by weight unit in ascending order
    .sort((a, b) => witnessWU(a.asm) - witnessWU(b.asm));

  for (const sat of sats) {
    //For the same nLockTime and nSequence, check if otherSat signatures are a
    //subset of sat. If this is the case then sat cannot be used.
    //"For the same nLockTime and nSequence" condition is set because signatures
    //change for each tuple of (nLockTime, nSequence):
    for (const otherSat of sats) {
      if (
        otherSat !== sat &&
        //for the same nLockTime and nSequence
        otherSat.nLockTime === sat.nLockTime &&
        otherSat.nSequence === sat.nSequence &&
        //is otherSat.signatures equal or a subset of sat.signatures?
        otherSat.signatures.every(sig => sat.signatures.includes(sig))
      ) {
        //sat is for example <sig(key1)> <sig(key2)> and otherSat is <sig(key1)>
        //otherSat cannot be used because an attacker could use it to create
        //<sig(key1)
        sat.dontuse = true;
      }
    }
  }

  const nonMalleableSats = sats.filter(sat => !sat.dontuse);
  const malleableSats = sats.filter(sat => sat.dontuse);

  //Clean the objects before returning them
  for (const sats of [nonMalleableSats, malleableSats]) {
    sats.forEach(sat => {
      delete sat.signatures;
      delete sat.dontuse;
    });
  }

  return { nonMalleableSats, malleableSats };
}

/**
 * Determines whether the specified argument of the given miniscript expression
 * is a scalar.
 * @param {string} functionName - the name of the function to check.
 * @param {number} argPosition - the position of the argument to check,
 * starting from 0.
 * @returns {boolean} `true` if the specified argument of the given function is
 * a scalar; `false` otherwise.
 */
function isScalarArg(functionName, argPosition) {
  switch (functionName) {
    case 'pk_k':
    case 'pk_h':
    case 'older':
    case 'after':
    case 'sha256':
    case 'ripemd160':
    case 'hash256':
    case 'hash160':
    case 'multi':
      return true;
    case 'thresh':
      if (argPosition === 0) return true;
  }
  return false;
}

/**
 * Evaluates a miniscript expression and returns its satisfactions.
 *
 * This function is called recursively to find subexpressions
 * within subexpressions until all the arguments of a subexpression are
 * scalars.
 *
 * @param {string} miniscript - A miniscript expression.
 *
 * @returns {Satisfactions} - The satisfactions.
 */
const evaluate = miniscript => {
  if (typeof miniscript !== 'string')
    throw new Error('Invalid expression: ' + miniscript);
  //convert wrappers like this "sln:" into "s:l:n:"
  while (miniscript.match(/^[a-z]{2,}:/)) {
    miniscript = miniscript.replace(/^[a-z]{2,}:/, match =>
      match.replace(match[0], match[0] + ':')
    );
  }
  //https://bitcoin.sipa.be/miniscript/
  //The pk, pkh, and and_n fragments and t:, l:, and u: wrappers are syntactic
  //sugar for other miniscripts:
  miniscript = miniscript
    .replace(/^pk\(/, 'c:pk_k(')
    .replace(/^pkh\(/, 'c:pk_h(')
    .replace(/^and_n\(.*\)/, match =>
      match.replace('and_n', 'andor').replace(/\)$/, ',0)')
    )
    .replace(/^t:(.*)/, match => match.replace('t:', 'and_v(') + ',1)')
    .replace(/^l:(.*)/, match => match.replace('l:', 'or_i(0,') + ')')
    .replace(/^u:(.*)/, match => match.replace('u:', 'or_i(') + ',0)');
  const reFunctionName = String.raw`([^\(:]*)`;
  const matchFunctionName = miniscript.match(reFunctionName);
  if (!matchFunctionName) throw new Error('Invalid expression: ' + miniscript);
  const functionName = matchFunctionName[0];
  if (typeof satisfactionsMaker[functionName] !== 'function')
    throw new Error(functionName + ' not implemented');

  let args;
  if (miniscript[functionName.length] === '(')
    args = miniscript.substring(functionName.length + 1, miniscript.length - 1);
  else if (miniscript[functionName.length] === ':')
    args = miniscript.substring(functionName.length + 1);

  //the function arguments for satisfactionsMaker[functionName]:
  //They will be called like using ES6 spread operator:
  //satisfactionsMaker[functionName](...satisfactionMakerArgs)
  const satisfactionMakerArgs = [];
  if (args) {
    let lastCommaPosition = -1;
    let argLevel = 0; //argLevel tracks nested parenthesis
    let argPosition = 0; //argPosition tracks argument order within functionName
    for (let i = 0; i < args.length; i++) {
      args[i] === '(' && argLevel++;
      args[i] === ')' && argLevel--;
      if (argLevel === 0) {
        let arg;
        if (args[i] === ',') {
          arg = args.substring(lastCommaPosition + 1, i);
          lastCommaPosition = i;
        } else if (i === args.length - 1) {
          arg = args.substring(lastCommaPosition + 1);
        }
        if (arg) {
          if (isScalarArg(functionName, argPosition)) {
            //This is the case when arg is a scalar value that will be directly
            //passed to a satisfier maker function (arg is not a nested
            //miniscript expression).
            //That is, arg is one of these: a key or a hash or an nLockTime,
            //nSequence, or the k (number of keys) in thresh/multi.
            satisfactionMakerArgs.push(arg);
          } else {
            //arg is a miniscript expression that has to be further evaluated:
            satisfactionMakerArgs.push(evaluate(arg));
          }
          argPosition++;
        }
      }
    }
  }

  return satisfactionsMaker[functionName](...satisfactionMakerArgs);
};

/**
 * Obtains the satisfactions of a miniscript.
 * @Function
 *
 * @param {string} miniscript - A miniscript expression.
 * @param {object} [options]
 * @param {string[]} [options.unknowns] - An array with the pieces of information that
 * cannot be used to construct solutions because they are unknown.
 *
 * For example, if a honest user cannot sign with `key`, doesn't know the
 * preimage of `H` and the preimage of `e946029032eae1752e181bebab65de15cf0b93aaac4ee0ffdcfccb683c874d43` then `unknown` must be:
 * ```
 * [
 *   '<sig(key)>',
 *   '<ripemd160_preimage(H)>',
 *   '<sha256_preimage(e946029032eae1752e181bebab65de15cf0b93aaac4ee0ffdcfccb683c874d43)>'
 * ]
 * ```
 *
 * Note that an expression will allways be NOT sane if it is NOT sane at the the
 * miniscript top level as per {@link https://bitcoin.sipa.be/miniscript/
 * Wuille's algorithm}.
 *
 * For example; if a miniscript is NOT sane at the top level because it can be
 * satisfyed using only preimages, then setting preimages as unknowns will not
 * change this behaviour.
 *
 * The reason for this limitation is that the satisfier uses an unmodified
 * version of Wuille's algorithm as an initial precondition before finding
 * solutions. If the miniscript is sane, then unknowns can be set to produce
 * more possible solutions, including preimages, as described above.
 *
 * @param {string[]} [options.knowns] - An array
 * with the only pieces of information that can be used to build satisfactions.
 * This is the complimentary to unknowns. Only `knowns` or `unknowns` must be
 * passed.
 *
 * If neither knowns and unknowns is passed then it is assumed that there are
 * no unknowns, in other words, that all pieces of information are known.
 *
 * @returns {SatisfierResult}
 *
 * @see {@link Solution}
 */
const satisfier = (miniscript, options = {}) => {
  let { unknowns, knowns } = options;
  const { issane, issanesublevel } = compileMiniscript(miniscript);

  if (!issane) {
    throw new Error(`Miniscript ${miniscript} is not sane.`);
  }

  if (typeof unknowns === 'undefined' && typeof knowns === 'undefined') {
    unknowns = [];
  } else if (typeof unknowns !== 'undefined' && typeof knowns !== 'undefined') {
    throw new Error(`Cannot pass both knowns and unknowns`);
  } else if (
    (knowns && !Array.isArray(knowns)) ||
    (unknowns && !Array.isArray(unknowns))
  ) {
    throw new Error(`Incorrect types for unknowns / knowns`);
  }

  const knownSats = [];
  const unknownSats = [];
  const sats = evaluate(miniscript).sats || [];
  sats.map(sat => {
    if (typeof sat.nSequence === 'undefined') delete sat.nSequence;
    if (typeof sat.nLockTime === 'undefined') delete sat.nLockTime;
    //Clean format: 1 consecutive spaces at most, no leading & trailing spaces
    sat.asm = sat.asm.replace(/  +/g, ' ').trim();

    if (unknowns) {
      if (unknowns.some(unknown => sat.asm.includes(unknown))) {
        unknownSats.push(sat);
      } else {
        knownSats.push(sat);
      }
    } else {
      const delKnowns = knowns.reduce(
        (acc, known) => acc.replace(known, ''),
        sat.asm
      );
      if (
        delKnowns.match(
          /<sig\(|<sha256_preimage\(|<hash256_preimage\(|<ripemd160_preimage\(|<hash160_preimage\(/
        )
      ) {
        //Even thought all known pieces of information are removed, there are
        //still other pieces of info needed. Thus, this sat is unkown.
        unknownSats.push(sat);
      } else {
        knownSats.push(sat);
      }
    }
  });

  return { ...malleabilityAnalysis(knownSats), unknownSats };
};

exports.compileMiniscript = compileMiniscript;
exports.compilePolicy = compilePolicy;
exports.satisfier = satisfier;

},{"bip68":102}],13:[function(require,module,exports){
'use strict';

var secp256k1 = require('@noble/curves/secp256k1');
var mod = require('@noble/curves/abstract/modular');
var utils = require('@noble/curves/abstract/utils');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var mod__namespace = /*#__PURE__*/_interopNamespaceDefault(mod);
var utils__namespace = /*#__PURE__*/_interopNamespaceDefault(utils);

/*
 * Copyright (c) 2023 Jose-Luis Landabaso
 * Distributed under the MIT software license.
 *
 * This file includes code from the following sources:
 *  * Paul Miller's @noble/secp256k1 (specifically, the privateAdd,
 *    privateNegate, pointAddScalar, and pointMultiply functions).
 *  * Some pieces from tiny-secp256k1
 *    (https://github.com/bitcoinjs/tiny-secp256k1)
 *  * It also uses code from BitGo's BitGoJS library
 *    (https://github.com/BitGo/BitGoJS)
 *
 * This package's tests are based on modified versions of tests from
 * tiny-secp256k1 (https://github.com/bitcoinjs/tiny-secp256k1/tests).
 */

const Point = secp256k1.secp256k1.ProjectivePoint;

const THROW_BAD_PRIVATE = "Expected Private";
const THROW_BAD_POINT = "Expected Point";
const THROW_BAD_TWEAK = "Expected Tweak";
const THROW_BAD_HASH = "Expected Hash";
const THROW_BAD_SIGNATURE = "Expected Signature";
const THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)";
const THROW_BAD_SCALAR = "Expected Scalar";
const THROW_BAD_RECOVERY_ID = "Bad Recovery Id";

const HASH_SIZE = 32;
const TWEAK_SIZE = 32;
const BN32_N = new Uint8Array([
  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,
]);
const EXTRA_DATA_SIZE = 32;
const BN32_ZERO = new Uint8Array(32);
const BN32_P_MINUS_N = new Uint8Array([
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,
  196, 64, 45, 161, 114, 47, 201, 186, 238,
]);
const _1n = BigInt(1);

function isUint8Array(value) {
  return value instanceof Uint8Array;
}

function cmpBN32(data1, data2) {
  for (let i = 0; i < 32; ++i) {
    if (data1[i] !== data2[i]) {
      return data1[i] < data2[i] ? -1 : 1;
    }
  }
  return 0;
}

function isZero(x) {
  return cmpBN32(x, BN32_ZERO) === 0;
}

function isTweak(tweak) {
  if (
    !(tweak instanceof Uint8Array) ||
    tweak.length !== TWEAK_SIZE ||
    cmpBN32(tweak, BN32_N) >= 0
  ) {
    return false;
  }
  return true;
}

function isSignature(signature) {
  return (
    signature instanceof Uint8Array &&
    signature.length === 64 &&
    cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&
    cmpBN32(signature.subarray(32, 64), BN32_N) < 0
  );
}

function isSigrLessThanPMinusN(signature) {
  return (
    isUint8Array(signature) &&
    signature.length === 64 &&
    cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0
  );
}

function isSignatureNonzeroRS(signature) {
  return !(
    isZero(signature.subarray(0, 32)) || isZero(signature.subarray(32, 64))
  );
}

function isHash(h) {
  return h instanceof Uint8Array && h.length === HASH_SIZE;
}

function isExtraData(e) {
  return (
    e === undefined || (e instanceof Uint8Array && e.length === EXTRA_DATA_SIZE)
  );
}

function normalizeScalar(scalar) {
  let num;
  if (typeof scalar === "bigint") {
    num = scalar;
  } else if (
    typeof scalar === "number" &&
    Number.isSafeInteger(scalar) &&
    scalar >= 0
  ) {
    num = BigInt(scalar);
  } else if (typeof scalar === "string") {
    if (scalar.length !== 64)
      throw new Error("Expected 32 bytes of private scalar");
    num = utils__namespace.hexToNumber(scalar);
  } else if (scalar instanceof Uint8Array) {
    if (scalar.length !== 32)
      throw new Error("Expected 32 bytes of private scalar");
    num = utils__namespace.bytesToNumberBE(scalar);
  } else {
    throw new TypeError("Expected valid private scalar");
  }
  if (num < 0) throw new Error("Expected private scalar >= 0");
  return num;
}

function normalizePrivateKey(privateKey) {
  return secp256k1.secp256k1.utils.normPrivateKeyToScalar(privateKey);
}

function _privateAdd(privateKey, tweak) {
  const p = normalizePrivateKey(privateKey);
  const t = normalizeScalar(tweak);
  const add = utils__namespace.numberToBytesBE(mod__namespace.mod(p + t, secp256k1.secp256k1.CURVE.n), 32);
  return secp256k1.secp256k1.utils.isValidPrivateKey(add) ? add : null;
}

function _privateSub(privateKey, tweak) {
  const p = normalizePrivateKey(privateKey);
  const t = normalizeScalar(tweak);
  const sub = utils__namespace.numberToBytesBE(mod__namespace.mod(p - t, secp256k1.secp256k1.CURVE.n), 32);
  return secp256k1.secp256k1.utils.isValidPrivateKey(sub) ? sub : null;
}

function _privateNegate(privateKey) {
  const p = normalizePrivateKey(privateKey);
  const not = utils__namespace.numberToBytesBE(secp256k1.secp256k1.CURVE.n - p, 32);
  return secp256k1.secp256k1.utils.isValidPrivateKey(not) ? not : null;
}

function _pointAddScalar(p, tweak, isCompressed) {
  const P = fromHex(p);
  const t = normalizeScalar(tweak);
  // multiplyAndAddUnsafe(P, scalar, 1) = P + scalar*G
  const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);
  if (!Q) throw new Error("Tweaked point at infinity");
  return Q.toRawBytes(isCompressed);
}

function _pointMultiply(p, tweak, isCompressed) {
  const P = fromHex(p);
  const h = typeof tweak === "string" ? tweak : utils__namespace.bytesToHex(tweak);
  const t = utils__namespace.hexToNumber(h);
  return P.multiply(t).toRawBytes(isCompressed);
}

function assumeCompression(compressed, p) {
  if (compressed === undefined) {
    return p !== undefined ? isPointCompressed(p) : true;
  }
  return !!compressed;
}

function throwToNull(fn) {
  try {
    return fn();
  } catch (e) {
    return null;
  }
}

function fromXOnly(bytes) {
  return secp256k1.schnorr.utils.lift_x(utils__namespace.bytesToNumberBE(bytes));
}

function fromHex(bytes) {
  return bytes.length === 32 ? fromXOnly(bytes) : Point.fromHex(bytes);
}

function _isPoint(p, xOnly) {
  if ((p.length === 32) !== xOnly) return false;
  try {
    if (xOnly) return !!fromXOnly(p);
    else return !!Point.fromHex(p);
  } catch (e) {
    return false;
  }
}

function isPoint(p) {
  return _isPoint(p, false);
}

function isPointCompressed(p) {
  const PUBLIC_KEY_COMPRESSED_SIZE = 33;
  return _isPoint(p, false) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;
}

function isPrivate(d) {
  return secp256k1.secp256k1.utils.isValidPrivateKey(d);
}

function isXOnlyPoint(p) {
  return _isPoint(p, true);
}

function xOnlyPointAddTweak(p, tweak) {
  if (!isXOnlyPoint(p)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isTweak(tweak)) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(() => {
    const P = _pointAddScalar(p, tweak, true);
    const parity = P[0] % 2 === 1 ? 1 : 0;
    return { parity, xOnlyPubkey: P.slice(1) };
  });
}

function xOnlyPointFromPoint(p) {
  if (!isPoint(p)) {
    throw new Error(THROW_BAD_POINT);
  }
  return p.slice(1, 33);
}

function pointFromScalar(sk, compressed) {
  if (!isPrivate(sk)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  return throwToNull(() =>
    secp256k1.secp256k1.getPublicKey(sk, assumeCompression(compressed)),
  );
}

function xOnlyPointFromScalar(d) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  return xOnlyPointFromPoint(pointFromScalar(d));
}

function pointCompress(p, compressed) {
  if (!isPoint(p)) {
    throw new Error(THROW_BAD_POINT);
  }
  return fromHex(p).toRawBytes(assumeCompression(compressed, p));
}

function pointMultiply(a, tweak, compressed) {
  if (!isPoint(a)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isTweak(tweak)) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(() =>
    _pointMultiply(a, tweak, assumeCompression(compressed, a)),
  );
}

function pointAdd(a, b, compressed) {
  if (!isPoint(a) || !isPoint(b)) {
    throw new Error(THROW_BAD_POINT);
  }
  return throwToNull(() => {
    const A = fromHex(a);
    const B = fromHex(b);
    if (A.equals(B.negate())) {
      return null;
    } else {
      return A.add(B).toRawBytes(assumeCompression(compressed, a));
    }
  });
}

function pointAddScalar(p, tweak, compressed) {
  if (!isPoint(p)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isTweak(tweak)) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(() =>
    _pointAddScalar(p, tweak, assumeCompression(compressed, p)),
  );
}

function privateAdd(d, tweak) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (!isTweak(tweak)) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(() => _privateAdd(d, tweak));
}

function privateSub(d, tweak) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (!isTweak(tweak)) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(() => _privateSub(d, tweak));
}

function privateNegate(d) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  return _privateNegate(d);
}

function sign(h, d, e) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  if (!isExtraData(e)) {
    throw new Error(THROW_BAD_EXTRA_DATA);
  }
  return secp256k1.secp256k1.sign(h, d, { extraEntropy: e }).toCompactRawBytes();
}

function signRecoverable(h, d, e) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  if (!isExtraData(e)) {
    throw new Error(THROW_BAD_EXTRA_DATA);
  }
  const sig = secp256k1.secp256k1.sign(h, d, { extraEntropy: e });
  return {
    signature: sig.toCompactRawBytes(),
    recoveryId: sig.recovery,
  };
}

function signSchnorr(h, d, e) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  if (!isExtraData(e)) {
    throw new Error(THROW_BAD_EXTRA_DATA);
  }
  return secp256k1.schnorr.sign(h, d, e);
}

function recover(h, signature, recoveryId, compressed) {
  if (!isHash(h)) {
    throw new Error(THROW_BAD_HASH);
  }

  if (!isSignature(signature) || !isSignatureNonzeroRS(signature)) {
    throw new Error(THROW_BAD_SIGNATURE);
  }

  if (recoveryId & 2) {
    if (!isSigrLessThanPMinusN(signature))
      throw new Error(THROW_BAD_RECOVERY_ID);
  }
  if (!isXOnlyPoint(signature.subarray(0, 32))) {
    throw new Error(THROW_BAD_SIGNATURE);
  }

  const s =
    secp256k1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(recoveryId);
  const Q = s.recoverPublicKey(h);
  if (!Q) throw new Error(THROW_BAD_SIGNATURE);
  return Q.toRawBytes(assumeCompression(compressed));
}

function verify(h, Q, signature, strict) {
  if (!isPoint(Q)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isSignature(signature)) {
    throw new Error(THROW_BAD_SIGNATURE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  return secp256k1.secp256k1.verify(signature, h, Q, { lowS: strict });
}

function verifySchnorr(h, Q, signature) {
  if (!isXOnlyPoint(Q)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isSignature(signature)) {
    throw new Error(THROW_BAD_SIGNATURE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  return secp256k1.schnorr.verify(signature, h, Q);
}

exports.isPoint = isPoint;
exports.isPointCompressed = isPointCompressed;
exports.isPrivate = isPrivate;
exports.isXOnlyPoint = isXOnlyPoint;
exports.pointAdd = pointAdd;
exports.pointAddScalar = pointAddScalar;
exports.pointCompress = pointCompress;
exports.pointFromScalar = pointFromScalar;
exports.pointMultiply = pointMultiply;
exports.privateAdd = privateAdd;
exports.privateNegate = privateNegate;
exports.privateSub = privateSub;
exports.recover = recover;
exports.sign = sign;
exports.signRecoverable = signRecoverable;
exports.signSchnorr = signSchnorr;
exports.verify = verify;
exports.verifySchnorr = verifySchnorr;
exports.xOnlyPointAddTweak = xOnlyPointAddTweak;
exports.xOnlyPointFromPoint = xOnlyPointFromPoint;
exports.xOnlyPointFromScalar = xOnlyPointFromScalar;

},{"@noble/curves/abstract/modular":17,"@noble/curves/abstract/utils":18,"@noble/curves/secp256k1":20}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHash = getHash;
exports.createCurve = createCurve;
/**
 * Utilities for short weierstrass curves, combined with noble-hashes.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const weierstrass_ts_1 = require("./abstract/weierstrass.js");
/** connects noble-curves to noble-hashes */
function getHash(hash) {
    return { hash };
}
/** @deprecated use new `weierstrass()` and `ecdsa()` methods */
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash });
    return { ...create(defHash), create };
}

},{"./abstract/weierstrass.js":19}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wNAF = void 0;
exports.negateCt = negateCt;
exports.normalizeZ = normalizeZ;
exports.mulEndoUnsafe = mulEndoUnsafe;
exports.pippenger = pippenger;
exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
exports.validateBasic = validateBasic;
exports._createCurveFields = _createCurveFields;
/**
 * Methods for elliptic curve multiplication by scalars.
 * Contains wNAF, pippenger.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = require("../utils.js");
const modular_ts_1 = require("./modular.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
/**
 * Takes a bunch of Projective Points but executes only one
 * inversion on all of them. Inversion is very slow operation,
 * so this improves performance massively.
 * Optimization: converts a list of projective points to a list of identical points with Z=1.
 */
function normalizeZ(c, points) {
    const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));
    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero
    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero
    const maxNumber = 2 ** W; // W=8 256
    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111
    const shiftBy = BigInt(W); // W=8 8
    return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask); // extract W bits.
    let nextN = n >> shiftBy; // shift number by W bits.
    // What actually happens here:
    // const highestBit = Number(mask ^ (mask >> 1n));
    // let wbits2 = wbits - 1; // skip zero
    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);
    // split if bits > max: +224 => 256-32
    if (wbits > windowSize) {
        // we skip zero, which means instead of `>= size-1`, we do `> size`
        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.
        nextN += _1n; // +256 (carry)
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero
    const isZero = wbits === 0; // is current window slice a 0?
    const isNeg = wbits < 0; // is current window slice negative?
    const isNegF = window % 2 !== 0; // fake random statement for noise
    const offsetF = offsetStart; // fake offset for noise
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
        throw new Error('array expected');
    points.forEach((p, i) => {
        if (!(p instanceof c))
            throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
        throw new Error('array of scalars expected');
    scalars.forEach((s, i) => {
        if (!field.isValid(s))
            throw new Error('invalid scalar at index ' + i);
    });
}
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes.
// Allows to make points frozen / immutable.
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap();
function getW(P) {
    // To disable precomputes:
    // return 1;
    return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
    if (n !== _0n)
        throw new Error('invalid wNAF');
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Table generation takes **30MB of ram and 10ms on high-end CPU**,
 * but may take much longer on slow devices. Actual generation will happen on
 * first call of `multiply()`. By default, `BASE` point is precomputed.
 *
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */
class wNAF {
    // Parametrized with a given Point class (not individual point)
    constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n) {
            if (n & _1n)
                p = p.add(d);
            d = d.double();
            n >>= _1n;
        }
        return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            // i=1, bc we skip 0
            for (let i = 1; i < windowSize; i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
        // Scalar should be smaller than field order
        if (!this.Fn.isValid(n))
            throw new Error('invalid scalar');
        // Accumulators
        let p = this.ZERO;
        let f = this.BASE;
        // This code was first written with assumption that 'f' and 'p' will never be infinity point:
        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
        // there is negate now: it is possible that negated element from low value
        // would be the same as high element, which will create carry into next window.
        // It's not obvious how this can fail, but still worth investigating later.
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise
            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // bits are 0: add garbage to fake point
                // Important part for const-time getPublicKey: add random "noise" point to f.
                f = f.add(negateCt(isNegF, precomputes[offsetF]));
            }
            else {
                // bits are 1: add to result point
                p = p.add(negateCt(isNeg, precomputes[offset]));
            }
        }
        assert0(n);
        // Return both real and fake points: JIT won't eliminate f.
        // At this point there is a way to F be infinity-point even if p is not,
        // which makes it less const-time: around 1 bigint multiply.
        return { p, f };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            if (n === _0n)
                break; // Early-exit, skip 0 value
            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // Window bits are 0: skip processing.
                // Move to next window.
                continue;
            }
            else {
                const item = precomputes[offset];
                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM
            }
        }
        assert0(n);
        return acc;
    }
    getPrecomputes(W, point, transform) {
        // Calculate precomputes on a first run, reuse them after
        let comp = pointPrecomputes.get(point);
        if (!comp) {
            comp = this.precomputeWindow(point, W);
            if (W !== 1) {
                // Doing transform outside of if brings 15% perf hit
                if (typeof transform === 'function')
                    comp = transform(comp);
                pointPrecomputes.set(point, comp);
            }
        }
        return comp;
    }
    cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
    }
    hasCache(elm) {
        return getW(elm) !== 1;
    }
}
exports.wNAF = wNAF;
/**
 * Endomorphism-specific multiplication for Koblitz curves.
 * Cost: 128 dbl, 0-256 adds.
 */
function mulEndoUnsafe(Point, point, k1, k2) {
    let acc = point;
    let p1 = Point.ZERO;
    let p2 = Point.ZERO;
    while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
            p1 = p1.add(acc);
        if (k2 & _1n)
            p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
    }
    return { p1, p2 };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster than precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka secret keys / bigints)
 */
function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
        throw new Error('arrays of points and scalars must have equal length');
    // if (plength === 0) throw new Error('array must be of length >= 2');
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
    let windowSize = 1; // bits
    if (wbits > 12)
        windowSize = wbits - 3;
    else if (wbits > 4)
        windowSize = wbits - 2;
    else if (wbits > 0)
        windowSize = 2;
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
            const scalar = scalars[j];
            const wbits = Number((scalar >> BigInt(i)) & MASK);
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
            for (let j = 0; j < windowSize; j++)
                sum = sum.double();
    }
    return sum;
}
/**
 * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @returns function which multiplies points with scaars
 */
function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    /**
     * Performance Analysis of Window-based Precomputation
     *
     * Base Case (256-bit scalar, 8-bit window):
     * - Standard precomputation requires:
     *   - 31 additions per scalar × 256 scalars = 7,936 ops
     *   - Plus 255 summary additions = 8,191 total ops
     *   Note: Summary additions can be optimized via accumulator
     *
     * Chunked Precomputation Analysis:
     * - Using 32 chunks requires:
     *   - 255 additions per chunk
     *   - 256 doublings
     *   - Total: (255 × 32) + 256 = 8,416 ops
     *
     * Memory Usage Comparison:
     * Window Size | Standard Points | Chunked Points
     * ------------|-----------------|---------------
     *     4-bit   |     520         |      15
     *     8-bit   |    4,224        |     255
     *    10-bit   |   13,824        |   1,023
     *    16-bit   |  557,056        |  65,535
     *
     * Key Advantages:
     * 1. Enables larger window sizes due to reduced memory overhead
     * 2. More efficient for smaller scalar counts:
     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops
     *    - ~2x faster than standard 8,191 ops
     *
     * Limitations:
     * - Not suitable for plain precomputes (requires 256 constant doublings)
     * - Performance degrades with larger scalar counts:
     *   - Optimal for ~256 scalars
     *   - Less efficient for 4096+ scalars (Pippenger preferred)
     */
    validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1; // table size (without zero)
    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
        }
        return res;
    });
    return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
            throw new Error('array of scalars must be smaller than array of points');
        let res = zero;
        for (let i = 0; i < chunks; i++) {
            // No need to double if accumulator is still zero.
            if (res !== zero)
                for (let j = 0; j < windowSize; j++)
                    res = res.double();
            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
            for (let j = 0; j < scalars.length; j++) {
                const n = scalars[j];
                const curr = Number((n >> shiftBy) & MASK);
                if (!curr)
                    continue; // skip zero scalars chunks
                res = res.add(tables[j][curr - 1]);
            }
        }
        return res;
    };
}
// TODO: remove
/** @deprecated */
function validateBasic(curve) {
    (0, modular_ts_1.validateField)(curve.Fp);
    (0, utils_ts_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
function createField(order, field, isLE) {
    if (field) {
        if (field.ORDER !== order)
            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');
        (0, modular_ts_1.validateField)(field);
        return field;
    }
    else {
        return (0, modular_ts_1.Field)(order, { isLE });
    }
}
/** Validates CURVE opts and creates fields */
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === undefined)
        FpFnLE = type === 'edwards';
    if (!CURVE || typeof CURVE !== 'object')
        throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ['p', 'n', 'h']) {
        const val = CURVE[p];
        if (!(typeof val === 'bigint' && val > _0n))
            throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b = type === 'weierstrass' ? 'b' : 'd';
    const params = ['Gx', 'Gy', 'a', _b];
    for (const p of params) {
        // @ts-ignore
        if (!Fp.isValid(CURVE[p]))
            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return { CURVE, Fp, Fn };
}

},{"../utils.js":21,"./modular.js":17}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._DST_scalar = void 0;
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const utils_ts_1 = require("../utils.js");
const modular_ts_1 = require("./modular.js");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_ts_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << (8 * length))
        throw new Error('invalid I2OSP input: ' + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
function normDST(DST) {
    if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== 'string')
        throw new Error('DST must be Uint8Array or string');
    return typeof DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
}
/**
 * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.
 * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).
 */
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
        throw new Error('expand_message_xmd: invalid lenInBytes');
    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
/**
 * Produces a uniformly random byte string using an extendable-output function (XOF) H.
 * 1. The collision resistance of H MUST be at least k bits.
 * 2. H MUST be an XOF that has been proved indifferentiable from
 *    a random oracle under a reasonable cryptographic assumption.
 * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).
 */
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.
 * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_ts_1._validateObject)(options, {
        p: 'bigint',
        m: 'number',
        k: 'number',
        hash: 'function',
    });
    const { p, k, m, hash, expand, DST } = options;
    if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error('expected valid hash');
    (0, utils_ts_1.abytes)(msg);
    anum(count);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        // 6.6.3
        // Exceptional cases of iso_map are inputs that cause the denominator of
        // either rational function to evaluate to zero; such cases MUST return
        // the identity point on E.
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv); // xNum / xDen
        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)
        return { x, y };
    };
}
exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)('HashToScalar-');
/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */
function createHasher(Point, mapToCurve, defaults) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    function map(num) {
        return Point.fromAffine(mapToCurve(num));
    }
    function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
            return Point.ZERO; // zero will throw in assert
        P.assertValidity();
        return P;
    }
    return {
        defaults,
        hashToCurve(msg, options) {
            const opts = Object.assign({}, defaults, options);
            const u = hash_to_field(msg, 2, opts);
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
            const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
            const opts = Object.assign({}, defaults, optsDst, options);
            const u = hash_to_field(msg, 1, opts);
            const u0 = map(u[0]);
            return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
            if (!Array.isArray(scalars))
                throw new Error('expected array of bigints');
            for (const i of scalars)
                if (typeof i !== 'bigint')
                    throw new Error('expected array of bigints');
            return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
            // @ts-ignore
            const N = Point.Fn.ORDER;
            const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);
            return hash_to_field(msg, 1, opts)[0][0];
        },
    };
}

},{"../utils.js":21,"./modular.js":17}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/**
 * Utils for modular division and fields.
 * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.
 * There is no division: it is replaced by modular multiplicative inverse.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = require("../utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);
// prettier-ignore
const _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);
// prettier-ignore
const _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
function pow(num, power, modulo) {
    return FpPow(Field(modulo), num, power);
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
/**
 * Inverses number over modulo.
 * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
 */
function invert(number, modulo) {
    if (number === _0n)
        throw new Error('invert: expected non-zero number');
    if (modulo <= _0n)
        throw new Error('invert: expected positive modulus, got ' + modulo);
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function assertIsSquare(Fp, root, n) {
    if (!Fp.eql(Fp.sqr(root), n))
        throw new Error('Cannot find square root');
}
// Not all roots are possible! Example which will throw:
// const NUM =
// n = 72057594037927816n;
// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));
function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n) / _4n;
    const root = Fp.pow(n, p1div4);
    assertIsSquare(Fp, root, n);
    return root;
}
function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
    assertIsSquare(Fp, root, n);
    return root;
}
// Based on RFC9380, Kong algorithm
// prettier-ignore
function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic
    return (Fp, n) => {
        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4
        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1
        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1
        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1
        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x
        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x
        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x
        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2
        assertIsSquare(Fp, root, n);
        return root;
    };
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Initialization (precomputation).
    // Caching initialization could boost perf by 7%.
    if (P < _3n)
        throw new Error('sqrt is not defined for small field');
    // Factor P - 1 = Q * 2^S, where Q is odd
    let Q = P - _1n;
    let S = 0;
    while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
    }
    // Find the first quadratic non-residue Z >= 2
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
        // Basic primality test for P. After x iterations, chance of
        // not finding quadratic non-residue is 2^x, so 2^1000.
        if (Z++ > 1000)
            throw new Error('Cannot find square root: probably non-prime P');
    }
    // Fast-path; usually done before Z, but we do "primality test".
    if (S === 1)
        return sqrt3mod4;
    // Slow-path
    // TODO: test on Fp2 and others
    let cc = _Fp.pow(Z, Q); // c = z^Q
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
            return n;
        // Check if n is a quadratic residue using Legendre symbol
        if (FpLegendre(Fp, n) !== 1)
            throw new Error('Cannot find square root');
        // Initialize variables for the main loop
        let M = S;
        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp
        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor
        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root
        // Main loop
        // while t != 1
        while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t))
                return Fp.ZERO; // if t=0 return R=0
            let i = 1;
            // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)
            let t_tmp = Fp.sqr(t); // t^(2^1)
            while (!Fp.eql(t_tmp, Fp.ONE)) {
                i++;
                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...
                if (i === M)
                    throw new Error('Cannot find square root');
            }
            // Calculate the exponent for b: 2^(M - i - 1)
            const exponent = _1n << BigInt(M - i - 1); // bigint is important
            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)
            // Update variables
            M = i;
            c = Fp.sqr(b); // c = b^2
            t = Fp.mul(t, c); // t = (t * b^2)
            R = Fp.mul(R, b); // R = R*b
        }
        return R;
    };
}
/**
 * Square root for a finite field. Will try optimized versions first:
 *
 * 1. P ≡ 3 (mod 4)
 * 2. P ≡ 5 (mod 8)
 * 3. P ≡ 9 (mod 16)
 * 4. Tonelli-Shanks algorithm
 *
 * Different algorithms can give different roots, it is up to user to decide which one they want.
 * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
 */
function FpSqrt(P) {
    // P ≡ 3 (mod 4) => √n = n^((P+1)/4)
    if (P % _4n === _3n)
        return sqrt3mod4;
    // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf
    if (P % _8n === _5n)
        return sqrt5mod8;
    // P ≡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)
    if (P % _16n === _9n)
        return sqrt9mod16(P);
    // Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'number',
        BITS: 'number',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    (0, utils_ts_1._validateObject)(field, opts);
    // const max = 16384;
    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');
    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');
    return field;
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(Fp, num, power) {
    if (power < _0n)
        throw new Error('invalid exponent, negatives unsupported');
    if (power === _0n)
        return Fp.ONE;
    if (power === _1n)
        return num;
    let p = Fp.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * Exception-free. Will return `undefined` for 0 elements.
 * @param passZero map 0 to 0 (instead of undefined)
 */
function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
    // Walk from first to last, multiply them by each other MOD p
    const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
    }, Fp.ONE);
    // Invert last element
    const invertedAcc = Fp.inv(multipliedAcc);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
}
// TODO: remove
function FpDiv(Fp, lhs, rhs) {
    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
}
/**
 * Legendre symbol.
 * Legendre constant is used to calculate Legendre symbol (a | p)
 * which denotes the value of a^((p-1)/2) (mod p).
 *
 * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue
 * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue
 * * (a | p) ≡ 0    if a ≡ 0 (mod p)
 */
function FpLegendre(Fp, n) {
    // We can use 3rd argument as optional cache of this value
    // but seems unneeded for now. The operation is very fast.
    const p1mod2 = (Fp.ORDER - _1n) / _2n;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no)
        throw new Error('invalid Legendre symbol result');
    return yes ? 1 : zero ? 0 : -1;
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(Fp, n) {
    const l = FpLegendre(Fp, n);
    return l === 1;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    if (nBitLength !== undefined)
        (0, utils_ts_1.anumber)(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
/**
 * Creates a finite field. Major performance optimizations:
 * * 1. Denormalized operations like mulN instead of mul.
 * * 2. Identical object shape: never add or remove keys.
 * * 3. `Object.freeze`.
 * Fragile: always run a benchmark on a change.
 * Security note: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you're doing.
 *
 * Note about field properties:
 * * CHARACTERISTIC p = prime number, number of elements in main subgroup.
 * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
 *
 * @param ORDER field order, probably prime, or could be composite
 * @param bitLen how many bits the field consumes
 * @param isLE (default: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?
isLE = false, opts = {}) {
    if (ORDER <= _0n)
        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
    let _nbitLength = undefined;
    let _sqrt = undefined;
    let modFromBytes = false;
    let allowedLengths = undefined;
    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
            throw new Error('cannot specify opts in two arguments');
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
            _nbitLength = _opts.BITS;
        if (_opts.sqrt)
            _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === 'boolean')
            isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === 'boolean')
            modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
    }
    else {
        if (typeof bitLenOrOpts === 'number')
            _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
            _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048)
        throw new Error('invalid field: expected ORDER of <= 2048 bytes');
    let sqrtP; // cached sqrtP
    const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths: allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error('invalid field element: expected bigint, got ' + typeof num);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt ||
            ((n) => {
                if (!sqrtP)
                    sqrtP = FpSqrt(ORDER);
                return sqrtP(f, n);
            }),
        toBytes: (num) => (isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes, skipValidation = true) => {
            if (allowedLengths) {
                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);
                }
                const padded = new Uint8Array(BYTES);
                // isLE add 0 to right, !isLE to the left.
                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
                bytes = padded;
            }
            if (bytes.length !== BYTES)
                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
            let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
            if (modFromBytes)
                scalar = mod(scalar, ORDER);
            if (!skipValidation)
                if (!f.isValid(scalar))
                    throw new Error('invalid field element: outside of range 0..ORDER');
            // NOTE: we don't validate scalar here, please use isValid. This done such way because some
            // protocol may allow non-reduced scalar that reduced later or changed some other way.
            return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => (c ? b : a),
    });
    return Object.freeze(f);
}
// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?
// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).
// which mean we cannot force this via opts.
// Not sure what to do with randomBytes, we can accept it inside opts if wanted.
// Probably need to export getMinHashLength somewhere?
// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {
//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;
//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?
//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;
//   return reduced;
// },
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use `mapKeyToField` instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
}

},{"../utils.js":21}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHash = exports.validateObject = exports.memoized = exports.notImplemented = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.aInRange = exports.inRange = exports.asciiToBytes = exports.copyBytes = exports.equalBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToNumber = exports.numberToHexUnpadded = exports.abool = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
/**
 * Deprecated module: moved from curves/abstract/utils.js to curves/utils.js
 * @module
 */
const u = require("../utils.js");
/** @deprecated moved to `@noble/curves/utils.js` */
exports.abytes = u.abytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.anumber = u.anumber;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToHex = u.bytesToHex;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToUtf8 = u.bytesToUtf8;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.concatBytes = u.concatBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.hexToBytes = u.hexToBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.isBytes = u.isBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.randomBytes = u.randomBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.utf8ToBytes = u.utf8ToBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.abool = u.abool;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToHexUnpadded = u.numberToHexUnpadded;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.hexToNumber = u.hexToNumber;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToNumberBE = u.bytesToNumberBE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToNumberLE = u.bytesToNumberLE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToBytesBE = u.numberToBytesBE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToBytesLE = u.numberToBytesLE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToVarBytesBE = u.numberToVarBytesBE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.ensureBytes = u.ensureBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.equalBytes = u.equalBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.copyBytes = u.copyBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.asciiToBytes = u.asciiToBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.inRange = u.inRange;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.aInRange = u.aInRange;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitLen = u.bitLen;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitGet = u.bitGet;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitSet = u.bitSet;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitMask = u.bitMask;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.createHmacDrbg = u.createHmacDrbg;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.notImplemented = u.notImplemented;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.memoized = u.memoized;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.validateObject = u.validateObject;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.isHash = u.isHash;

},{"../utils.js":21}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DER = exports.DERErr = void 0;
exports._splitEndoScalar = _splitEndoScalar;
exports._normFnElement = _normFnElement;
exports.weierstrassN = weierstrassN;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
exports.ecdh = ecdh;
exports.ecdsa = ecdsa;
exports.weierstrassPoints = weierstrassPoints;
exports._legacyHelperEquat = _legacyHelperEquat;
exports.weierstrass = weierstrass;
/**
 * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.
 *
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance
 * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
 * unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_js_1 = require("@noble/hashes/hmac.js");
const utils_1 = require("@noble/hashes/utils");
const utils_ts_1 = require("../utils.js");
const curve_ts_1 = require("./curve.js");
const modular_ts_1 = require("./modular.js");
// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)
const divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
/**
 * Splits scalar for GLV endomorphism.
 */
function _splitEndoScalar(k, basis, n) {
    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`
    // Since part can be negative, we need to do this on point.
    // TODO: verifyScalar function which consumes lambda
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    // |k1|/|k2| is < sqrt(N), but can be negative.
    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n;
    const k2neg = k2 < _0n;
    if (k1neg)
        k1 = -k1;
    if (k2neg)
        k2 = -k2;
    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.
    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.
    const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n; // Half bits of N
    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
        throw new Error('splitScalar (endomorphism): failed, k=' + k);
    }
    return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
    if (!['compact', 'recovered', 'der'].includes(format))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format;
}
function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
        // @ts-ignore
        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];
    }
    (0, utils_ts_1._abool2)(optsn.lowS, 'lowS');
    (0, utils_ts_1._abool2)(optsn.prehash, 'prehash');
    if (optsn.format !== undefined)
        validateSigFormat(optsn.format);
    return optsn;
}
class DERErr extends Error {
    constructor(m = '') {
        super(m);
    }
}
exports.DERErr = DERErr;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */
exports.DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data) => {
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length & 1)
                throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if ((len.length / 2) & 128)
                throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128) : '';
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag)
                throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong)
                length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen)
                    throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4)
                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen)
                    throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0)
                    throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)
                    length = (length << 8) | b;
                pos += lenLen;
                if (length < 128)
                    throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
                throw new E('tlv.decode: wrong value length');
            return { v, l: data.subarray(pos + length) };
        },
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode(num) {
            const { Err: E } = exports.DER;
            if (num < _0n)
                throw new E('integer: negative integers are not allowed');
            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 0b1000)
                hex = '00' + hex;
            if (hex.length & 1)
                throw new E('unexpected DER parsing assertion: unpadded hex');
            return hex;
        },
        decode(data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128)
                throw new E('invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128))
                throw new E('invalid signature integer: unnecessary leading zero');
            return (0, utils_ts_1.bytesToNumberBE)(data);
        },
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)('signature', hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(0x02, int.encode(sig.r));
        const ss = tlv.encode(0x02, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(0x30, seq);
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function _normFnElement(Fn, key) {
    const { BYTES: expected } = Fn;
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else {
        let bytes = (0, utils_ts_1.ensureBytes)('private key', key);
        try {
            num = Fn.fromBytes(bytes);
        }
        catch (error) {
            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
    }
    if (!Fn.isValidNot0(num))
        throw new Error('invalid private key: out of range [1..N-1]');
    return num;
}
/**
 * Creates weierstrass Point constructor, based on specified curve options.
 *
 * @example
```js
const opts = {
  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
  h: BigInt(1),
  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
};
const p256_Point = weierstrass(opts);
```
 */
function weierstrassN(params, extraOpts = {}) {
    const validated = (0, curve_ts_1._createCurveFields)('weierstrass', params, extraOpts);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(extraOpts, {}, {
        allowInfinityPoint: 'boolean',
        clearCofactor: 'function',
        isTorsionFree: 'function',
        fromBytes: 'function',
        toBytes: 'function',
        endo: 'object',
        wrapPrivateKey: 'boolean',
    });
    const { endo } = extraOpts;
    if (endo) {
        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {
            throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
    }
    const lengths = getWLengths(Fp, Fn);
    function assertCompressionIsSupported() {
        if (!Fp.isOdd)
            throw new Error('compression is not supported: Field does not have .isOdd()');
    }
    // Implements IEEE P1363 point encoding
    function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
        if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        }
        else {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));
        }
    }
    function pointFromBytes(bytes) {
        (0, utils_ts_1._abytes2)(bytes, undefined, 'Point');
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        // No actual validation is done here: use .assertValidity()
        if (length === comp && (head === 0x02 || head === 0x03)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x))
                throw new Error('bad point: is not on curve, wrong x');
            const y2 = weierstrassEquation(x); // y² = x³ + ax + b
            let y;
            try {
                y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
            }
            catch (sqrtError) {
                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                throw new Error('bad point: is not on curve, sqrt error' + err);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1; // ECDSA-specific
            if (isHeadOdd !== isYOdd)
                y = Fp.neg(y);
            return { x, y };
        }
        else if (length === uncomp && head === 0x04) {
            // TODO: more checks
            const L = Fp.BYTES;
            const x = Fp.fromBytes(tail.subarray(0, L));
            const y = Fp.fromBytes(tail.subarray(L, L * 2));
            if (!isValidXY(x, y))
                throw new Error('bad point: is not on curve');
            return { x, y };
        }
        else {
            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
        }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x² * x
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x³ + a * x + b
    }
    // TODO: move top-level
    /** Checks whether equation holds for given x, y: y² == x³ + ax + b */
    function isValidXY(x, y) {
        const left = Fp.sqr(y); // y²
        const right = weierstrassEquation(x); // x³ + ax + b
        return Fp.eql(left, right);
    }
    // Validate whether the passed curve params are valid.
    // Test 1: equation y² = x³ + ax + b should work for generator point.
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.
    // Guarantees curve is genus-1, smooth (non-singular).
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error('bad curve params: a or b');
    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */
    function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))
            throw new Error(`bad point coordinate ${title}`);
        return n;
    }
    function aprjpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    function splitEndoScalarN(k) {
        if (!endo || !endo.basises)
            throw new Error('no endo');
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        // Fast-path for normalized points
        if (Fp.eql(Z, Fp.ONE))
            return { x: X, y: Y };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
            throw new Error('invZ was invalid');
        return { x, y };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is invalid representation of ZERO.
            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
                return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error('bad point: x or y not field elements');
        if (!isValidXY(x, y))
            throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree())
            throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ∋ (x=X/Z, y=Y/Z).
     * Default Point works in 2d / affine coordinates: (x, y).
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
            this.X = acoord('x', X);
            this.Y = acoord('y', Y, true);
            this.Z = acoord('z', Z);
            Object.freeze(this);
        }
        static CURVE() {
            return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)
            if (Fp.is0(x) && Fp.is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
            const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, undefined, 'point')));
            P.assertValidity();
            return P;
        }
        static fromHex(hex) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex));
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
                this.multiply(_3n); // random number
            return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
            return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            const { endo } = extraOpts;
            if (!Fn.isValidNot0(scalar))
                throw new Error('invalid scalar: out of range'); // 0 is invalid
            let point, fake; // Fake point is used to const-time mult
            const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
            /** See docs for {@link EndomorphismOpts} */
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
                const { p: k1p, f: k1f } = mul(k1);
                const { p: k2p, f: k2f } = mul(k2);
                fake = k1f.add(k2f);
                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);
            }
            else {
                const { p, f } = mul(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
            const { endo } = extraOpts;
            const p = this;
            if (!Fn.isValid(sc))
                throw new Error('invalid scalar: out of range'); // 0 is valid
            if (sc === _0n || p.is0())
                return Point.ZERO;
            if (sc === _1n)
                return p; // fast-path
            if (wnaf.hasCache(this))
                return this.multiply(sc);
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
                const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe
                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);
            }
            else {
                return wnaf.unsafe(p, sc);
            }
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? undefined : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
            const { isTorsionFree } = extraOpts;
            if (cofactor === _1n)
                return true;
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
            const { clearCofactor } = extraOpts;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
            // can we use this.clearCofactor()?
            return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
            (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
            this.assertValidity();
            return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
            return this.X;
        }
        get py() {
            return this.X;
        }
        get pz() {
            return this.Z;
        }
        toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0
    // math field
    Point.Fp = Fp;
    // scalar field
    Point.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    return Point;
}
// Points start with byte 0x02 when y is even; otherwise 0x03
function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    (0, modular_ts_1.validateField)(Fp);
    const { A, B, Z } = opts;
    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
    if (!Fp.isOdd)
        throw new Error('Field does not have .isOdd()');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4
        return { x, y };
    };
}
function getWLengths(Fp, Fn) {
    return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES,
    };
}
/**
 * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.
 * This helper ensures no signature functionality is present. Less code, smaller bundle size.
 */
function ecdh(Point, ecdhOpts = {}) {
    const { Fn } = Point;
    const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });
    function isValidSecretKey(secretKey) {
        try {
            return !!_normFnElement(Fn, secretKey);
        }
        catch (error) {
            return false;
        }
    }
    function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
            const l = publicKey.length;
            if (isCompressed === true && l !== comp)
                return false;
            if (isCompressed === false && l !== publicKeyUncompressed)
                return false;
            return !!Point.fromBytes(publicKey);
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Produces cryptographically secure secret key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed'), Fn.ORDER);
    }
    /**
     * Computes public key for a secret key. Checks for validity of the secret key.
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        if (typeof item === 'bigint')
            return false;
        if (item instanceof Point)
            return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey)
            return undefined;
        const l = (0, utils_ts_1.ensureBytes)('key', item).length;
        return l === publicKey || l === publicKeyUncompressed;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from secret key A and public key B.
     * Checks: 1) secret key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
            throw new Error('first arg must be private key');
        if (isProbPub(publicKeyB) === false)
            throw new Error('second arg must be public key');
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB); // checks for being on-curve
        return b.multiply(s).toBytes(isCompressed);
    }
    const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
/**
 * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.
 * We need `hash` for 2 features:
 * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`
 * 2. k generation in `sign`, using HMAC-drbg(hash)
 *
 * ECDSAOpts are only rarely needed.
 *
 * @example
 * ```js
 * const p256_Point = weierstrass(...);
 * const p256_sha256 = ecdsa(p256_Point, sha256);
 * const p256_sha224 = ecdsa(p256_Point, sha224);
 * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });
 * ```
 */
function ecdsa(Point, hash, ecdsaOpts = {}) {
    (0, utils_1.ahash)(hash);
    (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: 'function',
        lowS: 'boolean',
        randomBytes: 'function',
        bits2int: 'function',
        bits2int_modN: 'function',
    });
    const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
    const hmac = ecdsaOpts.hmac ||
        ((key, ...msgs) => (0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
    const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,
        format: undefined, //'compact' as ECDSASigFormat,
        extraEntropy: false,
    };
    const defaultSigOpts_format = 'compact';
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function validateRS(title, num) {
        if (!Fn.isValidNot0(num))
            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
    }
    function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;
        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
    }
    /**
     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = validateRS('r', r); // r in [1..N-1];
            this.s = validateRS('s', s); // s in [1..N-1];
            if (recovery != null)
                this.recovery = recovery;
            Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
            validateSigLength(bytes, format);
            let recid;
            if (format === 'der') {
                const { r, s } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));
                return new Signature(r, s);
            }
            if (format === 'recovered') {
                recid = bytes[0];
                format = 'compact';
                bytes = bytes.subarray(1);
            }
            const L = Fn.BYTES;
            const r = bytes.subarray(0, L);
            const s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
            return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            // ECDSA recovery is hard for cofactor > 1 curves.
            // In sign, `r = q.x mod n`, and here we recover q.x from r.
            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.
            // However, for cofactor>1, r+n may not get q.x:
            // r+n*i would need to be done instead where i is unknown.
            // To easily get i, we either need to:
            // a. increase amount of valid recid values (4, 5...); OR
            // b. prohibit non-prime-order signatures (recid > 1).
            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1)
                throw new Error('recovery id is ambiguous for h>1 curve');
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj))
                throw new Error('recovery id 2 or 3 invalid');
            const x = Fp.toBytes(radj);
            const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj); // r^-1
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', messageHash)); // Truncate hash
            const u1 = Fn.create(-h * ir); // -hr^-1
            const u2 = Fn.create(s * ir); // sr^-1
            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0())
                throw new Error('point at infinify');
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
            validateSigFormat(format);
            if (format === 'der')
                return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            const r = Fn.toBytes(this.r);
            const s = Fn.toBytes(this.s);
            if (format === 'recovered') {
                if (this.recovery == null)
                    throw new Error('recovery bit must be present');
                return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
            }
            return (0, utils_ts_1.concatBytes)(r, s);
        }
        toHex(format) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() { }
        static fromCompact(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'compact');
        }
        static fromDER(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'der');
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
            return this.toBytes('der');
        }
        toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));
        }
        toCompactRawBytes() {
            return this.toBytes('compact');
        }
        toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));
        }
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = ecdsaOpts.bits2int ||
        function bits2int_def(bytes) {
            // Our custom check "just in case", for protection against DoS
            if (bytes.length > 8192)
                throw new Error('input is too large');
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = ecdsaOpts.bits2int_modN ||
        function bits2int_modN_def(bytes) {
            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // Pads output with zero as per spec
    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */
    function int2octets(num) {
        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`
        (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
    }
    function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, undefined, 'message');
        return prehash ? (0, utils_ts_1._abytes2)(hash(message), undefined, 'prehashed message') : message;
    }
    /**
     * Steps A, D of RFC6979 3.2.
     * Creates RFC6979 seed; converts msg/privKey to numbers.
     * Used only in sign, not in verify.
     *
     * Warning: we cannot assume here that message has same amount of bytes as curve order,
     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.
     */
    function prepSig(message, privateKey, opts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (extraEntropy != null && extraEntropy !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            // gen random bytes OR pass as-is
            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        // To transform k => Signature:
        // q = k⋅G
        // r = q.x mod n
        // s = k^-1(m + rd) mod n
        // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            // Important: all mod() calls here must be done over N
            const k = bits2int(kBytes); // mod n, not mod p
            if (!Fn.isValidNot0(k))
                return; // Valid scalars (including k) must be in 1..N-1
            const ik = Fn.inv(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = k⋅G
            const r = Fn.create(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = Fn.neg(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    /**
     * Signs message hash with a secret key.
     *
     * ```
     * sign(m, d) where
     *   k = rfc6979_hmac_drbg(m, d)
     *   (x, y) = G × k
     *   r = x mod n
     *   s = (m + dr) / k mod n
     * ```
     */
    function sign(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)('message', message);
        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);
        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G
        return sig;
    }
    function tryParsingSig(sg) {
        // Try to deduce format
        let sig = undefined;
        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex &&
            sg !== null &&
            typeof sg === 'object' &&
            typeof sg.r === 'bigint' &&
            typeof sg.s === 'bigint';
        if (!isHex && !isObj)
            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
        if (isObj) {
            sig = new Signature(sg.r, sg.s);
        }
        else if (isHex) {
            try {
                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'der');
            }
            catch (derError) {
                if (!(derError instanceof exports.DER.Err))
                    throw derError;
            }
            if (!sig) {
                try {
                    sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'compact');
                }
                catch (error) {
                    return false;
                }
            }
        }
        if (!sig)
            return false;
        return sig;
    }
    /**
     * Verifies a signature against message and public key.
     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.
     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   u1 = hs^-1 mod n
     *   u2 = rs^-1 mod n
     *   R = u1⋅G + u2⋅P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);
        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)('message', message), prehash);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const sig = format === undefined
            ? tryParsingSig(signature)
            : Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', signature), format);
        if (sig === false)
            return false;
        try {
            const P = Point.fromBytes(publicKey);
            if (lowS && sig.hasHighS())
                return false;
            const { r, s } = sig;
            const h = bits2int_modN(message); // mod n, not mod p
            const is = Fn.inv(s); // s^-1 mod n
            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n
            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n
            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1⋅G + u2⋅P
            if (R.is0())
                return false;
            const v = Fn.create(R.x); // v = r.x mod n
            return v === r;
        }
        catch (e) {
            return false;
        }
    }
    function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();
    }
    return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils,
        lengths,
        Point,
        sign,
        verify,
        recoverPublicKey,
        Signature,
        hash,
    });
}
/** @deprecated use `weierstrass` in newer releases */
function weierstrassPoints(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point);
}
function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths
        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))
        : undefined;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths: allowedLengths,
        modFromBytes: c.wrapPrivateKey,
    });
    const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes,
    };
    return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN,
    };
    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _legacyHelperEquat(Fp, a, b) {
    /**
     * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².
     * @returns y²
     */
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x² * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b
    }
    return weierstrassEquation;
}
function _weierstrass_new_output_to_legacy(c, Point) {
    const { Fp, Fn } = Point;
    function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
    return Object.assign({}, {
        CURVE: c,
        Point: Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        weierstrassEquation,
        isWithinCurveOrder,
    });
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
    const Point = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS)),
    });
}
// _ecdsa_legacy
function weierstrass(c) {
    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point, hash, ecdsaOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
}

},{"../utils.js":21,"./curve.js":15,"./modular.js":17,"@noble/hashes/hmac.js":25,"@noble/hashes/utils":33}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
/**
 * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).
 *
 * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ψ,
 * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = require("@noble/hashes/sha2.js");
const utils_js_1 = require("@noble/hashes/utils.js");
const _shortw_utils_ts_1 = require("./_shortw_utils.js");
const hash_to_curve_ts_1 = require("./abstract/hash-to-curve.js");
const modular_ts_1 = require("./abstract/modular.js");
const weierstrass_ts_1 = require("./abstract/weierstrass.js");
const utils_ts_1 = require("./utils.js");
// Seems like generator was produced from some seed:
// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`
// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n
const secp256k1_CURVE = {
    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),
};
const secp256k1_ENDO = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    basises: [
        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],
        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],
    ],
};
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
/**
 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = ((0, modular_ts_1.pow2)(b3, _3n, P) * b3) % P;
    const b9 = ((0, modular_ts_1.pow2)(b6, _3n, P) * b3) % P;
    const b11 = ((0, modular_ts_1.pow2)(b9, _2n, P) * b2) % P;
    const b22 = ((0, modular_ts_1.pow2)(b11, _11n, P) * b11) % P;
    const b44 = ((0, modular_ts_1.pow2)(b22, _22n, P) * b22) % P;
    const b88 = ((0, modular_ts_1.pow2)(b44, _44n, P) * b44) % P;
    const b176 = ((0, modular_ts_1.pow2)(b88, _88n, P) * b88) % P;
    const b220 = ((0, modular_ts_1.pow2)(b176, _44n, P) * b44) % P;
    const b223 = ((0, modular_ts_1.pow2)(b220, _3n, P) * b3) % P;
    const t1 = ((0, modular_ts_1.pow2)(b223, _23n, P) * b22) % P;
    const t2 = ((0, modular_ts_1.pow2)(t1, _6n, P) * b2) % P;
    const root = (0, modular_ts_1.pow2)(t2, _2n, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
/**
 * secp256k1 curve, ECDSA and ECDH methods.
 *
 * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`
 *
 * @example
 * ```js
 * import { secp256k1 } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = secp256k1.keygen();
 * const msg = new TextEncoder().encode('hello');
 * const sig = secp256k1.sign(msg, secretKey);
 * const isValid = secp256k1.verify(sig, msg, publicKey) === true;
 * ```
 */
exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point) => point.toBytes(true).slice(1);
const Pointk1 = /* @__PURE__ */ (() => exports.secp256k1.Point)();
const hasEven = (y) => y % _2n === _0n;
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    const { Fn, BASE } = Pointk1;
    const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
    const p = BASE.multiply(d_); // P = d'⋅G; 0 < d' < n check is done inside
    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
    return { scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    const Fp = Fpk1;
    if (!Fp.isValidNot0(x))
        throw new Error('invalid x: Fail if x ≥ p');
    const xx = Fp.create(x * x);
    const c = Fp.create(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().
    // Return the unique point P such that x(P) = x and
    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    if (!hasEven(y))
        y = Fp.neg(y);
    const p = Pointk1.fromAffine({ x, y });
    p.assertValidity();
    return p;
}
const num = utils_ts_1.bytesToNumberBE;
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge(...args) {
    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(secretKey) {
    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
    const { Fn } = Pointk1;
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder
    const a = (0, utils_ts_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'⋅G
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    const { Fn, BASE } = Pointk1;
    const sig = (0, utils_ts_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const pub = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
            return false;
        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
            return false;
        // int(challenge(bytes(r)||bytes(P)||m))%n
        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
        // R = s⋅G - e⋅P, where -eP == (n-e)P
        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
        const { x, y } = R.toAffine();
        // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
        if (R.is0() || !hasEven(y) || x !== r)
            return false;
        return true;
    }
    catch (error) {
        return false;
    }
}
/**
 * Schnorr signatures over secp256k1.
 * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 * @example
 * ```js
 * import { schnorr } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = schnorr.keygen();
 * // const publicKey = schnorr.getPublicKey(secretKey);
 * const msg = new TextEncoder().encode('hello');
 * const sig = schnorr.sign(msg, secretKey);
 * const isValid = schnorr.verify(sig, msg, publicKey);
 * ```
 */
exports.schnorr = (() => {
    const size = 32;
    const seedLength = 48;
    const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
    };
    // TODO: remove
    exports.secp256k1.utils.randomSecretKey;
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
    }
    return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
            randomSecretKey: randomSecretKey,
            randomPrivateKey: randomSecretKey,
            taggedHash,
            // TODO: remove
            lift_x,
            pointToBytes,
            numberToBytesBE: utils_ts_1.numberToBytesBE,
            bytesToNumberBE: utils_ts_1.bytesToNumberBE,
            mod: modular_ts_1.mod,
        },
        lengths: {
            secretKey: size,
            publicKey: size,
            publicKeyHasPrefix: false,
            signature: size * 2,
            seed: seedLength,
        },
    };
})();
const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
    // xNum
    [
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
    ],
    // xDen
    [
        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
    // yNum
    [
        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
    ],
    // yDen
    [
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
].map((i) => i.map((j) => BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fpk1.create(BigInt('-11')),
}))();
/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */
exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
    const { x, y } = mapSWU(Fpk1.create(scalars[0]));
    return isoMap(x, y);
}, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fpk1.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha2_js_1.sha256,
}))();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */
exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */
exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();

},{"./_shortw_utils.js":14,"./abstract/hash-to-curve.js":16,"./abstract/modular.js":17,"./abstract/weierstrass.js":19,"./utils.js":21,"@noble/hashes/sha2.js":30,"@noble/hashes/utils.js":33}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
exports.abool = abool;
exports._abool2 = _abool2;
exports._abytes2 = _abytes2;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.equalBytes = equalBytes;
exports.copyBytes = copyBytes;
exports.asciiToBytes = asciiToBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.isHash = isHash;
exports._validateObject = _validateObject;
exports.memoized = memoized;
/**
 * Hex, bytes and number utilities.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_js_1 = require("@noble/hashes/utils.js");
var utils_js_2 = require("@noble/hashes/utils.js");
Object.defineProperty(exports, "abytes", { enumerable: true, get: function () { return utils_js_2.abytes; } });
Object.defineProperty(exports, "anumber", { enumerable: true, get: function () { return utils_js_2.anumber; } });
Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return utils_js_2.bytesToHex; } });
Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } });
Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return utils_js_2.concatBytes; } });
Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function () { return utils_js_2.hexToBytes; } });
Object.defineProperty(exports, "isBytes", { enumerable: true, get: function () { return utils_js_2.isBytes; } });
Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function () { return utils_js_2.randomBytes; } });
Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } });
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
    if (typeof value !== 'boolean')
        throw new Error(title + ' boolean expected, got ' + value);
}
// tmp name until v2
function _abool2(value, title = '') {
    if (typeof value !== 'boolean') {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + 'expected boolean, got type=' + typeof value);
    }
    return value;
}
// tmp name until v2
/** Asserts something is Uint8Array. */
function _abytes2(value, length, title = '') {
    const bytes = (0, utils_js_1.isBytes)(value);
    const len = value?.length;
    const needsLen = length !== undefined;
    if (!bytes || (needsLen && len !== length)) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : '';
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);
    }
    return value;
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
}
function bytesToNumberLE(bytes) {
    (0, utils_js_1.abytes)(bytes);
    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'secret key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = (0, utils_js_1.hexToBytes)(hex);
        }
        catch (e) {
            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
        }
    }
    else if ((0, utils_js_1.isBytes)(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(title + ' must be hex string or Uint8Array');
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,
 * and Buffer#slice creates mutable copy. Never use Buffers!
 */
function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}
/**
 * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols
 * Should be safe to use for things expected to be ASCII.
 * Returns exact same result as utf8ToBytes for ASCII or throws.
 */
function asciiToBytes(ascii) {
    return Uint8Array.from(ascii, (c, i) => {
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) {
            throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
        }
        return charCode;
    });
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;
// Is positive bigint
const isPosBig = (n) => typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max))
        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
    return n | ((value ? _1n : _0n) << BigInt(pos));
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_1n << BigInt(n)) - _1n;
exports.bitMask = bitMask;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    const u8n = (len) => new Uint8Array(len); // creates Uint8Array
    const u8of = (byte) => Uint8Array.of(byte); // another shortcut
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0)) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error('invalid validator function');
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
function isHash(val) {
    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== 'object')
        throw new Error('expected valid options object');
    function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === undefined)
            return;
        const current = typeof val;
        if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
 * throws not implemented error
 */
const notImplemented = () => {
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== undefined)
            return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}

},{"@noble/hashes/utils.js":33}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */
const utils_ts_1 = require("./utils.js");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */
function Chi(a, b, c) {
    return (a & b) ^ (~a & c);
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
    return (a & b) ^ (a & c) ^ (b & c);
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */
/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */
exports.SHA256_IV = Uint32Array.from([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */
exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */
exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */
exports.SHA512_IV = Uint32Array.from([
    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,
]);

},{"./utils.js":33}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;

},{}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

},{}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hmac = exports.HMAC = void 0;
/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */
const utils_ts_1 = require("./utils.js");
class HMAC extends utils_ts_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);

},{"./utils.js":33}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
/**

SHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.
Don't use them in a new protocol. What "weak" means:

- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.
- No practical pre-image attacks (only theoretical, 2^123.4)
- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151
 * @module
 */
const _md_ts_1 = require("./_md.js");
const utils_ts_1 = require("./utils.js");
/** Initial SHA1 state */
const SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,
]);
// Reusable temporary buffer
const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
/** SHA1 legacy hash class. */
class SHA1 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
    }
    get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
    }
    set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
            SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        // Compression function main loop, 80 rounds
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
            let F, K;
            if (i < 20) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                K = 0x5a827999;
            }
            else if (i < 40) {
                F = B ^ C ^ D;
                K = 0x6ed9eba1;
            }
            else if (i < 60) {
                F = (0, _md_ts_1.Maj)(B, C, D);
                K = 0x8f1bbcdc;
            }
            else {
                F = B ^ C ^ D;
                K = 0xca62c1d6;
            }
            const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;
            E = D;
            D = C;
            C = (0, utils_ts_1.rotl)(B, 30);
            B = A;
            A = T;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        this.set(A, B, C, D, E);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA1 = SHA1;
/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */
exports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
/** Per-round constants */
const p32 = /* @__PURE__ */ Math.pow(2, 32);
const K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
/** md5 initial state: same as sha1, but 4 u32 instead of 5. */
const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
// Reusable temporary buffer
const MD5_W = /* @__PURE__ */ new Uint32Array(16);
/** MD5 legacy hash class. */
class MD5 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
    }
    get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
    }
    set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            MD5_W[i] = view.getUint32(offset, true);
        // Compression function main loop, 64 rounds
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
            let F, g, s;
            if (i < 16) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                g = i;
                s = [7, 12, 17, 22];
            }
            else if (i < 32) {
                F = (0, _md_ts_1.Chi)(D, B, C);
                g = (5 * i + 1) % 16;
                s = [5, 9, 14, 20];
            }
            else if (i < 48) {
                F = B ^ C ^ D;
                g = (3 * i + 5) % 16;
                s = [4, 11, 16, 23];
            }
            else {
                F = C ^ (B | ~D);
                g = (7 * i) % 16;
                s = [6, 10, 15, 21];
            }
            F = F + A + K[i] + MD5_W[g];
            A = D;
            D = C;
            C = B;
            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        this.set(A, B, C, D);
    }
    roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
    }
    destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.MD5 = MD5;
/**
 * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.
 * MD5 architecture is similar to SHA1, with some differences:
 * - Reduced output length: 16 bytes (128 bit) instead of 20
 * - 64 rounds, instead of 80
 * - Little-endian: could be faster, but will require more code
 * - Non-linear index selection: huge speed-up for unroll
 * - Per round constants: more memory accesses, additional speed-up for unroll
 */
exports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
// RIPEMD-160
const Rho160 = /* @__PURE__ */ Uint8Array.from([
    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
]);
const Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
const Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
const idxLR = /* @__PURE__ */ (() => {
    const L = [Id160];
    const R = [Pi160];
    const res = [L, R];
    for (let i = 0; i < 4; i++)
        for (let j of res)
            j.push(j[i].map((k) => Rho160[k]));
    return res;
})();
const idxL = /* @__PURE__ */ (() => idxLR[0])();
const idxR = /* @__PURE__ */ (() => idxLR[1])();
// const [idxL, idxR] = idxLR;
const shifts160 = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => Uint8Array.from(i));
const shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
const shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
const Kl160 = /* @__PURE__ */ Uint32Array.from([
    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
]);
const Kr160 = /* @__PURE__ */ Uint32Array.from([
    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
]);
// It's called f() in spec.
function ripemd_f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    if (group === 1)
        return (x & y) | (~x & z);
    if (group === 2)
        return (x | ~y) ^ z;
    if (group === 3)
        return (x & z) | (y & ~z);
    return x ^ (y | ~z);
}
// Reusable temporary buffer
const BUF_160 = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF_160[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = ((0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = ((0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a legacy hash function from 1990s.
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 */
exports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());

},{"./_md.js":22,"./utils.js":33}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pbkdf2 = pbkdf2;
exports.pbkdf2Async = pbkdf2Async;
/**
 * PBKDF (RFC 2898). Can be used to create a key from password and salt.
 * @module
 */
const hmac_ts_1 = require("./hmac.js");
// prettier-ignore
const utils_ts_1 = require("./utils.js");
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, utils_ts_1.ahash)(hash);
    const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, utils_ts_1.anumber)(c);
    (0, utils_ts_1.anumber)(dkLen);
    (0, utils_ts_1.anumber)(asyncTick);
    if (c < 1)
        throw new Error('iterations (c) should be >= 1');
    const password = (0, utils_ts_1.kdfInputToBytes)(_password);
    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_ts_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    (0, utils_ts_1.clean)(u);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 * @example
 * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });
 */
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.
 * @example
 * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });
 */
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

},{"./hmac.js":25,"./utils.js":33}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ripemd160 = exports.RIPEMD160 = void 0;
/**
 * RIPEMD-160 legacy hash function.
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 * @module
 * @deprecated
 */
const legacy_ts_1 = require("./legacy.js");
/** @deprecated Use import from `noble/hashes/legacy` module */
exports.RIPEMD160 = legacy_ts_1.RIPEMD160;
/** @deprecated Use import from `noble/hashes/legacy` module */
exports.ripemd160 = legacy_ts_1.ripemd160;

},{"./legacy.js":26}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha1 = exports.SHA1 = void 0;
/**
 * SHA1 (RFC 3174) legacy hash function.
 * @module
 * @deprecated
 */
const legacy_ts_1 = require("./legacy.js");
/** @deprecated Use import from `noble/hashes/legacy` module */
exports.SHA1 = legacy_ts_1.SHA1;
/** @deprecated Use import from `noble/hashes/legacy` module */
exports.sha1 = legacy_ts_1.sha1;

},{"./legacy.js":26}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */
const _md_ts_1 = require("./_md.js");
const u64 = require("./_u64.js");
const utils_ts_1 = require("./utils.js");
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */
// prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (() => u64.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */
/** SHA512/224 IV */
const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,
    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,
]);
/** SHA512/256 IV */
const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,
    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,
]);
class SHA512_224 extends SHA512 {
    constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */
exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
/** SHA2-224 hash function from RFC 4634 */
exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
/** SHA2-512 hash function from RFC 4634. */
exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
/** SHA2-384 hash function from RFC 4634. */
exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());

},{"./_md.js":22,"./_u64.js":23,"./utils.js":33}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
/**
 * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
 *
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 *
 * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 * @deprecated
 */
const sha2_ts_1 = require("./sha2.js");
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA256 = sha2_ts_1.SHA256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha256 = sha2_ts_1.sha256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA224 = sha2_ts_1.SHA224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha224 = sha2_ts_1.sha224;

},{"./sha2.js":30}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha512_256 = exports.SHA512_256 = exports.sha512_224 = exports.SHA512_224 = exports.sha384 = exports.SHA384 = exports.sha512 = exports.SHA512 = void 0;
/**
 * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.
 *
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).
 * @module
 * @deprecated
 */
const sha2_ts_1 = require("./sha2.js");
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA512 = sha2_ts_1.SHA512;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha512 = sha2_ts_1.sha512;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA384 = sha2_ts_1.SHA384;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha384 = sha2_ts_1.sha384;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA512_224 = sha2_ts_1.SHA512_224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha512_224 = sha2_ts_1.sha512_224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA512_256 = sha2_ts_1.SHA512_256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha512_256 = sha2_ts_1.sha512_256;

},{"./sha2.js":30}],33:[function(require,module,exports){
"use strict";
/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = require("@noble/hashes/crypto");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform */
exports.swap8IfBE = exports.isLE
    ? (n) => n
    : (n) => byteSwap(n);
/** @deprecated */
exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE
    ? (u) => u
    : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */
const nextTick = async () => { };
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */
function kdfInputToBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */
class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}

},{"@noble/hashes/crypto":24}],34:[function(require,module,exports){
"use strict";
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function isArrayOf(isString, arr) {
    if (!Array.isArray(arr))
        return false;
    if (arr.length === 0)
        return true;
    if (isString) {
        return arr.every((item) => typeof item === 'string');
    }
    else {
        return arr.every((item) => Number.isSafeInteger(item));
    }
}
// no abytes: seems to have 10% slowdown. Why?!
function afn(input) {
    if (typeof input !== 'function')
        throw new Error('function expected');
    return true;
}
function astr(label, input) {
    if (typeof input !== 'string')
        throw new Error(`${label}: string expected`);
    return true;
}
function anumber(n) {
    if (!Number.isSafeInteger(n))
        throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
    if (!Array.isArray(input))
        throw new Error('array expected');
}
function astrArr(label, input) {
    if (!isArrayOf(true, input))
        throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
    if (!isArrayOf(false, input))
        throw new Error(`${label}: array of numbers expected`);
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function chain(...args) {
    const id = (a) => a;
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b) => (c) => a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = args.map((x) => x.encode).reduceRight(wrap, id);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.map((x) => x.decode).reduce(wrap, id);
    return { encode, decode };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back.
 * Could also be array of strings.
 * @__NO_SIDE_EFFECTS__
 */
function alphabet(letters) {
    // mapping 1 to "b"
    const lettersA = typeof letters === 'string' ? letters.split('') : letters;
    const len = lettersA.length;
    astrArr('alphabet', lettersA);
    // mapping "b" to 1
    const indexes = new Map(lettersA.map((l, i) => [l, i]));
    return {
        encode: (digits) => {
            aArr(digits);
            return digits.map((i) => {
                if (!Number.isSafeInteger(i) || i < 0 || i >= len)
                    throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
                return lettersA[i];
            });
        },
        decode: (input) => {
            aArr(input);
            return input.map((letter) => {
                astr('alphabet.decode', letter);
                const i = indexes.get(letter);
                if (i === undefined)
                    throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
                return i;
            });
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function join(separator = '') {
    astr('join', separator);
    return {
        encode: (from) => {
            astrArr('join.decode', from);
            return from.join(separator);
        },
        decode: (to) => {
            astr('join.decode', to);
            return to.split(separator);
        },
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */
function padding(bits, chr = '=') {
    anumber(bits);
    astr('padding', chr);
    return {
        encode(data) {
            astrArr('padding.encode', data);
            while ((data.length * bits) % 8)
                data.push(chr);
            return data;
        },
        decode(input) {
            astrArr('padding.decode', input);
            let end = input.length;
            if ((end * bits) % 8)
                throw new Error('padding: invalid, string should have whole number of bytes');
            for (; end > 0 && input[end - 1] === chr; end--) {
                const last = end - 1;
                const byte = last * bits;
                if (byte % 8 === 0)
                    throw new Error('padding: invalid, string has too much padding');
            }
            return input.slice(0, end);
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function normalize(fn) {
    afn(fn);
    return { encode: (from) => from, decode: (to) => fn(to) };
}
/**
 * Slow: O(n^2) time complexity
 */
function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2)
        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2)
        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data);
    if (!data.length)
        return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data, (d) => {
        anumber(d);
        if (d < 0 || d >= from)
            throw new Error(`invalid integer: ${d}`);
        return d;
    });
    const dlen = digits.length;
    while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < dlen; i++) {
            const digit = digits[i];
            const fromCarry = from * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) ||
                fromCarry / from !== carry ||
                digitBase - digit !== fromCarry) {
                throw new Error('convertRadix: carry overflow');
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
                throw new Error('convertRadix: carry overflow');
            if (!done)
                continue;
            else if (!rounded)
                pos = i;
            else
                done = false;
        }
        res.push(carry);
        if (done)
            break;
    }
    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
    return res.reverse();
}
const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
const powers = /* @__PURE__ */ (() => {
    let res = [];
    for (let i = 0; i < 40; i++)
        res.push(2 ** i);
    return res;
})();
/**
 * Implemented with numbers, because BigInt is 5x slower
 */
function convertRadix2(data, from, to, padding) {
    aArr(data);
    if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data) {
        anumber(n);
        if (n >= max)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = (carry << from) | n;
        if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
            res.push(((carry >> (pos - to)) & mask) >>> 0);
        const pow = powers[pos];
        if (pow === undefined)
            throw new Error('invalid carry');
        carry &= pow - 1; // clean carry, otherwise it will cause overflow
    }
    carry = (carry << (to - pos)) & mask;
    if (!padding && pos >= from)
        throw new Error('Excess padding');
    if (!padding && carry > 0)
        throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0)
        res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function radix(num) {
    anumber(num);
    const _256 = 2 ** 8;
    return {
        encode: (bytes) => {
            if (!isBytes(bytes))
                throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits) => {
            anumArr('radix.decode', digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
        },
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */
function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32)
        throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error('radix2: carry overflow');
    return {
        encode: (bytes) => {
            if (!isBytes(bytes))
                throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
            anumArr('radix2.decode', digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        },
    };
}
function unsafeWrapper(fn) {
    afn(fn);
    return function (...args) {
        try {
            return fn.apply(null, args);
        }
        catch (e) { }
    };
}
function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
        encode(data) {
            if (!isBytes(data))
                throw new Error('checksum.encode: input should be Uint8Array');
            const sum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(sum, data.length);
            return res;
        },
        decode(data) {
            if (!isBytes(data))
                throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const oldChecksum = data.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for (let i = 0; i < len; i++)
                if (newChecksum[i] !== oldChecksum[i])
                    throw new Error('Invalid checksum');
            return payload;
        },
    };
}
// prettier-ignore
exports.utils = {
    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,
};
// RFC 4648 aka RFC 3548
// ---------------------
/**
 * base16 encoding from RFC 4648.
 * @example
 * ```js
 * base16.encode(Uint8Array.from([0x12, 0xab]));
 * // => '12AB'
 * ```
 */
exports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
/**
 * base32 encoding from RFC 4648. Has padding.
 * Use `base32nopad` for unpadded version.
 * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
 * @example
 * ```js
 * base32.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'CKVQ===='
 * base32.decode('CKVQ====');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
/**
 * base32 encoding from RFC 4648. No padding.
 * Use `base32` for padded version.
 * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
 * @example
 * ```js
 * base32nopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'CKVQ'
 * base32nopad.decode('CKVQ');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));
/**
 * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.
 * Use `base32hexnopad` for unpadded version.
 * @example
 * ```js
 * base32hex.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ALG===='
 * base32hex.decode('2ALG====');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
/**
 * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.
 * Use `base32hex` for padded version.
 * @example
 * ```js
 * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ALG'
 * base32hexnopad.decode('2ALG');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));
/**
 * base32 encoding from RFC 4648. Doug Crockford's version.
 * https://www.crockford.com/base32.html
 * @example
 * ```js
 * base32crockford.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ANG'
 * base32crockford.decode('2ANG');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64
// prettier-ignore
const hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&
    typeof Uint8Array.fromBase64 === 'function')();
const decodeBase64Builtin = (s, isUrl) => {
    astr('base64', s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet = isUrl ? 'base64url' : 'base64';
    if (s.length > 0 && !re.test(s))
        throw new Error('invalid base64');
    return Uint8Array.fromBase64(s, { alphabet, lastChunkHandling: 'strict' });
};
/**
 * base64 from RFC 4648. Padded.
 * Use `base64nopad` for unpadded version.
 * Also check out `base64url`, `base64urlnopad`.
 * Falls back to built-in function, when available.
 * @example
 * ```js
 * base64.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs='
 * base64.decode('Eqs=');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
// prettier-ignore
exports.base64 = hasBase64Builtin ? {
    encode(b) { abytes(b); return b.toBase64(); },
    decode(s) { return decodeBase64Builtin(s, false); },
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
/**
 * base64 from RFC 4648. No padding.
 * Use `base64` for padded version.
 * @example
 * ```js
 * base64nopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs'
 * base64nopad.decode('Eqs');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
/**
 * base64 from RFC 4648, using URL-safe alphabet. Padded.
 * Use `base64urlnopad` for unpadded version.
 * Falls back to built-in function, when available.
 * @example
 * ```js
 * base64url.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs='
 * base64url.decode('Eqs=');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
// prettier-ignore
exports.base64url = hasBase64Builtin ? {
    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },
    decode(s) { return decodeBase64Builtin(s, true); },
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
/**
 * base64 from RFC 4648, using URL-safe alphabet. No padding.
 * Use `base64url` for padded version.
 * @example
 * ```js
 * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs'
 * base64urlnopad.decode('Eqs');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
exports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));
/**
 * base58: base64 without ambigous characters +, /, 0, O, I, l.
 * Quadratic (O(n^2)) - so, can't be used on large inputs.
 * @example
 * ```js
 * base58.decode('01abcdef');
 * // => '3UhJW'
 * ```
 */
exports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
/**
 * base58: flickr version. Check out `base58`.
 */
exports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
/**
 * base58: XRP version. Check out `base58`.
 */
exports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
/**
 * base58: XMR version. Check out `base58`.
 * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.
 * Block encoding significantly reduces quadratic complexity of base58.
 */
exports.base58xmr = {
    encode(data) {
        let res = '';
        for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = exports.base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
                if (block[j] !== 0)
                    throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    },
};
/**
 * Method, which creates base58check encoder.
 * Requires function, calculating sha256.
 */
const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
exports.createBase58check = createBase58check;
/**
 * Use `createBase58check` instead.
 * @deprecated
 */
exports.base58check = exports.createBase58check;
const BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if (((b >> i) & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ (c >> 5);
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);
    for (let v of words)
        chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        astr('bech32.encode prefix', prefix);
        if (isBytes(words))
            words = Array.from(words);
        anumArr('bech32.encode', words);
        const plen = prefix.length;
        if (plen === 0)
            throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        astr('bech32.decode input', str);
        const slen = str.length;
        if (slen < 8 || (limit !== false && slen > limit))
            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6)
            throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
    }
    function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
    }
    return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords,
    };
}
/**
 * bech32 from BIP 173. Operates on words.
 * For high-level, check out scure-btc-signer:
 * https://github.com/paulmillr/scure-btc-signer.
 */
exports.bech32 = genBech32('bech32');
/**
 * bech32m from BIP 350. Operates on words.
 * It was to mitigate `bech32` weaknesses.
 * For high-level, check out scure-btc-signer:
 * https://github.com/paulmillr/scure-btc-signer.
 */
exports.bech32m = genBech32('bech32m');
/**
 * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.
 * @example
 * ```js
 * const b = utf8.decode("hey"); // => new Uint8Array([ 104, 101, 121 ])
 * const str = utf8.encode(b); // "hey"
 * ```
 */
exports.utf8 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str),
};
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
// prettier-ignore
const hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&
    typeof Uint8Array.fromHex === 'function')();
// prettier-ignore
const hexBuiltin = {
    encode(data) { abytes(data); return data.toHex(); },
    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },
};
/**
 * hex string decoder. Uses built-in function, when available.
 * @example
 * ```js
 * const b = hex.decode("0102ff"); // => new Uint8Array([ 1, 2, 255 ])
 * const str = hex.encode(b); // "0102ff"
 * ```
 */
exports.hex = hasHexBuiltin
    ? hexBuiltin
    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {
        if (typeof s !== 'string' || s.length % 2 !== 0)
            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
        return s.toLowerCase();
    }));
// prettier-ignore
const CODERS = {
    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
/** @deprecated */
const bytesToString = (type, bytes) => {
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (!isBytes(bytes))
        throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
exports.bytesToString = bytesToString;
/** @deprecated */
exports.str = exports.bytesToString; // as in python, but for bytes only
/** @deprecated */
const stringToBytes = (type, str) => {
    if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (typeof str !== 'string')
        throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
exports.stringToBytes = stringToBytes;
/** @deprecated */
exports.bytes = exports.stringToBytes;

},{}],35:[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":36,"./asn1/base":38,"./asn1/constants":42,"./asn1/decoders":44,"./asn1/encoders":47,"bn.js":49}],36:[function(require,module,exports){
var asn1 = require('../asn1');
var inherits = require('inherits');

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":35,"inherits":260,"vm":363}],37:[function(require,module,exports){
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":38,"buffer":167,"inherits":260}],38:[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":37,"./node":39,"./reporter":40}],39:[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var DecoderBuffer = require('../base').DecoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};

},{"../base":38,"minimalistic-assert":288}],40:[function(require,module,exports){
var inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

},{"inherits":260}],41:[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":42}],42:[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":41}],43:[function(require,module,exports){
var inherits = require('inherits');

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../../asn1":35,"inherits":260}],44:[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":43,"./pem":45}],45:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"./der":43,"buffer":167,"inherits":260}],46:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../../asn1":35,"buffer":167,"inherits":260}],47:[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":46,"./pem":48}],48:[function(require,module,exports){
var inherits = require('inherits');

var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"./der":46,"inherits":260}],49:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    this.length = num === 0 ? 1 : this.length;

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":135}],50:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = require('possible-typed-array-names');

var g = typeof globalThis === 'undefined' ? global : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
	var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			// @ts-expect-error
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"possible-typed-array-names":301}],51:[function(require,module,exports){
'use strict'
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source)
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Find code of next character
      var charCode = source.charCodeAt(psz)
            // Base map can not be indexed using char code
      if (charCode > 255) { return }
            // Decode character
      var carry = BASE_MAP[charCode]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = new Uint8Array(zeroes + (size - it4))
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base

},{}],52:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],53:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (((pre & 0x1ffffff) << 5) ^
        (-((b >> 0) & 1) & 0x3b6a57b2) ^
        (-((b >> 1) & 1) & 0x26508e6d) ^
        (-((b >> 2) & 1) & 0x1ea119fa) ^
        (-((b >> 3) & 1) & 0x3d4233dd) ^
        (-((b >> 4) & 1) & 0x2a1462b3));
}
function prefixChk(prefix) {
    let chk = 1;
    for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ (c >> 5);
    }
    chk = polymodStep(chk);
    for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ (v & 0x1f);
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
        }
    }
    else {
        if (bits >= inBits)
            return 'Excess padding';
        if ((value << (outBits - bits)) & maxV)
            return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    }
    else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            throw new Error(chk);
        let result = prefix + '1';
        for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
                throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
            const v = (chk >> ((5 - i) * 5)) & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
            return str + ' too short';
        if (str.length > LIMIT)
            return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
            return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1)
            return 'No separator character for ' + str;
        if (split === 0)
            return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
            return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined)
                return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length)
                continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST)
            return 'Invalid checksum for ' + str;
        return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords,
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

},{}],54:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const parser_1 = require('../parser');
function combine(psbts) {
  const self = psbts[0];
  const selfKeyVals = parser_1.psbtToKeyVals(self);
  const others = psbts.slice(1);
  if (others.length === 0) throw new Error('Combine: Nothing to combine');
  const selfTx = getTx(self);
  if (selfTx === undefined) {
    throw new Error('Combine: Self missing transaction');
  }
  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
  for (const other of others) {
    const otherTx = getTx(other);
    if (
      otherTx === undefined ||
      !otherTx.toBuffer().equals(selfTx.toBuffer())
    ) {
      throw new Error(
        'Combine: One of the Psbts does not have the same transaction.',
      );
    }
    const otherKeyVals = parser_1.psbtToKeyVals(other);
    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
    otherGlobalSet.forEach(
      keyPusher(
        selfGlobalSet,
        selfKeyVals.globalKeyVals,
        otherKeyVals.globalKeyVals,
      ),
    );
    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
    otherInputSets.forEach((inputSet, idx) =>
      inputSet.forEach(
        keyPusher(
          selfInputSets[idx],
          selfKeyVals.inputKeyVals[idx],
          otherKeyVals.inputKeyVals[idx],
        ),
      ),
    );
    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
    otherOutputSets.forEach((outputSet, idx) =>
      outputSet.forEach(
        keyPusher(
          selfOutputSets[idx],
          selfKeyVals.outputKeyVals[idx],
          otherKeyVals.outputKeyVals[idx],
        ),
      ),
    );
  }
  return parser_1.psbtFromKeyVals(selfTx, {
    globalMapKeyVals: selfKeyVals.globalKeyVals,
    inputKeyVals: selfKeyVals.inputKeyVals,
    outputKeyVals: selfKeyVals.outputKeyVals,
  });
}
exports.combine = combine;
function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
  return key => {
    if (selfSet.has(key)) return;
    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];
    selfKeyVals.push(newKv);
    selfSet.add(key);
  };
}
function getTx(psbt) {
  return psbt.globalMap.unsignedTx;
}
function getKeySet(keyVals) {
  const set = new Set();
  keyVals.forEach(keyVal => {
    const hex = keyVal.key.toString('hex');
    if (set.has(hex))
      throw new Error('Combine: KeyValue Map keys should be unique');
    set.add(hex);
  });
  return set;
}

},{"../parser":79}],55:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
const range = n => [...Array(n).keys()];
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
    throw new Error(
      'Decode Error: could not decode globalXpub with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
    throw new Error(
      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if ((keyVal.value.length / 4) % 1 !== 0) {
    throw new Error(
      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',
    );
  }
  const extendedPubkey = keyVal.key.slice(1);
  const data = {
    masterFingerprint: keyVal.value.slice(0, 4),
    extendedPubkey,
    path: 'm',
  };
  for (const i of range(keyVal.value.length / 4 - 1)) {
    const val = keyVal.value.readUInt32LE(i * 4 + 4);
    const isHard = !!(val & 0x80000000);
    const idx = val & 0x7fffffff;
    data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
  }
  return data;
}
exports.decode = decode;
function encode(data) {
  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
  const key = Buffer.concat([head, data.extendedPubkey]);
  const splitPath = data.path.split('/');
  const value = Buffer.allocUnsafe(splitPath.length * 4);
  data.masterFingerprint.copy(value, 0);
  let offset = 4;
  splitPath.slice(1).forEach(level => {
    const isHard = level.slice(-1) === "'";
    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
    if (isHard) num += 0x80000000;
    value.writeUInt32LE(num, offset);
    offset += 4;
  });
  return {
    key,
    value,
  };
}
exports.encode = encode;
exports.expected =
  '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';
function check(data) {
  const epk = data.extendedPubkey;
  const mfp = data.masterFingerprint;
  const p = data.path;
  return (
    Buffer.isBuffer(epk) &&
    epk.length === 78 &&
    [2, 3].indexOf(epk[45]) > -1 &&
    Buffer.isBuffer(mfp) &&
    mfp.length === 4 &&
    typeof p === 'string' &&
    !!p.match(/^m(\/\d+'?)*$/)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.extendedPubkey.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0
  );
}
exports.canAddToArray = canAddToArray;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],56:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function encode(data) {
  return {
    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
    value: data.toBuffer(),
  };
}
exports.encode = encode;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],57:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../typeFields');
const globalXpub = require('./global/globalXpub');
const unsignedTx = require('./global/unsignedTx');
const finalScriptSig = require('./input/finalScriptSig');
const finalScriptWitness = require('./input/finalScriptWitness');
const nonWitnessUtxo = require('./input/nonWitnessUtxo');
const partialSig = require('./input/partialSig');
const porCommitment = require('./input/porCommitment');
const sighashType = require('./input/sighashType');
const tapKeySig = require('./input/tapKeySig');
const tapLeafScript = require('./input/tapLeafScript');
const tapMerkleRoot = require('./input/tapMerkleRoot');
const tapScriptSig = require('./input/tapScriptSig');
const witnessUtxo = require('./input/witnessUtxo');
const tapTree = require('./output/tapTree');
const bip32Derivation = require('./shared/bip32Derivation');
const checkPubkey = require('./shared/checkPubkey');
const redeemScript = require('./shared/redeemScript');
const tapBip32Derivation = require('./shared/tapBip32Derivation');
const tapInternalKey = require('./shared/tapInternalKey');
const witnessScript = require('./shared/witnessScript');
const globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([]),
};
exports.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1.InputTypes.BIP32_DERIVATION,
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1.InputTypes.REDEEM_SCRIPT,
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1.InputTypes.WITNESS_SCRIPT,
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1.InputTypes.PARTIAL_SIG,
    typeFields_1.InputTypes.BIP32_DERIVATION,
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1.InputTypes.TAP_BIP32_DERIVATION,
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1.InputTypes.TAP_INTERNAL_KEY,
  ),
  tapMerkleRoot,
};
exports.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1.OutputTypes.BIP32_DERIVATION,
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1.OutputTypes.REDEEM_SCRIPT,
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1.OutputTypes.WITNESS_SCRIPT,
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1.OutputTypes.BIP32_DERIVATION,
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1.OutputTypes.TAP_BIP32_DERIVATION,
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1.OutputTypes.TAP_INTERNAL_KEY,
  ),
};
exports.outputs = outputs;

},{"../typeFields":82,"./global/globalXpub":55,"./global/unsignedTx":56,"./input/finalScriptSig":58,"./input/finalScriptWitness":59,"./input/nonWitnessUtxo":60,"./input/partialSig":61,"./input/porCommitment":62,"./input/sighashType":63,"./input/tapKeySig":64,"./input/tapLeafScript":65,"./input/tapMerkleRoot":66,"./input/tapScriptSig":67,"./input/witnessUtxo":68,"./output/tapTree":69,"./shared/bip32Derivation":70,"./shared/checkPubkey":71,"./shared/redeemScript":72,"./shared/tapBip32Derivation":73,"./shared/tapInternalKey":74,"./shared/witnessScript":75}],58:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
    throw new Error(
      'Decode Error: could not decode finalScriptSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
  return {
    key,
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptSig === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],59:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
    throw new Error(
      'Decode Error: could not decode finalScriptWitness with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
  return {
    key,
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return (
    !!currentData && !!newData && currentData.finalScriptWitness === undefined
  );
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],60:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode nonWitnessUtxo with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  return {
    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],61:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
    throw new Error(
      'Decode Error: could not decode partialSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (
    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
    ![2, 3, 4].includes(keyVal.key[1])
  ) {
    throw new Error(
      'Decode Error: partialSig has invalid pubkey in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const pubkey = keyVal.key.slice(1);
  return {
    pubkey,
    signature: keyVal.value,
  };
}
exports.decode = decode;
function encode(pSig) {
  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer.concat([head, pSig.pubkey]),
    value: pSig.signature,
  };
}
exports.encode = encode;
exports.expected = '{ pubkey: Buffer; signature: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.pubkey) &&
    Buffer.isBuffer(data.signature) &&
    [33, 65].includes(data.pubkey.length) &&
    [2, 3, 4].includes(data.pubkey[0]) &&
    isDerSigWithSighash(data.signature)
  );
}
exports.check = check;
function isDerSigWithSighash(buf) {
  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
  if (buf[0] !== 0x30) return false;
  if (buf.length !== buf[1] + 3) return false;
  if (buf[2] !== 0x02) return false;
  const rLen = buf[3];
  if (rLen > 33 || rLen < 1) return false;
  if (buf[3 + rLen + 1] !== 0x02) return false;
  const sLen = buf[3 + rLen + 2];
  if (sLen > 33 || sLen < 1) return false;
  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
  return true;
}
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.pubkey.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
}
exports.canAddToArray = canAddToArray;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],62:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
    throw new Error(
      'Decode Error: could not decode porCommitment with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value.toString('utf8');
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
  return {
    key,
    value: Buffer.from(data, 'utf8'),
  };
}
exports.encode = encode;
exports.expected = 'string';
function check(data) {
  return typeof data === 'string';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.porCommitment === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],63:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
    throw new Error(
      'Decode Error: could not decode sighashType with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value.readUInt32LE(0);
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
  const value = Buffer.allocUnsafe(4);
  value.writeUInt32LE(data, 0);
  return {
    key,
    value,
  };
}
exports.encode = encode;
exports.expected = 'number';
function check(data) {
  return typeof data === 'number';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.sighashType === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],64:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (
    keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG ||
    keyVal.key.length !== 1
  ) {
    throw new Error(
      'Decode Error: could not decode tapKeySig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (!check(keyVal.value)) {
    throw new Error(
      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(value) {
  const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
  return { key, value };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapKeySig === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],65:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
    throw new Error(
      'Decode Error: could not decode tapLeafScript with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if ((keyVal.key.length - 2) % 32 !== 0) {
    throw new Error(
      'Decode Error: tapLeafScript has invalid control block in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const leafVersion = keyVal.value[keyVal.value.length - 1];
  if ((keyVal.key[1] & 0xfe) !== leafVersion) {
    throw new Error(
      'Decode Error: tapLeafScript bad leaf version in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const script = keyVal.value.slice(0, -1);
  const controlBlock = keyVal.key.slice(1);
  return { controlBlock, script, leafVersion };
}
exports.decode = decode;
function encode(tScript) {
  const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
  const verBuf = Buffer.from([tScript.leafVersion]);
  return {
    key: Buffer.concat([head, tScript.controlBlock]),
    value: Buffer.concat([tScript.script, verBuf]),
  };
}
exports.encode = encode;
exports.expected =
  '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.controlBlock) &&
    (data.controlBlock.length - 1) % 32 === 0 &&
    (data.controlBlock[0] & 0xfe) === data.leafVersion &&
    Buffer.isBuffer(data.script)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.controlBlock.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0
  );
}
exports.canAddToArray = canAddToArray;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],66:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (
    keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT ||
    keyVal.key.length !== 1
  ) {
    throw new Error(
      'Decode Error: could not decode tapMerkleRoot with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (!check(keyVal.value)) {
    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(value) {
  const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
  return { key, value };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data) && data.length === 32;
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],67:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
    throw new Error(
      'Decode Error: could not decode tapScriptSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.key.length !== 65) {
    throw new Error(
      'Decode Error: tapScriptSig has invalid key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
    throw new Error(
      'Decode Error: tapScriptSig has invalid signature in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const pubkey = keyVal.key.slice(1, 33);
  const leafHash = keyVal.key.slice(33);
  return {
    pubkey,
    leafHash,
    signature: keyVal.value,
  };
}
exports.decode = decode;
function encode(tSig) {
  const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),
    value: tSig.signature,
  };
}
exports.encode = encode;
exports.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.pubkey) &&
    Buffer.isBuffer(data.leafHash) &&
    Buffer.isBuffer(data.signature) &&
    data.pubkey.length === 32 &&
    data.leafHash.length === 32 &&
    (data.signature.length === 64 || data.signature.length === 65)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString =
    item.pubkey.toString('hex') + item.leafHash.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(
      v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash),
    ).length === 0
  );
}
exports.canAddToArray = canAddToArray;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"buffer":167}],68:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
const tools_1 = require('../tools');
const varuint = require('../varint');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode witnessUtxo with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const value = tools_1.readUInt64LE(keyVal.value, 0);
  let _offset = 8;
  const scriptLen = varuint.decode(keyVal.value, _offset);
  _offset += varuint.encodingLength(scriptLen);
  const script = keyVal.value.slice(_offset);
  if (script.length !== scriptLen) {
    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');
  }
  return {
    script,
    value,
  };
}
exports.decode = decode;
function encode(data) {
  const { script, value } = data;
  const varintLen = varuint.encodingLength(script.length);
  const result = Buffer.allocUnsafe(8 + varintLen + script.length);
  tools_1.writeUInt64LE(result, value, 0);
  varuint.encode(script.length, result, 8);
  script.copy(result, 8 + varintLen);
  return {
    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
    value: result,
  };
}
exports.encode = encode;
exports.expected = '{ script: Buffer; value: number; }';
function check(data) {
  return Buffer.isBuffer(data.script) && typeof data.value === 'number';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.witnessUtxo === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"../tools":76,"../varint":77,"buffer":167}],69:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
const varuint = require('../varint');
function decode(keyVal) {
  if (
    keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE ||
    keyVal.key.length !== 1
  ) {
    throw new Error(
      'Decode Error: could not decode tapTree with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  let _offset = 0;
  const data = [];
  while (_offset < keyVal.value.length) {
    const depth = keyVal.value[_offset++];
    const leafVersion = keyVal.value[_offset++];
    const scriptLen = varuint.decode(keyVal.value, _offset);
    _offset += varuint.encodingLength(scriptLen);
    data.push({
      depth,
      leafVersion,
      script: keyVal.value.slice(_offset, _offset + scriptLen),
    });
    _offset += scriptLen;
  }
  return { leaves: data };
}
exports.decode = decode;
function encode(tree) {
  const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);
  const bufs = [].concat(
    ...tree.leaves.map(tapLeaf => [
      Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
      varuint.encode(tapLeaf.script.length),
      tapLeaf.script,
    ]),
  );
  return {
    key,
    value: Buffer.concat(bufs),
  };
}
exports.encode = encode;
exports.expected =
  '{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }';
function check(data) {
  return (
    Array.isArray(data.leaves) &&
    data.leaves.every(
      tapLeaf =>
        tapLeaf.depth >= 0 &&
        tapLeaf.depth <= 128 &&
        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&
        Buffer.isBuffer(tapLeaf.script),
    )
  );
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapTree === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":82,"../varint":77,"buffer":167}],70:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const range = n => [...Array(n).keys()];
const isValidDERKey = pubkey =>
  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||
  (pubkey.length === 65 && 4 === pubkey[0]);
function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode bip32Derivation with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    const pubkey = keyVal.key.slice(1);
    if (!isValidPubkey(pubkey)) {
      throw new Error(
        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if ((keyVal.value.length / 4) % 1 !== 0) {
      throw new Error(
        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',
      );
    }
    const data = {
      masterFingerprint: keyVal.value.slice(0, 4),
      pubkey,
      path: 'm',
    };
    for (const i of range(keyVal.value.length / 4 - 1)) {
      const val = keyVal.value.readUInt32LE(i * 4 + 4);
      const isHard = !!(val & 0x80000000);
      const idx = val & 0x7fffffff;
      data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
    }
    return data;
  }
  function encode(data) {
    const head = Buffer.from([TYPE_BYTE]);
    const key = Buffer.concat([head, data.pubkey]);
    const splitPath = data.path.split('/');
    const value = Buffer.allocUnsafe(splitPath.length * 4);
    data.masterFingerprint.copy(value, 0);
    let offset = 4;
    splitPath.slice(1).forEach(level => {
      const isHard = level.slice(-1) === "'";
      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
      if (isHard) num += 0x80000000;
      value.writeUInt32LE(num, offset);
      offset += 4;
    });
    return {
      key,
      value,
    };
  }
  const expected =
    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';
  function check(data) {
    return (
      Buffer.isBuffer(data.pubkey) &&
      Buffer.isBuffer(data.masterFingerprint) &&
      typeof data.path === 'string' &&
      isValidPubkey(data.pubkey) &&
      data.masterFingerprint.length === 4
    );
  }
  function canAddToArray(array, item, dupeSet) {
    const dupeString = item.pubkey.toString('hex');
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAddToArray,
  };
}
exports.makeConverter = makeConverter;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],71:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function makeChecker(pubkeyTypes) {
  return checkPubkey;
  function checkPubkey(keyVal) {
    let pubkey;
    if (pubkeyTypes.includes(keyVal.key[0])) {
      pubkey = keyVal.key.slice(1);
      if (
        !(pubkey.length === 33 || pubkey.length === 65) ||
        ![2, 3, 4].includes(pubkey[0])
      ) {
        throw new Error(
          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),
        );
      }
    }
    return pubkey;
  }
}
exports.makeChecker = makeChecker;

},{}],72:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode redeemScript with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Buffer.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.redeemScript === undefined;
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],73:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const varuint = require('../varint');
const bip32Derivation = require('./bip32Derivation');
const isValidBIP340Key = pubkey => pubkey.length === 32;
function makeConverter(TYPE_BYTE) {
  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
  function decode(keyVal) {
    const nHashes = varuint.decode(keyVal.value);
    const nHashesLen = varuint.encodingLength(nHashes);
    const base = parent.decode({
      key: keyVal.key,
      value: keyVal.value.slice(nHashesLen + nHashes * 32),
    });
    const leafHashes = new Array(nHashes);
    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
    }
    return Object.assign({}, base, { leafHashes });
  }
  function encode(data) {
    const base = parent.encode(data);
    const nHashesLen = varuint.encodingLength(data.leafHashes.length);
    const nHashesBuf = Buffer.allocUnsafe(nHashesLen);
    varuint.encode(data.leafHashes.length, nHashesBuf);
    const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);
    return Object.assign({}, base, { value });
  }
  const expected =
    '{ ' +
    'masterFingerprint: Buffer; ' +
    'pubkey: Buffer; ' +
    'path: string; ' +
    'leafHashes: Buffer[]; ' +
    '}';
  function check(data) {
    return (
      Array.isArray(data.leafHashes) &&
      data.leafHashes.every(
        leafHash => Buffer.isBuffer(leafHash) && leafHash.length === 32,
      ) &&
      parent.check(data)
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAddToArray: parent.canAddToArray,
  };
}
exports.makeConverter = makeConverter;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../varint":77,"./bip32Derivation":70,"buffer":167}],74:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
      throw new Error(
        'Decode Error: could not decode tapInternalKey with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if (keyVal.value.length !== 32) {
      throw new Error(
        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',
      );
    }
    return keyVal.value;
  }
  function encode(value) {
    const key = Buffer.from([TYPE_BYTE]);
    return { key, value };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data) && data.length === 32;
  }
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.tapInternalKey === undefined
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],75:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode witnessScript with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Buffer.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.witnessScript === undefined
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],76:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const varuint = require('./varint');
exports.range = n => [...Array(n).keys()];
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  let j = buffer.length - 1;
  let tmp = 0;
  for (let i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function keyValsToBuffer(keyVals) {
  const buffers = keyVals.map(keyValToBuffer);
  buffers.push(Buffer.from([0]));
  return Buffer.concat(buffers);
}
exports.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(keyVal) {
  const keyLen = keyVal.key.length;
  const valLen = keyVal.value.length;
  const keyVarIntLen = varuint.encodingLength(keyLen);
  const valVarIntLen = varuint.encodingLength(valLen);
  const buffer = Buffer.allocUnsafe(
    keyVarIntLen + keyLen + valVarIntLen + valLen,
  );
  varuint.encode(keyLen, buffer, 0);
  keyVal.key.copy(buffer, keyVarIntLen);
  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
  return buffer;
}
exports.keyValToBuffer = keyValToBuffer;
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
  if (typeof value !== 'number')
    throw new Error('cannot write a non-number as a number');
  if (value < 0)
    throw new Error('specified a negative value for writing an unsigned value');
  if (value > max) throw new Error('RangeError: value out of range');
  if (Math.floor(value) !== value)
    throw new Error('value has a fractional component');
}
function readUInt64LE(buffer, offset) {
  const a = buffer.readUInt32LE(offset);
  let b = buffer.readUInt32LE(offset + 4);
  b *= 0x100000000;
  verifuint(b + a, 0x001fffffffffffff);
  return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
  verifuint(value, 0x001fffffffffffff);
  buffer.writeInt32LE(value & -1, offset);
  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
  return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./varint":77,"buffer":167}],77:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
// Number.MAX_SAFE_INTEGER
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
    throw new RangeError('value out of range');
}
function encode(_number, buffer, offset) {
  checkUInt53(_number);
  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  // 8 bit
  if (_number < 0xfd) {
    buffer.writeUInt8(_number, offset);
    Object.assign(encode, { bytes: 1 });
    // 16 bit
  } else if (_number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset);
    buffer.writeUInt16LE(_number, offset + 1);
    Object.assign(encode, { bytes: 3 });
    // 32 bit
  } else if (_number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset);
    buffer.writeUInt32LE(_number, offset + 1);
    Object.assign(encode, { bytes: 5 });
    // 64 bit
  } else {
    buffer.writeUInt8(0xff, offset);
    buffer.writeUInt32LE(_number >>> 0, offset + 1);
    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);
    Object.assign(encode, { bytes: 9 });
  }
  return buffer;
}
exports.encode = encode;
function decode(buffer, offset) {
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  const first = buffer.readUInt8(offset);
  // 8 bit
  if (first < 0xfd) {
    Object.assign(decode, { bytes: 1 });
    return first;
    // 16 bit
  } else if (first === 0xfd) {
    Object.assign(decode, { bytes: 3 });
    return buffer.readUInt16LE(offset + 1);
    // 32 bit
  } else if (first === 0xfe) {
    Object.assign(decode, { bytes: 5 });
    return buffer.readUInt32LE(offset + 1);
    // 64 bit
  } else {
    Object.assign(decode, { bytes: 9 });
    const lo = buffer.readUInt32LE(offset + 1);
    const hi = buffer.readUInt32LE(offset + 5);
    const _number = hi * 0x0100000000 + lo;
    checkUInt53(_number);
    return _number;
  }
}
exports.decode = decode;
function encodingLength(_number) {
  checkUInt53(_number);
  return _number < 0xfd
    ? 1
    : _number <= 0xffff
    ? 3
    : _number <= 0xffffffff
    ? 5
    : 9;
}
exports.encodingLength = encodingLength;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],78:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const convert = require('../converter');
const tools_1 = require('../converter/tools');
const varuint = require('../converter/varint');
const typeFields_1 = require('../typeFields');
function psbtFromBuffer(buffer, txGetter) {
  let offset = 0;
  function varSlice() {
    const keyLen = varuint.decode(buffer, offset);
    offset += varuint.encodingLength(keyLen);
    const key = buffer.slice(offset, offset + keyLen);
    offset += keyLen;
    return key;
  }
  function readUInt32BE() {
    const num = buffer.readUInt32BE(offset);
    offset += 4;
    return num;
  }
  function readUInt8() {
    const num = buffer.readUInt8(offset);
    offset += 1;
    return num;
  }
  function getKeyValue() {
    const key = varSlice();
    const value = varSlice();
    return {
      key,
      value,
    };
  }
  function checkEndOfKeyValPairs() {
    if (offset >= buffer.length) {
      throw new Error('Format Error: Unexpected End of PSBT');
    }
    const isEnd = buffer.readUInt8(offset) === 0;
    if (isEnd) {
      offset++;
    }
    return isEnd;
  }
  if (readUInt32BE() !== 0x70736274) {
    throw new Error('Format Error: Invalid Magic Number');
  }
  if (readUInt8() !== 0xff) {
    throw new Error(
      'Format Error: Magic Number must be followed by 0xff separator',
    );
  }
  const globalMapKeyVals = [];
  const globalKeyIndex = {};
  while (!checkEndOfKeyValPairs()) {
    const keyVal = getKeyValue();
    const hexKey = keyVal.key.toString('hex');
    if (globalKeyIndex[hexKey]) {
      throw new Error(
        'Format Error: Keys must be unique for global keymap: key ' + hexKey,
      );
    }
    globalKeyIndex[hexKey] = 1;
    globalMapKeyVals.push(keyVal);
  }
  const unsignedTxMaps = globalMapKeyVals.filter(
    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,
  );
  if (unsignedTxMaps.length !== 1) {
    throw new Error('Format Error: Only one UNSIGNED_TX allowed');
  }
  const unsignedTx = txGetter(unsignedTxMaps[0].value);
  // Get input and output counts to loop the respective fields
  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
  const inputKeyVals = [];
  const outputKeyVals = [];
  // Get input fields
  for (const index of tools_1.range(inputCount)) {
    const inputKeyIndex = {};
    const input = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = keyVal.key.toString('hex');
      if (inputKeyIndex[hexKey]) {
        throw new Error(
          'Format Error: Keys must be unique for each input: ' +
            'input index ' +
            index +
            ' key ' +
            hexKey,
        );
      }
      inputKeyIndex[hexKey] = 1;
      input.push(keyVal);
    }
    inputKeyVals.push(input);
  }
  for (const index of tools_1.range(outputCount)) {
    const outputKeyIndex = {};
    const output = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = keyVal.key.toString('hex');
      if (outputKeyIndex[hexKey]) {
        throw new Error(
          'Format Error: Keys must be unique for each output: ' +
            'output index ' +
            index +
            ' key ' +
            hexKey,
        );
      }
      outputKeyIndex[hexKey] = 1;
      output.push(keyVal);
    }
    outputKeyVals.push(output);
  }
  return psbtFromKeyVals(unsignedTx, {
    globalMapKeyVals,
    inputKeyVals,
    outputKeyVals,
  });
}
exports.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(type, keyBuf, keyNum) {
  if (!keyBuf.equals(Buffer.from([keyNum]))) {
    throw new Error(
      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
    );
  }
}
exports.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(
  unsignedTx,
  { globalMapKeyVals, inputKeyVals, outputKeyVals },
) {
  // That was easy :-)
  const globalMap = {
    unsignedTx,
  };
  let txCount = 0;
  for (const keyVal of globalMapKeyVals) {
    // If a globalMap item needs pubkey, uncomment
    // const pubkey = convert.globals.checkPubkey(keyVal);
    switch (keyVal.key[0]) {
      case typeFields_1.GlobalTypes.UNSIGNED_TX:
        checkKeyBuffer(
          'global',
          keyVal.key,
          typeFields_1.GlobalTypes.UNSIGNED_TX,
        );
        if (txCount > 0) {
          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');
        }
        txCount++;
        break;
      case typeFields_1.GlobalTypes.GLOBAL_XPUB:
        if (globalMap.globalXpub === undefined) {
          globalMap.globalXpub = [];
        }
        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
        break;
      default:
        // This will allow inclusion during serialization.
        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
        globalMap.unknownKeyVals.push(keyVal);
    }
  }
  // Get input and output counts to loop the respective fields
  const inputCount = inputKeyVals.length;
  const outputCount = outputKeyVals.length;
  const inputs = [];
  const outputs = [];
  // Get input fields
  for (const index of tools_1.range(inputCount)) {
    const input = {};
    for (const keyVal of inputKeyVals[index]) {
      convert.inputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_1.InputTypes.NON_WITNESS_UTXO:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.NON_WITNESS_UTXO,
          );
          if (input.nonWitnessUtxo !== undefined) {
            throw new Error(
              'Format Error: Input has multiple NON_WITNESS_UTXO',
            );
          }
          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
          break;
        case typeFields_1.InputTypes.WITNESS_UTXO:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.WITNESS_UTXO,
          );
          if (input.witnessUtxo !== undefined) {
            throw new Error('Format Error: Input has multiple WITNESS_UTXO');
          }
          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
          break;
        case typeFields_1.InputTypes.PARTIAL_SIG:
          if (input.partialSig === undefined) {
            input.partialSig = [];
          }
          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
          break;
        case typeFields_1.InputTypes.SIGHASH_TYPE:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.SIGHASH_TYPE,
          );
          if (input.sighashType !== undefined) {
            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');
          }
          input.sighashType = convert.inputs.sighashType.decode(keyVal);
          break;
        case typeFields_1.InputTypes.REDEEM_SCRIPT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.REDEEM_SCRIPT,
          );
          if (input.redeemScript !== undefined) {
            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');
          }
          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
          break;
        case typeFields_1.InputTypes.WITNESS_SCRIPT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.WITNESS_SCRIPT,
          );
          if (input.witnessScript !== undefined) {
            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');
          }
          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
          break;
        case typeFields_1.InputTypes.BIP32_DERIVATION:
          if (input.bip32Derivation === undefined) {
            input.bip32Derivation = [];
          }
          input.bip32Derivation.push(
            convert.inputs.bip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.FINAL_SCRIPTSIG,
          );
          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
          break;
        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,
          );
          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
            keyVal,
          );
          break;
        case typeFields_1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.POR_COMMITMENT,
          );
          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
          break;
        case typeFields_1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.TAP_KEY_SIG,
          );
          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
          break;
        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
          if (input.tapScriptSig === undefined) {
            input.tapScriptSig = [];
          }
          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
          break;
        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
          if (input.tapLeafScript === undefined) {
            input.tapLeafScript = [];
          }
          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
          break;
        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
          if (input.tapBip32Derivation === undefined) {
            input.tapBip32Derivation = [];
          }
          input.tapBip32Derivation.push(
            convert.inputs.tapBip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.TAP_INTERNAL_KEY,
          );
          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
          break;
        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.TAP_MERKLE_ROOT,
          );
          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
          break;
        default:
          // This will allow inclusion during serialization.
          if (!input.unknownKeyVals) input.unknownKeyVals = [];
          input.unknownKeyVals.push(keyVal);
      }
    }
    inputs.push(input);
  }
  for (const index of tools_1.range(outputCount)) {
    const output = {};
    for (const keyVal of outputKeyVals[index]) {
      convert.outputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_1.OutputTypes.REDEEM_SCRIPT:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.REDEEM_SCRIPT,
          );
          if (output.redeemScript !== undefined) {
            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');
          }
          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.WITNESS_SCRIPT:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.WITNESS_SCRIPT,
          );
          if (output.witnessScript !== undefined) {
            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');
          }
          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.BIP32_DERIVATION:
          if (output.bip32Derivation === undefined) {
            output.bip32Derivation = [];
          }
          output.bip32Derivation.push(
            convert.outputs.bip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,
          );
          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.TAP_TREE,
          );
          output.tapTree = convert.outputs.tapTree.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
          if (output.tapBip32Derivation === undefined) {
            output.tapBip32Derivation = [];
          }
          output.tapBip32Derivation.push(
            convert.outputs.tapBip32Derivation.decode(keyVal),
          );
          break;
        default:
          if (!output.unknownKeyVals) output.unknownKeyVals = [];
          output.unknownKeyVals.push(keyVal);
      }
    }
    outputs.push(output);
  }
  return { globalMap, inputs, outputs };
}
exports.psbtFromKeyVals = psbtFromKeyVals;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../converter":57,"../converter/tools":76,"../converter/varint":77,"../typeFields":82,"buffer":167}],79:[function(require,module,exports){
'use strict';
function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, '__esModule', { value: true });
__export(require('./fromBuffer'));
__export(require('./toBuffer'));

},{"./fromBuffer":78,"./toBuffer":80}],80:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const convert = require('../converter');
const tools_1 = require('../converter/tools');
function psbtToBuffer({ globalMap, inputs, outputs }) {
  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
    globalMap,
    inputs,
    outputs,
  });
  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
  const keyValsOrEmptyToBuffer = keyVals =>
    keyVals.length === 0
      ? [Buffer.from([0])]
      : keyVals.map(tools_1.keyValsToBuffer);
  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
  const header = Buffer.allocUnsafe(5);
  header.writeUIntBE(0x70736274ff, 0, 5);
  return Buffer.concat(
    [header, globalBuffer].concat(inputBuffers, outputBuffers),
  );
}
exports.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (a, b) => {
  return a.key.compare(b.key);
};
function keyValsFromMap(keyValMap, converterFactory) {
  const keyHexSet = new Set();
  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
    if (key === 'unknownKeyVals') return result;
    // We are checking for undefined anyways. So ignore TS error
    // @ts-ignore
    const converter = converterFactory[key];
    if (converter === undefined) return result;
    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
      converter.encode,
    );
    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));
    keyHexes.forEach(hex => {
      if (keyHexSet.has(hex))
        throw new Error('Serialize Error: Duplicate key: ' + hex);
      keyHexSet.add(hex);
    });
    return result.concat(encodedKeyVals);
  }, []);
  // Get other keyVals that have not yet been gotten
  const otherKeyVals = keyValMap.unknownKeyVals
    ? keyValMap.unknownKeyVals.filter(keyVal => {
        return !keyHexSet.has(keyVal.key.toString('hex'));
      })
    : [];
  return keyVals.concat(otherKeyVals).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap, inputs, outputs }) {
  // First parse the global keyVals
  // Get any extra keyvals to pass along
  return {
    globalKeyVals: keyValsFromMap(globalMap, convert.globals),
    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),
    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),
  };
}
exports.psbtToKeyVals = psbtToKeyVals;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../converter":57,"../converter/tools":76,"buffer":167}],81:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const combiner_1 = require('./combiner');
const parser_1 = require('./parser');
const typeFields_1 = require('./typeFields');
const utils_1 = require('./utils');
class Psbt {
  constructor(tx) {
    this.inputs = [];
    this.outputs = [];
    this.globalMap = {
      unsignedTx: tx,
    };
  }
  static fromBase64(data, txFromBuffer) {
    const buffer = Buffer.from(data, 'base64');
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromHex(data, txFromBuffer) {
    const buffer = Buffer.from(data, 'hex');
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromBuffer(buffer, txFromBuffer) {
    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
    const psbt = new this(results.globalMap.unsignedTx);
    Object.assign(psbt, results);
    return psbt;
  }
  toBase64() {
    const buffer = this.toBuffer();
    return buffer.toString('base64');
  }
  toHex() {
    const buffer = this.toBuffer();
    return buffer.toString('hex');
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(updateData) {
    utils_1.updateGlobal(updateData, this.globalMap);
    return this;
  }
  updateInput(inputIndex, updateData) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.updateInput(updateData, input);
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const output = utils_1.checkForOutput(this.outputs, outputIndex);
    utils_1.updateOutput(updateData, output);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    utils_1.checkHasKey(
      keyVal,
      this.globalMap.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.GlobalTypes),
    );
    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
    this.globalMap.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.checkHasKey(
      keyVal,
      input.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.InputTypes),
    );
    if (!input.unknownKeyVals) input.unknownKeyVals = [];
    input.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    const output = utils_1.checkForOutput(this.outputs, outputIndex);
    utils_1.checkHasKey(
      keyVal,
      output.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.OutputTypes),
    );
    if (!output.unknownKeyVals) output.unknownKeyVals = [];
    output.unknownKeyVals.push(keyVal);
    return this;
  }
  addInput(inputData) {
    this.globalMap.unsignedTx.addInput(inputData);
    this.inputs.push({
      unknownKeyVals: [],
    });
    const addKeyVals = inputData.unknownKeyVals || [];
    const inputIndex = this.inputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error('unknownKeyVals must be an Array');
    }
    addKeyVals.forEach(keyVal =>
      this.addUnknownKeyValToInput(inputIndex, keyVal),
    );
    utils_1.addInputAttributes(this.inputs, inputData);
    return this;
  }
  addOutput(outputData) {
    this.globalMap.unsignedTx.addOutput(outputData);
    this.outputs.push({
      unknownKeyVals: [],
    });
    const addKeyVals = outputData.unknownKeyVals || [];
    const outputIndex = this.outputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error('unknownKeyVals must be an Array');
    }
    addKeyVals.forEach(keyVal =>
      this.addUnknownKeyValToOutput(outputIndex, keyVal),
    );
    utils_1.addOutputAttributes(this.outputs, outputData);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.inputCheckUncleanFinalized(inputIndex, input);
    for (const key of Object.keys(input)) {
      if (
        ![
          'witnessUtxo',
          'nonWitnessUtxo',
          'finalScriptSig',
          'finalScriptWitness',
          'unknownKeyVals',
        ].includes(key)
      ) {
        // @ts-ignore
        delete input[key];
      }
    }
    return this;
  }
  combine(...those) {
    // Combine this with those.
    // Return self for chaining.
    const result = combiner_1.combine([this].concat(those));
    Object.assign(this, result);
    return this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
}
exports.Psbt = Psbt;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./combiner":54,"./parser":79,"./typeFields":82,"./utils":83,"buffer":167}],82:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var GlobalTypes;
(function(GlobalTypes) {
  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';
  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';
})((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));
exports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];
var InputTypes;
(function(InputTypes) {
  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';
  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';
  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';
  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';
  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';
  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';
  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';
  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';
  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';
  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';
  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';
  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';
  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';
  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =
    'TAP_BIP32_DERIVATION';
  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';
  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';
})((InputTypes = exports.InputTypes || (exports.InputTypes = {})));
exports.INPUT_TYPE_NAMES = [
  'nonWitnessUtxo',
  'witnessUtxo',
  'partialSig',
  'sighashType',
  'redeemScript',
  'witnessScript',
  'bip32Derivation',
  'finalScriptSig',
  'finalScriptWitness',
  'porCommitment',
  'tapKeySig',
  'tapScriptSig',
  'tapLeafScript',
  'tapBip32Derivation',
  'tapInternalKey',
  'tapMerkleRoot',
];
var OutputTypes;
(function(OutputTypes) {
  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';
  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';
  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';
  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';
  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';
  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =
    'TAP_BIP32_DERIVATION';
})((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));
exports.OUTPUT_TYPE_NAMES = [
  'redeemScript',
  'witnessScript',
  'bip32Derivation',
  'tapInternalKey',
  'tapTree',
  'tapBip32Derivation',
];

},{}],83:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const converter = require('./converter');
function checkForInput(inputs, inputIndex) {
  const input = inputs[inputIndex];
  if (input === undefined) throw new Error(`No input #${inputIndex}`);
  return input;
}
exports.checkForInput = checkForInput;
function checkForOutput(outputs, outputIndex) {
  const output = outputs[outputIndex];
  if (output === undefined) throw new Error(`No output #${outputIndex}`);
  return output;
}
exports.checkForOutput = checkForOutput;
function checkHasKey(checkKeyVal, keyVals, enumLength) {
  if (checkKeyVal.key[0] < enumLength) {
    throw new Error(
      `Use the method for your specific key instead of addUnknownKeyVal*`,
    );
  }
  if (
    keyVals &&
    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0
  ) {
    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);
  }
}
exports.checkHasKey = checkHasKey;
function getEnumLength(myenum) {
  let count = 0;
  Object.keys(myenum).forEach(val => {
    if (Number(isNaN(Number(val)))) {
      count++;
    }
  });
  return count;
}
exports.getEnumLength = getEnumLength;
function inputCheckUncleanFinalized(inputIndex, input) {
  let result = false;
  if (input.nonWitnessUtxo || input.witnessUtxo) {
    const needScriptSig = !!input.redeemScript;
    const needWitnessScript = !!input.witnessScript;
    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
    result = scriptSigOK && witnessScriptOK && hasOneFinal;
  }
  if (result === false) {
    throw new Error(
      `Input #${inputIndex} has too much or too little data to clean`,
    );
  }
}
exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
function throwForUpdateMaker(typeName, name, expected, data) {
  throw new Error(
    `Data for ${typeName} key ${name} is incorrect: Expected ` +
      `${expected} and got ${JSON.stringify(data)}`,
  );
}
function updateMaker(typeName) {
  return (updateData, mainData) => {
    for (const name of Object.keys(updateData)) {
      // @ts-ignore
      const data = updateData[name];
      // @ts-ignore
      const { canAdd, canAddToArray, check, expected } =
        // @ts-ignore
        converter[typeName + 's'][name] || {};
      const isArray = !!canAddToArray;
      // If unknown data. ignore and do not add
      if (check) {
        if (isArray) {
          if (
            !Array.isArray(data) ||
            // @ts-ignore
            (mainData[name] && !Array.isArray(mainData[name]))
          ) {
            throw new Error(`Key type ${name} must be an array`);
          }
          if (!data.every(check)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          // @ts-ignore
          const arr = mainData[name] || [];
          const dupeCheckSet = new Set();
          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {
            throw new Error('Can not add duplicate data to array');
          }
          // @ts-ignore
          mainData[name] = arr.concat(data);
        } else {
          if (!check(data)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          if (!canAdd(mainData, data)) {
            throw new Error(`Can not add duplicate data to ${typeName}`);
          }
          // @ts-ignore
          mainData[name] = data;
        }
      }
    }
  };
}
exports.updateGlobal = updateMaker('global');
exports.updateInput = updateMaker('input');
exports.updateOutput = updateMaker('output');
function addInputAttributes(inputs, data) {
  const index = inputs.length - 1;
  const input = checkForInput(inputs, index);
  exports.updateInput(data, input);
}
exports.addInputAttributes = addInputAttributes;
function addOutputAttributes(outputs, data) {
  const index = outputs.length - 1;
  const output = checkForOutput(outputs, index);
  exports.updateOutput(data, output);
}
exports.addOutputAttributes = addOutputAttributes;
function defaultVersionSetter(version, txBuf) {
  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
    throw new Error('Set Version: Invalid Transaction');
  }
  txBuf.writeUInt32LE(version, 0);
  return txBuf;
}
exports.defaultVersionSetter = defaultVersionSetter;
function defaultLocktimeSetter(locktime, txBuf) {
  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
    throw new Error('Set Locktime: Invalid Transaction');
  }
  txBuf.writeUInt32LE(locktime, txBuf.length - 4);
  return txBuf;
}
exports.defaultLocktimeSetter = defaultLocktimeSetter;

}).call(this)}).call(this,{"isBuffer":require("../../../is-buffer/index.js")})
},{"../../../is-buffer/index.js":261,"./converter":57}],84:[function(require,module,exports){
/*
 * Bitcoin BIP32 path helpers
 * (C) 2016 Alex Beregszaszi
 */

const HARDENED = 0x80000000

var BIPPath = function (path) {
  if (!Array.isArray(path)) {
    throw new Error('Input must be an Array')
  }
  if (path.length === 0) {
    throw new Error('Path must contain at least one level')
  }
  for (var i = 0; i < path.length; i++) {
    if (typeof path[i] !== 'number') {
      throw new Error('Path element is not a number')
    }
  }
  this.path = path
}

BIPPath.validatePathArray = function (path) {
  try {
    BIPPath.fromPathArray(path)
    return true
  } catch (e) {
    return false
  }
}

BIPPath.validateString = function (text, reqRoot) {
  try {
    BIPPath.fromString(text, reqRoot)
    return true
  } catch (e) {
    return false
  }
}

BIPPath.fromPathArray = function (path) {
  return new BIPPath(path)
}

BIPPath.fromString = function (text, reqRoot) {
  // skip the root
  if (/^m\//i.test(text)) {
    text = text.slice(2)
  } else if (reqRoot) {
    throw new Error('Root element is required')
  }

  var path = text.split('/')
  var ret = new Array(path.length)
  for (var i = 0; i < path.length; i++) {
    var tmp = /(\d+)([hH\']?)/.exec(path[i])
    if (tmp === null) {
      throw new Error('Invalid input')
    }
    ret[i] = parseInt(tmp[1], 10)

    if (ret[i] >= HARDENED) {
      throw new Error('Invalid child index')
    }

    if (tmp[2] === 'h' || tmp[2] === 'H' || tmp[2] === '\'') {
      ret[i] += HARDENED
    } else if (tmp[2].length != 0) {
      throw new Error('Invalid modifier')
    }
  }
  return new BIPPath(ret)
}

BIPPath.prototype.toPathArray = function () {
  return this.path
}

BIPPath.prototype.toString = function (noRoot, oldStyle) {
  var ret = new Array(this.path.length)
  for (var i = 0; i < this.path.length; i++) {
    var tmp = this.path[i]
    if (tmp & HARDENED) {
      ret[i] = (tmp & ~HARDENED) + (oldStyle ? 'h' : '\'')
    } else {
      ret[i] = tmp
    }
  }
  return (noRoot ? '' : 'm/') + ret.join('/')
}

BIPPath.prototype.inspect = function () {
  return 'BIPPath <' + this.toString() + '>'
}

module.exports = BIPPath

},{}],85:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BIP32Factory = void 0;
const crypto = require("./crypto");
const testecc_1 = require("./testecc");
const base_1 = require("@scure/base");
const sha256_1 = require("@noble/hashes/sha256");
const typeforce = require('typeforce');
const wif = require('wif');
const _bs58check = (0, base_1.base58check)(sha256_1.sha256);
const bs58check = {
    encode: (data) => _bs58check.encode(Uint8Array.from(data)),
    decode: (str) => Buffer.from(_bs58check.decode(str)),
};
function BIP32Factory(ecc) {
    (0, testecc_1.testEcc)(ecc);
    const UINT256_TYPE = typeforce.BufferN(32);
    const NETWORK_TYPE = typeforce.compile({
        wif: typeforce.UInt8,
        bip32: {
            public: typeforce.UInt32,
            private: typeforce.UInt32,
        },
    });
    const BITCOIN = {
        messagePrefix: '\x18Bitcoin Signed Message:\n',
        bech32: 'bc',
        bip32: {
            public: 0x0488b21e,
            private: 0x0488ade4,
        },
        pubKeyHash: 0x00,
        scriptHash: 0x05,
        wif: 0x80,
    };
    const HIGHEST_BIT = 0x80000000;
    const UINT31_MAX = Math.pow(2, 31) - 1;
    function BIP32Path(value) {
        return (typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null);
    }
    function UInt31(value) {
        return typeforce.UInt32(value) && value <= UINT31_MAX;
    }
    function toXOnly(pubKey) {
        return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
    }
    class Bip32Signer {
        constructor(__D, __Q) {
            this.__D = __D;
            this.__Q = __Q;
            this.lowR = false;
        }
        get publicKey() {
            if (this.__Q === undefined)
                this.__Q = Buffer.from(ecc.pointFromScalar(this.__D, true));
            return this.__Q;
        }
        get privateKey() {
            return this.__D;
        }
        sign(hash, lowR) {
            if (!this.privateKey)
                throw new Error('Missing private key');
            if (lowR === undefined)
                lowR = this.lowR;
            if (lowR === false) {
                return Buffer.from(ecc.sign(hash, this.privateKey));
            }
            else {
                let sig = Buffer.from(ecc.sign(hash, this.privateKey));
                const extraData = Buffer.alloc(32, 0);
                let counter = 0;
                // if first try is lowR, skip the loop
                // for second try and on, add extra entropy counting up
                while (sig[0] > 0x7f) {
                    counter++;
                    extraData.writeUIntLE(counter, 0, 6);
                    sig = Buffer.from(ecc.sign(hash, this.privateKey, extraData));
                }
                return sig;
            }
        }
        signSchnorr(hash) {
            if (!this.privateKey)
                throw new Error('Missing private key');
            if (!ecc.signSchnorr)
                throw new Error('signSchnorr not supported by ecc library');
            return Buffer.from(ecc.signSchnorr(hash, this.privateKey));
        }
        verify(hash, signature) {
            return ecc.verify(hash, this.publicKey, signature);
        }
        verifySchnorr(hash, signature) {
            if (!ecc.verifySchnorr)
                throw new Error('verifySchnorr not supported by ecc library');
            return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
        }
    }
    class BIP32 extends Bip32Signer {
        constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {
            super(__D, __Q);
            this.chainCode = chainCode;
            this.network = network;
            this.__DEPTH = __DEPTH;
            this.__INDEX = __INDEX;
            this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
            typeforce(NETWORK_TYPE, network);
        }
        get depth() {
            return this.__DEPTH;
        }
        get index() {
            return this.__INDEX;
        }
        get parentFingerprint() {
            return this.__PARENT_FINGERPRINT;
        }
        get identifier() {
            return crypto.hash160(this.publicKey);
        }
        get fingerprint() {
            return this.identifier.slice(0, 4);
        }
        get compressed() {
            return true;
        }
        // Private === not neutered
        // Public === neutered
        isNeutered() {
            return this.__D === undefined;
        }
        neutered() {
            return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
        }
        toBase58() {
            const network = this.network;
            const version = !this.isNeutered()
                ? network.bip32.private
                : network.bip32.public;
            const buffer = Buffer.allocUnsafe(78);
            // 4 bytes: version bytes
            buffer.writeUInt32BE(version, 0);
            // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
            buffer.writeUInt8(this.depth, 4);
            // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
            buffer.writeUInt32BE(this.parentFingerprint, 5);
            // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
            // This is encoded in big endian. (0x00000000 if master key)
            buffer.writeUInt32BE(this.index, 9);
            // 32 bytes: the chain code
            this.chainCode.copy(buffer, 13);
            // 33 bytes: the public key or private key data
            if (!this.isNeutered()) {
                // 0x00 + k for private keys
                buffer.writeUInt8(0, 45);
                this.privateKey.copy(buffer, 46);
                // 33 bytes: the public key
            }
            else {
                // X9.62 encoding for public keys
                this.publicKey.copy(buffer, 45);
            }
            return bs58check.encode(buffer);
        }
        toWIF() {
            if (!this.privateKey)
                throw new TypeError('Missing private key');
            return wif.encode(this.network.wif, this.privateKey, true);
        }
        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
        derive(index) {
            typeforce(typeforce.UInt32, index);
            const isHardened = index >= HIGHEST_BIT;
            const data = Buffer.allocUnsafe(37);
            // Hardened child
            if (isHardened) {
                if (this.isNeutered())
                    throw new TypeError('Missing private key for hardened child key');
                // data = 0x00 || ser256(kpar) || ser32(index)
                data[0] = 0x00;
                this.privateKey.copy(data, 1);
                data.writeUInt32BE(index, 33);
                // Normal child
            }
            else {
                // data = serP(point(kpar)) || ser32(index)
                //      = serP(Kpar) || ser32(index)
                this.publicKey.copy(data, 0);
                data.writeUInt32BE(index, 33);
            }
            const I = crypto.hmacSHA512(this.chainCode, data);
            const IL = I.slice(0, 32);
            const IR = I.slice(32);
            // if parse256(IL) >= n, proceed with the next value for i
            if (!ecc.isPrivate(IL))
                return this.derive(index + 1);
            // Private parent key -> private child key
            let hd;
            if (!this.isNeutered()) {
                // ki = parse256(IL) + kpar (mod n)
                const ki = Buffer.from(ecc.privateAdd(this.privateKey, IL));
                // In case ki == 0, proceed with the next value for i
                if (ki == null)
                    return this.derive(index + 1);
                hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
                // Public parent key -> public child key
            }
            else {
                // Ki = point(parse256(IL)) + Kpar
                //    = G*IL + Kpar
                const Ki = Buffer.from(ecc.pointAddScalar(this.publicKey, IL, true));
                // In case Ki is the point at infinity, proceed with the next value for i
                if (Ki === null)
                    return this.derive(index + 1);
                hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
            }
            return hd;
        }
        deriveHardened(index) {
            typeforce(UInt31, index);
            // Only derives hardened private keys by default
            return this.derive(index + HIGHEST_BIT);
        }
        derivePath(path) {
            typeforce(BIP32Path, path);
            let splitPath = path.split('/');
            if (splitPath[0] === 'm') {
                if (this.parentFingerprint)
                    throw new TypeError('Expected master, got child');
                splitPath = splitPath.slice(1);
            }
            return splitPath.reduce((prevHd, indexStr) => {
                let index;
                if (indexStr.slice(-1) === `'`) {
                    index = parseInt(indexStr.slice(0, -1), 10);
                    return prevHd.deriveHardened(index);
                }
                else {
                    index = parseInt(indexStr, 10);
                    return prevHd.derive(index);
                }
            }, this);
        }
        tweak(t) {
            if (this.privateKey)
                return this.tweakFromPrivateKey(t);
            return this.tweakFromPublicKey(t);
        }
        tweakFromPublicKey(t) {
            const xOnlyPubKey = toXOnly(this.publicKey);
            if (!ecc.xOnlyPointAddTweak)
                throw new Error('xOnlyPointAddTweak not supported by ecc library');
            const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
            if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
                throw new Error('Cannot tweak public key!');
            const parityByte = Buffer.from([
                tweakedPublicKey.parity === 0 ? 0x02 : 0x03,
            ]);
            const tweakedPublicKeyCompresed = Buffer.concat([
                parityByte,
                tweakedPublicKey.xOnlyPubkey,
            ]);
            return new Bip32Signer(undefined, tweakedPublicKeyCompresed);
        }
        tweakFromPrivateKey(t) {
            const hasOddY = this.publicKey[0] === 3 ||
                (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);
            const privateKey = (() => {
                if (!hasOddY)
                    return this.privateKey;
                else if (!ecc.privateNegate)
                    throw new Error('privateNegate not supported by ecc library');
                else
                    return ecc.privateNegate(this.privateKey);
            })();
            const tweakedPrivateKey = ecc.privateAdd(privateKey, t);
            if (!tweakedPrivateKey)
                throw new Error('Invalid tweaked private key!');
            return new Bip32Signer(Buffer.from(tweakedPrivateKey), undefined);
        }
    }
    function fromBase58(inString, network) {
        const buffer = bs58check.decode(inString);
        if (buffer.length !== 78)
            throw new TypeError('Invalid buffer length');
        network = network || BITCOIN;
        // 4 bytes: version bytes
        const version = buffer.readUInt32BE(0);
        if (version !== network.bip32.private && version !== network.bip32.public)
            throw new TypeError('Invalid network version');
        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
        const depth = buffer[4];
        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
        const parentFingerprint = buffer.readUInt32BE(5);
        if (depth === 0) {
            if (parentFingerprint !== 0x00000000)
                throw new TypeError('Invalid parent fingerprint');
        }
        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
        // This is encoded in MSB order. (0x00000000 if master key)
        const index = buffer.readUInt32BE(9);
        if (depth === 0 && index !== 0)
            throw new TypeError('Invalid index');
        // 32 bytes: the chain code
        const chainCode = buffer.slice(13, 45);
        let hd;
        // 33 bytes: private key data (0x00 + k)
        if (version === network.bip32.private) {
            if (buffer.readUInt8(45) !== 0x00)
                throw new TypeError('Invalid private key');
            const k = buffer.slice(46, 78);
            hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
            // 33 bytes: public key data (0x02 + X or 0x03 + X)
        }
        else {
            const X = buffer.slice(45, 78);
            hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
        }
        return hd;
    }
    function fromPrivateKey(privateKey, chainCode, network) {
        return fromPrivateKeyLocal(privateKey, chainCode, network);
    }
    function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
        typeforce({
            privateKey: UINT256_TYPE,
            chainCode: UINT256_TYPE,
        }, { privateKey, chainCode });
        network = network || BITCOIN;
        if (!ecc.isPrivate(privateKey))
            throw new TypeError('Private key not in range [1, n)');
        return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
    }
    function fromPublicKey(publicKey, chainCode, network) {
        return fromPublicKeyLocal(publicKey, chainCode, network);
    }
    function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
        typeforce({
            publicKey: typeforce.BufferN(33),
            chainCode: UINT256_TYPE,
        }, { publicKey, chainCode });
        network = network || BITCOIN;
        // verify the X coordinate is a point on the curve
        if (!ecc.isPoint(publicKey))
            throw new TypeError('Point is not on the curve');
        return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
    }
    function fromSeed(seed, network) {
        typeforce(typeforce.Buffer, seed);
        if (seed.length < 16)
            throw new TypeError('Seed should be at least 128 bits');
        if (seed.length > 64)
            throw new TypeError('Seed should be at most 512 bits');
        network = network || BITCOIN;
        const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        return fromPrivateKey(IL, IR, network);
    }
    return {
        fromSeed,
        fromBase58,
        fromPublicKey,
        fromPrivateKey,
    };
}
exports.BIP32Factory = BIP32Factory;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./crypto":86,"./testecc":88,"@noble/hashes/sha256":31,"@scure/base":34,"buffer":167,"typeforce":359,"wif":365}],86:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hmacSHA512 = exports.hash160 = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const ripemd160_1 = require("@noble/hashes/ripemd160");
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
function hash160(buffer) {
    const sha256Hash = (0, sha256_1.sha256)(Uint8Array.from(buffer));
    return Buffer.from((0, ripemd160_1.ripemd160)(sha256Hash));
}
exports.hash160 = hash160;
function hmacSHA512(key, data) {
    return Buffer.from((0, hmac_1.hmac)(sha512_1.sha512, key, data));
}
exports.hmacSHA512 = hmacSHA512;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@noble/hashes/hmac":25,"@noble/hashes/ripemd160":28,"@noble/hashes/sha256":31,"@noble/hashes/sha512":32,"buffer":167}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BIP32Factory = exports.default = void 0;
var bip32_1 = require("./bip32");
Object.defineProperty(exports, "default", { enumerable: true, get: function () { return bip32_1.BIP32Factory; } });
Object.defineProperty(exports, "BIP32Factory", { enumerable: true, get: function () { return bip32_1.BIP32Factory; } });

},{"./bip32":85}],88:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testEcc = void 0;
const h = (hex) => Buffer.from(hex, 'hex');
function testEcc(ecc) {
    assert(ecc.isPoint(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
    assert(!ecc.isPoint(h('030000000000000000000000000000000000000000000000000000000000000005')));
    assert(ecc.isPrivate(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
    // order - 1
    assert(ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
    // 0
    assert(!ecc.isPrivate(h('0000000000000000000000000000000000000000000000000000000000000000')));
    // order
    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141')));
    // order + 1
    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142')));
    assert(Buffer.from(ecc.pointFromScalar(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))).equals(h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99')));
    if (ecc.xOnlyPointAddTweak) {
        assert(ecc.xOnlyPointAddTweak(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === null);
        let xOnlyRes = ecc.xOnlyPointAddTweak(h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'), h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'));
        assert(Buffer.from(xOnlyRes.xOnlyPubkey).equals(h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) && xOnlyRes.parity === 1);
        xOnlyRes = ecc.xOnlyPointAddTweak(h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'), h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'));
    }
    assert(Buffer.from(ecc.pointAddScalar(h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('0000000000000000000000000000000000000000000000000000000000000003'))).equals(h('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')));
    assert(Buffer.from(ecc.privateAdd(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'), h('0000000000000000000000000000000000000000000000000000000000000002'))).equals(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
    if (ecc.privateNegate) {
        assert(Buffer.from(ecc.privateNegate(h('0000000000000000000000000000000000000000000000000000000000000001'))).equals(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
        assert(Buffer.from(ecc.privateNegate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'))).equals(h('0000000000000000000000000000000000000000000000000000000000000003')));
        assert(Buffer.from(ecc.privateNegate(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))).equals(h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792')));
    }
    assert(Buffer.from(ecc.sign(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'))).equals(h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
    assert(ecc.verify(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
    if (ecc.signSchnorr) {
        assert(Buffer.from(ecc.signSchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'), h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906'))).equals(h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
    }
    if (ecc.verifySchnorr) {
        assert(ecc.verifySchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
    }
}
exports.testEcc = testEcc;
function assert(bool) {
    if (!bool)
        throw new Error('ecc library invalid');
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// browserify by default only pulls in files that are hard coded in requires
// In order of last to first in this file, the default wordlist will be chosen
// based on what is present. (Bundles may remove wordlists they don't need)
const wordlists = {};
exports.wordlists = wordlists;
let _default;
exports._default = _default;
try {
    exports._default = _default = require('./wordlists/czech.json');
    wordlists.czech = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/chinese_simplified.json');
    wordlists.chinese_simplified = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/chinese_traditional.json');
    wordlists.chinese_traditional = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/korean.json');
    wordlists.korean = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/french.json');
    wordlists.french = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/italian.json');
    wordlists.italian = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/spanish.json');
    wordlists.spanish = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/japanese.json');
    wordlists.japanese = _default;
    wordlists.JA = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/portuguese.json');
    wordlists.portuguese = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/english.json');
    wordlists.english = _default;
    wordlists.EN = _default;
}
catch (err) { }

},{"./wordlists/chinese_simplified.json":91,"./wordlists/chinese_traditional.json":92,"./wordlists/czech.json":93,"./wordlists/english.json":94,"./wordlists/french.json":95,"./wordlists/italian.json":96,"./wordlists/japanese.json":97,"./wordlists/korean.json":98,"./wordlists/portuguese.json":99,"./wordlists/spanish.json":100}],90:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
const pbkdf2_1 = require("@noble/hashes/pbkdf2");
const utils_1 = require("@noble/hashes/utils");
const _wordlists_1 = require("./_wordlists");
let DEFAULT_WORDLIST = _wordlists_1._default;
const INVALID_MNEMONIC = 'Invalid mnemonic';
const INVALID_ENTROPY = 'Invalid entropy';
const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
    'Please pass a 2048 word array explicitly.';
function normalize(str) {
    return (str || '').normalize('NFKD');
}
function lpad(str, padString, length) {
    while (str.length < length) {
        str = padString + str;
    }
    return str;
}
function binaryToByte(bin) {
    return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
}
function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
    return bytesToBinary(Array.from(hash)).slice(0, CS);
}
function salt(password) {
    return 'mnemonic' + (password || '');
}
function mnemonicToSeedSync(mnemonic, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64,
    });
    return Buffer.from(res);
}
exports.mnemonicToSeedSync = mnemonicToSeedSync;
function mnemonicToSeed(mnemonic, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64,
    }).then((res) => Buffer.from(res));
}
exports.mnemonicToSeed = mnemonicToSeed;
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    const words = normalize(mnemonic).split(' ');
    if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
    }
    // convert word indices to 11 bit binary strings
    const bits = words
        .map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
            throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), '0', 11);
    })
        .join('');
    // split the binary string into ENT/CS
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    // calculate the checksum and compare
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
    if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
    }
    const entropy = Buffer.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString('hex');
}
exports.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
    if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, 'hex');
    }
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    // 128 <= ENT <= 256
    if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
    });
    return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
        ? words.join('\u3000')
        : words.join(' ');
}
exports.entropyToMnemonic = entropyToMnemonic;
function generateMnemonic(strength, rng, wordlist) {
    strength = strength || 128;
    if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));
    return entropyToMnemonic(rng(strength / 8), wordlist);
}
exports.generateMnemonic = generateMnemonic;
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.validateMnemonic = validateMnemonic;
function setDefaultWordlist(language) {
    const result = _wordlists_1.wordlists[language];
    if (result) {
        DEFAULT_WORDLIST = result;
    }
    else {
        throw new Error('Could not find wordlist for language "' + language + '"');
    }
}
exports.setDefaultWordlist = setDefaultWordlist;
function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
        throw new Error('No Default Wordlist set');
    }
    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === 'JA' || lang === 'EN') {
            return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
    })[0];
}
exports.getDefaultWordlist = getDefaultWordlist;
var _wordlists_2 = require("./_wordlists");
exports.wordlists = _wordlists_2.wordlists;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./_wordlists":89,"@noble/hashes/pbkdf2":27,"@noble/hashes/sha256":31,"@noble/hashes/sha512":32,"@noble/hashes/utils":33,"buffer":167}],91:[function(require,module,exports){
module.exports=[
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "这",
    "中",
    "大",
    "为",
    "上",
    "个",
    "国",
    "我",
    "以",
    "要",
    "他",
    "时",
    "来",
    "用",
    "们",
    "生",
    "到",
    "作",
    "地",
    "于",
    "出",
    "就",
    "分",
    "对",
    "成",
    "会",
    "可",
    "主",
    "发",
    "年",
    "动",
    "同",
    "工",
    "也",
    "能",
    "下",
    "过",
    "子",
    "说",
    "产",
    "种",
    "面",
    "而",
    "方",
    "后",
    "多",
    "定",
    "行",
    "学",
    "法",
    "所",
    "民",
    "得",
    "经",
    "十",
    "三",
    "之",
    "进",
    "着",
    "等",
    "部",
    "度",
    "家",
    "电",
    "力",
    "里",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "现",
    "实",
    "加",
    "量",
    "都",
    "两",
    "体",
    "制",
    "机",
    "当",
    "使",
    "点",
    "从",
    "业",
    "本",
    "去",
    "把",
    "性",
    "好",
    "应",
    "开",
    "它",
    "合",
    "还",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "义",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "间",
    "样",
    "与",
    "关",
    "各",
    "重",
    "新",
    "线",
    "内",
    "数",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "么",
    "利",
    "比",
    "或",
    "但",
    "质",
    "气",
    "第",
    "向",
    "道",
    "命",
    "此",
    "变",
    "条",
    "只",
    "没",
    "结",
    "解",
    "问",
    "意",
    "建",
    "月",
    "公",
    "无",
    "系",
    "军",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "并",
    "提",
    "直",
    "题",
    "党",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "员",
    "革",
    "位",
    "入",
    "常",
    "文",
    "总",
    "次",
    "品",
    "式",
    "活",
    "设",
    "及",
    "管",
    "特",
    "件",
    "长",
    "求",
    "老",
    "头",
    "基",
    "资",
    "边",
    "流",
    "路",
    "级",
    "少",
    "图",
    "山",
    "统",
    "接",
    "知",
    "较",
    "将",
    "组",
    "见",
    "计",
    "别",
    "她",
    "手",
    "角",
    "期",
    "根",
    "论",
    "运",
    "农",
    "指",
    "几",
    "九",
    "区",
    "强",
    "放",
    "决",
    "西",
    "被",
    "干",
    "做",
    "必",
    "战",
    "先",
    "回",
    "则",
    "任",
    "取",
    "据",
    "处",
    "队",
    "南",
    "给",
    "色",
    "光",
    "门",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "规",
    "热",
    "领",
    "七",
    "海",
    "口",
    "东",
    "导",
    "器",
    "压",
    "志",
    "世",
    "金",
    "增",
    "争",
    "济",
    "阶",
    "油",
    "思",
    "术",
    "极",
    "交",
    "受",
    "联",
    "什",
    "认",
    "六",
    "共",
    "权",
    "收",
    "证",
    "改",
    "清",
    "美",
    "再",
    "采",
    "转",
    "更",
    "单",
    "风",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "带",
    "安",
    "场",
    "身",
    "车",
    "例",
    "真",
    "务",
    "具",
    "万",
    "每",
    "目",
    "至",
    "达",
    "走",
    "积",
    "示",
    "议",
    "声",
    "报",
    "斗",
    "完",
    "类",
    "八",
    "离",
    "华",
    "名",
    "确",
    "才",
    "科",
    "张",
    "信",
    "马",
    "节",
    "话",
    "米",
    "整",
    "空",
    "元",
    "况",
    "今",
    "集",
    "温",
    "传",
    "土",
    "许",
    "步",
    "群",
    "广",
    "石",
    "记",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "观",
    "越",
    "织",
    "装",
    "影",
    "算",
    "低",
    "持",
    "音",
    "众",
    "书",
    "布",
    "复",
    "容",
    "儿",
    "须",
    "际",
    "商",
    "非",
    "验",
    "连",
    "断",
    "深",
    "难",
    "近",
    "矿",
    "千",
    "周",
    "委",
    "素",
    "技",
    "备",
    "半",
    "办",
    "青",
    "省",
    "列",
    "习",
    "响",
    "约",
    "支",
    "般",
    "史",
    "感",
    "劳",
    "便",
    "团",
    "往",
    "酸",
    "历",
    "市",
    "克",
    "何",
    "除",
    "消",
    "构",
    "府",
    "称",
    "太",
    "准",
    "精",
    "值",
    "号",
    "率",
    "族",
    "维",
    "划",
    "选",
    "标",
    "写",
    "存",
    "候",
    "毛",
    "亲",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "养",
    "易",
    "置",
    "派",
    "层",
    "片",
    "始",
    "却",
    "专",
    "状",
    "育",
    "厂",
    "京",
    "识",
    "适",
    "属",
    "圆",
    "包",
    "火",
    "住",
    "调",
    "满",
    "县",
    "局",
    "照",
    "参",
    "红",
    "细",
    "引",
    "听",
    "该",
    "铁",
    "价",
    "严",
    "首",
    "底",
    "液",
    "官",
    "德",
    "随",
    "病",
    "苏",
    "失",
    "尔",
    "死",
    "讲",
    "配",
    "女",
    "黄",
    "推",
    "显",
    "谈",
    "罪",
    "神",
    "艺",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "营",
    "项",
    "防",
    "举",
    "球",
    "英",
    "氧",
    "势",
    "告",
    "李",
    "台",
    "落",
    "木",
    "帮",
    "轮",
    "破",
    "亚",
    "师",
    "围",
    "注",
    "远",
    "字",
    "材",
    "排",
    "供",
    "河",
    "态",
    "封",
    "另",
    "施",
    "减",
    "树",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "叶",
    "鱼",
    "波",
    "视",
    "仅",
    "费",
    "紧",
    "爱",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "续",
    "轻",
    "服",
    "试",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "护",
    "司",
    "足",
    "某",
    "练",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "负",
    "击",
    "范",
    "继",
    "兴",
    "似",
    "余",
    "坚",
    "曲",
    "输",
    "修",
    "故",
    "城",
    "夫",
    "够",
    "送",
    "笔",
    "船",
    "占",
    "右",
    "财",
    "吃",
    "富",
    "春",
    "职",
    "觉",
    "汉",
    "画",
    "功",
    "巴",
    "跟",
    "虽",
    "杂",
    "飞",
    "检",
    "吸",
    "助",
    "升",
    "阳",
    "互",
    "初",
    "创",
    "抗",
    "考",
    "投",
    "坏",
    "策",
    "古",
    "径",
    "换",
    "未",
    "跑",
    "留",
    "钢",
    "曾",
    "端",
    "责",
    "站",
    "简",
    "述",
    "钱",
    "副",
    "尽",
    "帝",
    "射",
    "草",
    "冲",
    "承",
    "独",
    "令",
    "限",
    "阿",
    "宣",
    "环",
    "双",
    "请",
    "超",
    "微",
    "让",
    "控",
    "州",
    "良",
    "轴",
    "找",
    "否",
    "纪",
    "益",
    "依",
    "优",
    "顶",
    "础",
    "载",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敌",
    "略",
    "客",
    "袁",
    "冷",
    "胜",
    "绝",
    "析",
    "块",
    "剂",
    "测",
    "丝",
    "协",
    "诉",
    "念",
    "陈",
    "仍",
    "罗",
    "盐",
    "友",
    "洋",
    "错",
    "苦",
    "夜",
    "刑",
    "移",
    "频",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "终",
    "聚",
    "汽",
    "村",
    "云",
    "哪",
    "既",
    "距",
    "卫",
    "停",
    "烈",
    "央",
    "察",
    "烧",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "游",
    "久",
    "菜",
    "味",
    "旧",
    "模",
    "湖",
    "货",
    "损",
    "预",
    "阻",
    "毫",
    "普",
    "稳",
    "乙",
    "妈",
    "植",
    "息",
    "扩",
    "银",
    "语",
    "挥",
    "酒",
    "守",
    "拿",
    "序",
    "纸",
    "医",
    "缺",
    "雨",
    "吗",
    "针",
    "刘",
    "啊",
    "急",
    "唱",
    "误",
    "训",
    "愿",
    "审",
    "附",
    "获",
    "茶",
    "鲜",
    "粮",
    "斤",
    "孩",
    "脱",
    "硫",
    "肥",
    "善",
    "龙",
    "演",
    "父",
    "渐",
    "血",
    "欢",
    "械",
    "掌",
    "歌",
    "沙",
    "刚",
    "攻",
    "谓",
    "盾",
    "讨",
    "晚",
    "粒",
    "乱",
    "燃",
    "矛",
    "乎",
    "杀",
    "药",
    "宁",
    "鲁",
    "贵",
    "钟",
    "煤",
    "读",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "丰",
    "培",
    "握",
    "兰",
    "担",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "执",
    "答",
    "乐",
    "谁",
    "顺",
    "烟",
    "缩",
    "征",
    "脸",
    "喜",
    "松",
    "脚",
    "困",
    "异",
    "免",
    "背",
    "星",
    "福",
    "买",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "静",
    "补",
    "评",
    "翻",
    "肉",
    "践",
    "尼",
    "衣",
    "宽",
    "扬",
    "棉",
    "希",
    "伤",
    "操",
    "垂",
    "秋",
    "宜",
    "氢",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "宪",
    "庆",
    "编",
    "牛",
    "触",
    "映",
    "雷",
    "销",
    "诗",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "绿",
    "晶",
    "厚",
    "盟",
    "衡",
    "鸡",
    "孙",
    "延",
    "危",
    "胶",
    "屋",
    "乡",
    "临",
    "陆",
    "顾",
    "掉",
    "呀",
    "灯",
    "岁",
    "措",
    "束",
    "耐",
    "剧",
    "玉",
    "赵",
    "跳",
    "哥",
    "季",
    "课",
    "凯",
    "胡",
    "额",
    "款",
    "绍",
    "卷",
    "齐",
    "伟",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "炉",
    "岩",
    "弱",
    "零",
    "杨",
    "奏",
    "沿",
    "露",
    "杆",
    "探",
    "滑",
    "镇",
    "饭",
    "浓",
    "航",
    "怀",
    "赶",
    "库",
    "夺",
    "伊",
    "灵",
    "税",
    "途",
    "灭",
    "赛",
    "归",
    "召",
    "鼓",
    "播",
    "盘",
    "裁",
    "险",
    "康",
    "唯",
    "录",
    "菌",
    "纯",
    "借",
    "糖",
    "盖",
    "横",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "枪",
    "润",
    "幅",
    "哈",
    "竟",
    "熟",
    "虫",
    "泽",
    "脑",
    "壤",
    "碳",
    "欧",
    "遍",
    "侧",
    "寨",
    "敢",
    "彻",
    "虑",
    "斜",
    "薄",
    "庭",
    "纳",
    "弹",
    "饲",
    "伸",
    "折",
    "麦",
    "湿",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "筑",
    "恶",
    "户",
    "访",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "迹",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "摆",
    "灰",
    "彩",
    "卖",
    "耗",
    "夏",
    "择",
    "忙",
    "铜",
    "献",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "阵",
    "阴",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "楼",
    "避",
    "谋",
    "吨",
    "野",
    "猪",
    "旗",
    "累",
    "偏",
    "典",
    "馆",
    "索",
    "秦",
    "脂",
    "潮",
    "爷",
    "豆",
    "忽",
    "托",
    "惊",
    "塑",
    "遗",
    "愈",
    "朱",
    "替",
    "纤",
    "粗",
    "倾",
    "尚",
    "痛",
    "楚",
    "谢",
    "奋",
    "购",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "监",
    "捕",
    "弟",
    "暴",
    "割",
    "贯",
    "殊",
    "释",
    "词",
    "亡",
    "壁",
    "顿",
    "宝",
    "午",
    "尘",
    "闻",
    "揭",
    "炮",
    "残",
    "冬",
    "桥",
    "妇",
    "警",
    "综",
    "招",
    "吴",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "摇",
    "谷",
    "赞",
    "箱",
    "隔",
    "订",
    "男",
    "吹",
    "园",
    "纷",
    "唐",
    "败",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "荣",
    "闭",
    "湾",
    "键",
    "凡",
    "驻",
    "锅",
    "救",
    "恩",
    "剥",
    "凝",
    "碱",
    "齿",
    "截",
    "炼",
    "麻",
    "纺",
    "禁",
    "废",
    "盛",
    "版",
    "缓",
    "净",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "庄",
    "街",
    "藏",
    "姑",
    "贸",
    "腐",
    "奴",
    "啦",
    "惯",
    "乘",
    "伙",
    "恢",
    "匀",
    "纱",
    "扎",
    "辩",
    "耳",
    "彪",
    "臣",
    "亿",
    "璃",
    "抵",
    "脉",
    "秀",
    "萨",
    "俄",
    "网",
    "舞",
    "店",
    "喷",
    "纵",
    "寸",
    "汗",
    "挂",
    "洪",
    "贺",
    "闪",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "墙",
    "软",
    "勇",
    "像",
    "滚",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "荡",
    "腿",
    "仪",
    "旅",
    "尾",
    "轧",
    "冰",
    "贡",
    "登",
    "黎",
    "削",
    "钻",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "币",
    "港",
    "伏",
    "轨",
    "亩",
    "毕",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "岛",
    "甘",
    "泡",
    "睡",
    "童",
    "铸",
    "汤",
    "阀",
    "休",
    "汇",
    "舍",
    "牧",
    "绕",
    "炸",
    "哲",
    "磷",
    "绩",
    "朋",
    "淡",
    "尖",
    "启",
    "陷",
    "柴",
    "呈",
    "徒",
    "颜",
    "泪",
    "稍",
    "忘",
    "泵",
    "蓝",
    "拖",
    "洞",
    "授",
    "镜",
    "辛",
    "壮",
    "锋",
    "贫",
    "虚",
    "弯",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "纲",
    "弄",
    "隶",
    "疑",
    "氏",
    "宫",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "违",
    "夹",
    "腰",
    "缘",
    "珠",
    "穷",
    "森",
    "枝",
    "竹",
    "沟",
    "催",
    "绳",
    "忆",
    "邦",
    "剩",
    "幸",
    "浆",
    "栏",
    "拥",
    "牙",
    "贮",
    "礼",
    "滤",
    "钠",
    "纹",
    "罢",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罚",
    "焦",
    "潜",
    "伍",
    "墨",
    "欲",
    "缝",
    "姓",
    "刊",
    "饱",
    "仿",
    "奖",
    "铝",
    "鬼",
    "丽",
    "跨",
    "默",
    "挖",
    "链",
    "扫",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "诸",
    "弧",
    "励",
    "梅",
    "奶",
    "洁",
    "灾",
    "舟",
    "鉴",
    "苯",
    "讼",
    "抱",
    "毁",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "届",
    "跃",
    "渡",
    "挑",
    "丹",
    "艰",
    "贝",
    "碰",
    "拔",
    "爹",
    "戴",
    "码",
    "梦",
    "芽",
    "熔",
    "赤",
    "渔",
    "哭",
    "敬",
    "颗",
    "奔",
    "铅",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "仓",
    "魏",
    "锐",
    "晓",
    "氮",
    "兼",
    "隐",
    "碍",
    "赫",
    "拨",
    "忠",
    "肃",
    "缸",
    "牵",
    "抢",
    "博",
    "巧",
    "壳",
    "兄",
    "杜",
    "讯",
    "诚",
    "碧",
    "祥",
    "柯",
    "页",
    "巡",
    "矩",
    "悲",
    "灌",
    "龄",
    "伦",
    "票",
    "寻",
    "桂",
    "铺",
    "圣",
    "恐",
    "恰",
    "郑",
    "趣",
    "抬",
    "荒",
    "腾",
    "贴",
    "柔",
    "滴",
    "猛",
    "阔",
    "辆",
    "妻",
    "填",
    "撤",
    "储",
    "签",
    "闹",
    "扰",
    "紫",
    "砂",
    "递",
    "戏",
    "吊",
    "陶",
    "伐",
    "喂",
    "疗",
    "瓶",
    "婆",
    "抚",
    "臂",
    "摸",
    "忍",
    "虾",
    "蜡",
    "邻",
    "胸",
    "巩",
    "挤",
    "偶",
    "弃",
    "槽",
    "劲",
    "乳",
    "邓",
    "吉",
    "仁",
    "烂",
    "砖",
    "租",
    "乌",
    "舰",
    "伴",
    "瓜",
    "浅",
    "丙",
    "暂",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "胆",
    "详",
    "簧",
    "踏",
    "瓷",
    "谱",
    "呆",
    "宾",
    "糊",
    "洛",
    "辉",
    "愤",
    "竞",
    "隙",
    "怒",
    "粘",
    "乃",
    "绪",
    "肩",
    "籍",
    "敏",
    "涂",
    "熙",
    "皆",
    "侦",
    "悬",
    "掘",
    "享",
    "纠",
    "醒",
    "狂",
    "锁",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "赏",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鸭",
    "趋",
    "凤",
    "晨",
    "畜",
    "辈",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "滩",
    "棋",
    "驱",
    "筛",
    "峡",
    "冒",
    "啥",
    "寿",
    "译",
    "浸",
    "泉",
    "帽",
    "迟",
    "硅",
    "疆",
    "贷",
    "漏",
    "稿",
    "冠",
    "嫩",
    "胁",
    "芯",
    "牢",
    "叛",
    "蚀",
    "奥",
    "鸣",
    "岭",
    "羊",
    "凭",
    "串",
    "塘",
    "绘",
    "酵",
    "融",
    "盆",
    "锡",
    "庙",
    "筹",
    "冻",
    "辅",
    "摄",
    "袭",
    "筋",
    "拒",
    "僚",
    "旱",
    "钾",
    "鸟",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韩",
    "逼",
    "扭",
    "侨",
    "凉",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "馏",
    "劝",
    "豪",
    "辽",
    "勃",
    "鸿",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "辊",
    "掩",
    "饮",
    "搬",
    "骂",
    "辞",
    "勾",
    "扣",
    "估",
    "蒋",
    "绒",
    "雾",
    "丈",
    "朵",
    "姆",
    "拟",
    "宇",
    "辑",
    "陕",
    "雕",
    "偿",
    "蓄",
    "崇",
    "剪",
    "倡",
    "厅",
    "咬",
    "驶",
    "薯",
    "刷",
    "斥",
    "番",
    "赋",
    "奉",
    "佛",
    "浇",
    "漫",
    "曼",
    "扇",
    "钙",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "亏",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "骗",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "胀",
    "谐",
    "抛",
    "霉",
    "桑",
    "岗",
    "嘛",
    "衰",
    "盗",
    "渗",
    "脏",
    "赖",
    "涌",
    "甜",
    "曹",
    "阅",
    "肌",
    "哩",
    "厉",
    "烃",
    "纬",
    "毅",
    "昨",
    "伪",
    "症",
    "煮",
    "叹",
    "钉",
    "搭",
    "茎",
    "笼",
    "酷",
    "偷",
    "弓",
    "锥",
    "恒",
    "杰",
    "坑",
    "鼻",
    "翼",
    "纶",
    "叙",
    "狱",
    "逮",
    "罐",
    "络",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "骤",
    "穆",
    "冶",
    "枯",
    "册",
    "尸",
    "凸",
    "绅",
    "坯",
    "牺",
    "焰",
    "轰",
    "欣",
    "晋",
    "瘦",
    "御",
    "锭",
    "锦",
    "丧",
    "旬",
    "锻",
    "垄",
    "搜",
    "扑",
    "邀",
    "亭",
    "酯",
    "迈",
    "舒",
    "脆",
    "酶",
    "闲",
    "忧",
    "酚",
    "顽",
    "羽",
    "涨",
    "卸",
    "仗",
    "陪",
    "辟",
    "惩",
    "杭",
    "姚",
    "肚",
    "捉",
    "飘",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "饰",
    "萧",
    "雅",
    "邮",
    "迁",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "烦",
    "债",
    "帐",
    "斑",
    "铃",
    "旨",
    "醇",
    "董",
    "饼",
    "雏",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "贤",
    "拆",
    "歪",
    "葡",
    "胺",
    "丢",
    "浩",
    "徽",
    "昂",
    "垫",
    "挡",
    "览",
    "贪",
    "慰",
    "缴",
    "汪",
    "慌",
    "冯",
    "诺",
    "姜",
    "谊",
    "凶",
    "劣",
    "诬",
    "耀",
    "昏",
    "躺",
    "盈",
    "骑",
    "乔",
    "溪",
    "丛",
    "卢",
    "抹",
    "闷",
    "咨",
    "刮",
    "驾",
    "缆",
    "悟",
    "摘",
    "铒",
    "掷",
    "颇",
    "幻",
    "柄",
    "惠",
    "惨",
    "佳",
    "仇",
    "腊",
    "窝",
    "涤",
    "剑",
    "瞧",
    "堡",
    "泼",
    "葱",
    "罩",
    "霍",
    "捞",
    "胎",
    "苍",
    "滨",
    "俩",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "疯",
    "淮",
    "遂",
    "熊",
    "粪",
    "烘",
    "宿",
    "档",
    "戈",
    "驳",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "肠",
    "撑",
    "晒",
    "辨",
    "殿",
    "莲",
    "摊",
    "搅",
    "酱",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皱",
    "畅",
    "叠",
    "阁",
    "莱",
    "敲",
    "辖",
    "钩",
    "痕",
    "坝",
    "巷",
    "饿",
    "祸",
    "丘",
    "玄",
    "溜",
    "曰",
    "逻",
    "彭",
    "尝",
    "卿",
    "妨",
    "艇",
    "吞",
    "韦",
    "怨",
    "矮",
    "歇"
]

},{}],92:[function(require,module,exports){
module.exports=[
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "這",
    "中",
    "大",
    "為",
    "上",
    "個",
    "國",
    "我",
    "以",
    "要",
    "他",
    "時",
    "來",
    "用",
    "們",
    "生",
    "到",
    "作",
    "地",
    "於",
    "出",
    "就",
    "分",
    "對",
    "成",
    "會",
    "可",
    "主",
    "發",
    "年",
    "動",
    "同",
    "工",
    "也",
    "能",
    "下",
    "過",
    "子",
    "說",
    "產",
    "種",
    "面",
    "而",
    "方",
    "後",
    "多",
    "定",
    "行",
    "學",
    "法",
    "所",
    "民",
    "得",
    "經",
    "十",
    "三",
    "之",
    "進",
    "著",
    "等",
    "部",
    "度",
    "家",
    "電",
    "力",
    "裡",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "現",
    "實",
    "加",
    "量",
    "都",
    "兩",
    "體",
    "制",
    "機",
    "當",
    "使",
    "點",
    "從",
    "業",
    "本",
    "去",
    "把",
    "性",
    "好",
    "應",
    "開",
    "它",
    "合",
    "還",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "義",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "間",
    "樣",
    "與",
    "關",
    "各",
    "重",
    "新",
    "線",
    "內",
    "數",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "麼",
    "利",
    "比",
    "或",
    "但",
    "質",
    "氣",
    "第",
    "向",
    "道",
    "命",
    "此",
    "變",
    "條",
    "只",
    "沒",
    "結",
    "解",
    "問",
    "意",
    "建",
    "月",
    "公",
    "無",
    "系",
    "軍",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "並",
    "提",
    "直",
    "題",
    "黨",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "員",
    "革",
    "位",
    "入",
    "常",
    "文",
    "總",
    "次",
    "品",
    "式",
    "活",
    "設",
    "及",
    "管",
    "特",
    "件",
    "長",
    "求",
    "老",
    "頭",
    "基",
    "資",
    "邊",
    "流",
    "路",
    "級",
    "少",
    "圖",
    "山",
    "統",
    "接",
    "知",
    "較",
    "將",
    "組",
    "見",
    "計",
    "別",
    "她",
    "手",
    "角",
    "期",
    "根",
    "論",
    "運",
    "農",
    "指",
    "幾",
    "九",
    "區",
    "強",
    "放",
    "決",
    "西",
    "被",
    "幹",
    "做",
    "必",
    "戰",
    "先",
    "回",
    "則",
    "任",
    "取",
    "據",
    "處",
    "隊",
    "南",
    "給",
    "色",
    "光",
    "門",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "規",
    "熱",
    "領",
    "七",
    "海",
    "口",
    "東",
    "導",
    "器",
    "壓",
    "志",
    "世",
    "金",
    "增",
    "爭",
    "濟",
    "階",
    "油",
    "思",
    "術",
    "極",
    "交",
    "受",
    "聯",
    "什",
    "認",
    "六",
    "共",
    "權",
    "收",
    "證",
    "改",
    "清",
    "美",
    "再",
    "採",
    "轉",
    "更",
    "單",
    "風",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "帶",
    "安",
    "場",
    "身",
    "車",
    "例",
    "真",
    "務",
    "具",
    "萬",
    "每",
    "目",
    "至",
    "達",
    "走",
    "積",
    "示",
    "議",
    "聲",
    "報",
    "鬥",
    "完",
    "類",
    "八",
    "離",
    "華",
    "名",
    "確",
    "才",
    "科",
    "張",
    "信",
    "馬",
    "節",
    "話",
    "米",
    "整",
    "空",
    "元",
    "況",
    "今",
    "集",
    "溫",
    "傳",
    "土",
    "許",
    "步",
    "群",
    "廣",
    "石",
    "記",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "觀",
    "越",
    "織",
    "裝",
    "影",
    "算",
    "低",
    "持",
    "音",
    "眾",
    "書",
    "布",
    "复",
    "容",
    "兒",
    "須",
    "際",
    "商",
    "非",
    "驗",
    "連",
    "斷",
    "深",
    "難",
    "近",
    "礦",
    "千",
    "週",
    "委",
    "素",
    "技",
    "備",
    "半",
    "辦",
    "青",
    "省",
    "列",
    "習",
    "響",
    "約",
    "支",
    "般",
    "史",
    "感",
    "勞",
    "便",
    "團",
    "往",
    "酸",
    "歷",
    "市",
    "克",
    "何",
    "除",
    "消",
    "構",
    "府",
    "稱",
    "太",
    "準",
    "精",
    "值",
    "號",
    "率",
    "族",
    "維",
    "劃",
    "選",
    "標",
    "寫",
    "存",
    "候",
    "毛",
    "親",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "養",
    "易",
    "置",
    "派",
    "層",
    "片",
    "始",
    "卻",
    "專",
    "狀",
    "育",
    "廠",
    "京",
    "識",
    "適",
    "屬",
    "圓",
    "包",
    "火",
    "住",
    "調",
    "滿",
    "縣",
    "局",
    "照",
    "參",
    "紅",
    "細",
    "引",
    "聽",
    "該",
    "鐵",
    "價",
    "嚴",
    "首",
    "底",
    "液",
    "官",
    "德",
    "隨",
    "病",
    "蘇",
    "失",
    "爾",
    "死",
    "講",
    "配",
    "女",
    "黃",
    "推",
    "顯",
    "談",
    "罪",
    "神",
    "藝",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "營",
    "項",
    "防",
    "舉",
    "球",
    "英",
    "氧",
    "勢",
    "告",
    "李",
    "台",
    "落",
    "木",
    "幫",
    "輪",
    "破",
    "亞",
    "師",
    "圍",
    "注",
    "遠",
    "字",
    "材",
    "排",
    "供",
    "河",
    "態",
    "封",
    "另",
    "施",
    "減",
    "樹",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "葉",
    "魚",
    "波",
    "視",
    "僅",
    "費",
    "緊",
    "愛",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "續",
    "輕",
    "服",
    "試",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "護",
    "司",
    "足",
    "某",
    "練",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "負",
    "擊",
    "范",
    "繼",
    "興",
    "似",
    "餘",
    "堅",
    "曲",
    "輸",
    "修",
    "故",
    "城",
    "夫",
    "夠",
    "送",
    "筆",
    "船",
    "佔",
    "右",
    "財",
    "吃",
    "富",
    "春",
    "職",
    "覺",
    "漢",
    "畫",
    "功",
    "巴",
    "跟",
    "雖",
    "雜",
    "飛",
    "檢",
    "吸",
    "助",
    "昇",
    "陽",
    "互",
    "初",
    "創",
    "抗",
    "考",
    "投",
    "壞",
    "策",
    "古",
    "徑",
    "換",
    "未",
    "跑",
    "留",
    "鋼",
    "曾",
    "端",
    "責",
    "站",
    "簡",
    "述",
    "錢",
    "副",
    "盡",
    "帝",
    "射",
    "草",
    "衝",
    "承",
    "獨",
    "令",
    "限",
    "阿",
    "宣",
    "環",
    "雙",
    "請",
    "超",
    "微",
    "讓",
    "控",
    "州",
    "良",
    "軸",
    "找",
    "否",
    "紀",
    "益",
    "依",
    "優",
    "頂",
    "礎",
    "載",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敵",
    "略",
    "客",
    "袁",
    "冷",
    "勝",
    "絕",
    "析",
    "塊",
    "劑",
    "測",
    "絲",
    "協",
    "訴",
    "念",
    "陳",
    "仍",
    "羅",
    "鹽",
    "友",
    "洋",
    "錯",
    "苦",
    "夜",
    "刑",
    "移",
    "頻",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "終",
    "聚",
    "汽",
    "村",
    "雲",
    "哪",
    "既",
    "距",
    "衛",
    "停",
    "烈",
    "央",
    "察",
    "燒",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "遊",
    "久",
    "菜",
    "味",
    "舊",
    "模",
    "湖",
    "貨",
    "損",
    "預",
    "阻",
    "毫",
    "普",
    "穩",
    "乙",
    "媽",
    "植",
    "息",
    "擴",
    "銀",
    "語",
    "揮",
    "酒",
    "守",
    "拿",
    "序",
    "紙",
    "醫",
    "缺",
    "雨",
    "嗎",
    "針",
    "劉",
    "啊",
    "急",
    "唱",
    "誤",
    "訓",
    "願",
    "審",
    "附",
    "獲",
    "茶",
    "鮮",
    "糧",
    "斤",
    "孩",
    "脫",
    "硫",
    "肥",
    "善",
    "龍",
    "演",
    "父",
    "漸",
    "血",
    "歡",
    "械",
    "掌",
    "歌",
    "沙",
    "剛",
    "攻",
    "謂",
    "盾",
    "討",
    "晚",
    "粒",
    "亂",
    "燃",
    "矛",
    "乎",
    "殺",
    "藥",
    "寧",
    "魯",
    "貴",
    "鐘",
    "煤",
    "讀",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "豐",
    "培",
    "握",
    "蘭",
    "擔",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "執",
    "答",
    "樂",
    "誰",
    "順",
    "煙",
    "縮",
    "徵",
    "臉",
    "喜",
    "松",
    "腳",
    "困",
    "異",
    "免",
    "背",
    "星",
    "福",
    "買",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "靜",
    "補",
    "評",
    "翻",
    "肉",
    "踐",
    "尼",
    "衣",
    "寬",
    "揚",
    "棉",
    "希",
    "傷",
    "操",
    "垂",
    "秋",
    "宜",
    "氫",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "憲",
    "慶",
    "編",
    "牛",
    "觸",
    "映",
    "雷",
    "銷",
    "詩",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "綠",
    "晶",
    "厚",
    "盟",
    "衡",
    "雞",
    "孫",
    "延",
    "危",
    "膠",
    "屋",
    "鄉",
    "臨",
    "陸",
    "顧",
    "掉",
    "呀",
    "燈",
    "歲",
    "措",
    "束",
    "耐",
    "劇",
    "玉",
    "趙",
    "跳",
    "哥",
    "季",
    "課",
    "凱",
    "胡",
    "額",
    "款",
    "紹",
    "卷",
    "齊",
    "偉",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "爐",
    "岩",
    "弱",
    "零",
    "楊",
    "奏",
    "沿",
    "露",
    "桿",
    "探",
    "滑",
    "鎮",
    "飯",
    "濃",
    "航",
    "懷",
    "趕",
    "庫",
    "奪",
    "伊",
    "靈",
    "稅",
    "途",
    "滅",
    "賽",
    "歸",
    "召",
    "鼓",
    "播",
    "盤",
    "裁",
    "險",
    "康",
    "唯",
    "錄",
    "菌",
    "純",
    "借",
    "糖",
    "蓋",
    "橫",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "槍",
    "潤",
    "幅",
    "哈",
    "竟",
    "熟",
    "蟲",
    "澤",
    "腦",
    "壤",
    "碳",
    "歐",
    "遍",
    "側",
    "寨",
    "敢",
    "徹",
    "慮",
    "斜",
    "薄",
    "庭",
    "納",
    "彈",
    "飼",
    "伸",
    "折",
    "麥",
    "濕",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "築",
    "惡",
    "戶",
    "訪",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "跡",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "擺",
    "灰",
    "彩",
    "賣",
    "耗",
    "夏",
    "擇",
    "忙",
    "銅",
    "獻",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "陣",
    "陰",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "樓",
    "避",
    "謀",
    "噸",
    "野",
    "豬",
    "旗",
    "累",
    "偏",
    "典",
    "館",
    "索",
    "秦",
    "脂",
    "潮",
    "爺",
    "豆",
    "忽",
    "托",
    "驚",
    "塑",
    "遺",
    "愈",
    "朱",
    "替",
    "纖",
    "粗",
    "傾",
    "尚",
    "痛",
    "楚",
    "謝",
    "奮",
    "購",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "監",
    "捕",
    "弟",
    "暴",
    "割",
    "貫",
    "殊",
    "釋",
    "詞",
    "亡",
    "壁",
    "頓",
    "寶",
    "午",
    "塵",
    "聞",
    "揭",
    "炮",
    "殘",
    "冬",
    "橋",
    "婦",
    "警",
    "綜",
    "招",
    "吳",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "搖",
    "谷",
    "贊",
    "箱",
    "隔",
    "訂",
    "男",
    "吹",
    "園",
    "紛",
    "唐",
    "敗",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "榮",
    "閉",
    "灣",
    "鍵",
    "凡",
    "駐",
    "鍋",
    "救",
    "恩",
    "剝",
    "凝",
    "鹼",
    "齒",
    "截",
    "煉",
    "麻",
    "紡",
    "禁",
    "廢",
    "盛",
    "版",
    "緩",
    "淨",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "莊",
    "街",
    "藏",
    "姑",
    "貿",
    "腐",
    "奴",
    "啦",
    "慣",
    "乘",
    "夥",
    "恢",
    "勻",
    "紗",
    "扎",
    "辯",
    "耳",
    "彪",
    "臣",
    "億",
    "璃",
    "抵",
    "脈",
    "秀",
    "薩",
    "俄",
    "網",
    "舞",
    "店",
    "噴",
    "縱",
    "寸",
    "汗",
    "掛",
    "洪",
    "賀",
    "閃",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "牆",
    "軟",
    "勇",
    "像",
    "滾",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "盪",
    "腿",
    "儀",
    "旅",
    "尾",
    "軋",
    "冰",
    "貢",
    "登",
    "黎",
    "削",
    "鑽",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "幣",
    "港",
    "伏",
    "軌",
    "畝",
    "畢",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "島",
    "甘",
    "泡",
    "睡",
    "童",
    "鑄",
    "湯",
    "閥",
    "休",
    "匯",
    "舍",
    "牧",
    "繞",
    "炸",
    "哲",
    "磷",
    "績",
    "朋",
    "淡",
    "尖",
    "啟",
    "陷",
    "柴",
    "呈",
    "徒",
    "顏",
    "淚",
    "稍",
    "忘",
    "泵",
    "藍",
    "拖",
    "洞",
    "授",
    "鏡",
    "辛",
    "壯",
    "鋒",
    "貧",
    "虛",
    "彎",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "綱",
    "弄",
    "隸",
    "疑",
    "氏",
    "宮",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "違",
    "夾",
    "腰",
    "緣",
    "珠",
    "窮",
    "森",
    "枝",
    "竹",
    "溝",
    "催",
    "繩",
    "憶",
    "邦",
    "剩",
    "幸",
    "漿",
    "欄",
    "擁",
    "牙",
    "貯",
    "禮",
    "濾",
    "鈉",
    "紋",
    "罷",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罰",
    "焦",
    "潛",
    "伍",
    "墨",
    "欲",
    "縫",
    "姓",
    "刊",
    "飽",
    "仿",
    "獎",
    "鋁",
    "鬼",
    "麗",
    "跨",
    "默",
    "挖",
    "鏈",
    "掃",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "諸",
    "弧",
    "勵",
    "梅",
    "奶",
    "潔",
    "災",
    "舟",
    "鑑",
    "苯",
    "訟",
    "抱",
    "毀",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "屆",
    "躍",
    "渡",
    "挑",
    "丹",
    "艱",
    "貝",
    "碰",
    "拔",
    "爹",
    "戴",
    "碼",
    "夢",
    "芽",
    "熔",
    "赤",
    "漁",
    "哭",
    "敬",
    "顆",
    "奔",
    "鉛",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "倉",
    "魏",
    "銳",
    "曉",
    "氮",
    "兼",
    "隱",
    "礙",
    "赫",
    "撥",
    "忠",
    "肅",
    "缸",
    "牽",
    "搶",
    "博",
    "巧",
    "殼",
    "兄",
    "杜",
    "訊",
    "誠",
    "碧",
    "祥",
    "柯",
    "頁",
    "巡",
    "矩",
    "悲",
    "灌",
    "齡",
    "倫",
    "票",
    "尋",
    "桂",
    "鋪",
    "聖",
    "恐",
    "恰",
    "鄭",
    "趣",
    "抬",
    "荒",
    "騰",
    "貼",
    "柔",
    "滴",
    "猛",
    "闊",
    "輛",
    "妻",
    "填",
    "撤",
    "儲",
    "簽",
    "鬧",
    "擾",
    "紫",
    "砂",
    "遞",
    "戲",
    "吊",
    "陶",
    "伐",
    "餵",
    "療",
    "瓶",
    "婆",
    "撫",
    "臂",
    "摸",
    "忍",
    "蝦",
    "蠟",
    "鄰",
    "胸",
    "鞏",
    "擠",
    "偶",
    "棄",
    "槽",
    "勁",
    "乳",
    "鄧",
    "吉",
    "仁",
    "爛",
    "磚",
    "租",
    "烏",
    "艦",
    "伴",
    "瓜",
    "淺",
    "丙",
    "暫",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "膽",
    "詳",
    "簧",
    "踏",
    "瓷",
    "譜",
    "呆",
    "賓",
    "糊",
    "洛",
    "輝",
    "憤",
    "競",
    "隙",
    "怒",
    "粘",
    "乃",
    "緒",
    "肩",
    "籍",
    "敏",
    "塗",
    "熙",
    "皆",
    "偵",
    "懸",
    "掘",
    "享",
    "糾",
    "醒",
    "狂",
    "鎖",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "賞",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鴨",
    "趨",
    "鳳",
    "晨",
    "畜",
    "輩",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "灘",
    "棋",
    "驅",
    "篩",
    "峽",
    "冒",
    "啥",
    "壽",
    "譯",
    "浸",
    "泉",
    "帽",
    "遲",
    "矽",
    "疆",
    "貸",
    "漏",
    "稿",
    "冠",
    "嫩",
    "脅",
    "芯",
    "牢",
    "叛",
    "蝕",
    "奧",
    "鳴",
    "嶺",
    "羊",
    "憑",
    "串",
    "塘",
    "繪",
    "酵",
    "融",
    "盆",
    "錫",
    "廟",
    "籌",
    "凍",
    "輔",
    "攝",
    "襲",
    "筋",
    "拒",
    "僚",
    "旱",
    "鉀",
    "鳥",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韓",
    "逼",
    "扭",
    "僑",
    "涼",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "餾",
    "勸",
    "豪",
    "遼",
    "勃",
    "鴻",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "輥",
    "掩",
    "飲",
    "搬",
    "罵",
    "辭",
    "勾",
    "扣",
    "估",
    "蔣",
    "絨",
    "霧",
    "丈",
    "朵",
    "姆",
    "擬",
    "宇",
    "輯",
    "陝",
    "雕",
    "償",
    "蓄",
    "崇",
    "剪",
    "倡",
    "廳",
    "咬",
    "駛",
    "薯",
    "刷",
    "斥",
    "番",
    "賦",
    "奉",
    "佛",
    "澆",
    "漫",
    "曼",
    "扇",
    "鈣",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "虧",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "騙",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "脹",
    "諧",
    "拋",
    "黴",
    "桑",
    "崗",
    "嘛",
    "衰",
    "盜",
    "滲",
    "臟",
    "賴",
    "湧",
    "甜",
    "曹",
    "閱",
    "肌",
    "哩",
    "厲",
    "烴",
    "緯",
    "毅",
    "昨",
    "偽",
    "症",
    "煮",
    "嘆",
    "釘",
    "搭",
    "莖",
    "籠",
    "酷",
    "偷",
    "弓",
    "錐",
    "恆",
    "傑",
    "坑",
    "鼻",
    "翼",
    "綸",
    "敘",
    "獄",
    "逮",
    "罐",
    "絡",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "驟",
    "穆",
    "冶",
    "枯",
    "冊",
    "屍",
    "凸",
    "紳",
    "坯",
    "犧",
    "焰",
    "轟",
    "欣",
    "晉",
    "瘦",
    "禦",
    "錠",
    "錦",
    "喪",
    "旬",
    "鍛",
    "壟",
    "搜",
    "撲",
    "邀",
    "亭",
    "酯",
    "邁",
    "舒",
    "脆",
    "酶",
    "閒",
    "憂",
    "酚",
    "頑",
    "羽",
    "漲",
    "卸",
    "仗",
    "陪",
    "闢",
    "懲",
    "杭",
    "姚",
    "肚",
    "捉",
    "飄",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "飾",
    "蕭",
    "雅",
    "郵",
    "遷",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "煩",
    "債",
    "帳",
    "斑",
    "鈴",
    "旨",
    "醇",
    "董",
    "餅",
    "雛",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "賢",
    "拆",
    "歪",
    "葡",
    "胺",
    "丟",
    "浩",
    "徽",
    "昂",
    "墊",
    "擋",
    "覽",
    "貪",
    "慰",
    "繳",
    "汪",
    "慌",
    "馮",
    "諾",
    "姜",
    "誼",
    "兇",
    "劣",
    "誣",
    "耀",
    "昏",
    "躺",
    "盈",
    "騎",
    "喬",
    "溪",
    "叢",
    "盧",
    "抹",
    "悶",
    "諮",
    "刮",
    "駕",
    "纜",
    "悟",
    "摘",
    "鉺",
    "擲",
    "頗",
    "幻",
    "柄",
    "惠",
    "慘",
    "佳",
    "仇",
    "臘",
    "窩",
    "滌",
    "劍",
    "瞧",
    "堡",
    "潑",
    "蔥",
    "罩",
    "霍",
    "撈",
    "胎",
    "蒼",
    "濱",
    "倆",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "瘋",
    "淮",
    "遂",
    "熊",
    "糞",
    "烘",
    "宿",
    "檔",
    "戈",
    "駁",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "腸",
    "撐",
    "曬",
    "辨",
    "殿",
    "蓮",
    "攤",
    "攪",
    "醬",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皺",
    "暢",
    "疊",
    "閣",
    "萊",
    "敲",
    "轄",
    "鉤",
    "痕",
    "壩",
    "巷",
    "餓",
    "禍",
    "丘",
    "玄",
    "溜",
    "曰",
    "邏",
    "彭",
    "嘗",
    "卿",
    "妨",
    "艇",
    "吞",
    "韋",
    "怨",
    "矮",
    "歇"
]

},{}],93:[function(require,module,exports){
module.exports=[
    "abdikace",
    "abeceda",
    "adresa",
    "agrese",
    "akce",
    "aktovka",
    "alej",
    "alkohol",
    "amputace",
    "ananas",
    "andulka",
    "anekdota",
    "anketa",
    "antika",
    "anulovat",
    "archa",
    "arogance",
    "asfalt",
    "asistent",
    "aspirace",
    "astma",
    "astronom",
    "atlas",
    "atletika",
    "atol",
    "autobus",
    "azyl",
    "babka",
    "bachor",
    "bacil",
    "baculka",
    "badatel",
    "bageta",
    "bagr",
    "bahno",
    "bakterie",
    "balada",
    "baletka",
    "balkon",
    "balonek",
    "balvan",
    "balza",
    "bambus",
    "bankomat",
    "barbar",
    "baret",
    "barman",
    "baroko",
    "barva",
    "baterka",
    "batoh",
    "bavlna",
    "bazalka",
    "bazilika",
    "bazuka",
    "bedna",
    "beran",
    "beseda",
    "bestie",
    "beton",
    "bezinka",
    "bezmoc",
    "beztak",
    "bicykl",
    "bidlo",
    "biftek",
    "bikiny",
    "bilance",
    "biograf",
    "biolog",
    "bitva",
    "bizon",
    "blahobyt",
    "blatouch",
    "blecha",
    "bledule",
    "blesk",
    "blikat",
    "blizna",
    "blokovat",
    "bloudit",
    "blud",
    "bobek",
    "bobr",
    "bodlina",
    "bodnout",
    "bohatost",
    "bojkot",
    "bojovat",
    "bokorys",
    "bolest",
    "borec",
    "borovice",
    "bota",
    "boubel",
    "bouchat",
    "bouda",
    "boule",
    "bourat",
    "boxer",
    "bradavka",
    "brambora",
    "branka",
    "bratr",
    "brepta",
    "briketa",
    "brko",
    "brloh",
    "bronz",
    "broskev",
    "brunetka",
    "brusinka",
    "brzda",
    "brzy",
    "bublina",
    "bubnovat",
    "buchta",
    "buditel",
    "budka",
    "budova",
    "bufet",
    "bujarost",
    "bukvice",
    "buldok",
    "bulva",
    "bunda",
    "bunkr",
    "burza",
    "butik",
    "buvol",
    "buzola",
    "bydlet",
    "bylina",
    "bytovka",
    "bzukot",
    "capart",
    "carevna",
    "cedr",
    "cedule",
    "cejch",
    "cejn",
    "cela",
    "celer",
    "celkem",
    "celnice",
    "cenina",
    "cennost",
    "cenovka",
    "centrum",
    "cenzor",
    "cestopis",
    "cetka",
    "chalupa",
    "chapadlo",
    "charita",
    "chata",
    "chechtat",
    "chemie",
    "chichot",
    "chirurg",
    "chlad",
    "chleba",
    "chlubit",
    "chmel",
    "chmura",
    "chobot",
    "chochol",
    "chodba",
    "cholera",
    "chomout",
    "chopit",
    "choroba",
    "chov",
    "chrapot",
    "chrlit",
    "chrt",
    "chrup",
    "chtivost",
    "chudina",
    "chutnat",
    "chvat",
    "chvilka",
    "chvost",
    "chyba",
    "chystat",
    "chytit",
    "cibule",
    "cigareta",
    "cihelna",
    "cihla",
    "cinkot",
    "cirkus",
    "cisterna",
    "citace",
    "citrus",
    "cizinec",
    "cizost",
    "clona",
    "cokoliv",
    "couvat",
    "ctitel",
    "ctnost",
    "cudnost",
    "cuketa",
    "cukr",
    "cupot",
    "cvaknout",
    "cval",
    "cvik",
    "cvrkot",
    "cyklista",
    "daleko",
    "dareba",
    "datel",
    "datum",
    "dcera",
    "debata",
    "dechovka",
    "decibel",
    "deficit",
    "deflace",
    "dekl",
    "dekret",
    "demokrat",
    "deprese",
    "derby",
    "deska",
    "detektiv",
    "dikobraz",
    "diktovat",
    "dioda",
    "diplom",
    "disk",
    "displej",
    "divadlo",
    "divoch",
    "dlaha",
    "dlouho",
    "dluhopis",
    "dnes",
    "dobro",
    "dobytek",
    "docent",
    "dochutit",
    "dodnes",
    "dohled",
    "dohoda",
    "dohra",
    "dojem",
    "dojnice",
    "doklad",
    "dokola",
    "doktor",
    "dokument",
    "dolar",
    "doleva",
    "dolina",
    "doma",
    "dominant",
    "domluvit",
    "domov",
    "donutit",
    "dopad",
    "dopis",
    "doplnit",
    "doposud",
    "doprovod",
    "dopustit",
    "dorazit",
    "dorost",
    "dort",
    "dosah",
    "doslov",
    "dostatek",
    "dosud",
    "dosyta",
    "dotaz",
    "dotek",
    "dotknout",
    "doufat",
    "doutnat",
    "dovozce",
    "dozadu",
    "doznat",
    "dozorce",
    "drahota",
    "drak",
    "dramatik",
    "dravec",
    "draze",
    "drdol",
    "drobnost",
    "drogerie",
    "drozd",
    "drsnost",
    "drtit",
    "drzost",
    "duben",
    "duchovno",
    "dudek",
    "duha",
    "duhovka",
    "dusit",
    "dusno",
    "dutost",
    "dvojice",
    "dvorec",
    "dynamit",
    "ekolog",
    "ekonomie",
    "elektron",
    "elipsa",
    "email",
    "emise",
    "emoce",
    "empatie",
    "epizoda",
    "epocha",
    "epopej",
    "epos",
    "esej",
    "esence",
    "eskorta",
    "eskymo",
    "etiketa",
    "euforie",
    "evoluce",
    "exekuce",
    "exkurze",
    "expedice",
    "exploze",
    "export",
    "extrakt",
    "facka",
    "fajfka",
    "fakulta",
    "fanatik",
    "fantazie",
    "farmacie",
    "favorit",
    "fazole",
    "federace",
    "fejeton",
    "fenka",
    "fialka",
    "figurant",
    "filozof",
    "filtr",
    "finance",
    "finta",
    "fixace",
    "fjord",
    "flanel",
    "flirt",
    "flotila",
    "fond",
    "fosfor",
    "fotbal",
    "fotka",
    "foton",
    "frakce",
    "freska",
    "fronta",
    "fukar",
    "funkce",
    "fyzika",
    "galeje",
    "garant",
    "genetika",
    "geolog",
    "gilotina",
    "glazura",
    "glejt",
    "golem",
    "golfista",
    "gotika",
    "graf",
    "gramofon",
    "granule",
    "grep",
    "gril",
    "grog",
    "groteska",
    "guma",
    "hadice",
    "hadr",
    "hala",
    "halenka",
    "hanba",
    "hanopis",
    "harfa",
    "harpuna",
    "havran",
    "hebkost",
    "hejkal",
    "hejno",
    "hejtman",
    "hektar",
    "helma",
    "hematom",
    "herec",
    "herna",
    "heslo",
    "hezky",
    "historik",
    "hladovka",
    "hlasivky",
    "hlava",
    "hledat",
    "hlen",
    "hlodavec",
    "hloh",
    "hloupost",
    "hltat",
    "hlubina",
    "hluchota",
    "hmat",
    "hmota",
    "hmyz",
    "hnis",
    "hnojivo",
    "hnout",
    "hoblina",
    "hoboj",
    "hoch",
    "hodiny",
    "hodlat",
    "hodnota",
    "hodovat",
    "hojnost",
    "hokej",
    "holinka",
    "holka",
    "holub",
    "homole",
    "honitba",
    "honorace",
    "horal",
    "horda",
    "horizont",
    "horko",
    "horlivec",
    "hormon",
    "hornina",
    "horoskop",
    "horstvo",
    "hospoda",
    "hostina",
    "hotovost",
    "houba",
    "houf",
    "houpat",
    "houska",
    "hovor",
    "hradba",
    "hranice",
    "hravost",
    "hrazda",
    "hrbolek",
    "hrdina",
    "hrdlo",
    "hrdost",
    "hrnek",
    "hrobka",
    "hromada",
    "hrot",
    "hrouda",
    "hrozen",
    "hrstka",
    "hrubost",
    "hryzat",
    "hubenost",
    "hubnout",
    "hudba",
    "hukot",
    "humr",
    "husita",
    "hustota",
    "hvozd",
    "hybnost",
    "hydrant",
    "hygiena",
    "hymna",
    "hysterik",
    "idylka",
    "ihned",
    "ikona",
    "iluze",
    "imunita",
    "infekce",
    "inflace",
    "inkaso",
    "inovace",
    "inspekce",
    "internet",
    "invalida",
    "investor",
    "inzerce",
    "ironie",
    "jablko",
    "jachta",
    "jahoda",
    "jakmile",
    "jakost",
    "jalovec",
    "jantar",
    "jarmark",
    "jaro",
    "jasan",
    "jasno",
    "jatka",
    "javor",
    "jazyk",
    "jedinec",
    "jedle",
    "jednatel",
    "jehlan",
    "jekot",
    "jelen",
    "jelito",
    "jemnost",
    "jenom",
    "jepice",
    "jeseter",
    "jevit",
    "jezdec",
    "jezero",
    "jinak",
    "jindy",
    "jinoch",
    "jiskra",
    "jistota",
    "jitrnice",
    "jizva",
    "jmenovat",
    "jogurt",
    "jurta",
    "kabaret",
    "kabel",
    "kabinet",
    "kachna",
    "kadet",
    "kadidlo",
    "kahan",
    "kajak",
    "kajuta",
    "kakao",
    "kaktus",
    "kalamita",
    "kalhoty",
    "kalibr",
    "kalnost",
    "kamera",
    "kamkoliv",
    "kamna",
    "kanibal",
    "kanoe",
    "kantor",
    "kapalina",
    "kapela",
    "kapitola",
    "kapka",
    "kaple",
    "kapota",
    "kapr",
    "kapusta",
    "kapybara",
    "karamel",
    "karotka",
    "karton",
    "kasa",
    "katalog",
    "katedra",
    "kauce",
    "kauza",
    "kavalec",
    "kazajka",
    "kazeta",
    "kazivost",
    "kdekoliv",
    "kdesi",
    "kedluben",
    "kemp",
    "keramika",
    "kino",
    "klacek",
    "kladivo",
    "klam",
    "klapot",
    "klasika",
    "klaun",
    "klec",
    "klenba",
    "klepat",
    "klesnout",
    "klid",
    "klima",
    "klisna",
    "klobouk",
    "klokan",
    "klopa",
    "kloub",
    "klubovna",
    "klusat",
    "kluzkost",
    "kmen",
    "kmitat",
    "kmotr",
    "kniha",
    "knot",
    "koalice",
    "koberec",
    "kobka",
    "kobliha",
    "kobyla",
    "kocour",
    "kohout",
    "kojenec",
    "kokos",
    "koktejl",
    "kolaps",
    "koleda",
    "kolize",
    "kolo",
    "komando",
    "kometa",
    "komik",
    "komnata",
    "komora",
    "kompas",
    "komunita",
    "konat",
    "koncept",
    "kondice",
    "konec",
    "konfese",
    "kongres",
    "konina",
    "konkurs",
    "kontakt",
    "konzerva",
    "kopanec",
    "kopie",
    "kopnout",
    "koprovka",
    "korbel",
    "korektor",
    "kormidlo",
    "koroptev",
    "korpus",
    "koruna",
    "koryto",
    "korzet",
    "kosatec",
    "kostka",
    "kotel",
    "kotleta",
    "kotoul",
    "koukat",
    "koupelna",
    "kousek",
    "kouzlo",
    "kovboj",
    "koza",
    "kozoroh",
    "krabice",
    "krach",
    "krajina",
    "kralovat",
    "krasopis",
    "kravata",
    "kredit",
    "krejcar",
    "kresba",
    "kreveta",
    "kriket",
    "kritik",
    "krize",
    "krkavec",
    "krmelec",
    "krmivo",
    "krocan",
    "krok",
    "kronika",
    "kropit",
    "kroupa",
    "krovka",
    "krtek",
    "kruhadlo",
    "krupice",
    "krutost",
    "krvinka",
    "krychle",
    "krypta",
    "krystal",
    "kryt",
    "kudlanka",
    "kufr",
    "kujnost",
    "kukla",
    "kulajda",
    "kulich",
    "kulka",
    "kulomet",
    "kultura",
    "kuna",
    "kupodivu",
    "kurt",
    "kurzor",
    "kutil",
    "kvalita",
    "kvasinka",
    "kvestor",
    "kynolog",
    "kyselina",
    "kytara",
    "kytice",
    "kytka",
    "kytovec",
    "kyvadlo",
    "labrador",
    "lachtan",
    "ladnost",
    "laik",
    "lakomec",
    "lamela",
    "lampa",
    "lanovka",
    "lasice",
    "laso",
    "lastura",
    "latinka",
    "lavina",
    "lebka",
    "leckdy",
    "leden",
    "lednice",
    "ledovka",
    "ledvina",
    "legenda",
    "legie",
    "legrace",
    "lehce",
    "lehkost",
    "lehnout",
    "lektvar",
    "lenochod",
    "lentilka",
    "lepenka",
    "lepidlo",
    "letadlo",
    "letec",
    "letmo",
    "letokruh",
    "levhart",
    "levitace",
    "levobok",
    "libra",
    "lichotka",
    "lidojed",
    "lidskost",
    "lihovina",
    "lijavec",
    "lilek",
    "limetka",
    "linie",
    "linka",
    "linoleum",
    "listopad",
    "litina",
    "litovat",
    "lobista",
    "lodivod",
    "logika",
    "logoped",
    "lokalita",
    "loket",
    "lomcovat",
    "lopata",
    "lopuch",
    "lord",
    "losos",
    "lotr",
    "loudal",
    "louh",
    "louka",
    "louskat",
    "lovec",
    "lstivost",
    "lucerna",
    "lucifer",
    "lump",
    "lusk",
    "lustrace",
    "lvice",
    "lyra",
    "lyrika",
    "lysina",
    "madam",
    "madlo",
    "magistr",
    "mahagon",
    "majetek",
    "majitel",
    "majorita",
    "makak",
    "makovice",
    "makrela",
    "malba",
    "malina",
    "malovat",
    "malvice",
    "maminka",
    "mandle",
    "manko",
    "marnost",
    "masakr",
    "maskot",
    "masopust",
    "matice",
    "matrika",
    "maturita",
    "mazanec",
    "mazivo",
    "mazlit",
    "mazurka",
    "mdloba",
    "mechanik",
    "meditace",
    "medovina",
    "melasa",
    "meloun",
    "mentolka",
    "metla",
    "metoda",
    "metr",
    "mezera",
    "migrace",
    "mihnout",
    "mihule",
    "mikina",
    "mikrofon",
    "milenec",
    "milimetr",
    "milost",
    "mimika",
    "mincovna",
    "minibar",
    "minomet",
    "minulost",
    "miska",
    "mistr",
    "mixovat",
    "mladost",
    "mlha",
    "mlhovina",
    "mlok",
    "mlsat",
    "mluvit",
    "mnich",
    "mnohem",
    "mobil",
    "mocnost",
    "modelka",
    "modlitba",
    "mohyla",
    "mokro",
    "molekula",
    "momentka",
    "monarcha",
    "monokl",
    "monstrum",
    "montovat",
    "monzun",
    "mosaz",
    "moskyt",
    "most",
    "motivace",
    "motorka",
    "motyka",
    "moucha",
    "moudrost",
    "mozaika",
    "mozek",
    "mozol",
    "mramor",
    "mravenec",
    "mrkev",
    "mrtvola",
    "mrzet",
    "mrzutost",
    "mstitel",
    "mudrc",
    "muflon",
    "mulat",
    "mumie",
    "munice",
    "muset",
    "mutace",
    "muzeum",
    "muzikant",
    "myslivec",
    "mzda",
    "nabourat",
    "nachytat",
    "nadace",
    "nadbytek",
    "nadhoz",
    "nadobro",
    "nadpis",
    "nahlas",
    "nahnat",
    "nahodile",
    "nahradit",
    "naivita",
    "najednou",
    "najisto",
    "najmout",
    "naklonit",
    "nakonec",
    "nakrmit",
    "nalevo",
    "namazat",
    "namluvit",
    "nanometr",
    "naoko",
    "naopak",
    "naostro",
    "napadat",
    "napevno",
    "naplnit",
    "napnout",
    "naposled",
    "naprosto",
    "narodit",
    "naruby",
    "narychlo",
    "nasadit",
    "nasekat",
    "naslepo",
    "nastat",
    "natolik",
    "navenek",
    "navrch",
    "navzdory",
    "nazvat",
    "nebe",
    "nechat",
    "necky",
    "nedaleko",
    "nedbat",
    "neduh",
    "negace",
    "nehet",
    "nehoda",
    "nejen",
    "nejprve",
    "neklid",
    "nelibost",
    "nemilost",
    "nemoc",
    "neochota",
    "neonka",
    "nepokoj",
    "nerost",
    "nerv",
    "nesmysl",
    "nesoulad",
    "netvor",
    "neuron",
    "nevina",
    "nezvykle",
    "nicota",
    "nijak",
    "nikam",
    "nikdy",
    "nikl",
    "nikterak",
    "nitro",
    "nocleh",
    "nohavice",
    "nominace",
    "nora",
    "norek",
    "nositel",
    "nosnost",
    "nouze",
    "noviny",
    "novota",
    "nozdra",
    "nuda",
    "nudle",
    "nuget",
    "nutit",
    "nutnost",
    "nutrie",
    "nymfa",
    "obal",
    "obarvit",
    "obava",
    "obdiv",
    "obec",
    "obehnat",
    "obejmout",
    "obezita",
    "obhajoba",
    "obilnice",
    "objasnit",
    "objekt",
    "obklopit",
    "oblast",
    "oblek",
    "obliba",
    "obloha",
    "obluda",
    "obnos",
    "obohatit",
    "obojek",
    "obout",
    "obrazec",
    "obrna",
    "obruba",
    "obrys",
    "obsah",
    "obsluha",
    "obstarat",
    "obuv",
    "obvaz",
    "obvinit",
    "obvod",
    "obvykle",
    "obyvatel",
    "obzor",
    "ocas",
    "ocel",
    "ocenit",
    "ochladit",
    "ochota",
    "ochrana",
    "ocitnout",
    "odboj",
    "odbyt",
    "odchod",
    "odcizit",
    "odebrat",
    "odeslat",
    "odevzdat",
    "odezva",
    "odhadce",
    "odhodit",
    "odjet",
    "odjinud",
    "odkaz",
    "odkoupit",
    "odliv",
    "odluka",
    "odmlka",
    "odolnost",
    "odpad",
    "odpis",
    "odplout",
    "odpor",
    "odpustit",
    "odpykat",
    "odrazka",
    "odsoudit",
    "odstup",
    "odsun",
    "odtok",
    "odtud",
    "odvaha",
    "odveta",
    "odvolat",
    "odvracet",
    "odznak",
    "ofina",
    "ofsajd",
    "ohlas",
    "ohnisko",
    "ohrada",
    "ohrozit",
    "ohryzek",
    "okap",
    "okenice",
    "oklika",
    "okno",
    "okouzlit",
    "okovy",
    "okrasa",
    "okres",
    "okrsek",
    "okruh",
    "okupant",
    "okurka",
    "okusit",
    "olejnina",
    "olizovat",
    "omak",
    "omeleta",
    "omezit",
    "omladina",
    "omlouvat",
    "omluva",
    "omyl",
    "onehdy",
    "opakovat",
    "opasek",
    "operace",
    "opice",
    "opilost",
    "opisovat",
    "opora",
    "opozice",
    "opravdu",
    "oproti",
    "orbital",
    "orchestr",
    "orgie",
    "orlice",
    "orloj",
    "ortel",
    "osada",
    "oschnout",
    "osika",
    "osivo",
    "oslava",
    "oslepit",
    "oslnit",
    "oslovit",
    "osnova",
    "osoba",
    "osolit",
    "ospalec",
    "osten",
    "ostraha",
    "ostuda",
    "ostych",
    "osvojit",
    "oteplit",
    "otisk",
    "otop",
    "otrhat",
    "otrlost",
    "otrok",
    "otruby",
    "otvor",
    "ovanout",
    "ovar",
    "oves",
    "ovlivnit",
    "ovoce",
    "oxid",
    "ozdoba",
    "pachatel",
    "pacient",
    "padouch",
    "pahorek",
    "pakt",
    "palanda",
    "palec",
    "palivo",
    "paluba",
    "pamflet",
    "pamlsek",
    "panenka",
    "panika",
    "panna",
    "panovat",
    "panstvo",
    "pantofle",
    "paprika",
    "parketa",
    "parodie",
    "parta",
    "paruka",
    "paryba",
    "paseka",
    "pasivita",
    "pastelka",
    "patent",
    "patrona",
    "pavouk",
    "pazneht",
    "pazourek",
    "pecka",
    "pedagog",
    "pejsek",
    "peklo",
    "peloton",
    "penalta",
    "pendrek",
    "penze",
    "periskop",
    "pero",
    "pestrost",
    "petarda",
    "petice",
    "petrolej",
    "pevnina",
    "pexeso",
    "pianista",
    "piha",
    "pijavice",
    "pikle",
    "piknik",
    "pilina",
    "pilnost",
    "pilulka",
    "pinzeta",
    "pipeta",
    "pisatel",
    "pistole",
    "pitevna",
    "pivnice",
    "pivovar",
    "placenta",
    "plakat",
    "plamen",
    "planeta",
    "plastika",
    "platit",
    "plavidlo",
    "plaz",
    "plech",
    "plemeno",
    "plenta",
    "ples",
    "pletivo",
    "plevel",
    "plivat",
    "plnit",
    "plno",
    "plocha",
    "plodina",
    "plomba",
    "plout",
    "pluk",
    "plyn",
    "pobavit",
    "pobyt",
    "pochod",
    "pocit",
    "poctivec",
    "podat",
    "podcenit",
    "podepsat",
    "podhled",
    "podivit",
    "podklad",
    "podmanit",
    "podnik",
    "podoba",
    "podpora",
    "podraz",
    "podstata",
    "podvod",
    "podzim",
    "poezie",
    "pohanka",
    "pohnutka",
    "pohovor",
    "pohroma",
    "pohyb",
    "pointa",
    "pojistka",
    "pojmout",
    "pokazit",
    "pokles",
    "pokoj",
    "pokrok",
    "pokuta",
    "pokyn",
    "poledne",
    "polibek",
    "polknout",
    "poloha",
    "polynom",
    "pomalu",
    "pominout",
    "pomlka",
    "pomoc",
    "pomsta",
    "pomyslet",
    "ponechat",
    "ponorka",
    "ponurost",
    "popadat",
    "popel",
    "popisek",
    "poplach",
    "poprosit",
    "popsat",
    "popud",
    "poradce",
    "porce",
    "porod",
    "porucha",
    "poryv",
    "posadit",
    "posed",
    "posila",
    "poskok",
    "poslanec",
    "posoudit",
    "pospolu",
    "postava",
    "posudek",
    "posyp",
    "potah",
    "potkan",
    "potlesk",
    "potomek",
    "potrava",
    "potupa",
    "potvora",
    "poukaz",
    "pouto",
    "pouzdro",
    "povaha",
    "povidla",
    "povlak",
    "povoz",
    "povrch",
    "povstat",
    "povyk",
    "povzdech",
    "pozdrav",
    "pozemek",
    "poznatek",
    "pozor",
    "pozvat",
    "pracovat",
    "prahory",
    "praktika",
    "prales",
    "praotec",
    "praporek",
    "prase",
    "pravda",
    "princip",
    "prkno",
    "probudit",
    "procento",
    "prodej",
    "profese",
    "prohra",
    "projekt",
    "prolomit",
    "promile",
    "pronikat",
    "propad",
    "prorok",
    "prosba",
    "proton",
    "proutek",
    "provaz",
    "prskavka",
    "prsten",
    "prudkost",
    "prut",
    "prvek",
    "prvohory",
    "psanec",
    "psovod",
    "pstruh",
    "ptactvo",
    "puberta",
    "puch",
    "pudl",
    "pukavec",
    "puklina",
    "pukrle",
    "pult",
    "pumpa",
    "punc",
    "pupen",
    "pusa",
    "pusinka",
    "pustina",
    "putovat",
    "putyka",
    "pyramida",
    "pysk",
    "pytel",
    "racek",
    "rachot",
    "radiace",
    "radnice",
    "radon",
    "raft",
    "ragby",
    "raketa",
    "rakovina",
    "rameno",
    "rampouch",
    "rande",
    "rarach",
    "rarita",
    "rasovna",
    "rastr",
    "ratolest",
    "razance",
    "razidlo",
    "reagovat",
    "reakce",
    "recept",
    "redaktor",
    "referent",
    "reflex",
    "rejnok",
    "reklama",
    "rekord",
    "rekrut",
    "rektor",
    "reputace",
    "revize",
    "revma",
    "revolver",
    "rezerva",
    "riskovat",
    "riziko",
    "robotika",
    "rodokmen",
    "rohovka",
    "rokle",
    "rokoko",
    "romaneto",
    "ropovod",
    "ropucha",
    "rorejs",
    "rosol",
    "rostlina",
    "rotmistr",
    "rotoped",
    "rotunda",
    "roubenka",
    "roucho",
    "roup",
    "roura",
    "rovina",
    "rovnice",
    "rozbor",
    "rozchod",
    "rozdat",
    "rozeznat",
    "rozhodce",
    "rozinka",
    "rozjezd",
    "rozkaz",
    "rozloha",
    "rozmar",
    "rozpad",
    "rozruch",
    "rozsah",
    "roztok",
    "rozum",
    "rozvod",
    "rubrika",
    "ruchadlo",
    "rukavice",
    "rukopis",
    "ryba",
    "rybolov",
    "rychlost",
    "rydlo",
    "rypadlo",
    "rytina",
    "ryzost",
    "sadista",
    "sahat",
    "sako",
    "samec",
    "samizdat",
    "samota",
    "sanitka",
    "sardinka",
    "sasanka",
    "satelit",
    "sazba",
    "sazenice",
    "sbor",
    "schovat",
    "sebranka",
    "secese",
    "sedadlo",
    "sediment",
    "sedlo",
    "sehnat",
    "sejmout",
    "sekera",
    "sekta",
    "sekunda",
    "sekvoje",
    "semeno",
    "seno",
    "servis",
    "sesadit",
    "seshora",
    "seskok",
    "seslat",
    "sestra",
    "sesuv",
    "sesypat",
    "setba",
    "setina",
    "setkat",
    "setnout",
    "setrvat",
    "sever",
    "seznam",
    "shoda",
    "shrnout",
    "sifon",
    "silnice",
    "sirka",
    "sirotek",
    "sirup",
    "situace",
    "skafandr",
    "skalisko",
    "skanzen",
    "skaut",
    "skeptik",
    "skica",
    "skladba",
    "sklenice",
    "sklo",
    "skluz",
    "skoba",
    "skokan",
    "skoro",
    "skripta",
    "skrz",
    "skupina",
    "skvost",
    "skvrna",
    "slabika",
    "sladidlo",
    "slanina",
    "slast",
    "slavnost",
    "sledovat",
    "slepec",
    "sleva",
    "slezina",
    "slib",
    "slina",
    "sliznice",
    "slon",
    "sloupek",
    "slovo",
    "sluch",
    "sluha",
    "slunce",
    "slupka",
    "slza",
    "smaragd",
    "smetana",
    "smilstvo",
    "smlouva",
    "smog",
    "smrad",
    "smrk",
    "smrtka",
    "smutek",
    "smysl",
    "snad",
    "snaha",
    "snob",
    "sobota",
    "socha",
    "sodovka",
    "sokol",
    "sopka",
    "sotva",
    "souboj",
    "soucit",
    "soudce",
    "souhlas",
    "soulad",
    "soumrak",
    "souprava",
    "soused",
    "soutok",
    "souviset",
    "spalovna",
    "spasitel",
    "spis",
    "splav",
    "spodek",
    "spojenec",
    "spolu",
    "sponzor",
    "spornost",
    "spousta",
    "sprcha",
    "spustit",
    "sranda",
    "sraz",
    "srdce",
    "srna",
    "srnec",
    "srovnat",
    "srpen",
    "srst",
    "srub",
    "stanice",
    "starosta",
    "statika",
    "stavba",
    "stehno",
    "stezka",
    "stodola",
    "stolek",
    "stopa",
    "storno",
    "stoupat",
    "strach",
    "stres",
    "strhnout",
    "strom",
    "struna",
    "studna",
    "stupnice",
    "stvol",
    "styk",
    "subjekt",
    "subtropy",
    "suchar",
    "sudost",
    "sukno",
    "sundat",
    "sunout",
    "surikata",
    "surovina",
    "svah",
    "svalstvo",
    "svetr",
    "svatba",
    "svazek",
    "svisle",
    "svitek",
    "svoboda",
    "svodidlo",
    "svorka",
    "svrab",
    "sykavka",
    "sykot",
    "synek",
    "synovec",
    "sypat",
    "sypkost",
    "syrovost",
    "sysel",
    "sytost",
    "tabletka",
    "tabule",
    "tahoun",
    "tajemno",
    "tajfun",
    "tajga",
    "tajit",
    "tajnost",
    "taktika",
    "tamhle",
    "tampon",
    "tancovat",
    "tanec",
    "tanker",
    "tapeta",
    "tavenina",
    "tazatel",
    "technika",
    "tehdy",
    "tekutina",
    "telefon",
    "temnota",
    "tendence",
    "tenista",
    "tenor",
    "teplota",
    "tepna",
    "teprve",
    "terapie",
    "termoska",
    "textil",
    "ticho",
    "tiskopis",
    "titulek",
    "tkadlec",
    "tkanina",
    "tlapka",
    "tleskat",
    "tlukot",
    "tlupa",
    "tmel",
    "toaleta",
    "topinka",
    "topol",
    "torzo",
    "touha",
    "toulec",
    "tradice",
    "traktor",
    "tramp",
    "trasa",
    "traverza",
    "trefit",
    "trest",
    "trezor",
    "trhavina",
    "trhlina",
    "trochu",
    "trojice",
    "troska",
    "trouba",
    "trpce",
    "trpitel",
    "trpkost",
    "trubec",
    "truchlit",
    "truhlice",
    "trus",
    "trvat",
    "tudy",
    "tuhnout",
    "tuhost",
    "tundra",
    "turista",
    "turnaj",
    "tuzemsko",
    "tvaroh",
    "tvorba",
    "tvrdost",
    "tvrz",
    "tygr",
    "tykev",
    "ubohost",
    "uboze",
    "ubrat",
    "ubrousek",
    "ubrus",
    "ubytovna",
    "ucho",
    "uctivost",
    "udivit",
    "uhradit",
    "ujednat",
    "ujistit",
    "ujmout",
    "ukazatel",
    "uklidnit",
    "uklonit",
    "ukotvit",
    "ukrojit",
    "ulice",
    "ulita",
    "ulovit",
    "umyvadlo",
    "unavit",
    "uniforma",
    "uniknout",
    "upadnout",
    "uplatnit",
    "uplynout",
    "upoutat",
    "upravit",
    "uran",
    "urazit",
    "usednout",
    "usilovat",
    "usmrtit",
    "usnadnit",
    "usnout",
    "usoudit",
    "ustlat",
    "ustrnout",
    "utahovat",
    "utkat",
    "utlumit",
    "utonout",
    "utopenec",
    "utrousit",
    "uvalit",
    "uvolnit",
    "uvozovka",
    "uzdravit",
    "uzel",
    "uzenina",
    "uzlina",
    "uznat",
    "vagon",
    "valcha",
    "valoun",
    "vana",
    "vandal",
    "vanilka",
    "varan",
    "varhany",
    "varovat",
    "vcelku",
    "vchod",
    "vdova",
    "vedro",
    "vegetace",
    "vejce",
    "velbloud",
    "veletrh",
    "velitel",
    "velmoc",
    "velryba",
    "venkov",
    "veranda",
    "verze",
    "veselka",
    "veskrze",
    "vesnice",
    "vespodu",
    "vesta",
    "veterina",
    "veverka",
    "vibrace",
    "vichr",
    "videohra",
    "vidina",
    "vidle",
    "vila",
    "vinice",
    "viset",
    "vitalita",
    "vize",
    "vizitka",
    "vjezd",
    "vklad",
    "vkus",
    "vlajka",
    "vlak",
    "vlasec",
    "vlevo",
    "vlhkost",
    "vliv",
    "vlnovka",
    "vloupat",
    "vnucovat",
    "vnuk",
    "voda",
    "vodivost",
    "vodoznak",
    "vodstvo",
    "vojensky",
    "vojna",
    "vojsko",
    "volant",
    "volba",
    "volit",
    "volno",
    "voskovka",
    "vozidlo",
    "vozovna",
    "vpravo",
    "vrabec",
    "vracet",
    "vrah",
    "vrata",
    "vrba",
    "vrcholek",
    "vrhat",
    "vrstva",
    "vrtule",
    "vsadit",
    "vstoupit",
    "vstup",
    "vtip",
    "vybavit",
    "vybrat",
    "vychovat",
    "vydat",
    "vydra",
    "vyfotit",
    "vyhledat",
    "vyhnout",
    "vyhodit",
    "vyhradit",
    "vyhubit",
    "vyjasnit",
    "vyjet",
    "vyjmout",
    "vyklopit",
    "vykonat",
    "vylekat",
    "vymazat",
    "vymezit",
    "vymizet",
    "vymyslet",
    "vynechat",
    "vynikat",
    "vynutit",
    "vypadat",
    "vyplatit",
    "vypravit",
    "vypustit",
    "vyrazit",
    "vyrovnat",
    "vyrvat",
    "vyslovit",
    "vysoko",
    "vystavit",
    "vysunout",
    "vysypat",
    "vytasit",
    "vytesat",
    "vytratit",
    "vyvinout",
    "vyvolat",
    "vyvrhel",
    "vyzdobit",
    "vyznat",
    "vzadu",
    "vzbudit",
    "vzchopit",
    "vzdor",
    "vzduch",
    "vzdychat",
    "vzestup",
    "vzhledem",
    "vzkaz",
    "vzlykat",
    "vznik",
    "vzorek",
    "vzpoura",
    "vztah",
    "vztek",
    "xylofon",
    "zabrat",
    "zabydlet",
    "zachovat",
    "zadarmo",
    "zadusit",
    "zafoukat",
    "zahltit",
    "zahodit",
    "zahrada",
    "zahynout",
    "zajatec",
    "zajet",
    "zajistit",
    "zaklepat",
    "zakoupit",
    "zalepit",
    "zamezit",
    "zamotat",
    "zamyslet",
    "zanechat",
    "zanikat",
    "zaplatit",
    "zapojit",
    "zapsat",
    "zarazit",
    "zastavit",
    "zasunout",
    "zatajit",
    "zatemnit",
    "zatknout",
    "zaujmout",
    "zavalit",
    "zavelet",
    "zavinit",
    "zavolat",
    "zavrtat",
    "zazvonit",
    "zbavit",
    "zbrusu",
    "zbudovat",
    "zbytek",
    "zdaleka",
    "zdarma",
    "zdatnost",
    "zdivo",
    "zdobit",
    "zdroj",
    "zdvih",
    "zdymadlo",
    "zelenina",
    "zeman",
    "zemina",
    "zeptat",
    "zezadu",
    "zezdola",
    "zhatit",
    "zhltnout",
    "zhluboka",
    "zhotovit",
    "zhruba",
    "zima",
    "zimnice",
    "zjemnit",
    "zklamat",
    "zkoumat",
    "zkratka",
    "zkumavka",
    "zlato",
    "zlehka",
    "zloba",
    "zlom",
    "zlost",
    "zlozvyk",
    "zmapovat",
    "zmar",
    "zmatek",
    "zmije",
    "zmizet",
    "zmocnit",
    "zmodrat",
    "zmrzlina",
    "zmutovat",
    "znak",
    "znalost",
    "znamenat",
    "znovu",
    "zobrazit",
    "zotavit",
    "zoubek",
    "zoufale",
    "zplodit",
    "zpomalit",
    "zprava",
    "zprostit",
    "zprudka",
    "zprvu",
    "zrada",
    "zranit",
    "zrcadlo",
    "zrnitost",
    "zrno",
    "zrovna",
    "zrychlit",
    "zrzavost",
    "zticha",
    "ztratit",
    "zubovina",
    "zubr",
    "zvednout",
    "zvenku",
    "zvesela",
    "zvon",
    "zvrat",
    "zvukovod",
    "zvyk"
]

},{}],94:[function(require,module,exports){
module.exports=[
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
]

},{}],95:[function(require,module,exports){
module.exports=[
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "académie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquérir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adéquat",
    "adhésif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aérer",
    "aéronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agréable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algèbre",
    "algue",
    "aliéner",
    "aliment",
    "alléger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alvéole",
    "amateur",
    "ambigu",
    "ambre",
    "aménager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "anéantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "apéritif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "artériel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "bannière",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "bélier",
    "belote",
    "bénéfice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "bétail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "brèche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "caféine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "caméra",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cédille",
    "ceinture",
    "céleste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cérébral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chéquier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimère",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinéma",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohésion",
    "coiffer",
    "coincer",
    "colère",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comédie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortège",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "créature",
    "créditer",
    "crémeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critère",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillère",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "débattre",
    "débiter",
    "déborder",
    "débrider",
    "débutant",
    "décaler",
    "décembre",
    "déchirer",
    "décider",
    "déclarer",
    "décorer",
    "décrire",
    "décupler",
    "dédale",
    "déductif",
    "déesse",
    "défensif",
    "défiler",
    "défrayer",
    "dégager",
    "dégivrer",
    "déglutir",
    "dégrafer",
    "déjeuner",
    "délice",
    "déloger",
    "demander",
    "demeurer",
    "démolir",
    "dénicher",
    "dénouer",
    "dentelle",
    "dénuder",
    "départ",
    "dépenser",
    "déphaser",
    "déplacer",
    "déposer",
    "déranger",
    "dérober",
    "désastre",
    "descente",
    "désert",
    "désigner",
    "désobéir",
    "dessiner",
    "destrier",
    "détacher",
    "détester",
    "détourer",
    "détresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "différer",
    "digérer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "éblouir",
    "écarter",
    "écharpe",
    "échelle",
    "éclairer",
    "éclipse",
    "éclore",
    "écluse",
    "école",
    "économie",
    "écorce",
    "écouter",
    "écraser",
    "écrémer",
    "écrivain",
    "écrou",
    "écume",
    "écureuil",
    "édifier",
    "éduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "égaliser",
    "égarer",
    "éjecter",
    "élaborer",
    "élargir",
    "électron",
    "élégant",
    "éléphant",
    "élève",
    "éligible",
    "élitisme",
    "éloge",
    "élucider",
    "éluder",
    "emballer",
    "embellir",
    "embryon",
    "émeraude",
    "émission",
    "emmener",
    "émotion",
    "émouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "émulsion",
    "encadrer",
    "enchère",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "énergie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "énigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "énumérer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "éolien",
    "épaissir",
    "épargne",
    "épatant",
    "épaule",
    "épicerie",
    "épidémie",
    "épier",
    "épilogue",
    "épine",
    "épisode",
    "épitaphe",
    "époque",
    "épreuve",
    "éprouver",
    "épuisant",
    "équerre",
    "équipe",
    "ériger",
    "érosion",
    "erreur",
    "éruption",
    "escalier",
    "espadon",
    "espèce",
    "espiègle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "étagère",
    "étaler",
    "étanche",
    "étatique",
    "éteindre",
    "étendoir",
    "éternel",
    "éthanol",
    "éthique",
    "ethnie",
    "étirer",
    "étoffer",
    "étoile",
    "étonnant",
    "étourdir",
    "étrange",
    "étroit",
    "étude",
    "euphorie",
    "évaluer",
    "évasion",
    "éventail",
    "évidence",
    "éviter",
    "évolutif",
    "évoquer",
    "exact",
    "exagérer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "exécuter",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expédier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "fébrile",
    "féconder",
    "fédérer",
    "félin",
    "femme",
    "fémur",
    "fendoir",
    "féodal",
    "fermer",
    "féroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "février",
    "fiasco",
    "ficeler",
    "fictif",
    "fidèle",
    "figure",
    "filature",
    "filetage",
    "filière",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fléau",
    "flèche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougère",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "frégate",
    "freiner",
    "frelon",
    "frémir",
    "frénésie",
    "frère",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "géant",
    "gélatine",
    "gélule",
    "gendarme",
    "général",
    "génie",
    "genou",
    "gentil",
    "géologie",
    "géomètre",
    "géranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyère",
    "guépard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "hélium",
    "hématome",
    "herbe",
    "hérisson",
    "hermine",
    "héron",
    "hésiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogène",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiène",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "impérial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inédit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingérer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irréel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvénile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacérer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "légal",
    "léger",
    "légume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lézard",
    "liasse",
    "libérer",
    "libre",
    "licence",
    "licorne",
    "liège",
    "lièvre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "linéaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisière",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumière",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "maléfice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "matériel",
    "matière",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "méchant",
    "méconnu",
    "médaille",
    "médecin",
    "méditer",
    "méduse",
    "meilleur",
    "mélange",
    "mélodie",
    "membre",
    "mémoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "mérite",
    "merle",
    "messager",
    "mesure",
    "métal",
    "météore",
    "méthode",
    "métier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "minéral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murène",
    "murmure",
    "muscle",
    "muséum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystère",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nébuleux",
    "nectar",
    "néfaste",
    "négation",
    "négliger",
    "négocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numéro",
    "nuptial",
    "nuque",
    "nutritif",
    "obéir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "océan",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onéreux",
    "onirique",
    "opale",
    "opaque",
    "opérer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygène",
    "ozone",
    "paisible",
    "palace",
    "palmarès",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pastèque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pélican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "pénétrer",
    "pénible",
    "pensif",
    "pénurie",
    "pépite",
    "péplum",
    "perdrix",
    "perforer",
    "période",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "pétale",
    "petit",
    "pétrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "pièce",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poésie",
    "poète",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "pondérer",
    "poney",
    "portique",
    "position",
    "posséder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "précieux",
    "prédire",
    "préfixe",
    "prélude",
    "prénom",
    "présence",
    "prétexte",
    "prévoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "problème",
    "procéder",
    "prodige",
    "profond",
    "progrès",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospère",
    "protéger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quiétude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "réactif",
    "réagir",
    "réaliser",
    "réanimer",
    "recevoir",
    "réciter",
    "réclamer",
    "récolter",
    "recruter",
    "reculer",
    "recycler",
    "rédiger",
    "redouter",
    "refaire",
    "réflexe",
    "réformer",
    "refrain",
    "refuge",
    "régalien",
    "région",
    "réglage",
    "régulier",
    "réitérer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remède",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "réserve",
    "résineux",
    "résoudre",
    "respect",
    "rester",
    "résultat",
    "rétablir",
    "retenir",
    "réticule",
    "retomber",
    "retracer",
    "réunion",
    "réussir",
    "revanche",
    "revivre",
    "révolte",
    "révulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "rivière",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scélérat",
    "scénario",
    "sceptre",
    "schéma",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "séance",
    "sécable",
    "sécher",
    "secouer",
    "sécréter",
    "sédatif",
    "séduire",
    "seigneur",
    "séjour",
    "sélectif",
    "semaine",
    "sembler",
    "semence",
    "séminal",
    "sénateur",
    "sensible",
    "sentence",
    "séparer",
    "séquence",
    "serein",
    "sergent",
    "sérieux",
    "serrure",
    "sérum",
    "service",
    "sésame",
    "sévir",
    "sevrage",
    "sextuple",
    "sidéral",
    "siècle",
    "siéger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincère",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "spécial",
    "sphère",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succès",
    "sucre",
    "suffixe",
    "suggérer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symétrie",
    "synapse",
    "syntaxe",
    "système",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "témoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tétine",
    "texte",
    "thème",
    "théorie",
    "thérapie",
    "thorax",
    "tibia",
    "tiède",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolérant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trèfle",
    "tremper",
    "trésor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "végétal",
    "véhicule",
    "veinard",
    "véloce",
    "vendredi",
    "vénérer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "vérin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "vétéran",
    "vétuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "vidéo",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipère",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xénon",
    "yacht",
    "zèbre",
    "zénith",
    "zeste",
    "zoologie"
]

},{}],96:[function(require,module,exports){
module.exports=[
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
]

},{}],97:[function(require,module,exports){
module.exports=[
    "あいこくしん",
    "あいさつ",
    "あいだ",
    "あおぞら",
    "あかちゃん",
    "あきる",
    "あけがた",
    "あける",
    "あこがれる",
    "あさい",
    "あさひ",
    "あしあと",
    "あじわう",
    "あずかる",
    "あずき",
    "あそぶ",
    "あたえる",
    "あたためる",
    "あたりまえ",
    "あたる",
    "あつい",
    "あつかう",
    "あっしゅく",
    "あつまり",
    "あつめる",
    "あてな",
    "あてはまる",
    "あひる",
    "あぶら",
    "あぶる",
    "あふれる",
    "あまい",
    "あまど",
    "あまやかす",
    "あまり",
    "あみもの",
    "あめりか",
    "あやまる",
    "あゆむ",
    "あらいぐま",
    "あらし",
    "あらすじ",
    "あらためる",
    "あらゆる",
    "あらわす",
    "ありがとう",
    "あわせる",
    "あわてる",
    "あんい",
    "あんがい",
    "あんこ",
    "あんぜん",
    "あんてい",
    "あんない",
    "あんまり",
    "いいだす",
    "いおん",
    "いがい",
    "いがく",
    "いきおい",
    "いきなり",
    "いきもの",
    "いきる",
    "いくじ",
    "いくぶん",
    "いけばな",
    "いけん",
    "いこう",
    "いこく",
    "いこつ",
    "いさましい",
    "いさん",
    "いしき",
    "いじゅう",
    "いじょう",
    "いじわる",
    "いずみ",
    "いずれ",
    "いせい",
    "いせえび",
    "いせかい",
    "いせき",
    "いぜん",
    "いそうろう",
    "いそがしい",
    "いだい",
    "いだく",
    "いたずら",
    "いたみ",
    "いたりあ",
    "いちおう",
    "いちじ",
    "いちど",
    "いちば",
    "いちぶ",
    "いちりゅう",
    "いつか",
    "いっしゅん",
    "いっせい",
    "いっそう",
    "いったん",
    "いっち",
    "いってい",
    "いっぽう",
    "いてざ",
    "いてん",
    "いどう",
    "いとこ",
    "いない",
    "いなか",
    "いねむり",
    "いのち",
    "いのる",
    "いはつ",
    "いばる",
    "いはん",
    "いびき",
    "いひん",
    "いふく",
    "いへん",
    "いほう",
    "いみん",
    "いもうと",
    "いもたれ",
    "いもり",
    "いやがる",
    "いやす",
    "いよかん",
    "いよく",
    "いらい",
    "いらすと",
    "いりぐち",
    "いりょう",
    "いれい",
    "いれもの",
    "いれる",
    "いろえんぴつ",
    "いわい",
    "いわう",
    "いわかん",
    "いわば",
    "いわゆる",
    "いんげんまめ",
    "いんさつ",
    "いんしょう",
    "いんよう",
    "うえき",
    "うえる",
    "うおざ",
    "うがい",
    "うかぶ",
    "うかべる",
    "うきわ",
    "うくらいな",
    "うくれれ",
    "うけたまわる",
    "うけつけ",
    "うけとる",
    "うけもつ",
    "うける",
    "うごかす",
    "うごく",
    "うこん",
    "うさぎ",
    "うしなう",
    "うしろがみ",
    "うすい",
    "うすぎ",
    "うすぐらい",
    "うすめる",
    "うせつ",
    "うちあわせ",
    "うちがわ",
    "うちき",
    "うちゅう",
    "うっかり",
    "うつくしい",
    "うったえる",
    "うつる",
    "うどん",
    "うなぎ",
    "うなじ",
    "うなずく",
    "うなる",
    "うねる",
    "うのう",
    "うぶげ",
    "うぶごえ",
    "うまれる",
    "うめる",
    "うもう",
    "うやまう",
    "うよく",
    "うらがえす",
    "うらぐち",
    "うらない",
    "うりあげ",
    "うりきれ",
    "うるさい",
    "うれしい",
    "うれゆき",
    "うれる",
    "うろこ",
    "うわき",
    "うわさ",
    "うんこう",
    "うんちん",
    "うんてん",
    "うんどう",
    "えいえん",
    "えいが",
    "えいきょう",
    "えいご",
    "えいせい",
    "えいぶん",
    "えいよう",
    "えいわ",
    "えおり",
    "えがお",
    "えがく",
    "えきたい",
    "えくせる",
    "えしゃく",
    "えすて",
    "えつらん",
    "えのぐ",
    "えほうまき",
    "えほん",
    "えまき",
    "えもじ",
    "えもの",
    "えらい",
    "えらぶ",
    "えりあ",
    "えんえん",
    "えんかい",
    "えんぎ",
    "えんげき",
    "えんしゅう",
    "えんぜつ",
    "えんそく",
    "えんちょう",
    "えんとつ",
    "おいかける",
    "おいこす",
    "おいしい",
    "おいつく",
    "おうえん",
    "おうさま",
    "おうじ",
    "おうせつ",
    "おうたい",
    "おうふく",
    "おうべい",
    "おうよう",
    "おえる",
    "おおい",
    "おおう",
    "おおどおり",
    "おおや",
    "おおよそ",
    "おかえり",
    "おかず",
    "おがむ",
    "おかわり",
    "おぎなう",
    "おきる",
    "おくさま",
    "おくじょう",
    "おくりがな",
    "おくる",
    "おくれる",
    "おこす",
    "おこなう",
    "おこる",
    "おさえる",
    "おさない",
    "おさめる",
    "おしいれ",
    "おしえる",
    "おじぎ",
    "おじさん",
    "おしゃれ",
    "おそらく",
    "おそわる",
    "おたがい",
    "おたく",
    "おだやか",
    "おちつく",
    "おっと",
    "おつり",
    "おでかけ",
    "おとしもの",
    "おとなしい",
    "おどり",
    "おどろかす",
    "おばさん",
    "おまいり",
    "おめでとう",
    "おもいで",
    "おもう",
    "おもたい",
    "おもちゃ",
    "おやつ",
    "おやゆび",
    "およぼす",
    "おらんだ",
    "おろす",
    "おんがく",
    "おんけい",
    "おんしゃ",
    "おんせん",
    "おんだん",
    "おんちゅう",
    "おんどけい",
    "かあつ",
    "かいが",
    "がいき",
    "がいけん",
    "がいこう",
    "かいさつ",
    "かいしゃ",
    "かいすいよく",
    "かいぜん",
    "かいぞうど",
    "かいつう",
    "かいてん",
    "かいとう",
    "かいふく",
    "がいへき",
    "かいほう",
    "かいよう",
    "がいらい",
    "かいわ",
    "かえる",
    "かおり",
    "かかえる",
    "かがく",
    "かがし",
    "かがみ",
    "かくご",
    "かくとく",
    "かざる",
    "がぞう",
    "かたい",
    "かたち",
    "がちょう",
    "がっきゅう",
    "がっこう",
    "がっさん",
    "がっしょう",
    "かなざわし",
    "かのう",
    "がはく",
    "かぶか",
    "かほう",
    "かほご",
    "かまう",
    "かまぼこ",
    "かめれおん",
    "かゆい",
    "かようび",
    "からい",
    "かるい",
    "かろう",
    "かわく",
    "かわら",
    "がんか",
    "かんけい",
    "かんこう",
    "かんしゃ",
    "かんそう",
    "かんたん",
    "かんち",
    "がんばる",
    "きあい",
    "きあつ",
    "きいろ",
    "ぎいん",
    "きうい",
    "きうん",
    "きえる",
    "きおう",
    "きおく",
    "きおち",
    "きおん",
    "きかい",
    "きかく",
    "きかんしゃ",
    "ききて",
    "きくばり",
    "きくらげ",
    "きけんせい",
    "きこう",
    "きこえる",
    "きこく",
    "きさい",
    "きさく",
    "きさま",
    "きさらぎ",
    "ぎじかがく",
    "ぎしき",
    "ぎじたいけん",
    "ぎじにってい",
    "ぎじゅつしゃ",
    "きすう",
    "きせい",
    "きせき",
    "きせつ",
    "きそう",
    "きぞく",
    "きぞん",
    "きたえる",
    "きちょう",
    "きつえん",
    "ぎっちり",
    "きつつき",
    "きつね",
    "きてい",
    "きどう",
    "きどく",
    "きない",
    "きなが",
    "きなこ",
    "きぬごし",
    "きねん",
    "きのう",
    "きのした",
    "きはく",
    "きびしい",
    "きひん",
    "きふく",
    "きぶん",
    "きぼう",
    "きほん",
    "きまる",
    "きみつ",
    "きむずかしい",
    "きめる",
    "きもだめし",
    "きもち",
    "きもの",
    "きゃく",
    "きやく",
    "ぎゅうにく",
    "きよう",
    "きょうりゅう",
    "きらい",
    "きらく",
    "きりん",
    "きれい",
    "きれつ",
    "きろく",
    "ぎろん",
    "きわめる",
    "ぎんいろ",
    "きんかくじ",
    "きんじょ",
    "きんようび",
    "ぐあい",
    "くいず",
    "くうかん",
    "くうき",
    "くうぐん",
    "くうこう",
    "ぐうせい",
    "くうそう",
    "ぐうたら",
    "くうふく",
    "くうぼ",
    "くかん",
    "くきょう",
    "くげん",
    "ぐこう",
    "くさい",
    "くさき",
    "くさばな",
    "くさる",
    "くしゃみ",
    "くしょう",
    "くすのき",
    "くすりゆび",
    "くせげ",
    "くせん",
    "ぐたいてき",
    "くださる",
    "くたびれる",
    "くちこみ",
    "くちさき",
    "くつした",
    "ぐっすり",
    "くつろぐ",
    "くとうてん",
    "くどく",
    "くなん",
    "くねくね",
    "くのう",
    "くふう",
    "くみあわせ",
    "くみたてる",
    "くめる",
    "くやくしょ",
    "くらす",
    "くらべる",
    "くるま",
    "くれる",
    "くろう",
    "くわしい",
    "ぐんかん",
    "ぐんしょく",
    "ぐんたい",
    "ぐんて",
    "けあな",
    "けいかく",
    "けいけん",
    "けいこ",
    "けいさつ",
    "げいじゅつ",
    "けいたい",
    "げいのうじん",
    "けいれき",
    "けいろ",
    "けおとす",
    "けおりもの",
    "げきか",
    "げきげん",
    "げきだん",
    "げきちん",
    "げきとつ",
    "げきは",
    "げきやく",
    "げこう",
    "げこくじょう",
    "げざい",
    "けさき",
    "げざん",
    "けしき",
    "けしごむ",
    "けしょう",
    "げすと",
    "けたば",
    "けちゃっぷ",
    "けちらす",
    "けつあつ",
    "けつい",
    "けつえき",
    "けっこん",
    "けつじょ",
    "けっせき",
    "けってい",
    "けつまつ",
    "げつようび",
    "げつれい",
    "けつろん",
    "げどく",
    "けとばす",
    "けとる",
    "けなげ",
    "けなす",
    "けなみ",
    "けぬき",
    "げねつ",
    "けねん",
    "けはい",
    "げひん",
    "けぶかい",
    "げぼく",
    "けまり",
    "けみかる",
    "けむし",
    "けむり",
    "けもの",
    "けらい",
    "けろけろ",
    "けわしい",
    "けんい",
    "けんえつ",
    "けんお",
    "けんか",
    "げんき",
    "けんげん",
    "けんこう",
    "けんさく",
    "けんしゅう",
    "けんすう",
    "げんそう",
    "けんちく",
    "けんてい",
    "けんとう",
    "けんない",
    "けんにん",
    "げんぶつ",
    "けんま",
    "けんみん",
    "けんめい",
    "けんらん",
    "けんり",
    "こあくま",
    "こいぬ",
    "こいびと",
    "ごうい",
    "こうえん",
    "こうおん",
    "こうかん",
    "ごうきゅう",
    "ごうけい",
    "こうこう",
    "こうさい",
    "こうじ",
    "こうすい",
    "ごうせい",
    "こうそく",
    "こうたい",
    "こうちゃ",
    "こうつう",
    "こうてい",
    "こうどう",
    "こうない",
    "こうはい",
    "ごうほう",
    "ごうまん",
    "こうもく",
    "こうりつ",
    "こえる",
    "こおり",
    "ごかい",
    "ごがつ",
    "ごかん",
    "こくご",
    "こくさい",
    "こくとう",
    "こくない",
    "こくはく",
    "こぐま",
    "こけい",
    "こける",
    "ここのか",
    "こころ",
    "こさめ",
    "こしつ",
    "こすう",
    "こせい",
    "こせき",
    "こぜん",
    "こそだて",
    "こたい",
    "こたえる",
    "こたつ",
    "こちょう",
    "こっか",
    "こつこつ",
    "こつばん",
    "こつぶ",
    "こてい",
    "こてん",
    "ことがら",
    "ことし",
    "ことば",
    "ことり",
    "こなごな",
    "こねこね",
    "このまま",
    "このみ",
    "このよ",
    "ごはん",
    "こひつじ",
    "こふう",
    "こふん",
    "こぼれる",
    "ごまあぶら",
    "こまかい",
    "ごますり",
    "こまつな",
    "こまる",
    "こむぎこ",
    "こもじ",
    "こもち",
    "こもの",
    "こもん",
    "こやく",
    "こやま",
    "こゆう",
    "こゆび",
    "こよい",
    "こよう",
    "こりる",
    "これくしょん",
    "ころっけ",
    "こわもて",
    "こわれる",
    "こんいん",
    "こんかい",
    "こんき",
    "こんしゅう",
    "こんすい",
    "こんだて",
    "こんとん",
    "こんなん",
    "こんびに",
    "こんぽん",
    "こんまけ",
    "こんや",
    "こんれい",
    "こんわく",
    "ざいえき",
    "さいかい",
    "さいきん",
    "ざいげん",
    "ざいこ",
    "さいしょ",
    "さいせい",
    "ざいたく",
    "ざいちゅう",
    "さいてき",
    "ざいりょう",
    "さうな",
    "さかいし",
    "さがす",
    "さかな",
    "さかみち",
    "さがる",
    "さぎょう",
    "さくし",
    "さくひん",
    "さくら",
    "さこく",
    "さこつ",
    "さずかる",
    "ざせき",
    "さたん",
    "さつえい",
    "ざつおん",
    "ざっか",
    "ざつがく",
    "さっきょく",
    "ざっし",
    "さつじん",
    "ざっそう",
    "さつたば",
    "さつまいも",
    "さてい",
    "さといも",
    "さとう",
    "さとおや",
    "さとし",
    "さとる",
    "さのう",
    "さばく",
    "さびしい",
    "さべつ",
    "さほう",
    "さほど",
    "さます",
    "さみしい",
    "さみだれ",
    "さむけ",
    "さめる",
    "さやえんどう",
    "さゆう",
    "さよう",
    "さよく",
    "さらだ",
    "ざるそば",
    "さわやか",
    "さわる",
    "さんいん",
    "さんか",
    "さんきゃく",
    "さんこう",
    "さんさい",
    "ざんしょ",
    "さんすう",
    "さんせい",
    "さんそ",
    "さんち",
    "さんま",
    "さんみ",
    "さんらん",
    "しあい",
    "しあげ",
    "しあさって",
    "しあわせ",
    "しいく",
    "しいん",
    "しうち",
    "しえい",
    "しおけ",
    "しかい",
    "しかく",
    "じかん",
    "しごと",
    "しすう",
    "じだい",
    "したうけ",
    "したぎ",
    "したて",
    "したみ",
    "しちょう",
    "しちりん",
    "しっかり",
    "しつじ",
    "しつもん",
    "してい",
    "してき",
    "してつ",
    "じてん",
    "じどう",
    "しなぎれ",
    "しなもの",
    "しなん",
    "しねま",
    "しねん",
    "しのぐ",
    "しのぶ",
    "しはい",
    "しばかり",
    "しはつ",
    "しはらい",
    "しはん",
    "しひょう",
    "しふく",
    "じぶん",
    "しへい",
    "しほう",
    "しほん",
    "しまう",
    "しまる",
    "しみん",
    "しむける",
    "じむしょ",
    "しめい",
    "しめる",
    "しもん",
    "しゃいん",
    "しゃうん",
    "しゃおん",
    "じゃがいも",
    "しやくしょ",
    "しゃくほう",
    "しゃけん",
    "しゃこ",
    "しゃざい",
    "しゃしん",
    "しゃせん",
    "しゃそう",
    "しゃたい",
    "しゃちょう",
    "しゃっきん",
    "じゃま",
    "しゃりん",
    "しゃれい",
    "じゆう",
    "じゅうしょ",
    "しゅくはく",
    "じゅしん",
    "しゅっせき",
    "しゅみ",
    "しゅらば",
    "じゅんばん",
    "しょうかい",
    "しょくたく",
    "しょっけん",
    "しょどう",
    "しょもつ",
    "しらせる",
    "しらべる",
    "しんか",
    "しんこう",
    "じんじゃ",
    "しんせいじ",
    "しんちく",
    "しんりん",
    "すあげ",
    "すあし",
    "すあな",
    "ずあん",
    "すいえい",
    "すいか",
    "すいとう",
    "ずいぶん",
    "すいようび",
    "すうがく",
    "すうじつ",
    "すうせん",
    "すおどり",
    "すきま",
    "すくう",
    "すくない",
    "すける",
    "すごい",
    "すこし",
    "ずさん",
    "すずしい",
    "すすむ",
    "すすめる",
    "すっかり",
    "ずっしり",
    "ずっと",
    "すてき",
    "すてる",
    "すねる",
    "すのこ",
    "すはだ",
    "すばらしい",
    "ずひょう",
    "ずぶぬれ",
    "すぶり",
    "すふれ",
    "すべて",
    "すべる",
    "ずほう",
    "すぼん",
    "すまい",
    "すめし",
    "すもう",
    "すやき",
    "すらすら",
    "するめ",
    "すれちがう",
    "すろっと",
    "すわる",
    "すんぜん",
    "すんぽう",
    "せあぶら",
    "せいかつ",
    "せいげん",
    "せいじ",
    "せいよう",
    "せおう",
    "せかいかん",
    "せきにん",
    "せきむ",
    "せきゆ",
    "せきらんうん",
    "せけん",
    "せこう",
    "せすじ",
    "せたい",
    "せたけ",
    "せっかく",
    "せっきゃく",
    "ぜっく",
    "せっけん",
    "せっこつ",
    "せっさたくま",
    "せつぞく",
    "せつだん",
    "せつでん",
    "せっぱん",
    "せつび",
    "せつぶん",
    "せつめい",
    "せつりつ",
    "せなか",
    "せのび",
    "せはば",
    "せびろ",
    "せぼね",
    "せまい",
    "せまる",
    "せめる",
    "せもたれ",
    "せりふ",
    "ぜんあく",
    "せんい",
    "せんえい",
    "せんか",
    "せんきょ",
    "せんく",
    "せんげん",
    "ぜんご",
    "せんさい",
    "せんしゅ",
    "せんすい",
    "せんせい",
    "せんぞ",
    "せんたく",
    "せんちょう",
    "せんてい",
    "せんとう",
    "せんぬき",
    "せんねん",
    "せんぱい",
    "ぜんぶ",
    "ぜんぽう",
    "せんむ",
    "せんめんじょ",
    "せんもん",
    "せんやく",
    "せんゆう",
    "せんよう",
    "ぜんら",
    "ぜんりゃく",
    "せんれい",
    "せんろ",
    "そあく",
    "そいとげる",
    "そいね",
    "そうがんきょう",
    "そうき",
    "そうご",
    "そうしん",
    "そうだん",
    "そうなん",
    "そうび",
    "そうめん",
    "そうり",
    "そえもの",
    "そえん",
    "そがい",
    "そげき",
    "そこう",
    "そこそこ",
    "そざい",
    "そしな",
    "そせい",
    "そせん",
    "そそぐ",
    "そだてる",
    "そつう",
    "そつえん",
    "そっかん",
    "そつぎょう",
    "そっけつ",
    "そっこう",
    "そっせん",
    "そっと",
    "そとがわ",
    "そとづら",
    "そなえる",
    "そなた",
    "そふぼ",
    "そぼく",
    "そぼろ",
    "そまつ",
    "そまる",
    "そむく",
    "そむりえ",
    "そめる",
    "そもそも",
    "そよかぜ",
    "そらまめ",
    "そろう",
    "そんかい",
    "そんけい",
    "そんざい",
    "そんしつ",
    "そんぞく",
    "そんちょう",
    "ぞんび",
    "ぞんぶん",
    "そんみん",
    "たあい",
    "たいいん",
    "たいうん",
    "たいえき",
    "たいおう",
    "だいがく",
    "たいき",
    "たいぐう",
    "たいけん",
    "たいこ",
    "たいざい",
    "だいじょうぶ",
    "だいすき",
    "たいせつ",
    "たいそう",
    "だいたい",
    "たいちょう",
    "たいてい",
    "だいどころ",
    "たいない",
    "たいねつ",
    "たいのう",
    "たいはん",
    "だいひょう",
    "たいふう",
    "たいへん",
    "たいほ",
    "たいまつばな",
    "たいみんぐ",
    "たいむ",
    "たいめん",
    "たいやき",
    "たいよう",
    "たいら",
    "たいりょく",
    "たいる",
    "たいわん",
    "たうえ",
    "たえる",
    "たおす",
    "たおる",
    "たおれる",
    "たかい",
    "たかね",
    "たきび",
    "たくさん",
    "たこく",
    "たこやき",
    "たさい",
    "たしざん",
    "だじゃれ",
    "たすける",
    "たずさわる",
    "たそがれ",
    "たたかう",
    "たたく",
    "ただしい",
    "たたみ",
    "たちばな",
    "だっかい",
    "だっきゃく",
    "だっこ",
    "だっしゅつ",
    "だったい",
    "たてる",
    "たとえる",
    "たなばた",
    "たにん",
    "たぬき",
    "たのしみ",
    "たはつ",
    "たぶん",
    "たべる",
    "たぼう",
    "たまご",
    "たまる",
    "だむる",
    "ためいき",
    "ためす",
    "ためる",
    "たもつ",
    "たやすい",
    "たよる",
    "たらす",
    "たりきほんがん",
    "たりょう",
    "たりる",
    "たると",
    "たれる",
    "たれんと",
    "たろっと",
    "たわむれる",
    "だんあつ",
    "たんい",
    "たんおん",
    "たんか",
    "たんき",
    "たんけん",
    "たんご",
    "たんさん",
    "たんじょうび",
    "だんせい",
    "たんそく",
    "たんたい",
    "だんち",
    "たんてい",
    "たんとう",
    "だんな",
    "たんにん",
    "だんねつ",
    "たんのう",
    "たんぴん",
    "だんぼう",
    "たんまつ",
    "たんめい",
    "だんれつ",
    "だんろ",
    "だんわ",
    "ちあい",
    "ちあん",
    "ちいき",
    "ちいさい",
    "ちえん",
    "ちかい",
    "ちから",
    "ちきゅう",
    "ちきん",
    "ちけいず",
    "ちけん",
    "ちこく",
    "ちさい",
    "ちしき",
    "ちしりょう",
    "ちせい",
    "ちそう",
    "ちたい",
    "ちたん",
    "ちちおや",
    "ちつじょ",
    "ちてき",
    "ちてん",
    "ちぬき",
    "ちぬり",
    "ちのう",
    "ちひょう",
    "ちへいせん",
    "ちほう",
    "ちまた",
    "ちみつ",
    "ちみどろ",
    "ちめいど",
    "ちゃんこなべ",
    "ちゅうい",
    "ちゆりょく",
    "ちょうし",
    "ちょさくけん",
    "ちらし",
    "ちらみ",
    "ちりがみ",
    "ちりょう",
    "ちるど",
    "ちわわ",
    "ちんたい",
    "ちんもく",
    "ついか",
    "ついたち",
    "つうか",
    "つうじょう",
    "つうはん",
    "つうわ",
    "つかう",
    "つかれる",
    "つくね",
    "つくる",
    "つけね",
    "つける",
    "つごう",
    "つたえる",
    "つづく",
    "つつじ",
    "つつむ",
    "つとめる",
    "つながる",
    "つなみ",
    "つねづね",
    "つのる",
    "つぶす",
    "つまらない",
    "つまる",
    "つみき",
    "つめたい",
    "つもり",
    "つもる",
    "つよい",
    "つるぼ",
    "つるみく",
    "つわもの",
    "つわり",
    "てあし",
    "てあて",
    "てあみ",
    "ていおん",
    "ていか",
    "ていき",
    "ていけい",
    "ていこく",
    "ていさつ",
    "ていし",
    "ていせい",
    "ていたい",
    "ていど",
    "ていねい",
    "ていひょう",
    "ていへん",
    "ていぼう",
    "てうち",
    "ておくれ",
    "てきとう",
    "てくび",
    "でこぼこ",
    "てさぎょう",
    "てさげ",
    "てすり",
    "てそう",
    "てちがい",
    "てちょう",
    "てつがく",
    "てつづき",
    "でっぱ",
    "てつぼう",
    "てつや",
    "でぬかえ",
    "てぬき",
    "てぬぐい",
    "てのひら",
    "てはい",
    "てぶくろ",
    "てふだ",
    "てほどき",
    "てほん",
    "てまえ",
    "てまきずし",
    "てみじか",
    "てみやげ",
    "てらす",
    "てれび",
    "てわけ",
    "てわたし",
    "でんあつ",
    "てんいん",
    "てんかい",
    "てんき",
    "てんぐ",
    "てんけん",
    "てんごく",
    "てんさい",
    "てんし",
    "てんすう",
    "でんち",
    "てんてき",
    "てんとう",
    "てんない",
    "てんぷら",
    "てんぼうだい",
    "てんめつ",
    "てんらんかい",
    "でんりょく",
    "でんわ",
    "どあい",
    "といれ",
    "どうかん",
    "とうきゅう",
    "どうぐ",
    "とうし",
    "とうむぎ",
    "とおい",
    "とおか",
    "とおく",
    "とおす",
    "とおる",
    "とかい",
    "とかす",
    "ときおり",
    "ときどき",
    "とくい",
    "とくしゅう",
    "とくてん",
    "とくに",
    "とくべつ",
    "とけい",
    "とける",
    "とこや",
    "とさか",
    "としょかん",
    "とそう",
    "とたん",
    "とちゅう",
    "とっきゅう",
    "とっくん",
    "とつぜん",
    "とつにゅう",
    "とどける",
    "ととのえる",
    "とない",
    "となえる",
    "となり",
    "とのさま",
    "とばす",
    "どぶがわ",
    "とほう",
    "とまる",
    "とめる",
    "ともだち",
    "ともる",
    "どようび",
    "とらえる",
    "とんかつ",
    "どんぶり",
    "ないかく",
    "ないこう",
    "ないしょ",
    "ないす",
    "ないせん",
    "ないそう",
    "なおす",
    "ながい",
    "なくす",
    "なげる",
    "なこうど",
    "なさけ",
    "なたでここ",
    "なっとう",
    "なつやすみ",
    "ななおし",
    "なにごと",
    "なにもの",
    "なにわ",
    "なのか",
    "なふだ",
    "なまいき",
    "なまえ",
    "なまみ",
    "なみだ",
    "なめらか",
    "なめる",
    "なやむ",
    "ならう",
    "ならび",
    "ならぶ",
    "なれる",
    "なわとび",
    "なわばり",
    "にあう",
    "にいがた",
    "にうけ",
    "におい",
    "にかい",
    "にがて",
    "にきび",
    "にくしみ",
    "にくまん",
    "にげる",
    "にさんかたんそ",
    "にしき",
    "にせもの",
    "にちじょう",
    "にちようび",
    "にっか",
    "にっき",
    "にっけい",
    "にっこう",
    "にっさん",
    "にっしょく",
    "にっすう",
    "にっせき",
    "にってい",
    "になう",
    "にほん",
    "にまめ",
    "にもつ",
    "にやり",
    "にゅういん",
    "にりんしゃ",
    "にわとり",
    "にんい",
    "にんか",
    "にんき",
    "にんげん",
    "にんしき",
    "にんずう",
    "にんそう",
    "にんたい",
    "にんち",
    "にんてい",
    "にんにく",
    "にんぷ",
    "にんまり",
    "にんむ",
    "にんめい",
    "にんよう",
    "ぬいくぎ",
    "ぬかす",
    "ぬぐいとる",
    "ぬぐう",
    "ぬくもり",
    "ぬすむ",
    "ぬまえび",
    "ぬめり",
    "ぬらす",
    "ぬんちゃく",
    "ねあげ",
    "ねいき",
    "ねいる",
    "ねいろ",
    "ねぐせ",
    "ねくたい",
    "ねくら",
    "ねこぜ",
    "ねこむ",
    "ねさげ",
    "ねすごす",
    "ねそべる",
    "ねだん",
    "ねつい",
    "ねっしん",
    "ねつぞう",
    "ねったいぎょ",
    "ねぶそく",
    "ねふだ",
    "ねぼう",
    "ねほりはほり",
    "ねまき",
    "ねまわし",
    "ねみみ",
    "ねむい",
    "ねむたい",
    "ねもと",
    "ねらう",
    "ねわざ",
    "ねんいり",
    "ねんおし",
    "ねんかん",
    "ねんきん",
    "ねんぐ",
    "ねんざ",
    "ねんし",
    "ねんちゃく",
    "ねんど",
    "ねんぴ",
    "ねんぶつ",
    "ねんまつ",
    "ねんりょう",
    "ねんれい",
    "のいず",
    "のおづま",
    "のがす",
    "のきなみ",
    "のこぎり",
    "のこす",
    "のこる",
    "のせる",
    "のぞく",
    "のぞむ",
    "のたまう",
    "のちほど",
    "のっく",
    "のばす",
    "のはら",
    "のべる",
    "のぼる",
    "のみもの",
    "のやま",
    "のらいぬ",
    "のらねこ",
    "のりもの",
    "のりゆき",
    "のれん",
    "のんき",
    "ばあい",
    "はあく",
    "ばあさん",
    "ばいか",
    "ばいく",
    "はいけん",
    "はいご",
    "はいしん",
    "はいすい",
    "はいせん",
    "はいそう",
    "はいち",
    "ばいばい",
    "はいれつ",
    "はえる",
    "はおる",
    "はかい",
    "ばかり",
    "はかる",
    "はくしゅ",
    "はけん",
    "はこぶ",
    "はさみ",
    "はさん",
    "はしご",
    "ばしょ",
    "はしる",
    "はせる",
    "ぱそこん",
    "はそん",
    "はたん",
    "はちみつ",
    "はつおん",
    "はっかく",
    "はづき",
    "はっきり",
    "はっくつ",
    "はっけん",
    "はっこう",
    "はっさん",
    "はっしん",
    "はったつ",
    "はっちゅう",
    "はってん",
    "はっぴょう",
    "はっぽう",
    "はなす",
    "はなび",
    "はにかむ",
    "はぶらし",
    "はみがき",
    "はむかう",
    "はめつ",
    "はやい",
    "はやし",
    "はらう",
    "はろうぃん",
    "はわい",
    "はんい",
    "はんえい",
    "はんおん",
    "はんかく",
    "はんきょう",
    "ばんぐみ",
    "はんこ",
    "はんしゃ",
    "はんすう",
    "はんだん",
    "ぱんち",
    "ぱんつ",
    "はんてい",
    "はんとし",
    "はんのう",
    "はんぱ",
    "はんぶん",
    "はんぺん",
    "はんぼうき",
    "はんめい",
    "はんらん",
    "はんろん",
    "ひいき",
    "ひうん",
    "ひえる",
    "ひかく",
    "ひかり",
    "ひかる",
    "ひかん",
    "ひくい",
    "ひけつ",
    "ひこうき",
    "ひこく",
    "ひさい",
    "ひさしぶり",
    "ひさん",
    "びじゅつかん",
    "ひしょ",
    "ひそか",
    "ひそむ",
    "ひたむき",
    "ひだり",
    "ひたる",
    "ひつぎ",
    "ひっこし",
    "ひっし",
    "ひつじゅひん",
    "ひっす",
    "ひつぜん",
    "ぴったり",
    "ぴっちり",
    "ひつよう",
    "ひてい",
    "ひとごみ",
    "ひなまつり",
    "ひなん",
    "ひねる",
    "ひはん",
    "ひびく",
    "ひひょう",
    "ひほう",
    "ひまわり",
    "ひまん",
    "ひみつ",
    "ひめい",
    "ひめじし",
    "ひやけ",
    "ひやす",
    "ひよう",
    "びょうき",
    "ひらがな",
    "ひらく",
    "ひりつ",
    "ひりょう",
    "ひるま",
    "ひるやすみ",
    "ひれい",
    "ひろい",
    "ひろう",
    "ひろき",
    "ひろゆき",
    "ひんかく",
    "ひんけつ",
    "ひんこん",
    "ひんしゅ",
    "ひんそう",
    "ぴんち",
    "ひんぱん",
    "びんぼう",
    "ふあん",
    "ふいうち",
    "ふうけい",
    "ふうせん",
    "ぷうたろう",
    "ふうとう",
    "ふうふ",
    "ふえる",
    "ふおん",
    "ふかい",
    "ふきん",
    "ふくざつ",
    "ふくぶくろ",
    "ふこう",
    "ふさい",
    "ふしぎ",
    "ふじみ",
    "ふすま",
    "ふせい",
    "ふせぐ",
    "ふそく",
    "ぶたにく",
    "ふたん",
    "ふちょう",
    "ふつう",
    "ふつか",
    "ふっかつ",
    "ふっき",
    "ふっこく",
    "ぶどう",
    "ふとる",
    "ふとん",
    "ふのう",
    "ふはい",
    "ふひょう",
    "ふへん",
    "ふまん",
    "ふみん",
    "ふめつ",
    "ふめん",
    "ふよう",
    "ふりこ",
    "ふりる",
    "ふるい",
    "ふんいき",
    "ぶんがく",
    "ぶんぐ",
    "ふんしつ",
    "ぶんせき",
    "ふんそう",
    "ぶんぽう",
    "へいあん",
    "へいおん",
    "へいがい",
    "へいき",
    "へいげん",
    "へいこう",
    "へいさ",
    "へいしゃ",
    "へいせつ",
    "へいそ",
    "へいたく",
    "へいてん",
    "へいねつ",
    "へいわ",
    "へきが",
    "へこむ",
    "べにいろ",
    "べにしょうが",
    "へらす",
    "へんかん",
    "べんきょう",
    "べんごし",
    "へんさい",
    "へんたい",
    "べんり",
    "ほあん",
    "ほいく",
    "ぼうぎょ",
    "ほうこく",
    "ほうそう",
    "ほうほう",
    "ほうもん",
    "ほうりつ",
    "ほえる",
    "ほおん",
    "ほかん",
    "ほきょう",
    "ぼきん",
    "ほくろ",
    "ほけつ",
    "ほけん",
    "ほこう",
    "ほこる",
    "ほしい",
    "ほしつ",
    "ほしゅ",
    "ほしょう",
    "ほせい",
    "ほそい",
    "ほそく",
    "ほたて",
    "ほたる",
    "ぽちぶくろ",
    "ほっきょく",
    "ほっさ",
    "ほったん",
    "ほとんど",
    "ほめる",
    "ほんい",
    "ほんき",
    "ほんけ",
    "ほんしつ",
    "ほんやく",
    "まいにち",
    "まかい",
    "まかせる",
    "まがる",
    "まける",
    "まこと",
    "まさつ",
    "まじめ",
    "ますく",
    "まぜる",
    "まつり",
    "まとめ",
    "まなぶ",
    "まぬけ",
    "まねく",
    "まほう",
    "まもる",
    "まゆげ",
    "まよう",
    "まろやか",
    "まわす",
    "まわり",
    "まわる",
    "まんが",
    "まんきつ",
    "まんぞく",
    "まんなか",
    "みいら",
    "みうち",
    "みえる",
    "みがく",
    "みかた",
    "みかん",
    "みけん",
    "みこん",
    "みじかい",
    "みすい",
    "みすえる",
    "みせる",
    "みっか",
    "みつかる",
    "みつける",
    "みてい",
    "みとめる",
    "みなと",
    "みなみかさい",
    "みねらる",
    "みのう",
    "みのがす",
    "みほん",
    "みもと",
    "みやげ",
    "みらい",
    "みりょく",
    "みわく",
    "みんか",
    "みんぞく",
    "むいか",
    "むえき",
    "むえん",
    "むかい",
    "むかう",
    "むかえ",
    "むかし",
    "むぎちゃ",
    "むける",
    "むげん",
    "むさぼる",
    "むしあつい",
    "むしば",
    "むじゅん",
    "むしろ",
    "むすう",
    "むすこ",
    "むすぶ",
    "むすめ",
    "むせる",
    "むせん",
    "むちゅう",
    "むなしい",
    "むのう",
    "むやみ",
    "むよう",
    "むらさき",
    "むりょう",
    "むろん",
    "めいあん",
    "めいうん",
    "めいえん",
    "めいかく",
    "めいきょく",
    "めいさい",
    "めいし",
    "めいそう",
    "めいぶつ",
    "めいれい",
    "めいわく",
    "めぐまれる",
    "めざす",
    "めした",
    "めずらしい",
    "めだつ",
    "めまい",
    "めやす",
    "めんきょ",
    "めんせき",
    "めんどう",
    "もうしあげる",
    "もうどうけん",
    "もえる",
    "もくし",
    "もくてき",
    "もくようび",
    "もちろん",
    "もどる",
    "もらう",
    "もんく",
    "もんだい",
    "やおや",
    "やける",
    "やさい",
    "やさしい",
    "やすい",
    "やすたろう",
    "やすみ",
    "やせる",
    "やそう",
    "やたい",
    "やちん",
    "やっと",
    "やっぱり",
    "やぶる",
    "やめる",
    "ややこしい",
    "やよい",
    "やわらかい",
    "ゆうき",
    "ゆうびんきょく",
    "ゆうべ",
    "ゆうめい",
    "ゆけつ",
    "ゆしゅつ",
    "ゆせん",
    "ゆそう",
    "ゆたか",
    "ゆちゃく",
    "ゆでる",
    "ゆにゅう",
    "ゆびわ",
    "ゆらい",
    "ゆれる",
    "ようい",
    "ようか",
    "ようきゅう",
    "ようじ",
    "ようす",
    "ようちえん",
    "よかぜ",
    "よかん",
    "よきん",
    "よくせい",
    "よくぼう",
    "よけい",
    "よごれる",
    "よさん",
    "よしゅう",
    "よそう",
    "よそく",
    "よっか",
    "よてい",
    "よどがわく",
    "よねつ",
    "よやく",
    "よゆう",
    "よろこぶ",
    "よろしい",
    "らいう",
    "らくがき",
    "らくご",
    "らくさつ",
    "らくだ",
    "らしんばん",
    "らせん",
    "らぞく",
    "らたい",
    "らっか",
    "られつ",
    "りえき",
    "りかい",
    "りきさく",
    "りきせつ",
    "りくぐん",
    "りくつ",
    "りけん",
    "りこう",
    "りせい",
    "りそう",
    "りそく",
    "りてん",
    "りねん",
    "りゆう",
    "りゅうがく",
    "りよう",
    "りょうり",
    "りょかん",
    "りょくちゃ",
    "りょこう",
    "りりく",
    "りれき",
    "りろん",
    "りんご",
    "るいけい",
    "るいさい",
    "るいじ",
    "るいせき",
    "るすばん",
    "るりがわら",
    "れいかん",
    "れいぎ",
    "れいせい",
    "れいぞうこ",
    "れいとう",
    "れいぼう",
    "れきし",
    "れきだい",
    "れんあい",
    "れんけい",
    "れんこん",
    "れんさい",
    "れんしゅう",
    "れんぞく",
    "れんらく",
    "ろうか",
    "ろうご",
    "ろうじん",
    "ろうそく",
    "ろくが",
    "ろこつ",
    "ろじうら",
    "ろしゅつ",
    "ろせん",
    "ろてん",
    "ろめん",
    "ろれつ",
    "ろんぎ",
    "ろんぱ",
    "ろんぶん",
    "ろんり",
    "わかす",
    "わかめ",
    "わかやま",
    "わかれる",
    "わしつ",
    "わじまし",
    "わすれもの",
    "わらう",
    "われる"
]

},{}],98:[function(require,module,exports){
module.exports=[
    "가격",
    "가끔",
    "가난",
    "가능",
    "가득",
    "가르침",
    "가뭄",
    "가방",
    "가상",
    "가슴",
    "가운데",
    "가을",
    "가이드",
    "가입",
    "가장",
    "가정",
    "가족",
    "가죽",
    "각오",
    "각자",
    "간격",
    "간부",
    "간섭",
    "간장",
    "간접",
    "간판",
    "갈등",
    "갈비",
    "갈색",
    "갈증",
    "감각",
    "감기",
    "감소",
    "감수성",
    "감자",
    "감정",
    "갑자기",
    "강남",
    "강당",
    "강도",
    "강력히",
    "강변",
    "강북",
    "강사",
    "강수량",
    "강아지",
    "강원도",
    "강의",
    "강제",
    "강조",
    "같이",
    "개구리",
    "개나리",
    "개방",
    "개별",
    "개선",
    "개성",
    "개인",
    "객관적",
    "거실",
    "거액",
    "거울",
    "거짓",
    "거품",
    "걱정",
    "건강",
    "건물",
    "건설",
    "건조",
    "건축",
    "걸음",
    "검사",
    "검토",
    "게시판",
    "게임",
    "겨울",
    "견해",
    "결과",
    "결국",
    "결론",
    "결석",
    "결승",
    "결심",
    "결정",
    "결혼",
    "경계",
    "경고",
    "경기",
    "경력",
    "경복궁",
    "경비",
    "경상도",
    "경영",
    "경우",
    "경쟁",
    "경제",
    "경주",
    "경찰",
    "경치",
    "경향",
    "경험",
    "계곡",
    "계단",
    "계란",
    "계산",
    "계속",
    "계약",
    "계절",
    "계층",
    "계획",
    "고객",
    "고구려",
    "고궁",
    "고급",
    "고등학생",
    "고무신",
    "고민",
    "고양이",
    "고장",
    "고전",
    "고집",
    "고춧가루",
    "고통",
    "고향",
    "곡식",
    "골목",
    "골짜기",
    "골프",
    "공간",
    "공개",
    "공격",
    "공군",
    "공급",
    "공기",
    "공동",
    "공무원",
    "공부",
    "공사",
    "공식",
    "공업",
    "공연",
    "공원",
    "공장",
    "공짜",
    "공책",
    "공통",
    "공포",
    "공항",
    "공휴일",
    "과목",
    "과일",
    "과장",
    "과정",
    "과학",
    "관객",
    "관계",
    "관광",
    "관념",
    "관람",
    "관련",
    "관리",
    "관습",
    "관심",
    "관점",
    "관찰",
    "광경",
    "광고",
    "광장",
    "광주",
    "괴로움",
    "굉장히",
    "교과서",
    "교문",
    "교복",
    "교실",
    "교양",
    "교육",
    "교장",
    "교직",
    "교통",
    "교환",
    "교훈",
    "구경",
    "구름",
    "구멍",
    "구별",
    "구분",
    "구석",
    "구성",
    "구속",
    "구역",
    "구입",
    "구청",
    "구체적",
    "국가",
    "국기",
    "국내",
    "국립",
    "국물",
    "국민",
    "국수",
    "국어",
    "국왕",
    "국적",
    "국제",
    "국회",
    "군대",
    "군사",
    "군인",
    "궁극적",
    "권리",
    "권위",
    "권투",
    "귀국",
    "귀신",
    "규정",
    "규칙",
    "균형",
    "그날",
    "그냥",
    "그늘",
    "그러나",
    "그룹",
    "그릇",
    "그림",
    "그제서야",
    "그토록",
    "극복",
    "극히",
    "근거",
    "근교",
    "근래",
    "근로",
    "근무",
    "근본",
    "근원",
    "근육",
    "근처",
    "글씨",
    "글자",
    "금강산",
    "금고",
    "금년",
    "금메달",
    "금액",
    "금연",
    "금요일",
    "금지",
    "긍정적",
    "기간",
    "기관",
    "기념",
    "기능",
    "기독교",
    "기둥",
    "기록",
    "기름",
    "기법",
    "기본",
    "기분",
    "기쁨",
    "기숙사",
    "기술",
    "기억",
    "기업",
    "기온",
    "기운",
    "기원",
    "기적",
    "기준",
    "기침",
    "기혼",
    "기획",
    "긴급",
    "긴장",
    "길이",
    "김밥",
    "김치",
    "김포공항",
    "깍두기",
    "깜빡",
    "깨달음",
    "깨소금",
    "껍질",
    "꼭대기",
    "꽃잎",
    "나들이",
    "나란히",
    "나머지",
    "나물",
    "나침반",
    "나흘",
    "낙엽",
    "난방",
    "날개",
    "날씨",
    "날짜",
    "남녀",
    "남대문",
    "남매",
    "남산",
    "남자",
    "남편",
    "남학생",
    "낭비",
    "낱말",
    "내년",
    "내용",
    "내일",
    "냄비",
    "냄새",
    "냇물",
    "냉동",
    "냉면",
    "냉방",
    "냉장고",
    "넥타이",
    "넷째",
    "노동",
    "노란색",
    "노력",
    "노인",
    "녹음",
    "녹차",
    "녹화",
    "논리",
    "논문",
    "논쟁",
    "놀이",
    "농구",
    "농담",
    "농민",
    "농부",
    "농업",
    "농장",
    "농촌",
    "높이",
    "눈동자",
    "눈물",
    "눈썹",
    "뉴욕",
    "느낌",
    "늑대",
    "능동적",
    "능력",
    "다방",
    "다양성",
    "다음",
    "다이어트",
    "다행",
    "단계",
    "단골",
    "단독",
    "단맛",
    "단순",
    "단어",
    "단위",
    "단점",
    "단체",
    "단추",
    "단편",
    "단풍",
    "달걀",
    "달러",
    "달력",
    "달리",
    "닭고기",
    "담당",
    "담배",
    "담요",
    "담임",
    "답변",
    "답장",
    "당근",
    "당분간",
    "당연히",
    "당장",
    "대규모",
    "대낮",
    "대단히",
    "대답",
    "대도시",
    "대략",
    "대량",
    "대륙",
    "대문",
    "대부분",
    "대신",
    "대응",
    "대장",
    "대전",
    "대접",
    "대중",
    "대책",
    "대출",
    "대충",
    "대통령",
    "대학",
    "대한민국",
    "대합실",
    "대형",
    "덩어리",
    "데이트",
    "도대체",
    "도덕",
    "도둑",
    "도망",
    "도서관",
    "도심",
    "도움",
    "도입",
    "도자기",
    "도저히",
    "도전",
    "도중",
    "도착",
    "독감",
    "독립",
    "독서",
    "독일",
    "독창적",
    "동화책",
    "뒷모습",
    "뒷산",
    "딸아이",
    "마누라",
    "마늘",
    "마당",
    "마라톤",
    "마련",
    "마무리",
    "마사지",
    "마약",
    "마요네즈",
    "마을",
    "마음",
    "마이크",
    "마중",
    "마지막",
    "마찬가지",
    "마찰",
    "마흔",
    "막걸리",
    "막내",
    "막상",
    "만남",
    "만두",
    "만세",
    "만약",
    "만일",
    "만점",
    "만족",
    "만화",
    "많이",
    "말기",
    "말씀",
    "말투",
    "맘대로",
    "망원경",
    "매년",
    "매달",
    "매력",
    "매번",
    "매스컴",
    "매일",
    "매장",
    "맥주",
    "먹이",
    "먼저",
    "먼지",
    "멀리",
    "메일",
    "며느리",
    "며칠",
    "면담",
    "멸치",
    "명단",
    "명령",
    "명예",
    "명의",
    "명절",
    "명칭",
    "명함",
    "모금",
    "모니터",
    "모델",
    "모든",
    "모범",
    "모습",
    "모양",
    "모임",
    "모조리",
    "모집",
    "모퉁이",
    "목걸이",
    "목록",
    "목사",
    "목소리",
    "목숨",
    "목적",
    "목표",
    "몰래",
    "몸매",
    "몸무게",
    "몸살",
    "몸속",
    "몸짓",
    "몸통",
    "몹시",
    "무관심",
    "무궁화",
    "무더위",
    "무덤",
    "무릎",
    "무슨",
    "무엇",
    "무역",
    "무용",
    "무조건",
    "무지개",
    "무척",
    "문구",
    "문득",
    "문법",
    "문서",
    "문제",
    "문학",
    "문화",
    "물가",
    "물건",
    "물결",
    "물고기",
    "물론",
    "물리학",
    "물음",
    "물질",
    "물체",
    "미국",
    "미디어",
    "미사일",
    "미술",
    "미역",
    "미용실",
    "미움",
    "미인",
    "미팅",
    "미혼",
    "민간",
    "민족",
    "민주",
    "믿음",
    "밀가루",
    "밀리미터",
    "밑바닥",
    "바가지",
    "바구니",
    "바나나",
    "바늘",
    "바닥",
    "바닷가",
    "바람",
    "바이러스",
    "바탕",
    "박물관",
    "박사",
    "박수",
    "반대",
    "반드시",
    "반말",
    "반발",
    "반성",
    "반응",
    "반장",
    "반죽",
    "반지",
    "반찬",
    "받침",
    "발가락",
    "발걸음",
    "발견",
    "발달",
    "발레",
    "발목",
    "발바닥",
    "발생",
    "발음",
    "발자국",
    "발전",
    "발톱",
    "발표",
    "밤하늘",
    "밥그릇",
    "밥맛",
    "밥상",
    "밥솥",
    "방금",
    "방면",
    "방문",
    "방바닥",
    "방법",
    "방송",
    "방식",
    "방안",
    "방울",
    "방지",
    "방학",
    "방해",
    "방향",
    "배경",
    "배꼽",
    "배달",
    "배드민턴",
    "백두산",
    "백색",
    "백성",
    "백인",
    "백제",
    "백화점",
    "버릇",
    "버섯",
    "버튼",
    "번개",
    "번역",
    "번지",
    "번호",
    "벌금",
    "벌레",
    "벌써",
    "범위",
    "범인",
    "범죄",
    "법률",
    "법원",
    "법적",
    "법칙",
    "베이징",
    "벨트",
    "변경",
    "변동",
    "변명",
    "변신",
    "변호사",
    "변화",
    "별도",
    "별명",
    "별일",
    "병실",
    "병아리",
    "병원",
    "보관",
    "보너스",
    "보라색",
    "보람",
    "보름",
    "보상",
    "보안",
    "보자기",
    "보장",
    "보전",
    "보존",
    "보통",
    "보편적",
    "보험",
    "복도",
    "복사",
    "복숭아",
    "복습",
    "볶음",
    "본격적",
    "본래",
    "본부",
    "본사",
    "본성",
    "본인",
    "본질",
    "볼펜",
    "봉사",
    "봉지",
    "봉투",
    "부근",
    "부끄러움",
    "부담",
    "부동산",
    "부문",
    "부분",
    "부산",
    "부상",
    "부엌",
    "부인",
    "부작용",
    "부장",
    "부정",
    "부족",
    "부지런히",
    "부친",
    "부탁",
    "부품",
    "부회장",
    "북부",
    "북한",
    "분노",
    "분량",
    "분리",
    "분명",
    "분석",
    "분야",
    "분위기",
    "분필",
    "분홍색",
    "불고기",
    "불과",
    "불교",
    "불꽃",
    "불만",
    "불법",
    "불빛",
    "불안",
    "불이익",
    "불행",
    "브랜드",
    "비극",
    "비난",
    "비닐",
    "비둘기",
    "비디오",
    "비로소",
    "비만",
    "비명",
    "비밀",
    "비바람",
    "비빔밥",
    "비상",
    "비용",
    "비율",
    "비중",
    "비타민",
    "비판",
    "빌딩",
    "빗물",
    "빗방울",
    "빗줄기",
    "빛깔",
    "빨간색",
    "빨래",
    "빨리",
    "사건",
    "사계절",
    "사나이",
    "사냥",
    "사람",
    "사랑",
    "사립",
    "사모님",
    "사물",
    "사방",
    "사상",
    "사생활",
    "사설",
    "사슴",
    "사실",
    "사업",
    "사용",
    "사월",
    "사장",
    "사전",
    "사진",
    "사촌",
    "사춘기",
    "사탕",
    "사투리",
    "사흘",
    "산길",
    "산부인과",
    "산업",
    "산책",
    "살림",
    "살인",
    "살짝",
    "삼계탕",
    "삼국",
    "삼십",
    "삼월",
    "삼촌",
    "상관",
    "상금",
    "상대",
    "상류",
    "상반기",
    "상상",
    "상식",
    "상업",
    "상인",
    "상자",
    "상점",
    "상처",
    "상추",
    "상태",
    "상표",
    "상품",
    "상황",
    "새벽",
    "색깔",
    "색연필",
    "생각",
    "생명",
    "생물",
    "생방송",
    "생산",
    "생선",
    "생신",
    "생일",
    "생활",
    "서랍",
    "서른",
    "서명",
    "서민",
    "서비스",
    "서양",
    "서울",
    "서적",
    "서점",
    "서쪽",
    "서클",
    "석사",
    "석유",
    "선거",
    "선물",
    "선배",
    "선생",
    "선수",
    "선원",
    "선장",
    "선전",
    "선택",
    "선풍기",
    "설거지",
    "설날",
    "설렁탕",
    "설명",
    "설문",
    "설사",
    "설악산",
    "설치",
    "설탕",
    "섭씨",
    "성공",
    "성당",
    "성명",
    "성별",
    "성인",
    "성장",
    "성적",
    "성질",
    "성함",
    "세금",
    "세미나",
    "세상",
    "세월",
    "세종대왕",
    "세탁",
    "센터",
    "센티미터",
    "셋째",
    "소규모",
    "소극적",
    "소금",
    "소나기",
    "소년",
    "소득",
    "소망",
    "소문",
    "소설",
    "소속",
    "소아과",
    "소용",
    "소원",
    "소음",
    "소중히",
    "소지품",
    "소질",
    "소풍",
    "소형",
    "속담",
    "속도",
    "속옷",
    "손가락",
    "손길",
    "손녀",
    "손님",
    "손등",
    "손목",
    "손뼉",
    "손실",
    "손질",
    "손톱",
    "손해",
    "솔직히",
    "솜씨",
    "송아지",
    "송이",
    "송편",
    "쇠고기",
    "쇼핑",
    "수건",
    "수년",
    "수단",
    "수돗물",
    "수동적",
    "수면",
    "수명",
    "수박",
    "수상",
    "수석",
    "수술",
    "수시로",
    "수업",
    "수염",
    "수영",
    "수입",
    "수준",
    "수집",
    "수출",
    "수컷",
    "수필",
    "수학",
    "수험생",
    "수화기",
    "숙녀",
    "숙소",
    "숙제",
    "순간",
    "순서",
    "순수",
    "순식간",
    "순위",
    "숟가락",
    "술병",
    "술집",
    "숫자",
    "스님",
    "스물",
    "스스로",
    "스승",
    "스웨터",
    "스위치",
    "스케이트",
    "스튜디오",
    "스트레스",
    "스포츠",
    "슬쩍",
    "슬픔",
    "습관",
    "습기",
    "승객",
    "승리",
    "승부",
    "승용차",
    "승진",
    "시각",
    "시간",
    "시골",
    "시금치",
    "시나리오",
    "시댁",
    "시리즈",
    "시멘트",
    "시민",
    "시부모",
    "시선",
    "시설",
    "시스템",
    "시아버지",
    "시어머니",
    "시월",
    "시인",
    "시일",
    "시작",
    "시장",
    "시절",
    "시점",
    "시중",
    "시즌",
    "시집",
    "시청",
    "시합",
    "시험",
    "식구",
    "식기",
    "식당",
    "식량",
    "식료품",
    "식물",
    "식빵",
    "식사",
    "식생활",
    "식초",
    "식탁",
    "식품",
    "신고",
    "신규",
    "신념",
    "신문",
    "신발",
    "신비",
    "신사",
    "신세",
    "신용",
    "신제품",
    "신청",
    "신체",
    "신화",
    "실감",
    "실내",
    "실력",
    "실례",
    "실망",
    "실수",
    "실습",
    "실시",
    "실장",
    "실정",
    "실질적",
    "실천",
    "실체",
    "실컷",
    "실태",
    "실패",
    "실험",
    "실현",
    "심리",
    "심부름",
    "심사",
    "심장",
    "심정",
    "심판",
    "쌍둥이",
    "씨름",
    "씨앗",
    "아가씨",
    "아나운서",
    "아드님",
    "아들",
    "아쉬움",
    "아스팔트",
    "아시아",
    "아울러",
    "아저씨",
    "아줌마",
    "아직",
    "아침",
    "아파트",
    "아프리카",
    "아픔",
    "아홉",
    "아흔",
    "악기",
    "악몽",
    "악수",
    "안개",
    "안경",
    "안과",
    "안내",
    "안녕",
    "안동",
    "안방",
    "안부",
    "안주",
    "알루미늄",
    "알코올",
    "암시",
    "암컷",
    "압력",
    "앞날",
    "앞문",
    "애인",
    "애정",
    "액수",
    "앨범",
    "야간",
    "야단",
    "야옹",
    "약간",
    "약국",
    "약속",
    "약수",
    "약점",
    "약품",
    "약혼녀",
    "양념",
    "양력",
    "양말",
    "양배추",
    "양주",
    "양파",
    "어둠",
    "어려움",
    "어른",
    "어젯밤",
    "어쨌든",
    "어쩌다가",
    "어쩐지",
    "언니",
    "언덕",
    "언론",
    "언어",
    "얼굴",
    "얼른",
    "얼음",
    "얼핏",
    "엄마",
    "업무",
    "업종",
    "업체",
    "엉덩이",
    "엉망",
    "엉터리",
    "엊그제",
    "에너지",
    "에어컨",
    "엔진",
    "여건",
    "여고생",
    "여관",
    "여군",
    "여권",
    "여대생",
    "여덟",
    "여동생",
    "여든",
    "여론",
    "여름",
    "여섯",
    "여성",
    "여왕",
    "여인",
    "여전히",
    "여직원",
    "여학생",
    "여행",
    "역사",
    "역시",
    "역할",
    "연결",
    "연구",
    "연극",
    "연기",
    "연락",
    "연설",
    "연세",
    "연속",
    "연습",
    "연애",
    "연예인",
    "연인",
    "연장",
    "연주",
    "연출",
    "연필",
    "연합",
    "연휴",
    "열기",
    "열매",
    "열쇠",
    "열심히",
    "열정",
    "열차",
    "열흘",
    "염려",
    "엽서",
    "영국",
    "영남",
    "영상",
    "영양",
    "영역",
    "영웅",
    "영원히",
    "영하",
    "영향",
    "영혼",
    "영화",
    "옆구리",
    "옆방",
    "옆집",
    "예감",
    "예금",
    "예방",
    "예산",
    "예상",
    "예선",
    "예술",
    "예습",
    "예식장",
    "예약",
    "예전",
    "예절",
    "예정",
    "예컨대",
    "옛날",
    "오늘",
    "오락",
    "오랫동안",
    "오렌지",
    "오로지",
    "오른발",
    "오븐",
    "오십",
    "오염",
    "오월",
    "오전",
    "오직",
    "오징어",
    "오페라",
    "오피스텔",
    "오히려",
    "옥상",
    "옥수수",
    "온갖",
    "온라인",
    "온몸",
    "온종일",
    "온통",
    "올가을",
    "올림픽",
    "올해",
    "옷차림",
    "와이셔츠",
    "와인",
    "완성",
    "완전",
    "왕비",
    "왕자",
    "왜냐하면",
    "왠지",
    "외갓집",
    "외국",
    "외로움",
    "외삼촌",
    "외출",
    "외침",
    "외할머니",
    "왼발",
    "왼손",
    "왼쪽",
    "요금",
    "요일",
    "요즘",
    "요청",
    "용기",
    "용서",
    "용어",
    "우산",
    "우선",
    "우승",
    "우연히",
    "우정",
    "우체국",
    "우편",
    "운동",
    "운명",
    "운반",
    "운전",
    "운행",
    "울산",
    "울음",
    "움직임",
    "웃어른",
    "웃음",
    "워낙",
    "원고",
    "원래",
    "원서",
    "원숭이",
    "원인",
    "원장",
    "원피스",
    "월급",
    "월드컵",
    "월세",
    "월요일",
    "웨이터",
    "위반",
    "위법",
    "위성",
    "위원",
    "위험",
    "위협",
    "윗사람",
    "유난히",
    "유럽",
    "유명",
    "유물",
    "유산",
    "유적",
    "유치원",
    "유학",
    "유행",
    "유형",
    "육군",
    "육상",
    "육십",
    "육체",
    "은행",
    "음력",
    "음료",
    "음반",
    "음성",
    "음식",
    "음악",
    "음주",
    "의견",
    "의논",
    "의문",
    "의복",
    "의식",
    "의심",
    "의외로",
    "의욕",
    "의원",
    "의학",
    "이것",
    "이곳",
    "이념",
    "이놈",
    "이달",
    "이대로",
    "이동",
    "이렇게",
    "이력서",
    "이론적",
    "이름",
    "이민",
    "이발소",
    "이별",
    "이불",
    "이빨",
    "이상",
    "이성",
    "이슬",
    "이야기",
    "이용",
    "이웃",
    "이월",
    "이윽고",
    "이익",
    "이전",
    "이중",
    "이튿날",
    "이틀",
    "이혼",
    "인간",
    "인격",
    "인공",
    "인구",
    "인근",
    "인기",
    "인도",
    "인류",
    "인물",
    "인생",
    "인쇄",
    "인연",
    "인원",
    "인재",
    "인종",
    "인천",
    "인체",
    "인터넷",
    "인하",
    "인형",
    "일곱",
    "일기",
    "일단",
    "일대",
    "일등",
    "일반",
    "일본",
    "일부",
    "일상",
    "일생",
    "일손",
    "일요일",
    "일월",
    "일정",
    "일종",
    "일주일",
    "일찍",
    "일체",
    "일치",
    "일행",
    "일회용",
    "임금",
    "임무",
    "입대",
    "입력",
    "입맛",
    "입사",
    "입술",
    "입시",
    "입원",
    "입장",
    "입학",
    "자가용",
    "자격",
    "자극",
    "자동",
    "자랑",
    "자부심",
    "자식",
    "자신",
    "자연",
    "자원",
    "자율",
    "자전거",
    "자정",
    "자존심",
    "자판",
    "작가",
    "작년",
    "작성",
    "작업",
    "작용",
    "작은딸",
    "작품",
    "잔디",
    "잔뜩",
    "잔치",
    "잘못",
    "잠깐",
    "잠수함",
    "잠시",
    "잠옷",
    "잠자리",
    "잡지",
    "장관",
    "장군",
    "장기간",
    "장래",
    "장례",
    "장르",
    "장마",
    "장면",
    "장모",
    "장미",
    "장비",
    "장사",
    "장소",
    "장식",
    "장애인",
    "장인",
    "장점",
    "장차",
    "장학금",
    "재능",
    "재빨리",
    "재산",
    "재생",
    "재작년",
    "재정",
    "재채기",
    "재판",
    "재학",
    "재활용",
    "저것",
    "저고리",
    "저곳",
    "저녁",
    "저런",
    "저렇게",
    "저번",
    "저울",
    "저절로",
    "저축",
    "적극",
    "적당히",
    "적성",
    "적용",
    "적응",
    "전개",
    "전공",
    "전기",
    "전달",
    "전라도",
    "전망",
    "전문",
    "전반",
    "전부",
    "전세",
    "전시",
    "전용",
    "전자",
    "전쟁",
    "전주",
    "전철",
    "전체",
    "전통",
    "전혀",
    "전후",
    "절대",
    "절망",
    "절반",
    "절약",
    "절차",
    "점검",
    "점수",
    "점심",
    "점원",
    "점점",
    "점차",
    "접근",
    "접시",
    "접촉",
    "젓가락",
    "정거장",
    "정도",
    "정류장",
    "정리",
    "정말",
    "정면",
    "정문",
    "정반대",
    "정보",
    "정부",
    "정비",
    "정상",
    "정성",
    "정오",
    "정원",
    "정장",
    "정지",
    "정치",
    "정확히",
    "제공",
    "제과점",
    "제대로",
    "제목",
    "제발",
    "제법",
    "제삿날",
    "제안",
    "제일",
    "제작",
    "제주도",
    "제출",
    "제품",
    "제한",
    "조각",
    "조건",
    "조금",
    "조깅",
    "조명",
    "조미료",
    "조상",
    "조선",
    "조용히",
    "조절",
    "조정",
    "조직",
    "존댓말",
    "존재",
    "졸업",
    "졸음",
    "종교",
    "종로",
    "종류",
    "종소리",
    "종업원",
    "종종",
    "종합",
    "좌석",
    "죄인",
    "주관적",
    "주름",
    "주말",
    "주머니",
    "주먹",
    "주문",
    "주민",
    "주방",
    "주변",
    "주식",
    "주인",
    "주일",
    "주장",
    "주전자",
    "주택",
    "준비",
    "줄거리",
    "줄기",
    "줄무늬",
    "중간",
    "중계방송",
    "중국",
    "중년",
    "중단",
    "중독",
    "중반",
    "중부",
    "중세",
    "중소기업",
    "중순",
    "중앙",
    "중요",
    "중학교",
    "즉석",
    "즉시",
    "즐거움",
    "증가",
    "증거",
    "증권",
    "증상",
    "증세",
    "지각",
    "지갑",
    "지경",
    "지극히",
    "지금",
    "지급",
    "지능",
    "지름길",
    "지리산",
    "지방",
    "지붕",
    "지식",
    "지역",
    "지우개",
    "지원",
    "지적",
    "지점",
    "지진",
    "지출",
    "직선",
    "직업",
    "직원",
    "직장",
    "진급",
    "진동",
    "진로",
    "진료",
    "진리",
    "진짜",
    "진찰",
    "진출",
    "진통",
    "진행",
    "질문",
    "질병",
    "질서",
    "짐작",
    "집단",
    "집안",
    "집중",
    "짜증",
    "찌꺼기",
    "차남",
    "차라리",
    "차량",
    "차림",
    "차별",
    "차선",
    "차츰",
    "착각",
    "찬물",
    "찬성",
    "참가",
    "참기름",
    "참새",
    "참석",
    "참여",
    "참외",
    "참조",
    "찻잔",
    "창가",
    "창고",
    "창구",
    "창문",
    "창밖",
    "창작",
    "창조",
    "채널",
    "채점",
    "책가방",
    "책방",
    "책상",
    "책임",
    "챔피언",
    "처벌",
    "처음",
    "천국",
    "천둥",
    "천장",
    "천재",
    "천천히",
    "철도",
    "철저히",
    "철학",
    "첫날",
    "첫째",
    "청년",
    "청바지",
    "청소",
    "청춘",
    "체계",
    "체력",
    "체온",
    "체육",
    "체중",
    "체험",
    "초등학생",
    "초반",
    "초밥",
    "초상화",
    "초순",
    "초여름",
    "초원",
    "초저녁",
    "초점",
    "초청",
    "초콜릿",
    "촛불",
    "총각",
    "총리",
    "총장",
    "촬영",
    "최근",
    "최상",
    "최선",
    "최신",
    "최악",
    "최종",
    "추석",
    "추억",
    "추진",
    "추천",
    "추측",
    "축구",
    "축소",
    "축제",
    "축하",
    "출근",
    "출발",
    "출산",
    "출신",
    "출연",
    "출입",
    "출장",
    "출판",
    "충격",
    "충고",
    "충돌",
    "충분히",
    "충청도",
    "취업",
    "취직",
    "취향",
    "치약",
    "친구",
    "친척",
    "칠십",
    "칠월",
    "칠판",
    "침대",
    "침묵",
    "침실",
    "칫솔",
    "칭찬",
    "카메라",
    "카운터",
    "칼국수",
    "캐릭터",
    "캠퍼스",
    "캠페인",
    "커튼",
    "컨디션",
    "컬러",
    "컴퓨터",
    "코끼리",
    "코미디",
    "콘서트",
    "콜라",
    "콤플렉스",
    "콩나물",
    "쾌감",
    "쿠데타",
    "크림",
    "큰길",
    "큰딸",
    "큰소리",
    "큰아들",
    "큰어머니",
    "큰일",
    "큰절",
    "클래식",
    "클럽",
    "킬로",
    "타입",
    "타자기",
    "탁구",
    "탁자",
    "탄생",
    "태권도",
    "태양",
    "태풍",
    "택시",
    "탤런트",
    "터널",
    "터미널",
    "테니스",
    "테스트",
    "테이블",
    "텔레비전",
    "토론",
    "토마토",
    "토요일",
    "통계",
    "통과",
    "통로",
    "통신",
    "통역",
    "통일",
    "통장",
    "통제",
    "통증",
    "통합",
    "통화",
    "퇴근",
    "퇴원",
    "퇴직금",
    "튀김",
    "트럭",
    "특급",
    "특별",
    "특성",
    "특수",
    "특징",
    "특히",
    "튼튼히",
    "티셔츠",
    "파란색",
    "파일",
    "파출소",
    "판결",
    "판단",
    "판매",
    "판사",
    "팔십",
    "팔월",
    "팝송",
    "패션",
    "팩스",
    "팩시밀리",
    "팬티",
    "퍼센트",
    "페인트",
    "편견",
    "편의",
    "편지",
    "편히",
    "평가",
    "평균",
    "평생",
    "평소",
    "평양",
    "평일",
    "평화",
    "포스터",
    "포인트",
    "포장",
    "포함",
    "표면",
    "표정",
    "표준",
    "표현",
    "품목",
    "품질",
    "풍경",
    "풍속",
    "풍습",
    "프랑스",
    "프린터",
    "플라스틱",
    "피곤",
    "피망",
    "피아노",
    "필름",
    "필수",
    "필요",
    "필자",
    "필통",
    "핑계",
    "하느님",
    "하늘",
    "하드웨어",
    "하룻밤",
    "하반기",
    "하숙집",
    "하순",
    "하여튼",
    "하지만",
    "하천",
    "하품",
    "하필",
    "학과",
    "학교",
    "학급",
    "학기",
    "학년",
    "학력",
    "학번",
    "학부모",
    "학비",
    "학생",
    "학술",
    "학습",
    "학용품",
    "학원",
    "학위",
    "학자",
    "학점",
    "한계",
    "한글",
    "한꺼번에",
    "한낮",
    "한눈",
    "한동안",
    "한때",
    "한라산",
    "한마디",
    "한문",
    "한번",
    "한복",
    "한식",
    "한여름",
    "한쪽",
    "할머니",
    "할아버지",
    "할인",
    "함께",
    "함부로",
    "합격",
    "합리적",
    "항공",
    "항구",
    "항상",
    "항의",
    "해결",
    "해군",
    "해답",
    "해당",
    "해물",
    "해석",
    "해설",
    "해수욕장",
    "해안",
    "핵심",
    "핸드백",
    "햄버거",
    "햇볕",
    "햇살",
    "행동",
    "행복",
    "행사",
    "행운",
    "행위",
    "향기",
    "향상",
    "향수",
    "허락",
    "허용",
    "헬기",
    "현관",
    "현금",
    "현대",
    "현상",
    "현실",
    "현장",
    "현재",
    "현지",
    "혈액",
    "협력",
    "형부",
    "형사",
    "형수",
    "형식",
    "형제",
    "형태",
    "형편",
    "혜택",
    "호기심",
    "호남",
    "호랑이",
    "호박",
    "호텔",
    "호흡",
    "혹시",
    "홀로",
    "홈페이지",
    "홍보",
    "홍수",
    "홍차",
    "화면",
    "화분",
    "화살",
    "화요일",
    "화장",
    "화학",
    "확보",
    "확인",
    "확장",
    "확정",
    "환갑",
    "환경",
    "환영",
    "환율",
    "환자",
    "활기",
    "활동",
    "활발히",
    "활용",
    "활짝",
    "회견",
    "회관",
    "회복",
    "회색",
    "회원",
    "회장",
    "회전",
    "횟수",
    "횡단보도",
    "효율적",
    "후반",
    "후춧가루",
    "훈련",
    "훨씬",
    "휴식",
    "휴일",
    "흉내",
    "흐름",
    "흑백",
    "흑인",
    "흔적",
    "흔히",
    "흥미",
    "흥분",
    "희곡",
    "희망",
    "희생",
    "흰색",
    "힘껏"
]

},{}],99:[function(require,module,exports){
module.exports=[
    "abacate",
    "abaixo",
    "abalar",
    "abater",
    "abduzir",
    "abelha",
    "aberto",
    "abismo",
    "abotoar",
    "abranger",
    "abreviar",
    "abrigar",
    "abrupto",
    "absinto",
    "absoluto",
    "absurdo",
    "abutre",
    "acabado",
    "acalmar",
    "acampar",
    "acanhar",
    "acaso",
    "aceitar",
    "acelerar",
    "acenar",
    "acervo",
    "acessar",
    "acetona",
    "achatar",
    "acidez",
    "acima",
    "acionado",
    "acirrar",
    "aclamar",
    "aclive",
    "acolhida",
    "acomodar",
    "acoplar",
    "acordar",
    "acumular",
    "acusador",
    "adaptar",
    "adega",
    "adentro",
    "adepto",
    "adequar",
    "aderente",
    "adesivo",
    "adeus",
    "adiante",
    "aditivo",
    "adjetivo",
    "adjunto",
    "admirar",
    "adorar",
    "adquirir",
    "adubo",
    "adverso",
    "advogado",
    "aeronave",
    "afastar",
    "aferir",
    "afetivo",
    "afinador",
    "afivelar",
    "aflito",
    "afluente",
    "afrontar",
    "agachar",
    "agarrar",
    "agasalho",
    "agenciar",
    "agilizar",
    "agiota",
    "agitado",
    "agora",
    "agradar",
    "agreste",
    "agrupar",
    "aguardar",
    "agulha",
    "ajoelhar",
    "ajudar",
    "ajustar",
    "alameda",
    "alarme",
    "alastrar",
    "alavanca",
    "albergue",
    "albino",
    "alcatra",
    "aldeia",
    "alecrim",
    "alegria",
    "alertar",
    "alface",
    "alfinete",
    "algum",
    "alheio",
    "aliar",
    "alicate",
    "alienar",
    "alinhar",
    "aliviar",
    "almofada",
    "alocar",
    "alpiste",
    "alterar",
    "altitude",
    "alucinar",
    "alugar",
    "aluno",
    "alusivo",
    "alvo",
    "amaciar",
    "amador",
    "amarelo",
    "amassar",
    "ambas",
    "ambiente",
    "ameixa",
    "amenizar",
    "amido",
    "amistoso",
    "amizade",
    "amolador",
    "amontoar",
    "amoroso",
    "amostra",
    "amparar",
    "ampliar",
    "ampola",
    "anagrama",
    "analisar",
    "anarquia",
    "anatomia",
    "andaime",
    "anel",
    "anexo",
    "angular",
    "animar",
    "anjo",
    "anomalia",
    "anotado",
    "ansioso",
    "anterior",
    "anuidade",
    "anunciar",
    "anzol",
    "apagador",
    "apalpar",
    "apanhado",
    "apego",
    "apelido",
    "apertada",
    "apesar",
    "apetite",
    "apito",
    "aplauso",
    "aplicada",
    "apoio",
    "apontar",
    "aposta",
    "aprendiz",
    "aprovar",
    "aquecer",
    "arame",
    "aranha",
    "arara",
    "arcada",
    "ardente",
    "areia",
    "arejar",
    "arenito",
    "aresta",
    "argiloso",
    "argola",
    "arma",
    "arquivo",
    "arraial",
    "arrebate",
    "arriscar",
    "arroba",
    "arrumar",
    "arsenal",
    "arterial",
    "artigo",
    "arvoredo",
    "asfaltar",
    "asilado",
    "aspirar",
    "assador",
    "assinar",
    "assoalho",
    "assunto",
    "astral",
    "atacado",
    "atadura",
    "atalho",
    "atarefar",
    "atear",
    "atender",
    "aterro",
    "ateu",
    "atingir",
    "atirador",
    "ativo",
    "atoleiro",
    "atracar",
    "atrevido",
    "atriz",
    "atual",
    "atum",
    "auditor",
    "aumentar",
    "aura",
    "aurora",
    "autismo",
    "autoria",
    "autuar",
    "avaliar",
    "avante",
    "avaria",
    "avental",
    "avesso",
    "aviador",
    "avisar",
    "avulso",
    "axila",
    "azarar",
    "azedo",
    "azeite",
    "azulejo",
    "babar",
    "babosa",
    "bacalhau",
    "bacharel",
    "bacia",
    "bagagem",
    "baiano",
    "bailar",
    "baioneta",
    "bairro",
    "baixista",
    "bajular",
    "baleia",
    "baliza",
    "balsa",
    "banal",
    "bandeira",
    "banho",
    "banir",
    "banquete",
    "barato",
    "barbado",
    "baronesa",
    "barraca",
    "barulho",
    "baseado",
    "bastante",
    "batata",
    "batedor",
    "batida",
    "batom",
    "batucar",
    "baunilha",
    "beber",
    "beijo",
    "beirada",
    "beisebol",
    "beldade",
    "beleza",
    "belga",
    "beliscar",
    "bendito",
    "bengala",
    "benzer",
    "berimbau",
    "berlinda",
    "berro",
    "besouro",
    "bexiga",
    "bezerro",
    "bico",
    "bicudo",
    "bienal",
    "bifocal",
    "bifurcar",
    "bigorna",
    "bilhete",
    "bimestre",
    "bimotor",
    "biologia",
    "biombo",
    "biosfera",
    "bipolar",
    "birrento",
    "biscoito",
    "bisneto",
    "bispo",
    "bissexto",
    "bitola",
    "bizarro",
    "blindado",
    "bloco",
    "bloquear",
    "boato",
    "bobagem",
    "bocado",
    "bocejo",
    "bochecha",
    "boicotar",
    "bolada",
    "boletim",
    "bolha",
    "bolo",
    "bombeiro",
    "bonde",
    "boneco",
    "bonita",
    "borbulha",
    "borda",
    "boreal",
    "borracha",
    "bovino",
    "boxeador",
    "branco",
    "brasa",
    "braveza",
    "breu",
    "briga",
    "brilho",
    "brincar",
    "broa",
    "brochura",
    "bronzear",
    "broto",
    "bruxo",
    "bucha",
    "budismo",
    "bufar",
    "bule",
    "buraco",
    "busca",
    "busto",
    "buzina",
    "cabana",
    "cabelo",
    "cabide",
    "cabo",
    "cabrito",
    "cacau",
    "cacetada",
    "cachorro",
    "cacique",
    "cadastro",
    "cadeado",
    "cafezal",
    "caiaque",
    "caipira",
    "caixote",
    "cajado",
    "caju",
    "calafrio",
    "calcular",
    "caldeira",
    "calibrar",
    "calmante",
    "calota",
    "camada",
    "cambista",
    "camisa",
    "camomila",
    "campanha",
    "camuflar",
    "canavial",
    "cancelar",
    "caneta",
    "canguru",
    "canhoto",
    "canivete",
    "canoa",
    "cansado",
    "cantar",
    "canudo",
    "capacho",
    "capela",
    "capinar",
    "capotar",
    "capricho",
    "captador",
    "capuz",
    "caracol",
    "carbono",
    "cardeal",
    "careca",
    "carimbar",
    "carneiro",
    "carpete",
    "carreira",
    "cartaz",
    "carvalho",
    "casaco",
    "casca",
    "casebre",
    "castelo",
    "casulo",
    "catarata",
    "cativar",
    "caule",
    "causador",
    "cautelar",
    "cavalo",
    "caverna",
    "cebola",
    "cedilha",
    "cegonha",
    "celebrar",
    "celular",
    "cenoura",
    "censo",
    "centeio",
    "cercar",
    "cerrado",
    "certeiro",
    "cerveja",
    "cetim",
    "cevada",
    "chacota",
    "chaleira",
    "chamado",
    "chapada",
    "charme",
    "chatice",
    "chave",
    "chefe",
    "chegada",
    "cheiro",
    "cheque",
    "chicote",
    "chifre",
    "chinelo",
    "chocalho",
    "chover",
    "chumbo",
    "chutar",
    "chuva",
    "cicatriz",
    "ciclone",
    "cidade",
    "cidreira",
    "ciente",
    "cigana",
    "cimento",
    "cinto",
    "cinza",
    "ciranda",
    "circuito",
    "cirurgia",
    "citar",
    "clareza",
    "clero",
    "clicar",
    "clone",
    "clube",
    "coado",
    "coagir",
    "cobaia",
    "cobertor",
    "cobrar",
    "cocada",
    "coelho",
    "coentro",
    "coeso",
    "cogumelo",
    "coibir",
    "coifa",
    "coiote",
    "colar",
    "coleira",
    "colher",
    "colidir",
    "colmeia",
    "colono",
    "coluna",
    "comando",
    "combinar",
    "comentar",
    "comitiva",
    "comover",
    "complexo",
    "comum",
    "concha",
    "condor",
    "conectar",
    "confuso",
    "congelar",
    "conhecer",
    "conjugar",
    "consumir",
    "contrato",
    "convite",
    "cooperar",
    "copeiro",
    "copiador",
    "copo",
    "coquetel",
    "coragem",
    "cordial",
    "corneta",
    "coronha",
    "corporal",
    "correio",
    "cortejo",
    "coruja",
    "corvo",
    "cosseno",
    "costela",
    "cotonete",
    "couro",
    "couve",
    "covil",
    "cozinha",
    "cratera",
    "cravo",
    "creche",
    "credor",
    "creme",
    "crer",
    "crespo",
    "criada",
    "criminal",
    "crioulo",
    "crise",
    "criticar",
    "crosta",
    "crua",
    "cruzeiro",
    "cubano",
    "cueca",
    "cuidado",
    "cujo",
    "culatra",
    "culminar",
    "culpar",
    "cultura",
    "cumprir",
    "cunhado",
    "cupido",
    "curativo",
    "curral",
    "cursar",
    "curto",
    "cuspir",
    "custear",
    "cutelo",
    "damasco",
    "datar",
    "debater",
    "debitar",
    "deboche",
    "debulhar",
    "decalque",
    "decimal",
    "declive",
    "decote",
    "decretar",
    "dedal",
    "dedicado",
    "deduzir",
    "defesa",
    "defumar",
    "degelo",
    "degrau",
    "degustar",
    "deitado",
    "deixar",
    "delator",
    "delegado",
    "delinear",
    "delonga",
    "demanda",
    "demitir",
    "demolido",
    "dentista",
    "depenado",
    "depilar",
    "depois",
    "depressa",
    "depurar",
    "deriva",
    "derramar",
    "desafio",
    "desbotar",
    "descanso",
    "desenho",
    "desfiado",
    "desgaste",
    "desigual",
    "deslize",
    "desmamar",
    "desova",
    "despesa",
    "destaque",
    "desviar",
    "detalhar",
    "detentor",
    "detonar",
    "detrito",
    "deusa",
    "dever",
    "devido",
    "devotado",
    "dezena",
    "diagrama",
    "dialeto",
    "didata",
    "difuso",
    "digitar",
    "dilatado",
    "diluente",
    "diminuir",
    "dinastia",
    "dinheiro",
    "diocese",
    "direto",
    "discreta",
    "disfarce",
    "disparo",
    "disquete",
    "dissipar",
    "distante",
    "ditador",
    "diurno",
    "diverso",
    "divisor",
    "divulgar",
    "dizer",
    "dobrador",
    "dolorido",
    "domador",
    "dominado",
    "donativo",
    "donzela",
    "dormente",
    "dorsal",
    "dosagem",
    "dourado",
    "doutor",
    "drenagem",
    "drible",
    "drogaria",
    "duelar",
    "duende",
    "dueto",
    "duplo",
    "duquesa",
    "durante",
    "duvidoso",
    "eclodir",
    "ecoar",
    "ecologia",
    "edificar",
    "edital",
    "educado",
    "efeito",
    "efetivar",
    "ejetar",
    "elaborar",
    "eleger",
    "eleitor",
    "elenco",
    "elevador",
    "eliminar",
    "elogiar",
    "embargo",
    "embolado",
    "embrulho",
    "embutido",
    "emenda",
    "emergir",
    "emissor",
    "empatia",
    "empenho",
    "empinado",
    "empolgar",
    "emprego",
    "empurrar",
    "emulador",
    "encaixe",
    "encenado",
    "enchente",
    "encontro",
    "endeusar",
    "endossar",
    "enfaixar",
    "enfeite",
    "enfim",
    "engajado",
    "engenho",
    "englobar",
    "engomado",
    "engraxar",
    "enguia",
    "enjoar",
    "enlatar",
    "enquanto",
    "enraizar",
    "enrolado",
    "enrugar",
    "ensaio",
    "enseada",
    "ensino",
    "ensopado",
    "entanto",
    "enteado",
    "entidade",
    "entortar",
    "entrada",
    "entulho",
    "envergar",
    "enviado",
    "envolver",
    "enxame",
    "enxerto",
    "enxofre",
    "enxuto",
    "epiderme",
    "equipar",
    "ereto",
    "erguido",
    "errata",
    "erva",
    "ervilha",
    "esbanjar",
    "esbelto",
    "escama",
    "escola",
    "escrita",
    "escuta",
    "esfinge",
    "esfolar",
    "esfregar",
    "esfumado",
    "esgrima",
    "esmalte",
    "espanto",
    "espelho",
    "espiga",
    "esponja",
    "espreita",
    "espumar",
    "esquerda",
    "estaca",
    "esteira",
    "esticar",
    "estofado",
    "estrela",
    "estudo",
    "esvaziar",
    "etanol",
    "etiqueta",
    "euforia",
    "europeu",
    "evacuar",
    "evaporar",
    "evasivo",
    "eventual",
    "evidente",
    "evoluir",
    "exagero",
    "exalar",
    "examinar",
    "exato",
    "exausto",
    "excesso",
    "excitar",
    "exclamar",
    "executar",
    "exemplo",
    "exibir",
    "exigente",
    "exonerar",
    "expandir",
    "expelir",
    "expirar",
    "explanar",
    "exposto",
    "expresso",
    "expulsar",
    "externo",
    "extinto",
    "extrato",
    "fabricar",
    "fabuloso",
    "faceta",
    "facial",
    "fada",
    "fadiga",
    "faixa",
    "falar",
    "falta",
    "familiar",
    "fandango",
    "fanfarra",
    "fantoche",
    "fardado",
    "farelo",
    "farinha",
    "farofa",
    "farpa",
    "fartura",
    "fatia",
    "fator",
    "favorita",
    "faxina",
    "fazenda",
    "fechado",
    "feijoada",
    "feirante",
    "felino",
    "feminino",
    "fenda",
    "feno",
    "fera",
    "feriado",
    "ferrugem",
    "ferver",
    "festejar",
    "fetal",
    "feudal",
    "fiapo",
    "fibrose",
    "ficar",
    "ficheiro",
    "figurado",
    "fileira",
    "filho",
    "filme",
    "filtrar",
    "firmeza",
    "fisgada",
    "fissura",
    "fita",
    "fivela",
    "fixador",
    "fixo",
    "flacidez",
    "flamingo",
    "flanela",
    "flechada",
    "flora",
    "flutuar",
    "fluxo",
    "focal",
    "focinho",
    "fofocar",
    "fogo",
    "foguete",
    "foice",
    "folgado",
    "folheto",
    "forjar",
    "formiga",
    "forno",
    "forte",
    "fosco",
    "fossa",
    "fragata",
    "fralda",
    "frango",
    "frasco",
    "fraterno",
    "freira",
    "frente",
    "fretar",
    "frieza",
    "friso",
    "fritura",
    "fronha",
    "frustrar",
    "fruteira",
    "fugir",
    "fulano",
    "fuligem",
    "fundar",
    "fungo",
    "funil",
    "furador",
    "furioso",
    "futebol",
    "gabarito",
    "gabinete",
    "gado",
    "gaiato",
    "gaiola",
    "gaivota",
    "galega",
    "galho",
    "galinha",
    "galocha",
    "ganhar",
    "garagem",
    "garfo",
    "gargalo",
    "garimpo",
    "garoupa",
    "garrafa",
    "gasoduto",
    "gasto",
    "gata",
    "gatilho",
    "gaveta",
    "gazela",
    "gelado",
    "geleia",
    "gelo",
    "gemada",
    "gemer",
    "gemido",
    "generoso",
    "gengiva",
    "genial",
    "genoma",
    "genro",
    "geologia",
    "gerador",
    "germinar",
    "gesso",
    "gestor",
    "ginasta",
    "gincana",
    "gingado",
    "girafa",
    "girino",
    "glacial",
    "glicose",
    "global",
    "glorioso",
    "goela",
    "goiaba",
    "golfe",
    "golpear",
    "gordura",
    "gorjeta",
    "gorro",
    "gostoso",
    "goteira",
    "governar",
    "gracejo",
    "gradual",
    "grafite",
    "gralha",
    "grampo",
    "granada",
    "gratuito",
    "graveto",
    "graxa",
    "grego",
    "grelhar",
    "greve",
    "grilo",
    "grisalho",
    "gritaria",
    "grosso",
    "grotesco",
    "grudado",
    "grunhido",
    "gruta",
    "guache",
    "guarani",
    "guaxinim",
    "guerrear",
    "guiar",
    "guincho",
    "guisado",
    "gula",
    "guloso",
    "guru",
    "habitar",
    "harmonia",
    "haste",
    "haver",
    "hectare",
    "herdar",
    "heresia",
    "hesitar",
    "hiato",
    "hibernar",
    "hidratar",
    "hiena",
    "hino",
    "hipismo",
    "hipnose",
    "hipoteca",
    "hoje",
    "holofote",
    "homem",
    "honesto",
    "honrado",
    "hormonal",
    "hospedar",
    "humorado",
    "iate",
    "ideia",
    "idoso",
    "ignorado",
    "igreja",
    "iguana",
    "ileso",
    "ilha",
    "iludido",
    "iluminar",
    "ilustrar",
    "imagem",
    "imediato",
    "imenso",
    "imersivo",
    "iminente",
    "imitador",
    "imortal",
    "impacto",
    "impedir",
    "implante",
    "impor",
    "imprensa",
    "impune",
    "imunizar",
    "inalador",
    "inapto",
    "inativo",
    "incenso",
    "inchar",
    "incidir",
    "incluir",
    "incolor",
    "indeciso",
    "indireto",
    "indutor",
    "ineficaz",
    "inerente",
    "infantil",
    "infestar",
    "infinito",
    "inflamar",
    "informal",
    "infrator",
    "ingerir",
    "inibido",
    "inicial",
    "inimigo",
    "injetar",
    "inocente",
    "inodoro",
    "inovador",
    "inox",
    "inquieto",
    "inscrito",
    "inseto",
    "insistir",
    "inspetor",
    "instalar",
    "insulto",
    "intacto",
    "integral",
    "intimar",
    "intocado",
    "intriga",
    "invasor",
    "inverno",
    "invicto",
    "invocar",
    "iogurte",
    "iraniano",
    "ironizar",
    "irreal",
    "irritado",
    "isca",
    "isento",
    "isolado",
    "isqueiro",
    "italiano",
    "janeiro",
    "jangada",
    "janta",
    "jararaca",
    "jardim",
    "jarro",
    "jasmim",
    "jato",
    "javali",
    "jazida",
    "jejum",
    "joaninha",
    "joelhada",
    "jogador",
    "joia",
    "jornal",
    "jorrar",
    "jovem",
    "juba",
    "judeu",
    "judoca",
    "juiz",
    "julgador",
    "julho",
    "jurado",
    "jurista",
    "juro",
    "justa",
    "labareda",
    "laboral",
    "lacre",
    "lactante",
    "ladrilho",
    "lagarta",
    "lagoa",
    "laje",
    "lamber",
    "lamentar",
    "laminar",
    "lampejo",
    "lanche",
    "lapidar",
    "lapso",
    "laranja",
    "lareira",
    "largura",
    "lasanha",
    "lastro",
    "lateral",
    "latido",
    "lavanda",
    "lavoura",
    "lavrador",
    "laxante",
    "lazer",
    "lealdade",
    "lebre",
    "legado",
    "legendar",
    "legista",
    "leigo",
    "leiloar",
    "leitura",
    "lembrete",
    "leme",
    "lenhador",
    "lentilha",
    "leoa",
    "lesma",
    "leste",
    "letivo",
    "letreiro",
    "levar",
    "leveza",
    "levitar",
    "liberal",
    "libido",
    "liderar",
    "ligar",
    "ligeiro",
    "limitar",
    "limoeiro",
    "limpador",
    "linda",
    "linear",
    "linhagem",
    "liquidez",
    "listagem",
    "lisura",
    "litoral",
    "livro",
    "lixa",
    "lixeira",
    "locador",
    "locutor",
    "lojista",
    "lombo",
    "lona",
    "longe",
    "lontra",
    "lorde",
    "lotado",
    "loteria",
    "loucura",
    "lousa",
    "louvar",
    "luar",
    "lucidez",
    "lucro",
    "luneta",
    "lustre",
    "lutador",
    "luva",
    "macaco",
    "macete",
    "machado",
    "macio",
    "madeira",
    "madrinha",
    "magnata",
    "magreza",
    "maior",
    "mais",
    "malandro",
    "malha",
    "malote",
    "maluco",
    "mamilo",
    "mamoeiro",
    "mamute",
    "manada",
    "mancha",
    "mandato",
    "manequim",
    "manhoso",
    "manivela",
    "manobrar",
    "mansa",
    "manter",
    "manusear",
    "mapeado",
    "maquinar",
    "marcador",
    "maresia",
    "marfim",
    "margem",
    "marinho",
    "marmita",
    "maroto",
    "marquise",
    "marreco",
    "martelo",
    "marujo",
    "mascote",
    "masmorra",
    "massagem",
    "mastigar",
    "matagal",
    "materno",
    "matinal",
    "matutar",
    "maxilar",
    "medalha",
    "medida",
    "medusa",
    "megafone",
    "meiga",
    "melancia",
    "melhor",
    "membro",
    "memorial",
    "menino",
    "menos",
    "mensagem",
    "mental",
    "merecer",
    "mergulho",
    "mesada",
    "mesclar",
    "mesmo",
    "mesquita",
    "mestre",
    "metade",
    "meteoro",
    "metragem",
    "mexer",
    "mexicano",
    "micro",
    "migalha",
    "migrar",
    "milagre",
    "milenar",
    "milhar",
    "mimado",
    "minerar",
    "minhoca",
    "ministro",
    "minoria",
    "miolo",
    "mirante",
    "mirtilo",
    "misturar",
    "mocidade",
    "moderno",
    "modular",
    "moeda",
    "moer",
    "moinho",
    "moita",
    "moldura",
    "moleza",
    "molho",
    "molinete",
    "molusco",
    "montanha",
    "moqueca",
    "morango",
    "morcego",
    "mordomo",
    "morena",
    "mosaico",
    "mosquete",
    "mostarda",
    "motel",
    "motim",
    "moto",
    "motriz",
    "muda",
    "muito",
    "mulata",
    "mulher",
    "multar",
    "mundial",
    "munido",
    "muralha",
    "murcho",
    "muscular",
    "museu",
    "musical",
    "nacional",
    "nadador",
    "naja",
    "namoro",
    "narina",
    "narrado",
    "nascer",
    "nativa",
    "natureza",
    "navalha",
    "navegar",
    "navio",
    "neblina",
    "nebuloso",
    "negativa",
    "negociar",
    "negrito",
    "nervoso",
    "neta",
    "neural",
    "nevasca",
    "nevoeiro",
    "ninar",
    "ninho",
    "nitidez",
    "nivelar",
    "nobreza",
    "noite",
    "noiva",
    "nomear",
    "nominal",
    "nordeste",
    "nortear",
    "notar",
    "noticiar",
    "noturno",
    "novelo",
    "novilho",
    "novo",
    "nublado",
    "nudez",
    "numeral",
    "nupcial",
    "nutrir",
    "nuvem",
    "obcecado",
    "obedecer",
    "objetivo",
    "obrigado",
    "obscuro",
    "obstetra",
    "obter",
    "obturar",
    "ocidente",
    "ocioso",
    "ocorrer",
    "oculista",
    "ocupado",
    "ofegante",
    "ofensiva",
    "oferenda",
    "oficina",
    "ofuscado",
    "ogiva",
    "olaria",
    "oleoso",
    "olhar",
    "oliveira",
    "ombro",
    "omelete",
    "omisso",
    "omitir",
    "ondulado",
    "oneroso",
    "ontem",
    "opcional",
    "operador",
    "oponente",
    "oportuno",
    "oposto",
    "orar",
    "orbitar",
    "ordem",
    "ordinal",
    "orfanato",
    "orgasmo",
    "orgulho",
    "oriental",
    "origem",
    "oriundo",
    "orla",
    "ortodoxo",
    "orvalho",
    "oscilar",
    "ossada",
    "osso",
    "ostentar",
    "otimismo",
    "ousadia",
    "outono",
    "outubro",
    "ouvido",
    "ovelha",
    "ovular",
    "oxidar",
    "oxigenar",
    "pacato",
    "paciente",
    "pacote",
    "pactuar",
    "padaria",
    "padrinho",
    "pagar",
    "pagode",
    "painel",
    "pairar",
    "paisagem",
    "palavra",
    "palestra",
    "palheta",
    "palito",
    "palmada",
    "palpitar",
    "pancada",
    "panela",
    "panfleto",
    "panqueca",
    "pantanal",
    "papagaio",
    "papelada",
    "papiro",
    "parafina",
    "parcial",
    "pardal",
    "parede",
    "partida",
    "pasmo",
    "passado",
    "pastel",
    "patamar",
    "patente",
    "patinar",
    "patrono",
    "paulada",
    "pausar",
    "peculiar",
    "pedalar",
    "pedestre",
    "pediatra",
    "pedra",
    "pegada",
    "peitoral",
    "peixe",
    "pele",
    "pelicano",
    "penca",
    "pendurar",
    "peneira",
    "penhasco",
    "pensador",
    "pente",
    "perceber",
    "perfeito",
    "pergunta",
    "perito",
    "permitir",
    "perna",
    "perplexo",
    "persiana",
    "pertence",
    "peruca",
    "pescado",
    "pesquisa",
    "pessoa",
    "petiscar",
    "piada",
    "picado",
    "piedade",
    "pigmento",
    "pilastra",
    "pilhado",
    "pilotar",
    "pimenta",
    "pincel",
    "pinguim",
    "pinha",
    "pinote",
    "pintar",
    "pioneiro",
    "pipoca",
    "piquete",
    "piranha",
    "pires",
    "pirueta",
    "piscar",
    "pistola",
    "pitanga",
    "pivete",
    "planta",
    "plaqueta",
    "platina",
    "plebeu",
    "plumagem",
    "pluvial",
    "pneu",
    "poda",
    "poeira",
    "poetisa",
    "polegada",
    "policiar",
    "poluente",
    "polvilho",
    "pomar",
    "pomba",
    "ponderar",
    "pontaria",
    "populoso",
    "porta",
    "possuir",
    "postal",
    "pote",
    "poupar",
    "pouso",
    "povoar",
    "praia",
    "prancha",
    "prato",
    "praxe",
    "prece",
    "predador",
    "prefeito",
    "premiar",
    "prensar",
    "preparar",
    "presilha",
    "pretexto",
    "prevenir",
    "prezar",
    "primata",
    "princesa",
    "prisma",
    "privado",
    "processo",
    "produto",
    "profeta",
    "proibido",
    "projeto",
    "prometer",
    "propagar",
    "prosa",
    "protetor",
    "provador",
    "publicar",
    "pudim",
    "pular",
    "pulmonar",
    "pulseira",
    "punhal",
    "punir",
    "pupilo",
    "pureza",
    "puxador",
    "quadra",
    "quantia",
    "quarto",
    "quase",
    "quebrar",
    "queda",
    "queijo",
    "quente",
    "querido",
    "quimono",
    "quina",
    "quiosque",
    "rabanada",
    "rabisco",
    "rachar",
    "racionar",
    "radial",
    "raiar",
    "rainha",
    "raio",
    "raiva",
    "rajada",
    "ralado",
    "ramal",
    "ranger",
    "ranhura",
    "rapadura",
    "rapel",
    "rapidez",
    "raposa",
    "raquete",
    "raridade",
    "rasante",
    "rascunho",
    "rasgar",
    "raspador",
    "rasteira",
    "rasurar",
    "ratazana",
    "ratoeira",
    "realeza",
    "reanimar",
    "reaver",
    "rebaixar",
    "rebelde",
    "rebolar",
    "recado",
    "recente",
    "recheio",
    "recibo",
    "recordar",
    "recrutar",
    "recuar",
    "rede",
    "redimir",
    "redonda",
    "reduzida",
    "reenvio",
    "refinar",
    "refletir",
    "refogar",
    "refresco",
    "refugiar",
    "regalia",
    "regime",
    "regra",
    "reinado",
    "reitor",
    "rejeitar",
    "relativo",
    "remador",
    "remendo",
    "remorso",
    "renovado",
    "reparo",
    "repelir",
    "repleto",
    "repolho",
    "represa",
    "repudiar",
    "requerer",
    "resenha",
    "resfriar",
    "resgatar",
    "residir",
    "resolver",
    "respeito",
    "ressaca",
    "restante",
    "resumir",
    "retalho",
    "reter",
    "retirar",
    "retomada",
    "retratar",
    "revelar",
    "revisor",
    "revolta",
    "riacho",
    "rica",
    "rigidez",
    "rigoroso",
    "rimar",
    "ringue",
    "risada",
    "risco",
    "risonho",
    "robalo",
    "rochedo",
    "rodada",
    "rodeio",
    "rodovia",
    "roedor",
    "roleta",
    "romano",
    "roncar",
    "rosado",
    "roseira",
    "rosto",
    "rota",
    "roteiro",
    "rotina",
    "rotular",
    "rouco",
    "roupa",
    "roxo",
    "rubro",
    "rugido",
    "rugoso",
    "ruivo",
    "rumo",
    "rupestre",
    "russo",
    "sabor",
    "saciar",
    "sacola",
    "sacudir",
    "sadio",
    "safira",
    "saga",
    "sagrada",
    "saibro",
    "salada",
    "saleiro",
    "salgado",
    "saliva",
    "salpicar",
    "salsicha",
    "saltar",
    "salvador",
    "sambar",
    "samurai",
    "sanar",
    "sanfona",
    "sangue",
    "sanidade",
    "sapato",
    "sarda",
    "sargento",
    "sarjeta",
    "saturar",
    "saudade",
    "saxofone",
    "sazonal",
    "secar",
    "secular",
    "seda",
    "sedento",
    "sediado",
    "sedoso",
    "sedutor",
    "segmento",
    "segredo",
    "segundo",
    "seiva",
    "seleto",
    "selvagem",
    "semanal",
    "semente",
    "senador",
    "senhor",
    "sensual",
    "sentado",
    "separado",
    "sereia",
    "seringa",
    "serra",
    "servo",
    "setembro",
    "setor",
    "sigilo",
    "silhueta",
    "silicone",
    "simetria",
    "simpatia",
    "simular",
    "sinal",
    "sincero",
    "singular",
    "sinopse",
    "sintonia",
    "sirene",
    "siri",
    "situado",
    "soberano",
    "sobra",
    "socorro",
    "sogro",
    "soja",
    "solda",
    "soletrar",
    "solteiro",
    "sombrio",
    "sonata",
    "sondar",
    "sonegar",
    "sonhador",
    "sono",
    "soprano",
    "soquete",
    "sorrir",
    "sorteio",
    "sossego",
    "sotaque",
    "soterrar",
    "sovado",
    "sozinho",
    "suavizar",
    "subida",
    "submerso",
    "subsolo",
    "subtrair",
    "sucata",
    "sucesso",
    "suco",
    "sudeste",
    "sufixo",
    "sugador",
    "sugerir",
    "sujeito",
    "sulfato",
    "sumir",
    "suor",
    "superior",
    "suplicar",
    "suposto",
    "suprimir",
    "surdina",
    "surfista",
    "surpresa",
    "surreal",
    "surtir",
    "suspiro",
    "sustento",
    "tabela",
    "tablete",
    "tabuada",
    "tacho",
    "tagarela",
    "talher",
    "talo",
    "talvez",
    "tamanho",
    "tamborim",
    "tampa",
    "tangente",
    "tanto",
    "tapar",
    "tapioca",
    "tardio",
    "tarefa",
    "tarja",
    "tarraxa",
    "tatuagem",
    "taurino",
    "taxativo",
    "taxista",
    "teatral",
    "tecer",
    "tecido",
    "teclado",
    "tedioso",
    "teia",
    "teimar",
    "telefone",
    "telhado",
    "tempero",
    "tenente",
    "tensor",
    "tentar",
    "termal",
    "terno",
    "terreno",
    "tese",
    "tesoura",
    "testado",
    "teto",
    "textura",
    "texugo",
    "tiara",
    "tigela",
    "tijolo",
    "timbrar",
    "timidez",
    "tingido",
    "tinteiro",
    "tiragem",
    "titular",
    "toalha",
    "tocha",
    "tolerar",
    "tolice",
    "tomada",
    "tomilho",
    "tonel",
    "tontura",
    "topete",
    "tora",
    "torcido",
    "torneio",
    "torque",
    "torrada",
    "torto",
    "tostar",
    "touca",
    "toupeira",
    "toxina",
    "trabalho",
    "tracejar",
    "tradutor",
    "trafegar",
    "trajeto",
    "trama",
    "trancar",
    "trapo",
    "traseiro",
    "tratador",
    "travar",
    "treino",
    "tremer",
    "trepidar",
    "trevo",
    "triagem",
    "tribo",
    "triciclo",
    "tridente",
    "trilogia",
    "trindade",
    "triplo",
    "triturar",
    "triunfal",
    "trocar",
    "trombeta",
    "trova",
    "trunfo",
    "truque",
    "tubular",
    "tucano",
    "tudo",
    "tulipa",
    "tupi",
    "turbo",
    "turma",
    "turquesa",
    "tutelar",
    "tutorial",
    "uivar",
    "umbigo",
    "unha",
    "unidade",
    "uniforme",
    "urologia",
    "urso",
    "urtiga",
    "urubu",
    "usado",
    "usina",
    "usufruir",
    "vacina",
    "vadiar",
    "vagaroso",
    "vaidoso",
    "vala",
    "valente",
    "validade",
    "valores",
    "vantagem",
    "vaqueiro",
    "varanda",
    "vareta",
    "varrer",
    "vascular",
    "vasilha",
    "vassoura",
    "vazar",
    "vazio",
    "veado",
    "vedar",
    "vegetar",
    "veicular",
    "veleiro",
    "velhice",
    "veludo",
    "vencedor",
    "vendaval",
    "venerar",
    "ventre",
    "verbal",
    "verdade",
    "vereador",
    "vergonha",
    "vermelho",
    "verniz",
    "versar",
    "vertente",
    "vespa",
    "vestido",
    "vetorial",
    "viaduto",
    "viagem",
    "viajar",
    "viatura",
    "vibrador",
    "videira",
    "vidraria",
    "viela",
    "viga",
    "vigente",
    "vigiar",
    "vigorar",
    "vilarejo",
    "vinco",
    "vinheta",
    "vinil",
    "violeta",
    "virada",
    "virtude",
    "visitar",
    "visto",
    "vitral",
    "viveiro",
    "vizinho",
    "voador",
    "voar",
    "vogal",
    "volante",
    "voleibol",
    "voltagem",
    "volumoso",
    "vontade",
    "vulto",
    "vuvuzela",
    "xadrez",
    "xarope",
    "xeque",
    "xeretar",
    "xerife",
    "xingar",
    "zangado",
    "zarpar",
    "zebu",
    "zelador",
    "zombar",
    "zoologia",
    "zumbido"
]

},{}],100:[function(require,module,exports){
module.exports=[
    "ábaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "acción",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "ácido",
    "aclarar",
    "acné",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aéreo",
    "afectar",
    "afición",
    "afinar",
    "afirmar",
    "ágil",
    "agitar",
    "agonía",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "águila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacrán",
    "alambre",
    "alarma",
    "alba",
    "álbum",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodón",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almíbar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ámbar",
    "ámbito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "andén",
    "anemia",
    "ángulo",
    "anillo",
    "ánimo",
    "anís",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "añadir",
    "añejo",
    "año",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "araña",
    "arar",
    "árbitro",
    "árbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "área",
    "árido",
    "aries",
    "armonía",
    "arnés",
    "aroma",
    "arpa",
    "arpón",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "áspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "ático",
    "atleta",
    "átomo",
    "atraer",
    "atroz",
    "atún",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avión",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafrán",
    "azar",
    "azote",
    "azúcar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahía",
    "baile",
    "bajar",
    "balanza",
    "balcón",
    "balde",
    "bambú",
    "banco",
    "banda",
    "baño",
    "barba",
    "barco",
    "barniz",
    "barro",
    "báscula",
    "bastón",
    "basura",
    "batalla",
    "batería",
    "batir",
    "batuta",
    "baúl",
    "bazar",
    "bebé",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsái",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botín",
    "bóveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufón",
    "búho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzón",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadáver",
    "cadena",
    "caer",
    "café",
    "caída",
    "caimán",
    "caja",
    "cajón",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cáncer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "caña",
    "cañón",
    "caoba",
    "caos",
    "capaz",
    "capitán",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbón",
    "cárcel",
    "careta",
    "carga",
    "cariño",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "célebre",
    "celoso",
    "célula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "césped",
    "cetro",
    "chacal",
    "chaleco",
    "champú",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclón",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "ciprés",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clínica",
    "cobre",
    "cocción",
    "cochino",
    "cocina",
    "coco",
    "código",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojín",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "cómodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazón",
    "corbata",
    "corcho",
    "cordón",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "cráneo",
    "cráter",
    "crear",
    "crecer",
    "creído",
    "crema",
    "cría",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "crónica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupón",
    "cúpula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "dátil",
    "deber",
    "débil",
    "década",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfín",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvío",
    "detalle",
    "detener",
    "deuda",
    "día",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "difícil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseño",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragón",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueño",
    "dulce",
    "dúo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ébano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edición",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "élite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emoción",
    "empate",
    "empeño",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encía",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engaño",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "enseñar",
    "entero",
    "entrar",
    "envase",
    "envío",
    "época",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espía",
    "esposa",
    "espuma",
    "esquí",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "ética",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "éxito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fábrica",
    "fábula",
    "fachada",
    "fácil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraón",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fértil",
    "fervor",
    "festín",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficción",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "flúor",
    "fobia",
    "foca",
    "fogata",
    "fogón",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "frágil",
    "franja",
    "frase",
    "fraude",
    "freír",
    "freno",
    "fresa",
    "frío",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "función",
    "funda",
    "furgón",
    "furia",
    "fusil",
    "fútbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galería",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilán",
    "gemelo",
    "gemir",
    "gen",
    "género",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "gráfico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grúa",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guía",
    "guiño",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "hábil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazaña",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "héroe",
    "hervir",
    "hielo",
    "hierro",
    "hígado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "húmedo",
    "humilde",
    "humo",
    "hundir",
    "huracán",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "ídolo",
    "iglesia",
    "iglú",
    "igual",
    "ilegal",
    "ilusión",
    "imagen",
    "imán",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "índice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interés",
    "íntimo",
    "intuir",
    "inútil",
    "invierno",
    "ira",
    "iris",
    "ironía",
    "isla",
    "islote",
    "jabalí",
    "jabón",
    "jamón",
    "jarabe",
    "jardín",
    "jarra",
    "jaula",
    "jazmín",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "júpiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladrón",
    "lagarto",
    "lágrima",
    "laguna",
    "laico",
    "lamer",
    "lámina",
    "lámpara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lápiz",
    "largo",
    "larva",
    "lástima",
    "lata",
    "látex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "lección",
    "leche",
    "lector",
    "leer",
    "legión",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "leña",
    "león",
    "leopardo",
    "lesión",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "líder",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "límite",
    "limón",
    "limpio",
    "lince",
    "lindo",
    "línea",
    "lingote",
    "lino",
    "linterna",
    "líquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "loción",
    "loco",
    "locura",
    "lógica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maíz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mamá",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniquí",
    "manjar",
    "mano",
    "manso",
    "manta",
    "mañana",
    "mapa",
    "máquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "mármol",
    "marrón",
    "martes",
    "marzo",
    "masa",
    "máscara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "máximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "médula",
    "mejilla",
    "mejor",
    "melena",
    "melón",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menú",
    "mercado",
    "merengue",
    "mérito",
    "mes",
    "mesón",
    "meta",
    "meter",
    "método",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millón",
    "mimo",
    "mina",
    "minero",
    "mínimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "moción",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "moño",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "móvil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muñeca",
    "mural",
    "muro",
    "músculo",
    "museo",
    "musgo",
    "música",
    "muslo",
    "nácar",
    "nación",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "náusea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "néctar",
    "negar",
    "negocio",
    "negro",
    "neón",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "niñez",
    "niño",
    "nítido",
    "nivel",
    "nobleza",
    "noche",
    "nómina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "núcleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "número",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "océano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oído",
    "oír",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opción",
    "ópera",
    "opinar",
    "oponer",
    "optar",
    "óptica",
    "opuesto",
    "oración",
    "orador",
    "oral",
    "órbita",
    "orca",
    "orden",
    "oreja",
    "órgano",
    "orgía",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadía",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otoño",
    "otro",
    "oveja",
    "óvulo",
    "óxido",
    "oxígeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "página",
    "pago",
    "país",
    "pájaro",
    "palabra",
    "palco",
    "paleta",
    "pálido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "pánico",
    "pantera",
    "pañuelo",
    "papá",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "párpado",
    "parque",
    "párrafo",
    "parte",
    "pasar",
    "paseo",
    "pasión",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peatón",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldaño",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "peñón",
    "peón",
    "peor",
    "pepino",
    "pequeño",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pésimo",
    "pestaña",
    "pétalo",
    "petróleo",
    "pez",
    "pezuña",
    "picar",
    "pichón",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "piña",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "pitón",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesía",
    "poeta",
    "polen",
    "policía",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porción",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "príncipe",
    "prisión",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "próximo",
    "prueba",
    "público",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmón",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "puñal",
    "puño",
    "pupa",
    "pupila",
    "puré",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "química",
    "quince",
    "quitar",
    "rábano",
    "rabia",
    "rabo",
    "ración",
    "radical",
    "raíz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rápido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razón",
    "reacción",
    "realidad",
    "rebaño",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refrán",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehén",
    "reino",
    "reír",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "revés",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rígido",
    "rigor",
    "rincón",
    "riñón",
    "río",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubí",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sábado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmón",
    "salón",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sanción",
    "sandía",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sartén",
    "sastre",
    "satán",
    "sauna",
    "saxofón",
    "sección",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "señal",
    "señor",
    "separar",
    "sepia",
    "sequía",
    "ser",
    "serie",
    "sermón",
    "servir",
    "sesenta",
    "sesión",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "sílaba",
    "silbar",
    "silencio",
    "silla",
    "símbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "sólido",
    "soltar",
    "solución",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sostén",
    "sótano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueño",
    "suerte",
    "sufrir",
    "sujeto",
    "sultán",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureño",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabú",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talón",
    "tamaño",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapón",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazón",
    "teatro",
    "techo",
    "tecla",
    "técnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "teléfono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoría",
    "terapia",
    "terco",
    "término",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburón",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "tímido",
    "timo",
    "tinta",
    "tío",
    "típico",
    "tipo",
    "tira",
    "tirón",
    "titán",
    "títere",
    "título",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "tórax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "tóxico",
    "trabajo",
    "tractor",
    "traer",
    "tráfico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trébol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tubería",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "túnel",
    "túnica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "úlcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "uña",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "útil",
    "utopía",
    "uva",
    "vaca",
    "vacío",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "válido",
    "valle",
    "valor",
    "válvula",
    "vampiro",
    "vara",
    "variar",
    "varón",
    "vaso",
    "vecino",
    "vector",
    "vehículo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "vía",
    "viaje",
    "vibrar",
    "vicio",
    "víctima",
    "vida",
    "vídeo",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "viñedo",
    "violín",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "víspera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcán",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
]

},{}],101:[function(require,module,exports){
'use strict'

// https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/script/script.h#L39
const LOCKTIME_THRESHOLD = 0x1dcd6500 // 500000000

function decode (lockTime) {
  if (lockTime >= LOCKTIME_THRESHOLD) {
    return {
      utc: lockTime
    }
  }

  return {
    blocks: lockTime
  }
}

function encode (obj) {
  let blocks = obj.blocks
  let utc = obj.utc
  if (blocks !== undefined && utc !== undefined) throw new TypeError('Cannot encode blocks AND utc')
  if (blocks === undefined && utc === undefined) return 0 // neither?

  if (utc !== undefined) {
    if (!Number.isFinite(utc)) throw new TypeError('Expected Number utc')
    if (utc < LOCKTIME_THRESHOLD) throw new TypeError('Expected Number utc >= ' + LOCKTIME_THRESHOLD)

    return utc
  }

  if (!Number.isFinite(blocks)) throw new TypeError('Expected Number blocks')
  if (blocks >= LOCKTIME_THRESHOLD) throw new TypeError('Expected Number blocks < ' + LOCKTIME_THRESHOLD)

  return blocks
}

module.exports = { decode, encode }

},{}],102:[function(require,module,exports){
// see https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki#compatibility

const SEQUENCE_FINAL = 0xffffffff
const SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31)
const SEQUENCE_LOCKTIME_GRANULARITY = 9
const SEQUENCE_LOCKTIME_MASK = 0x0000ffff
const SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22)

const BLOCKS_MAX = SEQUENCE_LOCKTIME_MASK
const SECONDS_MOD = 1 << SEQUENCE_LOCKTIME_GRANULARITY
const SECONDS_MAX = SEQUENCE_LOCKTIME_MASK << SEQUENCE_LOCKTIME_GRANULARITY

function decode (sequence) {
  if (sequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) return {}
  if (sequence & SEQUENCE_LOCKTIME_TYPE_FLAG) {
    return {
      seconds: (sequence & SEQUENCE_LOCKTIME_MASK) << SEQUENCE_LOCKTIME_GRANULARITY
    }
  }

  return {
    blocks: sequence & SEQUENCE_LOCKTIME_MASK
  }
}

function encode ({ blocks, seconds }) {
  if (blocks !== undefined && seconds !== undefined) throw new TypeError('Cannot encode blocks AND seconds')
  if (blocks === undefined && seconds === undefined) return SEQUENCE_FINAL // neither? assume final

  if (seconds !== undefined) {
    if (!Number.isFinite(seconds)) throw new TypeError('Expected Number seconds')
    if (seconds > SECONDS_MAX) throw new TypeError('Expected Number seconds <= ' + SECONDS_MAX)
    if (seconds % SECONDS_MOD !== 0) throw new TypeError('Expected Number seconds as a multiple of ' + SECONDS_MOD)

    return SEQUENCE_LOCKTIME_TYPE_FLAG | (seconds >> SEQUENCE_LOCKTIME_GRANULARITY)
  }

  if (!Number.isFinite(blocks)) throw new TypeError('Expected Number blocks')
  if (blocks > SEQUENCE_LOCKTIME_MASK) throw new TypeError('Expected Number blocks <= ' + BLOCKS_MAX)

  return blocks
}

module.exports = { decode, encode }

},{}],103:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.toOutputScript =
  exports.fromOutputScript =
  exports.toBech32 =
  exports.toBase58Check =
  exports.fromBech32 =
  exports.fromBase58Check =
    void 0;
const networks = require('./networks');
const payments = require('./payments');
const bscript = require('./script');
const types_1 = require('./types');
const bech32_1 = require('bech32');
const bs58check = require('bs58check');
const FUTURE_SEGWIT_MAX_SIZE = 40;
const FUTURE_SEGWIT_MIN_SIZE = 2;
const FUTURE_SEGWIT_MAX_VERSION = 16;
const FUTURE_SEGWIT_MIN_VERSION = 2;
const FUTURE_SEGWIT_VERSION_DIFF = 0x50;
const FUTURE_SEGWIT_VERSION_WARNING =
  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +
  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +
  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +
  'then decide when it is safe to use which version of segwit.';
function _toFutureSegwitAddress(output, network) {
  const data = output.slice(2);
  if (
    data.length < FUTURE_SEGWIT_MIN_SIZE ||
    data.length > FUTURE_SEGWIT_MAX_SIZE
  )
    throw new TypeError('Invalid program length for segwit address');
  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
  if (
    version < FUTURE_SEGWIT_MIN_VERSION ||
    version > FUTURE_SEGWIT_MAX_VERSION
  )
    throw new TypeError('Invalid version for segwit address');
  if (output[1] !== data.length)
    throw new TypeError('Invalid script for segwit address');
  console.warn(FUTURE_SEGWIT_VERSION_WARNING);
  return toBech32(data, version, network.bech32);
}
/**
 * decode address with base58 specification,  return address version and address hash if valid
 */
function fromBase58Check(address) {
  const payload = Buffer.from(bs58check.decode(address));
  // TODO: 4.0.0, move to "toOutputScript"
  if (payload.length < 21) throw new TypeError(address + ' is too short');
  if (payload.length > 21) throw new TypeError(address + ' is too long');
  const version = payload.readUInt8(0);
  const hash = payload.slice(1);
  return { version, hash };
}
exports.fromBase58Check = fromBase58Check;
/**
 * decode address with bech32 specification,  return address version、address prefix and address data if valid
 */
function fromBech32(address) {
  let result;
  let version;
  try {
    result = bech32_1.bech32.decode(address);
  } catch (e) {}
  if (result) {
    version = result.words[0];
    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');
  } else {
    result = bech32_1.bech32m.decode(address);
    version = result.words[0];
    if (version === 0) throw new TypeError(address + ' uses wrong encoding');
  }
  const data = bech32_1.bech32.fromWords(result.words.slice(1));
  return {
    version,
    prefix: result.prefix,
    data: Buffer.from(data),
  };
}
exports.fromBech32 = fromBech32;
/**
 * encode address hash to base58 address with version
 */
function toBase58Check(hash, version) {
  (0, types_1.typeforce)(
    (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),
    arguments,
  );
  const payload = Buffer.allocUnsafe(21);
  payload.writeUInt8(version, 0);
  hash.copy(payload, 1);
  return bs58check.encode(payload);
}
exports.toBase58Check = toBase58Check;
/**
 * encode address hash to bech32 address with version and prefix
 */
function toBech32(data, version, prefix) {
  const words = bech32_1.bech32.toWords(data);
  words.unshift(version);
  return version === 0
    ? bech32_1.bech32.encode(prefix, words)
    : bech32_1.bech32m.encode(prefix, words);
}
exports.toBech32 = toBech32;
/**
 * decode address from output script with network, return address if matched
 */
function fromOutputScript(output, network) {
  // TODO: Network
  network = network || networks.bitcoin;
  try {
    return payments.p2pkh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2sh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2wpkh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2wsh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2tr({ output, network }).address;
  } catch (e) {}
  try {
    return _toFutureSegwitAddress(output, network);
  } catch (e) {}
  throw new Error(bscript.toASM(output) + ' has no matching Address');
}
exports.fromOutputScript = fromOutputScript;
/**
 * encodes address to output script with network, return output script if address matched
 */
function toOutputScript(address, network) {
  network = network || networks.bitcoin;
  let decodeBase58;
  let decodeBech32;
  try {
    decodeBase58 = fromBase58Check(address);
  } catch (e) {}
  if (decodeBase58) {
    if (decodeBase58.version === network.pubKeyHash)
      return payments.p2pkh({ hash: decodeBase58.hash }).output;
    if (decodeBase58.version === network.scriptHash)
      return payments.p2sh({ hash: decodeBase58.hash }).output;
  } else {
    try {
      decodeBech32 = fromBech32(address);
    } catch (e) {}
    if (decodeBech32) {
      if (decodeBech32.prefix !== network.bech32)
        throw new Error(address + ' has an invalid prefix');
      if (decodeBech32.version === 0) {
        if (decodeBech32.data.length === 20)
          return payments.p2wpkh({ hash: decodeBech32.data }).output;
        if (decodeBech32.data.length === 32)
          return payments.p2wsh({ hash: decodeBech32.data }).output;
      } else if (decodeBech32.version === 1) {
        if (decodeBech32.data.length === 32)
          return payments.p2tr({ pubkey: decodeBech32.data }).output;
      } else if (
        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&
        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&
        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&
        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE
      ) {
        console.warn(FUTURE_SEGWIT_VERSION_WARNING);
        return bscript.compile([
          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
          decodeBech32.data,
        ]);
      }
    }
  }
  throw new Error(address + ' has no matching Script');
}
exports.toOutputScript = toOutputScript;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./networks":111,"./payments":115,"./script":128,"./types":132,"bech32":53,"bs58check":165,"buffer":167}],104:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use
Object.defineProperty(exports, '__esModule', { value: true });
exports.encode = exports.decode = exports.check = void 0;
function check(buffer) {
  if (buffer.length < 8) return false;
  if (buffer.length > 72) return false;
  if (buffer[0] !== 0x30) return false;
  if (buffer[1] !== buffer.length - 2) return false;
  if (buffer[2] !== 0x02) return false;
  const lenR = buffer[3];
  if (lenR === 0) return false;
  if (5 + lenR >= buffer.length) return false;
  if (buffer[4 + lenR] !== 0x02) return false;
  const lenS = buffer[5 + lenR];
  if (lenS === 0) return false;
  if (6 + lenR + lenS !== buffer.length) return false;
  if (buffer[4] & 0x80) return false;
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;
  if (buffer[lenR + 6] & 0x80) return false;
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
    return false;
  return true;
}
exports.check = check;
function decode(buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short');
  if (buffer.length > 72) throw new Error('DER sequence length is too long');
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');
  if (buffer[1] !== buffer.length - 2)
    throw new Error('DER sequence length is invalid');
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');
  const lenR = buffer[3];
  if (lenR === 0) throw new Error('R length is zero');
  if (5 + lenR >= buffer.length) throw new Error('R length is too long');
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');
  const lenS = buffer[5 + lenR];
  if (lenS === 0) throw new Error('S length is zero');
  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');
  if (buffer[4] & 0x80) throw new Error('R value is negative');
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))
    throw new Error('R value excessively padded');
  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
    throw new Error('S value excessively padded');
  // non-BIP66 - extract R, S values
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR),
  };
}
exports.decode = decode;
/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
 */
function encode(r, s) {
  const lenR = r.length;
  const lenS = s.length;
  if (lenR === 0) throw new Error('R length is zero');
  if (lenS === 0) throw new Error('S length is zero');
  if (lenR > 33) throw new Error('R length is too long');
  if (lenS > 33) throw new Error('S length is too long');
  if (r[0] & 0x80) throw new Error('R value is negative');
  if (s[0] & 0x80) throw new Error('S value is negative');
  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))
    throw new Error('R value excessively padded');
  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))
    throw new Error('S value excessively padded');
  const signature = Buffer.allocUnsafe(6 + lenR + lenS);
  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  signature[0] = 0x30;
  signature[1] = signature.length - 2;
  signature[2] = 0x02;
  signature[3] = r.length;
  r.copy(signature, 4);
  signature[4 + lenR] = 0x02;
  signature[5 + lenR] = s.length;
  s.copy(signature, 6 + lenR);
  return signature;
}
exports.encode = encode;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],105:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.Block = void 0;
const bufferutils_1 = require('./bufferutils');
const bcrypto = require('./crypto');
const merkle_1 = require('./merkle');
const transaction_1 = require('./transaction');
const types = require('./types');
const { typeforce } = types;
const errorMerkleNoTxes = new TypeError(
  'Cannot compute merkle root for zero transactions',
);
const errorWitnessNotSegwit = new TypeError(
  'Cannot compute witness commit for non-segwit block',
);
class Block {
  constructor() {
    this.version = 1;
    this.prevHash = undefined;
    this.merkleRoot = undefined;
    this.timestamp = 0;
    this.witnessCommit = undefined;
    this.bits = 0;
    this.nonce = 0;
    this.transactions = undefined;
  }
  static fromBuffer(buffer) {
    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');
    const bufferReader = new bufferutils_1.BufferReader(buffer);
    const block = new Block();
    block.version = bufferReader.readInt32();
    block.prevHash = bufferReader.readSlice(32);
    block.merkleRoot = bufferReader.readSlice(32);
    block.timestamp = bufferReader.readUInt32();
    block.bits = bufferReader.readUInt32();
    block.nonce = bufferReader.readUInt32();
    if (buffer.length === 80) return block;
    const readTransaction = () => {
      const tx = transaction_1.Transaction.fromBuffer(
        bufferReader.buffer.slice(bufferReader.offset),
        true,
      );
      bufferReader.offset += tx.byteLength();
      return tx;
    };
    const nTransactions = bufferReader.readVarInt();
    block.transactions = [];
    for (let i = 0; i < nTransactions; ++i) {
      const tx = readTransaction();
      block.transactions.push(tx);
    }
    const witnessCommit = block.getWitnessCommit();
    // This Block contains a witness commit
    if (witnessCommit) block.witnessCommit = witnessCommit;
    return block;
  }
  static fromHex(hex) {
    return Block.fromBuffer(Buffer.from(hex, 'hex'));
  }
  static calculateTarget(bits) {
    const exponent = ((bits & 0xff000000) >> 24) - 3;
    const mantissa = bits & 0x007fffff;
    const target = Buffer.alloc(32, 0);
    target.writeUIntBE(mantissa, 29 - exponent, 3);
    return target;
  }
  static calculateMerkleRoot(transactions, forWitness) {
    typeforce([{ getHash: types.Function }], transactions);
    if (transactions.length === 0) throw errorMerkleNoTxes;
    if (forWitness && !txesHaveWitnessCommit(transactions))
      throw errorWitnessNotSegwit;
    const hashes = transactions.map(transaction =>
      transaction.getHash(forWitness),
    );
    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);
    return forWitness
      ? bcrypto.hash256(
          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),
        )
      : rootHash;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    // The merkle root for the witness data is in an OP_RETURN output.
    // There is no rule for the index of the output, so use filter to find it.
    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed
    // If multiple commits are found, the output with highest index is assumed.
    const witnessCommits = this.transactions[0].outs
      .filter(out =>
        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),
      )
      .map(out => out.script.slice(6, 38));
    if (witnessCommits.length === 0) return null;
    // Use the commit with the highest output (should only be one though)
    const result = witnessCommits[witnessCommits.length - 1];
    if (!(result instanceof Buffer && result.length === 32)) return null;
    return result;
  }
  hasWitnessCommit() {
    if (
      this.witnessCommit instanceof Buffer &&
      this.witnessCommit.length === 32
    )
      return true;
    if (this.getWitnessCommit() !== null) return true;
    return false;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const base = this.byteLength(false, false);
    const total = this.byteLength(false, true);
    return base * 3 + total;
  }
  byteLength(headersOnly, allowWitness = true) {
    if (headersOnly || !this.transactions) return 80;
    return (
      80 +
      bufferutils_1.varuint.encodingLength(this.transactions.length) +
      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)
    );
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(true));
  }
  getId() {
    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');
  }
  getUTCDate() {
    const date = new Date(0); // epoch
    date.setUTCSeconds(this.timestamp);
    return date;
  }
  // TODO: buffer, offset compatibility
  toBuffer(headersOnly) {
    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
    const bufferWriter = new bufferutils_1.BufferWriter(buffer);
    bufferWriter.writeInt32(this.version);
    bufferWriter.writeSlice(this.prevHash);
    bufferWriter.writeSlice(this.merkleRoot);
    bufferWriter.writeUInt32(this.timestamp);
    bufferWriter.writeUInt32(this.bits);
    bufferWriter.writeUInt32(this.nonce);
    if (headersOnly || !this.transactions) return buffer;
    bufferutils_1.varuint.encode(
      this.transactions.length,
      buffer,
      bufferWriter.offset,
    );
    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;
    this.transactions.forEach(tx => {
      const txSize = tx.byteLength(); // TODO: extract from toBuffer?
      tx.toBuffer(buffer, bufferWriter.offset);
      bufferWriter.offset += txSize;
    });
    return buffer;
  }
  toHex(headersOnly) {
    return this.toBuffer(headersOnly).toString('hex');
  }
  checkTxRoots() {
    // If the Block has segwit transactions but no witness commit,
    // there's no way it can be valid, so fail the check.
    const hasWitnessCommit = this.hasWitnessCommit();
    if (!hasWitnessCommit && this.hasWitness()) return false;
    return (
      this.__checkMerkleRoot() &&
      (hasWitnessCommit ? this.__checkWitnessCommit() : true)
    );
  }
  checkProofOfWork() {
    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());
    const target = Block.calculateTarget(this.bits);
    return hash.compare(target) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(actualMerkleRoot) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const actualWitnessCommit = Block.calculateMerkleRoot(
      this.transactions,
      true,
    );
    return this.witnessCommit.compare(actualWitnessCommit) === 0;
  }
}
exports.Block = Block;
function txesHaveWitnessCommit(transactions) {
  return (
    transactions instanceof Array &&
    transactions[0] &&
    transactions[0].ins &&
    transactions[0].ins instanceof Array &&
    transactions[0].ins[0] &&
    transactions[0].ins[0].witness &&
    transactions[0].ins[0].witness instanceof Array &&
    transactions[0].ins[0].witness.length > 0
  );
}
function anyTxHasWitness(transactions) {
  return (
    transactions instanceof Array &&
    transactions.some(
      tx =>
        typeof tx === 'object' &&
        tx.ins instanceof Array &&
        tx.ins.some(
          input =>
            typeof input === 'object' &&
            input.witness instanceof Array &&
            input.witness.length > 0,
        ),
    )
  );
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bufferutils":106,"./crypto":107,"./merkle":110,"./transaction":131,"./types":132,"buffer":167}],106:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.BufferReader =
  exports.BufferWriter =
  exports.cloneBuffer =
  exports.reverseBuffer =
  exports.writeUInt64LE =
  exports.readUInt64LE =
  exports.varuint =
    void 0;
const types = require('./types');
const { typeforce } = types;
const varuint = require('varuint-bitcoin');
exports.varuint = varuint;
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
  if (typeof value !== 'number')
    throw new Error('cannot write a non-number as a number');
  if (value < 0)
    throw new Error('specified a negative value for writing an unsigned value');
  if (value > max) throw new Error('RangeError: value out of range');
  if (Math.floor(value) !== value)
    throw new Error('value has a fractional component');
}
function readUInt64LE(buffer, offset) {
  const a = buffer.readUInt32LE(offset);
  let b = buffer.readUInt32LE(offset + 4);
  b *= 0x100000000;
  verifuint(b + a, 0x001fffffffffffff);
  return b + a;
}
exports.readUInt64LE = readUInt64LE;
/**
 * Writes a 64-bit unsigned integer in little-endian format to the specified buffer at the given offset.
 *
 * @param buffer - The buffer to write the value to.
 * @param value - The 64-bit unsigned integer value to write.
 * @param offset - The offset in the buffer where the value should be written.
 * @returns The new offset after writing the value.
 */
function writeUInt64LE(buffer, value, offset) {
  verifuint(value, 0x001fffffffffffff);
  buffer.writeInt32LE(value & -1, offset);
  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
  return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;
/**
 * Reverses the order of bytes in a buffer.
 * @param buffer - The buffer to reverse.
 * @returns A new buffer with the bytes reversed.
 */
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  let j = buffer.length - 1;
  let tmp = 0;
  for (let i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function cloneBuffer(buffer) {
  const clone = Buffer.allocUnsafe(buffer.length);
  buffer.copy(clone);
  return clone;
}
exports.cloneBuffer = cloneBuffer;
/**
 * Helper class for serialization of bitcoin data types into a pre-allocated buffer.
 */
class BufferWriter {
  static withCapacity(size) {
    return new BufferWriter(Buffer.alloc(size));
  }
  constructor(buffer, offset = 0) {
    this.buffer = buffer;
    this.offset = offset;
    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
  }
  writeUInt8(i) {
    this.offset = this.buffer.writeUInt8(i, this.offset);
  }
  writeInt32(i) {
    this.offset = this.buffer.writeInt32LE(i, this.offset);
  }
  writeUInt32(i) {
    this.offset = this.buffer.writeUInt32LE(i, this.offset);
  }
  writeUInt64(i) {
    this.offset = writeUInt64LE(this.buffer, i, this.offset);
  }
  writeVarInt(i) {
    varuint.encode(i, this.buffer, this.offset);
    this.offset += varuint.encode.bytes;
  }
  writeSlice(slice) {
    if (this.buffer.length < this.offset + slice.length) {
      throw new Error('Cannot write slice out of bounds');
    }
    this.offset += slice.copy(this.buffer, this.offset);
  }
  writeVarSlice(slice) {
    this.writeVarInt(slice.length);
    this.writeSlice(slice);
  }
  writeVector(vector) {
    this.writeVarInt(vector.length);
    vector.forEach(buf => this.writeVarSlice(buf));
  }
  end() {
    if (this.buffer.length === this.offset) {
      return this.buffer;
    }
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
exports.BufferWriter = BufferWriter;
/**
 * Helper class for reading of bitcoin data types from a buffer.
 */
class BufferReader {
  constructor(buffer, offset = 0) {
    this.buffer = buffer;
    this.offset = offset;
    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
  }
  readUInt8() {
    const result = this.buffer.readUInt8(this.offset);
    this.offset++;
    return result;
  }
  readInt32() {
    const result = this.buffer.readInt32LE(this.offset);
    this.offset += 4;
    return result;
  }
  readUInt32() {
    const result = this.buffer.readUInt32LE(this.offset);
    this.offset += 4;
    return result;
  }
  readUInt64() {
    const result = readUInt64LE(this.buffer, this.offset);
    this.offset += 8;
    return result;
  }
  readVarInt() {
    const vi = varuint.decode(this.buffer, this.offset);
    this.offset += varuint.decode.bytes;
    return vi;
  }
  readSlice(n) {
    if (this.buffer.length < this.offset + n) {
      throw new Error('Cannot read slice out of bounds');
    }
    const result = this.buffer.slice(this.offset, this.offset + n);
    this.offset += n;
    return result;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const count = this.readVarInt();
    const vector = [];
    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());
    return vector;
  }
}
exports.BufferReader = BufferReader;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./types":132,"buffer":167,"varuint-bitcoin":362}],107:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.taggedHash =
  exports.TAGGED_HASH_PREFIXES =
  exports.TAGS =
  exports.hash256 =
  exports.hash160 =
  exports.sha256 =
  exports.sha1 =
  exports.ripemd160 =
    void 0;
/**
 * A module for hashing functions.
 * include ripemd160、sha1、sha256、hash160、hash256、taggedHash
 *
 * @packageDocumentation
 */
const ripemd160_1 = require('@noble/hashes/ripemd160');
const sha1_1 = require('@noble/hashes/sha1');
const sha256_1 = require('@noble/hashes/sha256');
function ripemd160(buffer) {
  return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));
}
exports.ripemd160 = ripemd160;
function sha1(buffer) {
  return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));
}
exports.sha1 = sha1;
function sha256(buffer) {
  return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));
}
exports.sha256 = sha256;
function hash160(buffer) {
  return Buffer.from(
    (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer))),
  );
}
exports.hash160 = hash160;
function hash256(buffer) {
  return Buffer.from(
    (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer))),
  );
}
exports.hash256 = hash256;
exports.TAGS = [
  'BIP0340/challenge',
  'BIP0340/aux',
  'BIP0340/nonce',
  'TapLeaf',
  'TapBranch',
  'TapSighash',
  'TapTweak',
  'KeyAgg list',
  'KeyAgg coefficient',
];
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
/**
 * Defines the tagged hash prefixes used in the crypto module.
 */
exports.TAGGED_HASH_PREFIXES = {
  'BIP0340/challenge': Buffer.from([
    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,
    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,
    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,
    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,
  ]),
  'BIP0340/aux': Buffer.from([
    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,
    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,
    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,
    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,
  ]),
  'BIP0340/nonce': Buffer.from([
    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,
    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,
    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,
    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,
  ]),
  TapLeaf: Buffer.from([
    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,
    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,
    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,
    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,
  ]),
  TapBranch: Buffer.from([
    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,
    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,
    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,
    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,
  ]),
  TapSighash: Buffer.from([
    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,
    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,
    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,
    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,
  ]),
  TapTweak: Buffer.from([
    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,
    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,
    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,
    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,
  ]),
  'KeyAgg list': Buffer.from([
    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,
    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,
    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,
    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,
  ]),
  'KeyAgg coefficient': Buffer.from([
    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,
    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,
    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,
    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,
  ]),
};
function taggedHash(prefix, data) {
  return sha256(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));
}
exports.taggedHash = taggedHash;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@noble/hashes/ripemd160":28,"@noble/hashes/sha1":29,"@noble/hashes/sha256":31,"buffer":167}],108:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.getEccLib = exports.initEccLib = void 0;
const _ECCLIB_CACHE = {};
/**
 * Initializes the ECC library with the provided instance.
 * If `eccLib` is `undefined`, the library will be cleared.
 * If `eccLib` is a new instance, it will be verified before setting it as the active library.
 *
 * @param eccLib The instance of the ECC library to initialize.
 * @param opts Extra initialization options. Use {DANGER_DO_NOT_VERIFY_ECCLIB:true} if ecc verification should not be executed. Not recommended!
 */
function initEccLib(eccLib, opts) {
  if (!eccLib) {
    // allow clearing the library
    _ECCLIB_CACHE.eccLib = eccLib;
  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
    if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)
      // new instance, verify it
      verifyEcc(eccLib);
    _ECCLIB_CACHE.eccLib = eccLib;
  }
}
exports.initEccLib = initEccLib;
/**
 * Retrieves the ECC Library instance.
 * Throws an error if the ECC Library is not provided.
 * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.
 * @returns The ECC Library instance.
 * @throws Error if the ECC Library is not provided.
 */
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',
    );
  return _ECCLIB_CACHE.eccLib;
}
exports.getEccLib = getEccLib;
const h = hex => Buffer.from(hex, 'hex');
/**
 * Verifies the ECC functionality.
 *
 * @param ecc - The TinySecp256k1Interface object.
 */
function verifyEcc(ecc) {
  assert(typeof ecc.isXOnlyPoint === 'function');
  assert(
    ecc.isXOnlyPoint(
      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  assert(
    ecc.isXOnlyPoint(
      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),
    ),
  );
  assert(
    ecc.isXOnlyPoint(
      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),
    ),
  );
  assert(
    ecc.isXOnlyPoint(
      h('0000000000000000000000000000000000000000000000000000000000000001'),
    ),
  );
  assert(
    !ecc.isXOnlyPoint(
      h('0000000000000000000000000000000000000000000000000000000000000000'),
    ),
  );
  assert(
    !ecc.isXOnlyPoint(
      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    ),
  );
  assert(typeof ecc.xOnlyPointAddTweak === 'function');
  tweakAddVectors.forEach(t => {
    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));
    if (t.result === null) {
      assert(r === null);
    } else {
      assert(r !== null);
      assert(r.parity === t.parity);
      assert(Buffer.from(r.xOnlyPubkey).equals(h(t.result)));
    }
  });
}
function assert(bool) {
  if (!bool) throw new Error('ecc library invalid');
}
const tweakAddVectors = [
  {
    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',
    parity: -1,
    result: null,
  },
  {
    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',
    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',
    parity: 1,
    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',
  },
  {
    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',
    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',
    parity: 0,
    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',
  },
];

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],109:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.initEccLib =
  exports.Transaction =
  exports.opcodes =
  exports.Psbt =
  exports.Block =
  exports.script =
  exports.payments =
  exports.networks =
  exports.crypto =
  exports.address =
    void 0;
const address = require('./address');
exports.address = address;
const crypto = require('./crypto');
exports.crypto = crypto;
const networks = require('./networks');
exports.networks = networks;
const payments = require('./payments');
exports.payments = payments;
const script = require('./script');
exports.script = script;
var block_1 = require('./block');
Object.defineProperty(exports, 'Block', {
  enumerable: true,
  get: function () {
    return block_1.Block;
  },
});
var psbt_1 = require('./psbt');
Object.defineProperty(exports, 'Psbt', {
  enumerable: true,
  get: function () {
    return psbt_1.Psbt;
  },
});
/** @hidden */
var ops_1 = require('./ops');
Object.defineProperty(exports, 'opcodes', {
  enumerable: true,
  get: function () {
    return ops_1.OPS;
  },
});
var transaction_1 = require('./transaction');
Object.defineProperty(exports, 'Transaction', {
  enumerable: true,
  get: function () {
    return transaction_1.Transaction;
  },
});
var ecc_lib_1 = require('./ecc_lib');
Object.defineProperty(exports, 'initEccLib', {
  enumerable: true,
  get: function () {
    return ecc_lib_1.initEccLib;
  },
});

},{"./address":103,"./block":105,"./crypto":107,"./ecc_lib":108,"./networks":111,"./ops":112,"./payments":115,"./psbt":124,"./script":128,"./transaction":131}],110:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.fastMerkleRoot = void 0;
/**
 * Calculates the Merkle root of an array of buffers using a specified digest function.
 *
 * @param values - The array of buffers.
 * @param digestFn - The digest function used to calculate the hash of the concatenated buffers.
 * @returns The Merkle root as a buffer.
 * @throws {TypeError} If the values parameter is not an array or the digestFn parameter is not a function.
 */
function fastMerkleRoot(values, digestFn) {
  if (!Array.isArray(values)) throw TypeError('Expected values Array');
  if (typeof digestFn !== 'function')
    throw TypeError('Expected digest Function');
  let length = values.length;
  const results = values.concat();
  while (length > 1) {
    let j = 0;
    for (let i = 0; i < length; i += 2, ++j) {
      const left = results[i];
      const right = i + 1 === length ? left : results[i + 1];
      const data = Buffer.concat([left, right]);
      results[j] = digestFn(data);
    }
    length = j;
  }
  return results[0];
}
exports.fastMerkleRoot = fastMerkleRoot;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],111:[function(require,module,exports){
'use strict';
// https://en.bitcoin.it/wiki/List_of_address_prefixes
// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731
Object.defineProperty(exports, '__esModule', { value: true });
exports.testnet = exports.regtest = exports.bitcoin = void 0;
/**
 * Represents the Bitcoin network configuration.
 */
exports.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: 'bc',
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 0x0488b21e,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 0x0488ade4,
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0x00,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 0x05,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 0x80,
};
/**
 * Represents the regtest network configuration.
 */
exports.regtest = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bcrt',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};
/**
 * Represents the testnet network configuration.
 */
exports.testnet = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'tb',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};

},{}],112:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.REVERSE_OPS = exports.OPS = void 0;
const OPS = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255,
};
exports.OPS = OPS;
const REVERSE_OPS = {};
exports.REVERSE_OPS = REVERSE_OPS;
for (const op of Object.keys(OPS)) {
  const code = OPS[op];
  REVERSE_OPS[code] = op;
}

},{}],113:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.tweakKey =
  exports.tapTweakHash =
  exports.tapleafHash =
  exports.findScriptPath =
  exports.toHashTree =
  exports.rootHashFromPath =
  exports.MAX_TAPTREE_DEPTH =
  exports.LEAF_VERSION_TAPSCRIPT =
    void 0;
const buffer_1 = require('buffer');
const ecc_lib_1 = require('../ecc_lib');
const bcrypto = require('../crypto');
const bufferutils_1 = require('../bufferutils');
const types_1 = require('../types');
exports.LEAF_VERSION_TAPSCRIPT = 0xc0;
exports.MAX_TAPTREE_DEPTH = 128;
const isHashBranch = ht => 'left' in ht && 'right' in ht;
/**
 * Calculates the root hash from a given control block and leaf hash.
 * @param controlBlock - The control block buffer.
 * @param leafHash - The leaf hash buffer.
 * @returns The root hash buffer.
 * @throws {TypeError} If the control block length is less than 33.
 */
function rootHashFromPath(controlBlock, leafHash) {
  if (controlBlock.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,
    );
  const m = (controlBlock.length - 33) / 32;
  let kj = leafHash;
  for (let j = 0; j < m; j++) {
    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);
    if (kj.compare(ej) < 0) {
      kj = tapBranchHash(kj, ej);
    } else {
      kj = tapBranchHash(ej, kj);
    }
  }
  return kj;
}
exports.rootHashFromPath = rootHashFromPath;
/**
 * Build a hash tree of merkle nodes from the scripts binary tree.
 * @param scriptTree - the tree of scripts to pairwise hash.
 */
function toHashTree(scriptTree) {
  if ((0, types_1.isTapleaf)(scriptTree))
    return { hash: tapleafHash(scriptTree) };
  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
  hashes.sort((a, b) => a.hash.compare(b.hash));
  const [left, right] = hashes;
  return {
    hash: tapBranchHash(left.hash, right.hash),
    left,
    right,
  };
}
exports.toHashTree = toHashTree;
/**
 * Given a HashTree, finds the path from a particular hash to the root.
 * @param node - the root of the tree
 * @param hash - the hash to search for
 * @returns - array of sibling hashes, from leaf (inclusive) to root
 * (exclusive) needed to prove inclusion of the specified hash. undefined if no
 * path is found
 */
function findScriptPath(node, hash) {
  if (isHashBranch(node)) {
    const leftPath = findScriptPath(node.left, hash);
    if (leftPath !== undefined) return [...leftPath, node.right.hash];
    const rightPath = findScriptPath(node.right, hash);
    if (rightPath !== undefined) return [...rightPath, node.left.hash];
  } else if (node.hash.equals(hash)) {
    return [];
  }
  return undefined;
}
exports.findScriptPath = findScriptPath;
function tapleafHash(leaf) {
  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;
  return bcrypto.taggedHash(
    'TapLeaf',
    buffer_1.Buffer.concat([
      buffer_1.Buffer.from([version]),
      serializeScript(leaf.output),
    ]),
  );
}
exports.tapleafHash = tapleafHash;
function tapTweakHash(pubKey, h) {
  return bcrypto.taggedHash(
    'TapTweak',
    buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]),
  );
}
exports.tapTweakHash = tapTweakHash;
function tweakKey(pubKey, h) {
  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;
  if (pubKey.length !== 32) return null;
  if (h && h.length !== 32) return null;
  const tweakHash = tapTweakHash(pubKey, h);
  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
  if (!res || res.xOnlyPubkey === null) return null;
  return {
    parity: res.parity,
    x: buffer_1.Buffer.from(res.xOnlyPubkey),
  };
}
exports.tweakKey = tweakKey;
function tapBranchHash(a, b) {
  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));
}
function serializeScript(s) {
  const varintLen = bufferutils_1.varuint.encodingLength(s.length);
  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better
  bufferutils_1.varuint.encode(s.length, buffer);
  return buffer_1.Buffer.concat([buffer, s]);
}

},{"../bufferutils":106,"../crypto":107,"../ecc_lib":108,"../types":132,"buffer":167}],114:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2data = void 0;
const networks_1 = require('../networks');
const bscript = require('../script');
const types_1 = require('../types');
const lazy = require('./lazy');
const OPS = bscript.OPS;
// output: OP_RETURN ...
/**
 * Embeds data in a Bitcoin payment.
 * @param a - The payment object.
 * @param opts - Optional payment options.
 * @returns The modified payment object.
 * @throws {TypeError} If there is not enough data or if the output is invalid.
 */
function p2data(a, opts) {
  if (!a.data && !a.output) throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      data: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'embed', network };
  lazy.prop(o, 'output', () => {
    if (!a.data) return;
    return bscript.compile([OPS.OP_RETURN].concat(a.data));
  });
  lazy.prop(o, 'data', () => {
    if (!a.output) return;
    return bscript.decompile(a.output).slice(1);
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      const chunks = bscript.decompile(a.output);
      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');
      if (!chunks.slice(1).every(types_1.typeforce.Buffer))
        throw new TypeError('Output is invalid');
      if (a.data && !(0, types_1.stacksEqual)(a.data, o.data))
        throw new TypeError('Data mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2data = p2data;

},{"../networks":111,"../script":128,"../types":132,"./lazy":116}],115:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2tr =
  exports.p2wsh =
  exports.p2wpkh =
  exports.p2sh =
  exports.p2pkh =
  exports.p2pk =
  exports.p2ms =
  exports.embed =
    void 0;
const embed_1 = require('./embed');
Object.defineProperty(exports, 'embed', {
  enumerable: true,
  get: function () {
    return embed_1.p2data;
  },
});
const p2ms_1 = require('./p2ms');
Object.defineProperty(exports, 'p2ms', {
  enumerable: true,
  get: function () {
    return p2ms_1.p2ms;
  },
});
const p2pk_1 = require('./p2pk');
Object.defineProperty(exports, 'p2pk', {
  enumerable: true,
  get: function () {
    return p2pk_1.p2pk;
  },
});
const p2pkh_1 = require('./p2pkh');
Object.defineProperty(exports, 'p2pkh', {
  enumerable: true,
  get: function () {
    return p2pkh_1.p2pkh;
  },
});
const p2sh_1 = require('./p2sh');
Object.defineProperty(exports, 'p2sh', {
  enumerable: true,
  get: function () {
    return p2sh_1.p2sh;
  },
});
const p2wpkh_1 = require('./p2wpkh');
Object.defineProperty(exports, 'p2wpkh', {
  enumerable: true,
  get: function () {
    return p2wpkh_1.p2wpkh;
  },
});
const p2wsh_1 = require('./p2wsh');
Object.defineProperty(exports, 'p2wsh', {
  enumerable: true,
  get: function () {
    return p2wsh_1.p2wsh;
  },
});
const p2tr_1 = require('./p2tr');
Object.defineProperty(exports, 'p2tr', {
  enumerable: true,
  get: function () {
    return p2tr_1.p2tr;
  },
});
// TODO
// witness commitment

},{"./embed":114,"./p2ms":117,"./p2pk":118,"./p2pkh":119,"./p2sh":120,"./p2tr":121,"./p2wpkh":122,"./p2wsh":123}],116:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.value = exports.prop = void 0;
function prop(object, name, f) {
  Object.defineProperty(object, name, {
    configurable: true,
    enumerable: true,
    get() {
      const _value = f.call(this);
      this[name] = _value;
      return _value;
    },
    set(_value) {
      Object.defineProperty(this, name, {
        configurable: true,
        enumerable: true,
        value: _value,
        writable: true,
      });
    },
  });
}
exports.prop = prop;
function value(f) {
  let _value;
  return () => {
    if (_value !== undefined) return _value;
    _value = f();
    return _value;
  };
}
exports.value = value;

},{}],117:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2ms = void 0;
const networks_1 = require('../networks');
const bscript = require('../script');
const types_1 = require('../types');
const lazy = require('./lazy');
const OPS = bscript.OPS;
const OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1
// input: OP_0 [signatures ...]
// output: m [pubKeys ...] n OP_CHECKMULTISIG
/**
 * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.
 * @param a - The payment object.
 * @param opts - Optional payment options.
 * @returns The created payment object.
 * @throws {TypeError} If the provided data is not valid.
 */
function p2ms(a, opts) {
  if (
    !a.input &&
    !a.output &&
    !(a.pubkeys && a.m !== undefined) &&
    !a.signatures
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  function isAcceptableSignature(x) {
    return (
      bscript.isCanonicalScriptSignature(x) ||
      (opts.allowIncomplete && x === OPS.OP_0) !== undefined
    );
  }
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      m: types_1.typeforce.maybe(types_1.typeforce.Number),
      n: types_1.typeforce.maybe(types_1.typeforce.Number),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      pubkeys: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.isPoint),
      ),
      signatures: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(isAcceptableSignature),
      ),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const network = a.network || networks_1.bitcoin;
  const o = { network };
  let chunks = [];
  let decoded = false;
  function decode(output) {
    if (decoded) return;
    decoded = true;
    chunks = bscript.decompile(output);
    o.m = chunks[0] - OP_INT_BASE;
    o.n = chunks[chunks.length - 2] - OP_INT_BASE;
    o.pubkeys = chunks.slice(1, -2);
  }
  lazy.prop(o, 'output', () => {
    if (!a.m) return;
    if (!o.n) return;
    if (!a.pubkeys) return;
    return bscript.compile(
      [].concat(
        OP_INT_BASE + a.m,
        a.pubkeys,
        OP_INT_BASE + o.n,
        OPS.OP_CHECKMULTISIG,
      ),
    );
  });
  lazy.prop(o, 'm', () => {
    if (!o.output) return;
    decode(o.output);
    return o.m;
  });
  lazy.prop(o, 'n', () => {
    if (!o.pubkeys) return;
    return o.pubkeys.length;
  });
  lazy.prop(o, 'pubkeys', () => {
    if (!a.output) return;
    decode(a.output);
    return o.pubkeys;
  });
  lazy.prop(o, 'signatures', () => {
    if (!a.input) return;
    return bscript.decompile(a.input).slice(1);
  });
  lazy.prop(o, 'input', () => {
    if (!a.signatures) return;
    return bscript.compile([OPS.OP_0].concat(a.signatures));
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  lazy.prop(o, 'name', () => {
    if (!o.m || !o.n) return;
    return `p2ms(${o.m} of ${o.n})`;
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      decode(a.output);
      if (!types_1.typeforce.Number(chunks[0]))
        throw new TypeError('Output is invalid');
      if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
        throw new TypeError('Output is invalid');
      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
        throw new TypeError('Output is invalid');
      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
        throw new TypeError('Output is invalid');
      if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))
        throw new TypeError('Output is invalid');
      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');
      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');
      if (a.pubkeys && !(0, types_1.stacksEqual)(a.pubkeys, o.pubkeys))
        throw new TypeError('Pubkeys mismatch');
    }
    if (a.pubkeys) {
      if (a.n !== undefined && a.n !== a.pubkeys.length)
        throw new TypeError('Pubkey count mismatch');
      o.n = a.pubkeys.length;
      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');
    }
    if (a.signatures) {
      if (a.signatures.length < o.m)
        throw new TypeError('Not enough signatures provided');
      if (a.signatures.length > o.m)
        throw new TypeError('Too many signatures provided');
    }
    if (a.input) {
      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');
      if (
        o.signatures.length === 0 ||
        !o.signatures.every(isAcceptableSignature)
      )
        throw new TypeError('Input has invalid signature(s)');
      if (a.signatures && !(0, types_1.stacksEqual)(a.signatures, o.signatures))
        throw new TypeError('Signature mismatch');
      if (a.m !== undefined && a.m !== a.signatures.length)
        throw new TypeError('Signature count mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2ms = p2ms;

},{"../networks":111,"../script":128,"../types":132,"./lazy":116}],118:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2pk = void 0;
const networks_1 = require('../networks');
const bscript = require('../script');
const types_1 = require('../types');
const lazy = require('./lazy');
const OPS = bscript.OPS;
// input: {signature}
// output: {pubKey} OP_CHECKSIG
/**
 * Creates a pay-to-public-key (P2PK) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The P2PK payment object.
 * @throws {TypeError} If the required data is not provided or if the data is invalid.
 */
function p2pk(a, opts) {
  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2pk', network };
  lazy.prop(o, 'output', () => {
    if (!a.pubkey) return;
    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (!a.output) return;
    return a.output.slice(1, -1);
  });
  lazy.prop(o, 'signature', () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', () => {
    if (!a.signature) return;
    return bscript.compile([a.signature]);
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
        throw new TypeError('Output is invalid');
      if (!(0, types_1.isPoint)(o.pubkey))
        throw new TypeError('Output pubkey is invalid');
      if (a.pubkey && !a.pubkey.equals(o.pubkey))
        throw new TypeError('Pubkey mismatch');
    }
    if (a.signature) {
      if (a.input && !a.input.equals(o.input))
        throw new TypeError('Signature mismatch');
    }
    if (a.input) {
      if (_chunks().length !== 1) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(o.signature))
        throw new TypeError('Input has invalid signature');
    }
  }
  return Object.assign(o, a);
}
exports.p2pk = p2pk;

},{"../networks":111,"../script":128,"../types":132,"./lazy":116}],119:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2pkh = void 0;
const bcrypto = require('../crypto');
const networks_1 = require('../networks');
const bscript = require('../script');
const types_1 = require('../types');
const lazy = require('./lazy');
const bs58check = require('bs58check');
const OPS = bscript.OPS;
// input: {signature} {pubkey}
// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG
/**
 * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The P2PKH payment object.
 * @throws {TypeError} If the required data is not provided or if the data is invalid.
 */
function p2pkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const _address = lazy.value(() => {
    const payload = Buffer.from(bs58check.decode(a.address));
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2pkh', network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(network.pubKeyHash, 0);
    o.hash.copy(payload, 1);
    return bs58check.encode(payload);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(3, 23);
    if (a.address) return _address().hash;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([
      OPS.OP_DUP,
      OPS.OP_HASH160,
      o.hash,
      OPS.OP_EQUALVERIFY,
      OPS.OP_CHECKSIG,
    ]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (!a.input) return;
    return _chunks()[1];
  });
  lazy.prop(o, 'signature', () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return bscript.compile([a.signature, a.pubkey]);
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (_address().version !== network.pubKeyHash)
        throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 25 ||
        a.output[0] !== OPS.OP_DUP ||
        a.output[1] !== OPS.OP_HASH160 ||
        a.output[2] !== 0x14 ||
        a.output[23] !== OPS.OP_EQUALVERIFY ||
        a.output[24] !== OPS.OP_CHECKSIG
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(3, 23);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    if (a.pubkey) {
      const pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
      else hash = pkh;
    }
    if (a.input) {
      const chunks = _chunks();
      if (chunks.length !== 2) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(chunks[0]))
        throw new TypeError('Input has invalid signature');
      if (!(0, types_1.isPoint)(chunks[1]))
        throw new TypeError('Input has invalid pubkey');
      if (a.signature && !a.signature.equals(chunks[0]))
        throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(chunks[1]))
        throw new TypeError('Pubkey mismatch');
      const pkh = bcrypto.hash160(chunks[1]);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2pkh = p2pkh;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../crypto":107,"../networks":111,"../script":128,"../types":132,"./lazy":116,"bs58check":165,"buffer":167}],120:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2sh = void 0;
const bcrypto = require('../crypto');
const networks_1 = require('../networks');
const bscript = require('../script');
const types_1 = require('../types');
const lazy = require('./lazy');
const bs58check = require('bs58check');
const OPS = bscript.OPS;
// input: [redeemScriptSig ...] {redeemScript}
// witness: <?>
// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL
/**
 * Creates a Pay-to-Script-Hash (P2SH) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The P2SH payment object.
 * @throws {TypeError} If the required data is not provided or if the data is invalid.
 */
function p2sh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
      redeem: types_1.typeforce.maybe({
        network: types_1.typeforce.maybe(types_1.typeforce.Object),
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  let network = a.network;
  if (!network) {
    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
  }
  const o = { network };
  const _address = lazy.value(() => {
    const payload = Buffer.from(bs58check.decode(a.address));
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const _redeem = lazy.value(() => {
    const chunks = _chunks();
    const lastChunk = chunks[chunks.length - 1];
    return {
      network,
      output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,
      input: bscript.compile(chunks.slice(0, -1)),
      witness: a.witness || [],
    };
  });
  // output dependents
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(o.network.scriptHash, 0);
    o.hash.copy(payload, 1);
    return bs58check.encode(payload);
  });
  lazy.prop(o, 'hash', () => {
    // in order of least effort
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().hash;
    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
  });
  // input dependents
  lazy.prop(o, 'redeem', () => {
    if (!a.input) return;
    return _redeem();
  });
  lazy.prop(o, 'input', () => {
    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
    return bscript.compile(
      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),
    );
  });
  lazy.prop(o, 'witness', () => {
    if (o.redeem && o.redeem.witness) return o.redeem.witness;
    if (o.input) return [];
  });
  lazy.prop(o, 'name', () => {
    const nameParts = ['p2sh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined)
      nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (_address().version !== network.scriptHash)
        throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 23 ||
        a.output[0] !== OPS.OP_HASH160 ||
        a.output[1] !== 0x14 ||
        a.output[22] !== OPS.OP_EQUAL
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(2, 22);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    // inlined to prevent 'no-inner-declarations' failing
    const checkRedeem = redeem => {
      // is the redeem output empty/invalid?
      if (redeem.output) {
        const decompile = bscript.decompile(redeem.output);
        if (!decompile || decompile.length < 1)
          throw new TypeError('Redeem.output too short');
        if (redeem.output.byteLength > 520)
          throw new TypeError(
            'Redeem.output unspendable if larger than 520 bytes',
          );
        if (bscript.countNonPushOnlyOPs(decompile) > 201)
          throw new TypeError(
            'Redeem.output unspendable with more than 201 non-push ops',
          );
        // match hash against other sources
        const hash2 = bcrypto.hash160(redeem.output);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (redeem.input) {
        const hasInput = redeem.input.length > 0;
        const hasWitness = redeem.witness && redeem.witness.length > 0;
        if (!hasInput && !hasWitness) throw new TypeError('Empty input');
        if (hasInput && hasWitness)
          throw new TypeError('Input and witness provided');
        if (hasInput) {
          const richunks = bscript.decompile(redeem.input);
          if (!bscript.isPushOnly(richunks))
            throw new TypeError('Non push-only scriptSig');
        }
      }
    };
    if (a.input) {
      const chunks = _chunks();
      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');
      if (!Buffer.isBuffer(_redeem().output))
        throw new TypeError('Input is invalid');
      checkRedeem(_redeem());
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError('Network mismatch');
      if (a.input) {
        const redeem = _redeem();
        if (a.redeem.output && !a.redeem.output.equals(redeem.output))
          throw new TypeError('Redeem.output mismatch');
        if (a.redeem.input && !a.redeem.input.equals(redeem.input))
          throw new TypeError('Redeem.input mismatch');
      }
      checkRedeem(a.redeem);
    }
    if (a.witness) {
      if (
        a.redeem &&
        a.redeem.witness &&
        !(0, types_1.stacksEqual)(a.redeem.witness, a.witness)
      )
        throw new TypeError('Witness and redeem.witness mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2sh = p2sh;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../crypto":107,"../networks":111,"../script":128,"../types":132,"./lazy":116,"bs58check":165,"buffer":167}],121:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2tr = void 0;
const buffer_1 = require('buffer');
const networks_1 = require('../networks');
const bscript = require('../script');
const types_1 = require('../types');
const ecc_lib_1 = require('../ecc_lib');
const bip341_1 = require('./bip341');
const lazy = require('./lazy');
const bech32_1 = require('bech32');
const address_1 = require('../address');
const OPS = bscript.OPS;
const TAPROOT_WITNESS_VERSION = 0x01;
const ANNEX_PREFIX = 0x50;
/**
 * Creates a Pay-to-Taproot (P2TR) payment object.
 *
 * @param a - The payment object containing the necessary data for P2TR.
 * @param opts - Optional payment options.
 * @returns The P2TR payment object.
 * @throws {TypeError} If the provided data is invalid or insufficient.
 */
function p2tr(a, opts) {
  if (
    !a.address &&
    !a.output &&
    !a.pubkey &&
    !a.internalPubkey &&
    !(a.witness && a.witness.length > 1)
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
      internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      signature: types_1.typeforce.maybe(
        types_1.typeforce.anyOf(
          types_1.typeforce.BufferN(64),
          types_1.typeforce.BufferN(65),
        ),
      ),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
      scriptTree: types_1.typeforce.maybe(types_1.isTaptree),
      redeem: types_1.typeforce.maybe({
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
    },
    a,
  );
  const _address = lazy.value(() => {
    return (0, address_1.fromBech32)(a.address);
  });
  // remove annex if present, ignored by taproot
  const _witness = lazy.value(() => {
    if (!a.witness || !a.witness.length) return;
    if (
      a.witness.length >= 2 &&
      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX
    ) {
      return a.witness.slice(0, -1);
    }
    return a.witness.slice();
  });
  const _hashTree = lazy.value(() => {
    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);
    if (a.hash) return { hash: a.hash };
    return;
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2tr', network };
  lazy.prop(o, 'address', () => {
    if (!o.pubkey) return;
    const words = bech32_1.bech32m.toWords(o.pubkey);
    words.unshift(TAPROOT_WITNESS_VERSION);
    return bech32_1.bech32m.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    const hashTree = _hashTree();
    if (hashTree) return hashTree.hash;
    const w = _witness();
    if (w && w.length > 1) {
      const controlBlock = w[w.length - 1];
      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
      const script = w[w.length - 2];
      const leafHash = (0, bip341_1.tapleafHash)({
        output: script,
        version: leafVersion,
      });
      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
    }
    return null;
  });
  lazy.prop(o, 'output', () => {
    if (!o.pubkey) return;
    return bscript.compile([OPS.OP_1, o.pubkey]);
  });
  lazy.prop(o, 'redeemVersion', () => {
    if (a.redeemVersion) return a.redeemVersion;
    if (
      a.redeem &&
      a.redeem.redeemVersion !== undefined &&
      a.redeem.redeemVersion !== null
    ) {
      return a.redeem.redeemVersion;
    }
    return bip341_1.LEAF_VERSION_TAPSCRIPT;
  });
  lazy.prop(o, 'redeem', () => {
    const witness = _witness(); // witness without annex
    if (!witness || witness.length < 2) return;
    return {
      output: witness[witness.length - 2],
      witness: witness.slice(0, -2),
      redeemVersion:
        witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,
    };
  });
  lazy.prop(o, 'pubkey', () => {
    if (a.pubkey) return a.pubkey;
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.internalPubkey) {
      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);
      if (tweakedKey) return tweakedKey.x;
    }
  });
  lazy.prop(o, 'internalPubkey', () => {
    if (a.internalPubkey) return a.internalPubkey;
    const witness = _witness();
    if (witness && witness.length > 1)
      return witness[witness.length - 1].slice(1, 33);
  });
  lazy.prop(o, 'signature', () => {
    if (a.signature) return a.signature;
    const witness = _witness(); // witness without annex
    if (!witness || witness.length !== 1) return;
    return witness[0];
  });
  lazy.prop(o, 'witness', () => {
    if (a.witness) return a.witness;
    const hashTree = _hashTree();
    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion,
      });
      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);
      if (!path) return;
      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);
      if (!outputKey) return;
      const controlBock = buffer_1.Buffer.concat(
        [
          buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),
          a.internalPubkey,
        ].concat(path),
      );
      return [a.redeem.output, controlBock];
    }
    if (a.signature) return [a.signature];
  });
  // extended validation
  if (opts.validate) {
    let pubkey = buffer_1.Buffer.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== TAPROOT_WITNESS_VERSION)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 32)
        throw new TypeError('Invalid address data');
      pubkey = _address().data;
    }
    if (a.pubkey) {
      if (pubkey.length > 0 && !pubkey.equals(a.pubkey))
        throw new TypeError('Pubkey mismatch');
      else pubkey = a.pubkey;
    }
    if (a.output) {
      if (
        a.output.length !== 34 ||
        a.output[0] !== OPS.OP_1 ||
        a.output[1] !== 0x20
      )
        throw new TypeError('Output is invalid');
      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))
        throw new TypeError('Pubkey mismatch');
      else pubkey = a.output.slice(2);
    }
    if (a.internalPubkey) {
      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);
      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))
        throw new TypeError('Pubkey mismatch');
      else pubkey = tweakedKey.x;
    }
    if (pubkey && pubkey.length) {
      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))
        throw new TypeError('Invalid pubkey for p2tr');
    }
    const hashTree = _hashTree();
    if (a.hash && hashTree) {
      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');
    }
    if (a.redeem && a.redeem.output && hashTree) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion,
      });
      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))
        throw new TypeError('Redeem script not in tree');
    }
    const witness = _witness();
    // compare the provided redeem data with the one computed from witness
    if (a.redeem && o.redeem) {
      if (a.redeem.redeemVersion) {
        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)
          throw new TypeError('Redeem.redeemVersion and witness mismatch');
      }
      if (a.redeem.output) {
        if (bscript.decompile(a.redeem.output).length === 0)
          throw new TypeError('Redeem.output is invalid');
        // output redeem is constructed from the witness
        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))
          throw new TypeError('Redeem.output and witness mismatch');
      }
      if (a.redeem.witness) {
        if (
          o.redeem.witness &&
          !(0, types_1.stacksEqual)(a.redeem.witness, o.redeem.witness)
        )
          throw new TypeError('Redeem.witness and witness mismatch');
      }
    }
    if (witness && witness.length) {
      if (witness.length === 1) {
        // key spending
        if (a.signature && !a.signature.equals(witness[0]))
          throw new TypeError('Signature mismatch');
      } else {
        // script path spending
        const controlBlock = witness[witness.length - 1];
        if (controlBlock.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,
          );
        if ((controlBlock.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${controlBlock.length} is incorrect!`,
          );
        const m = (controlBlock.length - 33) / 32;
        if (m > 128)
          throw new TypeError(
            `The script path is too long. Got ${m}, expected max 128.`,
          );
        const internalPubkey = controlBlock.slice(1, 33);
        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))
          throw new TypeError('Internal pubkey mismatch');
        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))
          throw new TypeError('Invalid internalPubkey for p2tr witness');
        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
        const script = witness[witness.length - 2];
        const leafHash = (0, bip341_1.tapleafHash)({
          output: script,
          version: leafVersion,
        });
        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);
        if (!outputKey)
          // todo: needs test data
          throw new TypeError('Invalid outputKey for p2tr witness');
        if (pubkey.length && !pubkey.equals(outputKey.x))
          throw new TypeError('Pubkey mismatch for p2tr witness');
        if (outputKey.parity !== (controlBlock[0] & 1))
          throw new Error('Incorrect parity');
      }
    }
  }
  return Object.assign(o, a);
}
exports.p2tr = p2tr;

},{"../address":103,"../ecc_lib":108,"../networks":111,"../script":128,"../types":132,"./bip341":113,"./lazy":116,"bech32":53,"buffer":167}],122:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2wpkh = void 0;
const bcrypto = require('../crypto');
const networks_1 = require('../networks');
const bscript = require('../script');
const types_1 = require('../types');
const lazy = require('./lazy');
const bech32_1 = require('bech32');
const OPS = bscript.OPS;
const EMPTY_BUFFER = Buffer.alloc(0);
// witness: {signature} {pubKey}
// input: <>
// output: OP_0 {pubKeyHash}
/**
 * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The p2wpkh payment object.
 * @throws {TypeError} If the required data is missing or invalid.
 */
function p2wpkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const _address = lazy.value(() => {
    const result = bech32_1.bech32.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Buffer.from(data),
    };
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2wpkh', network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().data;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (a.pubkey) return a.pubkey;
    if (!a.witness) return;
    return a.witness[1];
  });
  lazy.prop(o, 'signature', () => {
    if (!a.witness) return;
    return a.witness[0];
  });
  lazy.prop(o, 'input', () => {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return [a.signature, a.pubkey];
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 20)
        throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 22 ||
        a.output[0] !== OPS.OP_0 ||
        a.output[1] !== 0x14
      )
        throw new TypeError('Output is invalid');
      if (hash.length > 0 && !hash.equals(a.output.slice(2)))
        throw new TypeError('Hash mismatch');
      else hash = a.output.slice(2);
    }
    if (a.pubkey) {
      const pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
      else hash = pkh;
      if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)
        throw new TypeError('Invalid pubkey for p2wpkh');
    }
    if (a.witness) {
      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');
      if (!bscript.isCanonicalScriptSignature(a.witness[0]))
        throw new TypeError('Witness has invalid signature');
      if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)
        throw new TypeError('Witness has invalid pubkey');
      if (a.signature && !a.signature.equals(a.witness[0]))
        throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(a.witness[1]))
        throw new TypeError('Pubkey mismatch');
      const pkh = bcrypto.hash160(a.witness[1]);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2wpkh = p2wpkh;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../crypto":107,"../networks":111,"../script":128,"../types":132,"./lazy":116,"bech32":53,"buffer":167}],123:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2wsh = void 0;
const bcrypto = require('../crypto');
const networks_1 = require('../networks');
const bscript = require('../script');
const types_1 = require('../types');
const lazy = require('./lazy');
const bech32_1 = require('bech32');
const OPS = bscript.OPS;
const EMPTY_BUFFER = Buffer.alloc(0);
function chunkHasUncompressedPubkey(chunk) {
  if (
    Buffer.isBuffer(chunk) &&
    chunk.length === 65 &&
    chunk[0] === 0x04 &&
    (0, types_1.isPoint)(chunk)
  ) {
    return true;
  } else {
    return false;
  }
}
// input: <>
// witness: [redeemScriptSig ...] {redeemScript}
// output: OP_0 {sha256(redeemScript)}
/**
 * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The P2WSH payment object.
 * @throws {TypeError} If the required data is missing or invalid.
 */
function p2wsh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
      redeem: types_1.typeforce.maybe({
        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        network: types_1.typeforce.maybe(types_1.typeforce.Object),
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const _address = lazy.value(() => {
    const result = bech32_1.bech32.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Buffer.from(data),
    };
  });
  const _rchunks = lazy.value(() => {
    return bscript.decompile(a.redeem.input);
  });
  let network = a.network;
  if (!network) {
    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
  }
  const o = { network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'redeem', () => {
    if (!a.witness) return;
    return {
      output: a.witness[a.witness.length - 1],
      input: EMPTY_BUFFER,
      witness: a.witness.slice(0, -1),
    };
  });
  lazy.prop(o, 'input', () => {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', () => {
    // transform redeem input to witness stack?
    if (
      a.redeem &&
      a.redeem.input &&
      a.redeem.input.length > 0 &&
      a.redeem.output &&
      a.redeem.output.length > 0
    ) {
      const stack = bscript.toStack(_rchunks());
      // assign, and blank the existing input
      o.redeem = Object.assign({ witness: stack }, a.redeem);
      o.redeem.input = EMPTY_BUFFER;
      return [].concat(stack, a.redeem.output);
    }
    if (!a.redeem) return;
    if (!a.redeem.output) return;
    if (!a.redeem.witness) return;
    return [].concat(a.redeem.witness, a.redeem.output);
  });
  lazy.prop(o, 'name', () => {
    const nameParts = ['p2wsh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined)
      nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (_address().prefix !== network.bech32)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 32)
        throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 34 ||
        a.output[0] !== OPS.OP_0 ||
        a.output[1] !== 0x20
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(2);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError('Network mismatch');
      // is there two redeem sources?
      if (
        a.redeem.input &&
        a.redeem.input.length > 0 &&
        a.redeem.witness &&
        a.redeem.witness.length > 0
      )
        throw new TypeError('Ambiguous witness source');
      // is the redeem output non-empty/valid?
      if (a.redeem.output) {
        const decompile = bscript.decompile(a.redeem.output);
        if (!decompile || decompile.length < 1)
          throw new TypeError('Redeem.output is invalid');
        if (a.redeem.output.byteLength > 3600)
          throw new TypeError(
            'Redeem.output unspendable if larger than 3600 bytes',
          );
        if (bscript.countNonPushOnlyOPs(decompile) > 201)
          throw new TypeError(
            'Redeem.output unspendable with more than 201 non-push ops',
          );
        // match hash against other sources
        const hash2 = bcrypto.sha256(a.redeem.output);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
        throw new TypeError('Non push-only scriptSig');
      if (
        a.witness &&
        a.redeem.witness &&
        !(0, types_1.stacksEqual)(a.witness, a.redeem.witness)
      )
        throw new TypeError('Witness and redeem.witness mismatch');
      if (
        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||
        (a.redeem.output &&
          (bscript.decompile(a.redeem.output) || []).some(
            chunkHasUncompressedPubkey,
          ))
      ) {
        throw new TypeError(
          'redeem.input or redeem.output contains uncompressed pubkey',
        );
      }
    }
    if (a.witness && a.witness.length > 0) {
      const wScript = a.witness[a.witness.length - 1];
      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
        throw new TypeError('Witness and redeem.output mismatch');
      if (
        a.witness.some(chunkHasUncompressedPubkey) ||
        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)
      )
        throw new TypeError('Witness contains uncompressed pubkey');
    }
  }
  return Object.assign(o, a);
}
exports.p2wsh = p2wsh;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../crypto":107,"../networks":111,"../script":128,"../types":132,"./lazy":116,"bech32":53,"buffer":167}],124:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.Psbt = void 0;
const bip174_1 = require('bip174');
const varuint = require('bip174/src/lib/converter/varint');
const utils_1 = require('bip174/src/lib/utils');
const address_1 = require('./address');
const bufferutils_1 = require('./bufferutils');
const networks_1 = require('./networks');
const payments = require('./payments');
const bip341_1 = require('./payments/bip341');
const bscript = require('./script');
const transaction_1 = require('./transaction');
const bip371_1 = require('./psbt/bip371');
const psbtutils_1 = require('./psbt/psbtutils');
/**
 * These are the default arguments for a Psbt instance.
 */
const DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5000, // satoshi per byte
};
/**
 * Psbt class can parse and generate a PSBT binary based off of the BIP174.
 * There are 6 roles that this class fulfills. (Explained in BIP174)
 *
 * Creator: This can be done with `new Psbt()`
 *
 * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
 *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
 *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
 *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
 *   addInput requires hash: Buffer | string; and index: number; as attributes
 *   and can also include any attributes that are used in updateInput method.
 *   addOutput requires script: Buffer; and value: number; and likewise can include
 *   data for updateOutput.
 *   For a list of what attributes should be what types. Check the bip174 library.
 *   Also, check the integration tests for some examples of usage.
 *
 * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
 *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
 *   your info. Or you can explicitly sign a specific input with signInput and
 *   signInputAsync. For the async methods you can create a SignerAsync object
 *   and use something like a hardware wallet to sign with. (You must implement this)
 *
 * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
 *   the psbt calling combine will always have precedence when a conflict occurs.
 *   Combine checks if the internal bitcoin transaction is the same, so be sure that
 *   all sequences, version, locktime, etc. are the same before combining.
 *
 * Input Finalizer: This role is fairly important. Not only does it need to construct
 *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
 *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
 *   Running any finalize method will delete any data in the input(s) that are no longer
 *   needed due to the finalized scripts containing the information.
 *
 * Transaction Extractor: This role will perform some checks before returning a
 *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
 */
class Psbt {
  static fromBase64(data, opts = {}) {
    const buffer = Buffer.from(data, 'base64');
    return this.fromBuffer(buffer, opts);
  }
  static fromHex(data, opts = {}) {
    const buffer = Buffer.from(data, 'hex');
    return this.fromBuffer(buffer, opts);
  }
  static fromBuffer(buffer, opts = {}) {
    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
    const psbt = new Psbt(opts, psbtBase);
    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
    return psbt;
  }
  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = data;
    // set defaults
    this.opts = Object.assign({}, DEFAULT_OPTS, opts);
    this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: false,
    };
    if (this.data.inputs.length === 0) this.setVersion(2);
    // Make data hidden when enumerating
    const dpew = (obj, attr, enumerable, writable) =>
      Object.defineProperty(obj, attr, {
        enumerable,
        writable,
      });
    dpew(this, '__CACHE', false, true);
    dpew(this, 'opts', false, true);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(version) {
    this.setVersion(version);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(locktime) {
    this.setLocktime(locktime);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map(input => ({
      hash: (0, bufferutils_1.cloneBuffer)(input.hash),
      index: input.index,
      sequence: input.sequence,
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map(output => {
      let address;
      try {
        address = (0, address_1.fromOutputScript)(
          output.script,
          this.opts.network,
        );
      } catch (_) {}
      return {
        script: (0, bufferutils_1.cloneBuffer)(output.script),
        value: output.value,
        address,
      };
    });
  }
  combine(...those) {
    this.data.combine(...those.map(o => o.data));
    return this;
  }
  clone() {
    // TODO: more efficient cloning
    const res = Psbt.fromBuffer(this.data.toBuffer());
    res.opts = JSON.parse(JSON.stringify(this.opts));
    return res;
  }
  setMaximumFeeRate(satoshiPerByte) {
    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw
    this.opts.maximumFeeRate = satoshiPerByte;
  }
  setVersion(version) {
    check32Bit(version);
    checkInputsForPartialSig(this.data.inputs, 'setVersion');
    const c = this.__CACHE;
    c.__TX.version = version;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  setLocktime(locktime) {
    check32Bit(locktime);
    checkInputsForPartialSig(this.data.inputs, 'setLocktime');
    const c = this.__CACHE;
    c.__TX.locktime = locktime;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  setInputSequence(inputIndex, sequence) {
    check32Bit(sequence);
    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');
    const c = this.__CACHE;
    if (c.__TX.ins.length <= inputIndex) {
      throw new Error('Input index too high');
    }
    c.__TX.ins[inputIndex].sequence = sequence;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  addInputs(inputDatas) {
    inputDatas.forEach(inputData => this.addInput(inputData));
    return this;
  }
  addInput(inputData) {
    if (
      arguments.length > 1 ||
      !inputData ||
      inputData.hash === undefined ||
      inputData.index === undefined
    ) {
      throw new Error(
        `Invalid arguments for Psbt.addInput. ` +
          `Requires single object with at least [hash] and [index]`,
      );
    }
    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');
    checkInputsForPartialSig(this.data.inputs, 'addInput');
    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
    const c = this.__CACHE;
    this.data.addInput(inputData);
    const txIn = c.__TX.ins[c.__TX.ins.length - 1];
    checkTxInputCache(c, txIn);
    const inputIndex = this.data.inputs.length - 1;
    const input = this.data.inputs[inputIndex];
    if (input.nonWitnessUtxo) {
      addNonWitnessTxCache(this.__CACHE, input, inputIndex);
    }
    c.__FEE = undefined;
    c.__FEE_RATE = undefined;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  addOutputs(outputDatas) {
    outputDatas.forEach(outputData => this.addOutput(outputData));
    return this;
  }
  addOutput(outputData) {
    if (
      arguments.length > 1 ||
      !outputData ||
      outputData.value === undefined ||
      (outputData.address === undefined && outputData.script === undefined)
    ) {
      throw new Error(
        `Invalid arguments for Psbt.addOutput. ` +
          `Requires single object with at least [script or address] and [value]`,
      );
    }
    checkInputsForPartialSig(this.data.inputs, 'addOutput');
    const { address } = outputData;
    if (typeof address === 'string') {
      const { network } = this.opts;
      const script = (0, address_1.toOutputScript)(address, network);
      outputData = Object.assign({}, outputData, { script });
    }
    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');
    const c = this.__CACHE;
    this.data.addOutput(outputData);
    c.__FEE = undefined;
    c.__FEE_RATE = undefined;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  extractTransaction(disableFeeCheck) {
    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');
    const c = this.__CACHE;
    if (!disableFeeCheck) {
      checkFees(this, c, this.opts);
    }
    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
    const tx = c.__TX.clone();
    inputFinalizeGetAmts(this.data.inputs, tx, c, true);
    return tx;
  }
  getFeeRate() {
    return getTxCacheValue(
      '__FEE_RATE',
      'fee rate',
      this.data.inputs,
      this.__CACHE,
    );
  }
  getFee() {
    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));
    return this;
  }
  finalizeInput(inputIndex, finalScriptsFunc) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input))
      return this._finalizeTaprootInput(
        inputIndex,
        input,
        undefined,
        finalScriptsFunc,
      );
    return this._finalizeInput(inputIndex, input, finalScriptsFunc);
  }
  finalizeTaprootInput(
    inputIndex,
    tapLeafHashToFinalize,
    finalScriptsFunc = bip371_1.tapScriptFinalizer,
  ) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input))
      return this._finalizeTaprootInput(
        inputIndex,
        input,
        tapLeafHashToFinalize,
        finalScriptsFunc,
      );
    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
  }
  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {
    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
      inputIndex,
      input,
      this.__CACHE,
    );
    if (!script) throw new Error(`No script found for input #${inputIndex}`);
    checkPartialSigSighashes(input);
    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
      inputIndex,
      input,
      script,
      isSegwit,
      isP2SH,
      isP2WSH,
    );
    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
    if (finalScriptWitness)
      this.data.updateInput(inputIndex, { finalScriptWitness });
    if (!finalScriptSig && !finalScriptWitness)
      throw new Error(`Unknown error finalizing input #${inputIndex}`);
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  _finalizeTaprootInput(
    inputIndex,
    input,
    tapLeafHashToFinalize,
    finalScriptsFunc = bip371_1.tapScriptFinalizer,
  ) {
    if (!input.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,
      );
    // Check key spend first. Increased privacy and reduced block space.
    if (input.tapKeySig) {
      const payment = payments.p2tr({
        output: input.witnessUtxo.script,
        signature: input.tapKeySig,
      });
      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
        payment.witness,
      );
      this.data.updateInput(inputIndex, { finalScriptWitness });
    } else {
      const { finalScriptWitness } = finalScriptsFunc(
        inputIndex,
        input,
        tapLeafHashToFinalize,
      );
      this.data.updateInput(inputIndex, { finalScriptWitness });
    }
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  getInputType(inputIndex) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
    const result = getMeaningfulScript(
      script,
      inputIndex,
      'input',
      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
      input.witnessScript ||
        redeemFromFinalWitnessScript(input.finalScriptWitness),
    );
    const type = result.type === 'raw' ? '' : result.type + '-';
    const mainType = classifyScript(result.meaningfulScript);
    return type + mainType;
  }
  inputHasPubkey(inputIndex, pubkey) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
  }
  inputHasHDKey(inputIndex, root) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return (
      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)
    );
  }
  outputHasPubkey(outputIndex, pubkey) {
    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
  }
  outputHasHDKey(outputIndex, root) {
    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return (
      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)
    );
  }
  validateSignaturesOfAllInputs(validator) {
    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
    const results = range(this.data.inputs.length).map(idx =>
      this.validateSignaturesOfInput(idx, validator),
    );
    return results.reduce((final, res) => res === true && final, true);
  }
  validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    if ((0, bip371_1.isTaprootInput)(input))
      return this.validateSignaturesOfTaprootInput(
        inputIndex,
        validator,
        pubkey,
      );
    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
  }
  _validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const partialSig = (input || {}).partialSig;
    if (!input || !partialSig || partialSig.length < 1)
      throw new Error('No signatures to validate');
    if (typeof validator !== 'function')
      throw new Error('Need validator function to validate signatures');
    const mySigs = pubkey
      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))
      : partialSig;
    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');
    const results = [];
    let hashCache;
    let scriptCache;
    let sighashCache;
    for (const pSig of mySigs) {
      const sig = bscript.signature.decode(pSig.signature);
      const { hash, script } =
        sighashCache !== sig.hashType
          ? getHashForSig(
              inputIndex,
              Object.assign({}, input, { sighashType: sig.hashType }),
              this.__CACHE,
              true,
            )
          : { hash: hashCache, script: scriptCache };
      sighashCache = sig.hashType;
      hashCache = hash;
      scriptCache = script;
      checkScriptForPubkey(pSig.pubkey, script, 'verify');
      results.push(validator(pSig.pubkey, hash, sig.signature));
    }
    return results.every(res => res === true);
  }
  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const tapKeySig = (input || {}).tapKeySig;
    const tapScriptSig = (input || {}).tapScriptSig;
    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
      throw new Error('No signatures to validate');
    if (typeof validator !== 'function')
      throw new Error('Need validator function to validate signatures');
    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);
    const allHashses = pubkey
      ? getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          pubkey,
          this.__CACHE,
        )
      : getAllTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          this.__CACHE,
        );
    if (!allHashses.length) throw new Error('No signatures for this pubkey');
    const tapKeyHash = allHashses.find(h => !h.leafHash);
    let validationResultCount = 0;
    if (tapKeySig && tapKeyHash) {
      const isValidTapkeySig = validator(
        tapKeyHash.pubkey,
        tapKeyHash.hash,
        trimTaprootSig(tapKeySig),
      );
      if (!isValidTapkeySig) return false;
      validationResultCount++;
    }
    if (tapScriptSig) {
      for (const tapSig of tapScriptSig) {
        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));
        if (tapSigHash) {
          const isValidTapScriptSig = validator(
            tapSig.pubkey,
            tapSigHash.hash,
            trimTaprootSig(tapSig.signature),
          );
          if (!isValidTapScriptSig) return false;
          validationResultCount++;
        }
      }
    }
    return validationResultCount > 0;
  }
  signAllInputsHD(
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error('Need HDSigner to sign input');
    }
    const results = [];
    for (const i of range(this.data.inputs.length)) {
      try {
        this.signInputHD(i, hdKeyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every(v => v === false)) {
      throw new Error('No inputs were signed');
    }
    return this;
  }
  signAllInputsHDAsync(
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error('Need HDSigner to sign input'));
      }
      const results = [];
      const promises = [];
      for (const i of range(this.data.inputs.length)) {
        promises.push(
          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
            () => {
              results.push(true);
            },
            () => {
              results.push(false);
            },
          ),
        );
      }
      return Promise.all(promises).then(() => {
        if (results.every(v => v === false)) {
          return reject(new Error('No inputs were signed'));
        }
        resolve();
      });
    });
  }
  signInputHD(
    inputIndex,
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error('Need HDSigner to sign input');
    }
    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));
    return this;
  }
  signInputHDAsync(
    inputIndex,
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error('Need HDSigner to sign input'));
      }
      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
      const promises = signers.map(signer =>
        this.signInputAsync(inputIndex, signer, sighashTypes),
      );
      return Promise.all(promises)
        .then(() => {
          resolve();
        })
        .catch(reject);
    });
  }
  signAllInputs(keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    // TODO: Add a pubkey/pubkeyhash cache to each input
    // as input information is added, then eventually
    // optimize this method.
    const results = [];
    for (const i of range(this.data.inputs.length)) {
      try {
        this.signInput(i, keyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every(v => v === false)) {
      throw new Error('No inputs were signed');
    }
    return this;
  }
  signAllInputsAsync(keyPair, sighashTypes) {
    return new Promise((resolve, reject) => {
      if (!keyPair || !keyPair.publicKey)
        return reject(new Error('Need Signer to sign input'));
      // TODO: Add a pubkey/pubkeyhash cache to each input
      // as input information is added, then eventually
      // optimize this method.
      const results = [];
      const promises = [];
      for (const [i] of this.data.inputs.entries()) {
        promises.push(
          this.signInputAsync(i, keyPair, sighashTypes).then(
            () => {
              results.push(true);
            },
            () => {
              results.push(false);
            },
          ),
        );
      }
      return Promise.all(promises).then(() => {
        if (results.every(v => v === false)) {
          return reject(new Error('No inputs were signed'));
        }
        resolve();
      });
    });
  }
  signInput(inputIndex, keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input)) {
      return this._signTaprootInput(
        inputIndex,
        input,
        keyPair,
        undefined,
        sighashTypes,
      );
    }
    return this._signInput(inputIndex, keyPair, sighashTypes);
  }
  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input))
      return this._signTaprootInput(
        inputIndex,
        input,
        keyPair,
        tapLeafHashToSign,
        sighashTypes,
      );
    throw new Error(`Input #${inputIndex} is not of type Taproot.`);
  }
  _signInput(
    inputIndex,
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    const { hash, sighashType } = getHashAndSighashType(
      this.data.inputs,
      inputIndex,
      keyPair.publicKey,
      this.__CACHE,
      sighashTypes,
    );
    const partialSig = [
      {
        pubkey: keyPair.publicKey,
        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),
      },
    ];
    this.data.updateInput(inputIndex, { partialSig });
    return this;
  }
  _signTaprootInput(
    inputIndex,
    input,
    keyPair,
    tapLeafHashToSign,
    allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],
  ) {
    const hashesForSig = this.checkTaprootHashesForSig(
      inputIndex,
      input,
      keyPair,
      tapLeafHashToSign,
      allowedSighashTypes,
    );
    const tapKeySig = hashesForSig
      .filter(h => !h.leafHash)
      .map(h =>
        (0, bip371_1.serializeTaprootSignature)(
          keyPair.signSchnorr(h.hash),
          input.sighashType,
        ),
      )[0];
    const tapScriptSig = hashesForSig
      .filter(h => !!h.leafHash)
      .map(h => ({
        pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
        signature: (0, bip371_1.serializeTaprootSignature)(
          keyPair.signSchnorr(h.hash),
          input.sighashType,
        ),
        leafHash: h.leafHash,
      }));
    if (tapKeySig) {
      this.data.updateInput(inputIndex, { tapKeySig });
    }
    if (tapScriptSig.length) {
      this.data.updateInput(inputIndex, { tapScriptSig });
    }
    return this;
  }
  signInputAsync(inputIndex, keyPair, sighashTypes) {
    return Promise.resolve().then(() => {
      if (!keyPair || !keyPair.publicKey)
        throw new Error('Need Signer to sign input');
      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_1.isTaprootInput)(input))
        return this._signTaprootInputAsync(
          inputIndex,
          input,
          keyPair,
          undefined,
          sighashTypes,
        );
      return this._signInputAsync(inputIndex, keyPair, sighashTypes);
    });
  }
  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
    return Promise.resolve().then(() => {
      if (!keyPair || !keyPair.publicKey)
        throw new Error('Need Signer to sign input');
      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_1.isTaprootInput)(input))
        return this._signTaprootInputAsync(
          inputIndex,
          input,
          keyPair,
          tapLeafHash,
          sighashTypes,
        );
      throw new Error(`Input #${inputIndex} is not of type Taproot.`);
    });
  }
  _signInputAsync(
    inputIndex,
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    const { hash, sighashType } = getHashAndSighashType(
      this.data.inputs,
      inputIndex,
      keyPair.publicKey,
      this.__CACHE,
      sighashTypes,
    );
    return Promise.resolve(keyPair.sign(hash)).then(signature => {
      const partialSig = [
        {
          pubkey: keyPair.publicKey,
          signature: bscript.signature.encode(signature, sighashType),
        },
      ];
      this.data.updateInput(inputIndex, { partialSig });
    });
  }
  async _signTaprootInputAsync(
    inputIndex,
    input,
    keyPair,
    tapLeafHash,
    sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],
  ) {
    const hashesForSig = this.checkTaprootHashesForSig(
      inputIndex,
      input,
      keyPair,
      tapLeafHash,
      sighashTypes,
    );
    const signaturePromises = [];
    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];
    if (tapKeyHash) {
      const tapKeySigPromise = Promise.resolve(
        keyPair.signSchnorr(tapKeyHash.hash),
      ).then(sig => {
        return {
          tapKeySig: (0, bip371_1.serializeTaprootSignature)(
            sig,
            input.sighashType,
          ),
        };
      });
      signaturePromises.push(tapKeySigPromise);
    }
    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);
    if (tapScriptHashes.length) {
      const tapScriptSigPromises = tapScriptHashes.map(tsh => {
        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(
          signature => {
            const tapScriptSig = [
              {
                pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
                signature: (0, bip371_1.serializeTaprootSignature)(
                  signature,
                  input.sighashType,
                ),
                leafHash: tsh.leafHash,
              },
            ];
            return { tapScriptSig };
          },
        );
      });
      signaturePromises.push(...tapScriptSigPromises);
    }
    return Promise.all(signaturePromises).then(results => {
      results.forEach(v => this.data.updateInput(inputIndex, v));
    });
  }
  checkTaprootHashesForSig(
    inputIndex,
    input,
    keyPair,
    tapLeafHashToSign,
    allowedSighashTypes,
  ) {
    if (typeof keyPair.signSchnorr !== 'function')
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,
      );
    const hashesForSig = getTaprootHashesForSig(
      inputIndex,
      input,
      this.data.inputs,
      keyPair.publicKey,
      this.__CACHE,
      tapLeafHashToSign,
      allowedSighashTypes,
    );
    if (!hashesForSig || !hashesForSig.length)
      throw new Error(
        `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(
          'hex',
        )}`,
      );
    return hashesForSig;
  }
  toBuffer() {
    checkCache(this.__CACHE);
    return this.data.toBuffer();
  }
  toHex() {
    checkCache(this.__CACHE);
    return this.data.toHex();
  }
  toBase64() {
    checkCache(this.__CACHE);
    return this.data.toBase64();
  }
  updateGlobal(updateData) {
    this.data.updateGlobal(updateData);
    return this;
  }
  updateInput(inputIndex, updateData) {
    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
    (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[inputIndex],
      updateData,
      'updateInput',
    );
    this.data.updateInput(inputIndex, updateData);
    if (updateData.nonWitnessUtxo) {
      addNonWitnessTxCache(
        this.__CACHE,
        this.data.inputs[inputIndex],
        inputIndex,
      );
    }
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const outputData = this.data.outputs[outputIndex];
    (0, bip371_1.checkTaprootOutputFields)(
      outputData,
      updateData,
      'updateOutput',
    );
    this.data.updateOutput(outputIndex, updateData);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    this.data.addUnknownKeyValToGlobal(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    this.data.addUnknownKeyValToInput(inputIndex, keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
}
exports.Psbt = Psbt;
/**
 * This function is needed to pass to the bip174 base class's fromBuffer.
 * It takes the "transaction buffer" portion of the psbt buffer and returns a
 * Transaction (From the bip174 library) interface.
 */
const transactionFromBuffer = buffer => new PsbtTransaction(buffer);
/**
 * This class implements the Transaction interface from bip174 library.
 * It contains a bitcoinjs-lib Transaction object.
 */
class PsbtTransaction {
  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(buffer);
    checkTxEmpty(this.tx);
    Object.defineProperty(this, 'tx', {
      enumerable: false,
      writable: true,
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length,
    };
  }
  addInput(input) {
    if (
      input.hash === undefined ||
      input.index === undefined ||
      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||
      typeof input.index !== 'number'
    ) {
      throw new Error('Error adding input.');
    }
    const hash =
      typeof input.hash === 'string'
        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))
        : input.hash;
    this.tx.addInput(hash, input.index, input.sequence);
  }
  addOutput(output) {
    if (
      output.script === undefined ||
      output.value === undefined ||
      !Buffer.isBuffer(output.script) ||
      typeof output.value !== 'number'
    ) {
      throw new Error('Error adding output.');
    }
    this.tx.addOutput(output.script, output.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(input, script, scriptType) {
  switch (scriptType) {
    case 'pubkey':
    case 'pubkeyhash':
    case 'witnesspubkeyhash':
      return hasSigs(1, input.partialSig);
    case 'multisig':
      const p2ms = payments.p2ms({ output: script });
      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
    default:
      return false;
  }
}
function checkCache(cache) {
  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
    throw new Error('Not BIP174 compliant, can not export');
  }
}
function hasSigs(neededSigs, partialSig, pubkeys) {
  if (!partialSig) return false;
  let sigs;
  if (pubkeys) {
    sigs = pubkeys
      .map(pkey => {
        const pubkey = compressPubkey(pkey);
        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));
      })
      .filter(v => !!v);
  } else {
    sigs = partialSig;
  }
  if (sigs.length > neededSigs) throw new Error('Too many signatures');
  return sigs.length === neededSigs;
}
function isFinalized(input) {
  return !!input.finalScriptSig || !!input.finalScriptWitness;
}
function bip32DerivationIsMine(root) {
  return d => {
    if (!d.masterFingerprint.equals(root.fingerprint)) return false;
    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
    return true;
  };
}
function check32Bit(num) {
  if (
    typeof num !== 'number' ||
    num !== Math.floor(num) ||
    num > 0xffffffff ||
    num < 0
  ) {
    throw new Error('Invalid 32 bit integer');
  }
}
function checkFees(psbt, cache, opts) {
  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
  const vsize = cache.__EXTRACTED_TX.virtualSize();
  const satoshis = feeRate * vsize;
  if (feeRate >= opts.maximumFeeRate) {
    throw new Error(
      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +
        `fees, which is ${feeRate} satoshi per byte for a transaction ` +
        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +
        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +
        `pass true to the first arg of extractTransaction.`,
    );
  }
}
function checkInputsForPartialSig(inputs, action) {
  inputs.forEach(input => {
    const throws = (0, bip371_1.isTaprootInput)(input)
      ? (0, bip371_1.checkTaprootInputForSigs)(input, action)
      : (0, psbtutils_1.checkInputForSig)(input, action);
    if (throws)
      throw new Error('Can not modify transaction, signatures exist.');
  });
}
function checkPartialSigSighashes(input) {
  if (!input.sighashType || !input.partialSig) return;
  const { partialSig, sighashType } = input;
  partialSig.forEach(pSig => {
    const { hashType } = bscript.signature.decode(pSig.signature);
    if (sighashType !== hashType) {
      throw new Error('Signature sighash does not match input sighash type');
    }
  });
}
function checkScriptForPubkey(pubkey, script, action) {
  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {
    throw new Error(
      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,
    );
  }
}
function checkTxEmpty(tx) {
  const isEmpty = tx.ins.every(
    input =>
      input.script &&
      input.script.length === 0 &&
      input.witness &&
      input.witness.length === 0,
  );
  if (!isEmpty) {
    throw new Error('Format Error: Transaction ScriptSigs are not empty');
  }
}
function checkTxForDupeIns(tx, cache) {
  tx.ins.forEach(input => {
    checkTxInputCache(cache, input);
  });
}
function checkTxInputCache(cache, input) {
  const key =
    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +
    ':' +
    input.index;
  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');
  cache.__TX_IN_CACHE[key] = 1;
}
function scriptCheckerFactory(payment, paymentScriptName) {
  return (inputIndex, scriptPubKey, redeemScript, ioType) => {
    const redeemScriptOutput = payment({
      redeem: { output: redeemScript },
    }).output;
    if (!scriptPubKey.equals(redeemScriptOutput)) {
      throw new Error(
        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,
      );
    }
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');
const checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  'Witness script',
);
function getTxCacheValue(key, name, inputs, c) {
  if (!inputs.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${name}`);
  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;
  if (key === '__FEE' && c.__FEE) return c.__FEE;
  let tx;
  let mustFinalize = true;
  if (c.__EXTRACTED_TX) {
    tx = c.__EXTRACTED_TX;
    mustFinalize = false;
  } else {
    tx = c.__TX.clone();
  }
  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
  if (key === '__FEE_RATE') return c.__FEE_RATE;
  else if (key === '__FEE') return c.__FEE;
}
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
  const scriptType = classifyScript(script);
  if (!canFinalize(input, script, scriptType))
    throw new Error(`Can not finalize input #${inputIndex}`);
  return prepareFinalScripts(
    script,
    scriptType,
    input.partialSig,
    isSegwit,
    isP2SH,
    isP2WSH,
  );
}
function prepareFinalScripts(
  script,
  scriptType,
  partialSig,
  isSegwit,
  isP2SH,
  isP2WSH,
) {
  let finalScriptSig;
  let finalScriptWitness;
  // Wow, the payments API is very handy
  const payment = getPayment(script, scriptType, partialSig);
  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
  if (isSegwit) {
    if (p2wsh) {
      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
        p2wsh.witness,
      );
    } else {
      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
        payment.witness,
      );
    }
    if (p2sh) {
      finalScriptSig = p2sh.input;
    }
  } else {
    if (p2sh) {
      finalScriptSig = p2sh.input;
    } else {
      finalScriptSig = payment.input;
    }
  }
  return {
    finalScriptSig,
    finalScriptWitness,
  };
}
function getHashAndSighashType(
  inputs,
  inputIndex,
  pubkey,
  cache,
  sighashTypes,
) {
  const input = (0, utils_1.checkForInput)(inputs, inputIndex);
  const { hash, sighashType, script } = getHashForSig(
    inputIndex,
    input,
    cache,
    false,
    sighashTypes,
  );
  checkScriptForPubkey(pubkey, script, 'sign');
  return {
    hash,
    sighashType,
  };
}
function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
  const unsignedTx = cache.__TX;
  const sighashType =
    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(sighashType, sighashTypes);
  let hash;
  let prevout;
  if (input.nonWitnessUtxo) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
      cache,
      input,
      inputIndex,
    );
    const prevoutHash = unsignedTx.ins[inputIndex].hash;
    const utxoHash = nonWitnessUtxoTx.getHash();
    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
    if (!prevoutHash.equals(utxoHash)) {
      throw new Error(
        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,
      );
    }
    const prevoutIndex = unsignedTx.ins[inputIndex].index;
    prevout = nonWitnessUtxoTx.outs[prevoutIndex];
  } else if (input.witnessUtxo) {
    prevout = input.witnessUtxo;
  } else {
    throw new Error('Need a Utxo input item for signing');
  }
  const { meaningfulScript, type } = getMeaningfulScript(
    prevout.script,
    inputIndex,
    'input',
    input.redeemScript,
    input.witnessScript,
  );
  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {
    hash = unsignedTx.hashForWitnessV0(
      inputIndex,
      meaningfulScript,
      prevout.value,
      sighashType,
    );
  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {
    // P2WPKH uses the P2PKH template for prevoutScript when signing
    const signingScript = payments.p2pkh({
      hash: meaningfulScript.slice(2),
    }).output;
    hash = unsignedTx.hashForWitnessV0(
      inputIndex,
      signingScript,
      prevout.value,
      sighashType,
    );
  } else {
    // non-segwit
    if (
      input.nonWitnessUtxo === undefined &&
      cache.__UNSAFE_SIGN_NONSEGWIT === false
    )
      throw new Error(
        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +
          `${meaningfulScript.toString('hex')}`,
      );
    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)
      console.warn(
        'Warning: Signing non-segwit inputs without the full parent transaction ' +
          'means there is a chance that a miner could feed you incorrect information ' +
          "to trick you into paying large fees. This behavior is the same as Psbt's predecessor " +
          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +
          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +
          'BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n' +
          '*********************',
      );
    hash = unsignedTx.hashForSignature(
      inputIndex,
      meaningfulScript,
      sighashType,
    );
  }
  return {
    script: meaningfulScript,
    sighashType,
    hash,
  };
}
function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
  const allPublicKeys = [];
  if (input.tapInternalKey) {
    const key = getPrevoutTaprootKey(inputIndex, input, cache);
    if (key) {
      allPublicKeys.push(key);
    }
  }
  if (input.tapScriptSig) {
    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);
    allPublicKeys.push(...tapScriptPubkeys);
  }
  const allHashes = allPublicKeys.map(pubicKey =>
    getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache),
  );
  return allHashes.flat();
}
function getPrevoutTaprootKey(inputIndex, input, cache) {
  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;
}
function trimTaprootSig(signature) {
  return signature.length === 64 ? signature : signature.subarray(0, 64);
}
function getTaprootHashesForSig(
  inputIndex,
  input,
  inputs,
  pubkey,
  cache,
  tapLeafHashToSign,
  allowedSighashTypes,
) {
  const unsignedTx = cache.__TX;
  const sighashType =
    input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(sighashType, allowedSighashTypes);
  const prevOuts = inputs.map((i, index) =>
    getScriptAndAmountFromUtxo(index, i, cache),
  );
  const signingScripts = prevOuts.map(o => o.script);
  const values = prevOuts.map(o => o.value);
  const hashes = [];
  if (input.tapInternalKey && !tapLeafHashToSign) {
    const outputKey =
      getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);
    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {
      const tapKeyHash = unsignedTx.hashForWitnessV1(
        inputIndex,
        signingScripts,
        values,
        sighashType,
      );
      hashes.push({ pubkey, hash: tapKeyHash });
    }
  }
  const tapLeafHashes = (input.tapLeafScript || [])
    .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))
    .map(tapLeaf => {
      const hash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion,
      });
      return Object.assign({ hash }, tapLeaf);
    })
    .filter(
      tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash),
    )
    .map(tapLeaf => {
      const tapScriptHash = unsignedTx.hashForWitnessV1(
        inputIndex,
        signingScripts,
        values,
        sighashType,
        tapLeaf.hash,
      );
      return {
        pubkey,
        hash: tapScriptHash,
        leafHash: tapLeaf.hash,
      };
    });
  return hashes.concat(tapLeafHashes);
}
function checkSighashTypeAllowed(sighashType, sighashTypes) {
  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
    const str = sighashTypeToString(sighashType);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the ` +
        `sighashTypes array of whitelisted types. Sighash type: ${str}`,
    );
  }
}
function getPayment(script, scriptType, partialSig) {
  let payment;
  switch (scriptType) {
    case 'multisig':
      const sigs = getSortedSigs(script, partialSig);
      payment = payments.p2ms({
        output: script,
        signatures: sigs,
      });
      break;
    case 'pubkey':
      payment = payments.p2pk({
        output: script,
        signature: partialSig[0].signature,
      });
      break;
    case 'pubkeyhash':
      payment = payments.p2pkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature,
      });
      break;
    case 'witnesspubkeyhash':
      payment = payments.p2wpkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature,
      });
      break;
  }
  return payment;
}
function getScriptFromInput(inputIndex, input, cache) {
  const unsignedTx = cache.__TX;
  const res = {
    script: null,
    isSegwit: false,
    isP2SH: false,
    isP2WSH: false,
  };
  res.isP2SH = !!input.redeemScript;
  res.isP2WSH = !!input.witnessScript;
  if (input.witnessScript) {
    res.script = input.witnessScript;
  } else if (input.redeemScript) {
    res.script = input.redeemScript;
  } else {
    if (input.nonWitnessUtxo) {
      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
        cache,
        input,
        inputIndex,
      );
      const prevoutIndex = unsignedTx.ins[inputIndex].index;
      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
    } else if (input.witnessUtxo) {
      res.script = input.witnessUtxo.script;
    }
  }
  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {
    res.isSegwit = true;
  }
  return res;
}
function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
  const input = (0, utils_1.checkForInput)(inputs, inputIndex);
  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
    throw new Error('Need bip32Derivation to sign with HD');
  }
  const myDerivations = input.bip32Derivation
    .map(bipDv => {
      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
        return bipDv;
      } else {
        return;
      }
    })
    .filter(v => !!v);
  if (myDerivations.length === 0) {
    throw new Error(
      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',
    );
  }
  const signers = myDerivations.map(bipDv => {
    const node = hdKeyPair.derivePath(bipDv.path);
    if (!bipDv.pubkey.equals(node.publicKey)) {
      throw new Error('pubkey did not match bip32Derivation');
    }
    return node;
  });
  return signers;
}
function getSortedSigs(script, partialSig) {
  const p2ms = payments.p2ms({ output: script });
  // for each pubkey in order of p2ms script
  return p2ms.pubkeys
    .map(pk => {
      // filter partialSig array by pubkey being equal
      return (
        partialSig.filter(ps => {
          return ps.pubkey.equals(pk);
        })[0] || {}
      ).signature;
      // Any pubkey without a match will return undefined
      // this last filter removes all the undefined items in the array.
    })
    .filter(v => !!v);
}
function scriptWitnessToWitnessStack(buffer) {
  let offset = 0;
  function readSlice(n) {
    offset += n;
    return buffer.slice(offset - n, offset);
  }
  function readVarInt() {
    const vi = varuint.decode(buffer, offset);
    offset += varuint.decode.bytes;
    return vi;
  }
  function readVarSlice() {
    return readSlice(readVarInt());
  }
  function readVector() {
    const count = readVarInt();
    const vector = [];
    for (let i = 0; i < count; i++) vector.push(readVarSlice());
    return vector;
  }
  return readVector();
}
function sighashTypeToString(sighashType) {
  let text =
    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY
      ? 'SIGHASH_ANYONECANPAY | '
      : '';
  const sigMod = sighashType & 0x1f;
  switch (sigMod) {
    case transaction_1.Transaction.SIGHASH_ALL:
      text += 'SIGHASH_ALL';
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      text += 'SIGHASH_SINGLE';
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      text += 'SIGHASH_NONE';
      break;
  }
  return text;
}
function addNonWitnessTxCache(cache, input, inputIndex) {
  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
  const self = cache;
  const selfIndex = inputIndex;
  delete input.nonWitnessUtxo;
  Object.defineProperty(input, 'nonWitnessUtxo', {
    enumerable: true,
    get() {
      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
      if (buf !== undefined) {
        return buf;
      } else {
        const newBuf = txCache.toBuffer();
        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
        return newBuf;
      }
    },
    set(data) {
      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
    },
  });
}
function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
  let inputAmount = 0;
  inputs.forEach((input, idx) => {
    if (mustFinalize && input.finalScriptSig)
      tx.ins[idx].script = input.finalScriptSig;
    if (mustFinalize && input.finalScriptWitness) {
      tx.ins[idx].witness = scriptWitnessToWitnessStack(
        input.finalScriptWitness,
      );
    }
    if (input.witnessUtxo) {
      inputAmount += input.witnessUtxo.value;
    } else if (input.nonWitnessUtxo) {
      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
      const vout = tx.ins[idx].index;
      const out = nwTx.outs[vout];
      inputAmount += out.value;
    }
  });
  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
  const fee = inputAmount - outputAmount;
  if (fee < 0) {
    throw new Error('Outputs are spending more than Inputs');
  }
  const bytes = tx.virtualSize();
  cache.__FEE = fee;
  cache.__EXTRACTED_TX = tx;
  cache.__FEE_RATE = Math.floor(fee / bytes);
}
function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
  if (!c[inputIndex]) {
    addNonWitnessTxCache(cache, input, inputIndex);
  }
  return c[inputIndex];
}
function getScriptFromUtxo(inputIndex, input, cache) {
  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
  return script;
}
function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
  if (input.witnessUtxo !== undefined) {
    return {
      script: input.witnessUtxo.script,
      value: input.witnessUtxo.value,
    };
  } else if (input.nonWitnessUtxo !== undefined) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
      cache,
      input,
      inputIndex,
    );
    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
    return { script: o.script, value: o.value };
  } else {
    throw new Error("Can't find pubkey in input without Utxo data");
  }
}
function pubkeyInInput(pubkey, input, inputIndex, cache) {
  const script = getScriptFromUtxo(inputIndex, input, cache);
  const { meaningfulScript } = getMeaningfulScript(
    script,
    inputIndex,
    'input',
    input.redeemScript,
    input.witnessScript,
  );
  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
}
function pubkeyInOutput(pubkey, output, outputIndex, cache) {
  const script = cache.__TX.outs[outputIndex].script;
  const { meaningfulScript } = getMeaningfulScript(
    script,
    outputIndex,
    'output',
    output.redeemScript,
    output.witnessScript,
  );
  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
}
function redeemFromFinalScriptSig(finalScript) {
  if (!finalScript) return;
  const decomp = bscript.decompile(finalScript);
  if (!decomp) return;
  const lastItem = decomp[decomp.length - 1];
  if (
    !Buffer.isBuffer(lastItem) ||
    isPubkeyLike(lastItem) ||
    isSigLike(lastItem)
  )
    return;
  const sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function redeemFromFinalWitnessScript(finalScript) {
  if (!finalScript) return;
  const decomp = scriptWitnessToWitnessStack(finalScript);
  const lastItem = decomp[decomp.length - 1];
  if (isPubkeyLike(lastItem)) return;
  const sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function compressPubkey(pubkey) {
  if (pubkey.length === 65) {
    const parity = pubkey[64] & 1;
    const newKey = pubkey.slice(0, 33);
    newKey[0] = 2 | parity;
    return newKey;
  }
  return pubkey.slice();
}
function isPubkeyLike(buf) {
  return buf.length === 33 && bscript.isCanonicalPubKey(buf);
}
function isSigLike(buf) {
  return bscript.isCanonicalScriptSignature(buf);
}
function getMeaningfulScript(
  script,
  index,
  ioType,
  redeemScript,
  witnessScript,
) {
  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);
  const isP2SHP2WSH =
    isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);
  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);
  if (isP2SH && redeemScript === undefined)
    throw new Error('scriptPubkey is P2SH but redeemScript missing');
  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)
    throw new Error(
      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',
    );
  let meaningfulScript;
  if (isP2SHP2WSH) {
    meaningfulScript = witnessScript;
    checkRedeemScript(index, script, redeemScript, ioType);
    checkWitnessScript(index, redeemScript, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2WSH) {
    meaningfulScript = witnessScript;
    checkWitnessScript(index, script, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2SH) {
    meaningfulScript = redeemScript;
    checkRedeemScript(index, script, redeemScript, ioType);
  } else {
    meaningfulScript = script;
  }
  return {
    meaningfulScript,
    type: isP2SHP2WSH
      ? 'p2sh-p2wsh'
      : isP2SH
      ? 'p2sh'
      : isP2WSH
      ? 'p2wsh'
      : 'raw',
  };
}
function checkInvalidP2WSH(script) {
  if (
    (0, psbtutils_1.isP2WPKH)(script) ||
    (0, psbtutils_1.isP2SHScript)(script)
  ) {
    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');
  }
}
function classifyScript(script) {
  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';
  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';
  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';
  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';
  return 'nonstandard';
}
function range(n) {
  return [...Array(n).keys()];
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./address":103,"./bufferutils":106,"./networks":111,"./payments":115,"./payments/bip341":113,"./psbt/bip371":125,"./psbt/psbtutils":126,"./script":128,"./transaction":131,"bip174":81,"bip174/src/lib/converter/varint":77,"bip174/src/lib/utils":83,"buffer":167}],125:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.checkTaprootInputForSigs =
  exports.tapTreeFromList =
  exports.tapTreeToList =
  exports.tweakInternalPubKey =
  exports.checkTaprootOutputFields =
  exports.checkTaprootInputFields =
  exports.isTaprootOutput =
  exports.isTaprootInput =
  exports.serializeTaprootSignature =
  exports.tapScriptFinalizer =
  exports.toXOnly =
    void 0;
const types_1 = require('../types');
const transaction_1 = require('../transaction');
const psbtutils_1 = require('./psbtutils');
const bip341_1 = require('../payments/bip341');
const payments_1 = require('../payments');
const psbtutils_2 = require('./psbtutils');
const toXOnly = pubKey => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));
exports.toXOnly = toXOnly;
/**
 * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.
 * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.
 * @param inputIndex the position of the PSBT input.
 * @param input the PSBT input.
 * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash
 *                              and will try to build the finalScriptWitness.
 * @returns the finalScriptWitness or throws an exception if no tapleaf found.
 */
function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
  const tapLeaf = findTapLeafToFinalize(
    input,
    inputIndex,
    tapLeafHashToFinalize,
  );
  try {
    const sigs = sortSignatures(input, tapLeaf);
    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness),
    };
  } catch (err) {
    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
  }
}
exports.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(sig, sighashType) {
  const sighashTypeByte = sighashType
    ? Buffer.from([sighashType])
    : Buffer.from([]);
  return Buffer.concat([sig, sighashTypeByte]);
}
exports.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(input) {
  return (
    input &&
    !!(
      input.tapInternalKey ||
      input.tapMerkleRoot ||
      (input.tapLeafScript && input.tapLeafScript.length) ||
      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||
      (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))
    )
  );
}
exports.isTaprootInput = isTaprootInput;
function isTaprootOutput(output, script) {
  return (
    output &&
    !!(
      output.tapInternalKey ||
      output.tapTree ||
      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||
      (script && (0, psbtutils_1.isP2TR)(script))
    )
  );
}
exports.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(inputData, newInputData, action) {
  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
  checkIfTapLeafInTree(inputData, newInputData, action);
}
exports.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(outputData, newOutputData, action) {
  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
  checkTaprootScriptPubkey(outputData, newOutputData);
}
exports.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(outputData, newOutputData) {
  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
  const tapInternalKey =
    newOutputData.tapInternalKey || outputData.tapInternalKey;
  const tapTree = newOutputData.tapTree || outputData.tapTree;
  if (tapInternalKey) {
    const { script: scriptPubkey } = outputData;
    const script = getTaprootScripPubkey(tapInternalKey, tapTree);
    if (scriptPubkey && !scriptPubkey.equals(script))
      throw new Error('Error adding output. Script or address missmatch.');
  }
}
function getTaprootScripPubkey(tapInternalKey, tapTree) {
  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
  const { output } = (0, payments_1.p2tr)({
    internalPubkey: tapInternalKey,
    scriptTree,
  });
  return output;
}
function tweakInternalPubKey(inputIndex, input) {
  const tapInternalKey = input.tapInternalKey;
  const outputKey =
    tapInternalKey &&
    (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);
  if (!outputKey)
    throw new Error(
      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${
        tapInternalKey && tapInternalKey.toString('hex')
      }`,
    );
  return outputKey.x;
}
exports.tweakInternalPubKey = tweakInternalPubKey;
/**
 * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):
 * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,
 * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that
 * the tree is correctly reconstructed.
 * @param tree the binary tap tree
 * @returns a list of BIP 371 tapleaves
 */
function tapTreeToList(tree) {
  if (!(0, types_1.isTaptree)(tree))
    throw new Error(
      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',
    );
  return _tapTreeToList(tree);
}
exports.tapTreeToList = tapTreeToList;
/**
 * Convert a BIP371 TapLeaf list to a TapTree (binary).
 * @param leaves a list of tapleaves where each element of the list is (according to BIP371):
 * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,
 * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that
 * the tree is correctly reconstructed.
 * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed
 */
function tapTreeFromList(leaves = []) {
  if (leaves.length === 1 && leaves[0].depth === 0)
    return {
      output: leaves[0].script,
      version: leaves[0].leafVersion,
    };
  return instertLeavesInTree(leaves);
}
exports.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(input, action) {
  const sigs = extractTaprootSigs(input);
  return sigs.some(sig =>
    (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action),
  );
}
exports.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(signature) {
  return {
    signature: signature.slice(0, 64),
    hashType:
      signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,
  };
}
function extractTaprootSigs(input) {
  const sigs = [];
  if (input.tapKeySig) sigs.push(input.tapKeySig);
  if (input.tapScriptSig)
    sigs.push(...input.tapScriptSig.map(s => s.signature));
  if (!sigs.length) {
    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
    if (finalTapKeySig) sigs.push(finalTapKeySig);
  }
  return sigs;
}
function getTapKeySigFromWithness(finalScriptWitness) {
  if (!finalScriptWitness) return;
  const witness = finalScriptWitness.slice(2);
  // todo: add schnorr signature validation
  if (witness.length === 64 || witness.length === 65) return witness;
}
function _tapTreeToList(tree, leaves = [], depth = 0) {
  if (depth > bip341_1.MAX_TAPTREE_DEPTH)
    throw new Error('Max taptree depth exceeded.');
  if (!tree) return [];
  if ((0, types_1.isTapleaf)(tree)) {
    leaves.push({
      depth,
      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,
      script: tree.output,
    });
    return leaves;
  }
  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
  return leaves;
}
function instertLeavesInTree(leaves) {
  let tree;
  for (const leaf of leaves) {
    tree = instertLeafInTree(leaf, tree);
    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);
  }
  return tree;
}
function instertLeafInTree(leaf, tree, depth = 0) {
  if (depth > bip341_1.MAX_TAPTREE_DEPTH)
    throw new Error('Max taptree depth exceeded.');
  if (leaf.depth === depth) {
    if (!tree)
      return {
        output: leaf.script,
        version: leaf.leafVersion,
      };
    return;
  }
  if ((0, types_1.isTapleaf)(tree)) return;
  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
  if (leftSide) return [leftSide, tree && tree[1]];
  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
  if (rightSide) return [tree && tree[0], rightSide];
}
function checkMixedTaprootAndNonTaprootInputFields(
  inputData,
  newInputData,
  action,
) {
  const isBadTaprootUpdate =
    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
  const isBadNonTaprootUpdate =
    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
  const hasMixedFields =
    inputData === newInputData &&
    isTaprootInput(newInputData) &&
    hasNonTaprootFields(newInputData); // todo: bad? use !===
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
    throw new Error(
      `Invalid arguments for Psbt.${action}. ` +
        `Cannot use both taproot and non-taproot fields.`,
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(
  inputData,
  newInputData,
  action,
) {
  const isBadTaprootUpdate =
    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
  const isBadNonTaprootUpdate =
    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
  const hasMixedFields =
    inputData === newInputData &&
    isTaprootOutput(newInputData) &&
    hasNonTaprootFields(newInputData);
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
    throw new Error(
      `Invalid arguments for Psbt.${action}. ` +
        `Cannot use both taproot and non-taproot fields.`,
    );
}
/**
 * Checks if the tap leaf is part of the tap tree for the given input data.
 * Throws an error if the tap leaf is not part of the tap tree.
 * @param inputData - The original PsbtInput data.
 * @param newInputData - The new PsbtInput data.
 * @param action - The action being performed.
 * @throws {Error} - If the tap leaf is not part of the tap tree.
 */
function checkIfTapLeafInTree(inputData, newInputData, action) {
  if (newInputData.tapMerkleRoot) {
    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>
      isTapLeafInTree(l, newInputData.tapMerkleRoot),
    );
    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>
      isTapLeafInTree(l, newInputData.tapMerkleRoot),
    );
    if (!newLeafsInTree || !oldLeafsInTree)
      throw new Error(
        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,
      );
  } else if (inputData.tapMerkleRoot) {
    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>
      isTapLeafInTree(l, inputData.tapMerkleRoot),
    );
    if (!newLeafsInTree)
      throw new Error(
        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,
      );
  }
}
/**
 * Checks if a TapLeafScript is present in a Merkle tree.
 * @param tapLeaf The TapLeafScript to check.
 * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.
 * @returns A boolean indicating whether the TapLeafScript is present in the tree.
 */
function isTapLeafInTree(tapLeaf, merkleRoot) {
  if (!merkleRoot) return true;
  const leafHash = (0, bip341_1.tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion,
  });
  const rootHash = (0, bip341_1.rootHashFromPath)(
    tapLeaf.controlBlock,
    leafHash,
  );
  return rootHash.equals(merkleRoot);
}
/**
 * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.
 *
 * @param input - The PsbtInput object.
 * @param tapLeaf - The TapLeafScript object.
 * @returns An array of sorted signatures as Buffers.
 */
function sortSignatures(input, tapLeaf) {
  const leafHash = (0, bip341_1.tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion,
  });
  return (input.tapScriptSig || [])
    .filter(tss => tss.leafHash.equals(leafHash))
    .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))
    .sort((t1, t2) => t2.positionInScript - t1.positionInScript)
    .map(t => t.signature);
}
/**
 * Adds the position of a public key in a script to a TapScriptSig object.
 * @param script The script in which to find the position of the public key.
 * @param tss The TapScriptSig object to add the position to.
 * @returns A TapScriptSigWitPosition object with the added position.
 */
function addPubkeyPositionInScript(script, tss) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(
        tss.pubkey,
        script,
      ),
    },
    tss,
  );
}
/**
 * Find tapleaf by hash, or get the signed tapleaf with the shortest path.
 */
function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
  if (!input.tapScriptSig || !input.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,
    );
  const tapLeaf = (input.tapLeafScript || [])
    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)
    .find(leaf =>
      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),
    );
  if (!tapLeaf)
    throw new Error(
      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,
    );
  return tapLeaf;
}
/**
 * Determines whether a TapLeafScript can be finalized.
 *
 * @param leaf - The TapLeafScript to check.
 * @param tapScriptSig - The array of TapScriptSig objects.
 * @param hash - The optional hash to compare with the leaf hash.
 * @returns A boolean indicating whether the TapLeafScript can be finalized.
 */
function canFinalizeLeaf(leaf, tapScriptSig, hash) {
  const leafHash = (0, bip341_1.tapleafHash)({
    output: leaf.script,
    version: leaf.leafVersion,
  });
  const whiteListedHash = !hash || hash.equals(leafHash);
  return (
    whiteListedHash &&
    tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined
  );
}
/**
 * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.
 * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.
 * @param io The PsbtInput or PsbtOutput to check.
 * @returns A boolean indicating whether the given input or output has non-taproot fields.
 */
function hasNonTaprootFields(io) {
  return (
    io &&
    !!(
      io.redeemScript ||
      io.witnessScript ||
      (io.bip32Derivation && io.bip32Derivation.length)
    )
  );
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"../payments":115,"../payments/bip341":113,"../transaction":131,"../types":132,"./psbtutils":126,"buffer":167}],126:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.signatureBlocksAction =
  exports.checkInputForSig =
  exports.pubkeyInScript =
  exports.pubkeyPositionInScript =
  exports.witnessStackToScriptWitness =
  exports.isP2TR =
  exports.isP2SHScript =
  exports.isP2WSHScript =
  exports.isP2WPKH =
  exports.isP2PKH =
  exports.isP2PK =
  exports.isP2MS =
    void 0;
const varuint = require('bip174/src/lib/converter/varint');
const bscript = require('../script');
const transaction_1 = require('../transaction');
const crypto_1 = require('../crypto');
const payments = require('../payments');
function isPaymentFactory(payment) {
  return script => {
    try {
      payment({ output: script });
      return true;
    } catch (err) {
      return false;
    }
  };
}
exports.isP2MS = isPaymentFactory(payments.p2ms);
exports.isP2PK = isPaymentFactory(payments.p2pk);
exports.isP2PKH = isPaymentFactory(payments.p2pkh);
exports.isP2WPKH = isPaymentFactory(payments.p2wpkh);
exports.isP2WSHScript = isPaymentFactory(payments.p2wsh);
exports.isP2SHScript = isPaymentFactory(payments.p2sh);
exports.isP2TR = isPaymentFactory(payments.p2tr);
/**
 * Converts a witness stack to a script witness.
 * @param witness The witness stack to convert.
 * @returns The script witness as a Buffer.
 */
/**
 * Converts a witness stack to a script witness.
 * @param witness The witness stack to convert.
 * @returns The converted script witness.
 */
function witnessStackToScriptWitness(witness) {
  let buffer = Buffer.allocUnsafe(0);
  function writeSlice(slice) {
    buffer = Buffer.concat([buffer, Buffer.from(slice)]);
  }
  function writeVarInt(i) {
    const currentLen = buffer.length;
    const varintLen = varuint.encodingLength(i);
    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
    varuint.encode(i, buffer, currentLen);
  }
  function writeVarSlice(slice) {
    writeVarInt(slice.length);
    writeSlice(slice);
  }
  function writeVector(vector) {
    writeVarInt(vector.length);
    vector.forEach(writeVarSlice);
  }
  writeVector(witness);
  return buffer;
}
exports.witnessStackToScriptWitness = witnessStackToScriptWitness;
/**
 * Finds the position of a public key in a script.
 * @param pubkey The public key to search for.
 * @param script The script to search in.
 * @returns The index of the public key in the script, or -1 if not found.
 * @throws {Error} If there is an unknown script error.
 */
function pubkeyPositionInScript(pubkey, script) {
  const pubkeyHash = (0, crypto_1.hash160)(pubkey);
  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?
  const decompiled = bscript.decompile(script);
  if (decompiled === null) throw new Error('Unknown script error');
  return decompiled.findIndex(element => {
    if (typeof element === 'number') return false;
    return (
      element.equals(pubkey) ||
      element.equals(pubkeyHash) ||
      element.equals(pubkeyXOnly)
    );
  });
}
exports.pubkeyPositionInScript = pubkeyPositionInScript;
/**
 * Checks if a public key is present in a script.
 * @param pubkey The public key to check.
 * @param script The script to search in.
 * @returns A boolean indicating whether the public key is present in the script.
 */
function pubkeyInScript(pubkey, script) {
  return pubkeyPositionInScript(pubkey, script) !== -1;
}
exports.pubkeyInScript = pubkeyInScript;
/**
 * Checks if an input contains a signature for a specific action.
 * @param input - The input to check.
 * @param action - The action to check for.
 * @returns A boolean indicating whether the input contains a signature for the specified action.
 */
function checkInputForSig(input, action) {
  const pSigs = extractPartialSigs(input);
  return pSigs.some(pSig =>
    signatureBlocksAction(pSig, bscript.signature.decode, action),
  );
}
exports.checkInputForSig = checkInputForSig;
/**
 * Determines if a given action is allowed for a signature block.
 * @param signature - The signature block.
 * @param signatureDecodeFn - The function used to decode the signature.
 * @param action - The action to be checked.
 * @returns True if the action is allowed, false otherwise.
 */
function signatureBlocksAction(signature, signatureDecodeFn, action) {
  const { hashType } = signatureDecodeFn(signature);
  const whitelist = [];
  const isAnyoneCanPay =
    hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
  if (isAnyoneCanPay) whitelist.push('addInput');
  const hashMod = hashType & 0x1f;
  switch (hashMod) {
    case transaction_1.Transaction.SIGHASH_ALL:
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
    case transaction_1.Transaction.SIGHASH_NONE:
      whitelist.push('addOutput');
      whitelist.push('setInputSequence');
      break;
  }
  if (whitelist.indexOf(action) === -1) {
    return true;
  }
  return false;
}
exports.signatureBlocksAction = signatureBlocksAction;
/**
 * Extracts the signatures from a PsbtInput object.
 * If the input has partial signatures, it returns an array of the signatures.
 * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.
 * If it does, it extracts the signatures from the final scripts and returns them.
 * If none of the above conditions are met, it returns an empty array.
 *
 * @param input - The PsbtInput object from which to extract the signatures.
 * @returns An array of signatures extracted from the PsbtInput object.
 */
function extractPartialSigs(input) {
  let pSigs = [];
  if ((input.partialSig || []).length === 0) {
    if (!input.finalScriptSig && !input.finalScriptWitness) return [];
    pSigs = getPsigsFromInputFinalScripts(input);
  } else {
    pSigs = input.partialSig;
  }
  return pSigs.map(p => p.signature);
}
/**
 * Retrieves the partial signatures (Psigs) from the input's final scripts.
 * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.
 * Only canonical script signatures are considered.
 *
 * @param input - The PsbtInput object representing the input.
 * @returns An array of PartialSig objects containing the extracted Psigs.
 */
function getPsigsFromInputFinalScripts(input) {
  const scriptItems = !input.finalScriptSig
    ? []
    : bscript.decompile(input.finalScriptSig) || [];
  const witnessItems = !input.finalScriptWitness
    ? []
    : bscript.decompile(input.finalScriptWitness) || [];
  return scriptItems
    .concat(witnessItems)
    .filter(item => {
      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
    })
    .map(sig => ({ signature: sig }));
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"../crypto":107,"../payments":115,"../script":128,"../transaction":131,"bip174/src/lib/converter/varint":77,"buffer":167}],127:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.decode = exports.encode = exports.encodingLength = void 0;
const ops_1 = require('./ops');
/**
 * Calculates the encoding length of a number used for push data in Bitcoin transactions.
 * @param i The number to calculate the encoding length for.
 * @returns The encoding length of the number.
 */
function encodingLength(i) {
  return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;
}
exports.encodingLength = encodingLength;
/**
 * Encodes a number into a buffer using a variable-length encoding scheme.
 * The encoded buffer is written starting at the specified offset.
 * Returns the size of the encoded buffer.
 *
 * @param buffer - The buffer to write the encoded data into.
 * @param num - The number to encode.
 * @param offset - The offset at which to start writing the encoded buffer.
 * @returns The size of the encoded buffer.
 */
function encode(buffer, num, offset) {
  const size = encodingLength(num);
  // ~6 bit
  if (size === 1) {
    buffer.writeUInt8(num, offset);
    // 8 bit
  } else if (size === 2) {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
    buffer.writeUInt8(num, offset + 1);
    // 16 bit
  } else if (size === 3) {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
    buffer.writeUInt16LE(num, offset + 1);
    // 32 bit
  } else {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
    buffer.writeUInt32LE(num, offset + 1);
  }
  return size;
}
exports.encode = encode;
/**
 * Decodes a buffer and returns information about the opcode, number, and size.
 * @param buffer - The buffer to decode.
 * @param offset - The offset within the buffer to start decoding.
 * @returns An object containing the opcode, number, and size, or null if decoding fails.
 */
function decode(buffer, offset) {
  const opcode = buffer.readUInt8(offset);
  let num;
  let size;
  // ~6 bit
  if (opcode < ops_1.OPS.OP_PUSHDATA1) {
    num = opcode;
    size = 1;
    // 8 bit
  } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
    if (offset + 2 > buffer.length) return null;
    num = buffer.readUInt8(offset + 1);
    size = 2;
    // 16 bit
  } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
    if (offset + 3 > buffer.length) return null;
    num = buffer.readUInt16LE(offset + 1);
    size = 3;
    // 32 bit
  } else {
    if (offset + 5 > buffer.length) return null;
    if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');
    num = buffer.readUInt32LE(offset + 1);
    size = 5;
  }
  return {
    opcode,
    number: num,
    size,
  };
}
exports.decode = decode;

},{"./ops":112}],128:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.signature =
  exports.number =
  exports.isCanonicalScriptSignature =
  exports.isDefinedHashType =
  exports.isCanonicalPubKey =
  exports.toStack =
  exports.fromASM =
  exports.toASM =
  exports.decompile =
  exports.compile =
  exports.countNonPushOnlyOPs =
  exports.isPushOnly =
  exports.OPS =
    void 0;
/**
 * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature
 * @packageDocumentation
 */
const bip66 = require('./bip66');
const ops_1 = require('./ops');
Object.defineProperty(exports, 'OPS', {
  enumerable: true,
  get: function () {
    return ops_1.OPS;
  },
});
const pushdata = require('./push_data');
const scriptNumber = require('./script_number');
const scriptSignature = require('./script_signature');
const types = require('./types');
const { typeforce } = types;
const OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1
function isOPInt(value) {
  return (
    types.Number(value) &&
    (value === ops_1.OPS.OP_0 ||
      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||
      value === ops_1.OPS.OP_1NEGATE)
  );
}
function isPushOnlyChunk(value) {
  return types.Buffer(value) || isOPInt(value);
}
function isPushOnly(value) {
  return types.Array(value) && value.every(isPushOnlyChunk);
}
exports.isPushOnly = isPushOnly;
function countNonPushOnlyOPs(value) {
  return value.length - value.filter(isPushOnlyChunk).length;
}
exports.countNonPushOnlyOPs = countNonPushOnlyOPs;
function asMinimalOP(buffer) {
  if (buffer.length === 0) return ops_1.OPS.OP_0;
  if (buffer.length !== 1) return;
  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;
}
function chunksIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
function chunksIsArray(buf) {
  return types.Array(buf);
}
function singleChunkIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
/**
 * Compiles an array of chunks into a Buffer.
 *
 * @param chunks - The array of chunks to compile.
 * @returns The compiled Buffer.
 * @throws Error if the compilation fails.
 */
function compile(chunks) {
  // TODO: remove me
  if (chunksIsBuffer(chunks)) return chunks;
  typeforce(types.Array, chunks);
  const bufferSize = chunks.reduce((accum, chunk) => {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
        return accum + 1;
      }
      return accum + pushdata.encodingLength(chunk.length) + chunk.length;
    }
    // opcode
    return accum + 1;
  }, 0.0);
  const buffer = Buffer.allocUnsafe(bufferSize);
  let offset = 0;
  chunks.forEach(chunk => {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      const opcode = asMinimalOP(chunk);
      if (opcode !== undefined) {
        buffer.writeUInt8(opcode, offset);
        offset += 1;
        return;
      }
      offset += pushdata.encode(buffer, chunk.length, offset);
      chunk.copy(buffer, offset);
      offset += chunk.length;
      // opcode
    } else {
      buffer.writeUInt8(chunk, offset);
      offset += 1;
    }
  });
  if (offset !== buffer.length) throw new Error('Could not decode chunks');
  return buffer;
}
exports.compile = compile;
function decompile(buffer) {
  // TODO: remove me
  if (chunksIsArray(buffer)) return buffer;
  typeforce(types.Buffer, buffer);
  const chunks = [];
  let i = 0;
  while (i < buffer.length) {
    const opcode = buffer[i];
    // data chunk
    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
      const d = pushdata.decode(buffer, i);
      // did reading a pushDataInt fail?
      if (d === null) return null;
      i += d.size;
      // attempt to read too much data?
      if (i + d.number > buffer.length) return null;
      const data = buffer.slice(i, i + d.number);
      i += d.number;
      // decompile minimally
      const op = asMinimalOP(data);
      if (op !== undefined) {
        chunks.push(op);
      } else {
        chunks.push(data);
      }
      // opcode
    } else {
      chunks.push(opcode);
      i += 1;
    }
  }
  return chunks;
}
exports.decompile = decompile;
/**
 * Converts the given chunks into an ASM (Assembly) string representation.
 * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.
 * @param chunks - The chunks to convert into ASM.
 * @returns The ASM string representation of the chunks.
 */
function toASM(chunks) {
  if (chunksIsBuffer(chunks)) {
    chunks = decompile(chunks);
  }
  if (!chunks) {
    throw new Error('Could not convert invalid chunks to ASM');
  }
  return chunks
    .map(chunk => {
      // data?
      if (singleChunkIsBuffer(chunk)) {
        const op = asMinimalOP(chunk);
        if (op === undefined) return chunk.toString('hex');
        chunk = op;
      }
      // opcode!
      return ops_1.REVERSE_OPS[chunk];
    })
    .join(' ');
}
exports.toASM = toASM;
/**
 * Converts an ASM string to a Buffer.
 * @param asm The ASM string to convert.
 * @returns The converted Buffer.
 */
function fromASM(asm) {
  typeforce(types.String, asm);
  return compile(
    asm.split(' ').map(chunkStr => {
      // opcode?
      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];
      typeforce(types.Hex, chunkStr);
      // data!
      return Buffer.from(chunkStr, 'hex');
    }),
  );
}
exports.fromASM = fromASM;
/**
 * Converts the given chunks into a stack of buffers.
 *
 * @param chunks - The chunks to convert.
 * @returns The stack of buffers.
 */
function toStack(chunks) {
  chunks = decompile(chunks);
  typeforce(isPushOnly, chunks);
  return chunks.map(op => {
    if (singleChunkIsBuffer(op)) return op;
    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);
    return scriptNumber.encode(op - OP_INT_BASE);
  });
}
exports.toStack = toStack;
function isCanonicalPubKey(buffer) {
  return types.isPoint(buffer);
}
exports.isCanonicalPubKey = isCanonicalPubKey;
function isDefinedHashType(hashType) {
  const hashTypeMod = hashType & ~0x80;
  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE
  return hashTypeMod > 0x00 && hashTypeMod < 0x04;
}
exports.isDefinedHashType = isDefinedHashType;
function isCanonicalScriptSignature(buffer) {
  if (!Buffer.isBuffer(buffer)) return false;
  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
  return bip66.check(buffer.slice(0, -1));
}
exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
exports.number = scriptNumber;
exports.signature = scriptSignature;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bip66":104,"./ops":112,"./push_data":127,"./script_number":129,"./script_signature":130,"./types":132,"buffer":167}],129:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.encode = exports.decode = void 0;
/**
 * Decodes a script number from a buffer.
 *
 * @param buffer - The buffer containing the script number.
 * @param maxLength - The maximum length of the script number. Defaults to 4.
 * @param minimal - Whether the script number should be minimal. Defaults to true.
 * @returns The decoded script number.
 * @throws {TypeError} If the script number overflows the maximum length.
 * @throws {Error} If the script number is not minimally encoded when minimal is true.
 */
function decode(buffer, maxLength, minimal) {
  maxLength = maxLength || 4;
  minimal = minimal === undefined ? true : minimal;
  const length = buffer.length;
  if (length === 0) return 0;
  if (length > maxLength) throw new TypeError('Script number overflow');
  if (minimal) {
    if ((buffer[length - 1] & 0x7f) === 0) {
      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)
        throw new Error('Non-minimally encoded script number');
    }
  }
  // 40-bit
  if (length === 5) {
    const a = buffer.readUInt32LE(0);
    const b = buffer.readUInt8(4);
    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);
    return b * 0x100000000 + a;
  }
  // 32-bit / 24-bit / 16-bit / 8-bit
  let result = 0;
  for (let i = 0; i < length; ++i) {
    result |= buffer[i] << (8 * i);
  }
  if (buffer[length - 1] & 0x80)
    return -(result & ~(0x80 << (8 * (length - 1))));
  return result;
}
exports.decode = decode;
function scriptNumSize(i) {
  return i > 0x7fffffff
    ? 5
    : i > 0x7fffff
    ? 4
    : i > 0x7fff
    ? 3
    : i > 0x7f
    ? 2
    : i > 0x00
    ? 1
    : 0;
}
/**
 * Encodes a number into a Buffer using a specific format.
 *
 * @param _number - The number to encode.
 * @returns The encoded number as a Buffer.
 */
function encode(_number) {
  let value = Math.abs(_number);
  const size = scriptNumSize(value);
  const buffer = Buffer.allocUnsafe(size);
  const negative = _number < 0;
  for (let i = 0; i < size; ++i) {
    buffer.writeUInt8(value & 0xff, i);
    value >>= 8;
  }
  if (buffer[size - 1] & 0x80) {
    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
  } else if (negative) {
    buffer[size - 1] |= 0x80;
  }
  return buffer;
}
exports.encode = encode;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],130:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.encode = exports.decode = void 0;
const bip66 = require('./bip66');
const script_1 = require('./script');
const types = require('./types');
const { typeforce } = types;
const ZERO = Buffer.alloc(1, 0);
/**
 * Converts a buffer to a DER-encoded buffer.
 * @param x - The buffer to be converted.
 * @returns The DER-encoded buffer.
 */
function toDER(x) {
  let i = 0;
  while (x[i] === 0) ++i;
  if (i === x.length) return ZERO;
  x = x.slice(i);
  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);
  return x;
}
/**
 * Converts a DER-encoded signature to a buffer.
 * If the first byte of the input buffer is 0x00, it is skipped.
 * The resulting buffer is 32 bytes long, filled with zeros if necessary.
 * @param x - The DER-encoded signature.
 * @returns The converted buffer.
 */
function fromDER(x) {
  if (x[0] === 0x00) x = x.slice(1);
  const buffer = Buffer.alloc(32, 0);
  const bstart = Math.max(0, 32 - x.length);
  x.copy(buffer, bstart);
  return buffer;
}
// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
/**
 * Decodes a buffer into a ScriptSignature object.
 * @param buffer - The buffer to decode.
 * @returns The decoded ScriptSignature object.
 * @throws Error if the hashType is invalid.
 */
function decode(buffer) {
  const hashType = buffer.readUInt8(buffer.length - 1);
  if (!(0, script_1.isDefinedHashType)(hashType)) {
    throw new Error('Invalid hashType ' + hashType);
  }
  const decoded = bip66.decode(buffer.slice(0, -1));
  const r = fromDER(decoded.r);
  const s = fromDER(decoded.s);
  const signature = Buffer.concat([r, s], 64);
  return { signature, hashType };
}
exports.decode = decode;
/**
 * Encodes a signature and hash type into a buffer.
 * @param signature - The signature to encode.
 * @param hashType - The hash type to encode.
 * @returns The encoded buffer.
 * @throws Error if the hashType is invalid.
 */
function encode(signature, hashType) {
  typeforce(
    {
      signature: types.BufferN(64),
      hashType: types.UInt8,
    },
    { signature, hashType },
  );
  if (!(0, script_1.isDefinedHashType)(hashType)) {
    throw new Error('Invalid hashType ' + hashType);
  }
  const hashTypeBuffer = Buffer.allocUnsafe(1);
  hashTypeBuffer.writeUInt8(hashType, 0);
  const r = toDER(signature.slice(0, 32));
  const s = toDER(signature.slice(32, 64));
  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
}
exports.encode = encode;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bip66":104,"./script":128,"./types":132,"buffer":167}],131:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.Transaction = void 0;
const bufferutils_1 = require('./bufferutils');
const bcrypto = require('./crypto');
const bscript = require('./script');
const script_1 = require('./script');
const types = require('./types');
const { typeforce } = types;
function varSliceSize(someScript) {
  const length = someScript.length;
  return bufferutils_1.varuint.encodingLength(length) + length;
}
function vectorSize(someVector) {
  const length = someVector.length;
  return (
    bufferutils_1.varuint.encodingLength(length) +
    someVector.reduce((sum, witness) => {
      return sum + varSliceSize(witness);
    }, 0)
  );
}
const EMPTY_BUFFER = Buffer.allocUnsafe(0);
const EMPTY_WITNESS = [];
const ZERO = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000000',
  'hex',
);
const ONE = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000001',
  'hex',
);
const VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');
const BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX,
};
function isOutput(out) {
  return out.value !== undefined;
}
/**
 * Represents a Bitcoin transaction.
 */
class Transaction {
  constructor() {
    this.version = 1;
    this.locktime = 0;
    this.ins = [];
    this.outs = [];
  }
  static fromBuffer(buffer, _NO_STRICT) {
    const bufferReader = new bufferutils_1.BufferReader(buffer);
    const tx = new Transaction();
    tx.version = bufferReader.readInt32();
    const marker = bufferReader.readUInt8();
    const flag = bufferReader.readUInt8();
    let hasWitnesses = false;
    if (
      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&
      flag === Transaction.ADVANCED_TRANSACTION_FLAG
    ) {
      hasWitnesses = true;
    } else {
      bufferReader.offset -= 2;
    }
    const vinLen = bufferReader.readVarInt();
    for (let i = 0; i < vinLen; ++i) {
      tx.ins.push({
        hash: bufferReader.readSlice(32),
        index: bufferReader.readUInt32(),
        script: bufferReader.readVarSlice(),
        sequence: bufferReader.readUInt32(),
        witness: EMPTY_WITNESS,
      });
    }
    const voutLen = bufferReader.readVarInt();
    for (let i = 0; i < voutLen; ++i) {
      tx.outs.push({
        value: bufferReader.readUInt64(),
        script: bufferReader.readVarSlice(),
      });
    }
    if (hasWitnesses) {
      for (let i = 0; i < vinLen; ++i) {
        tx.ins[i].witness = bufferReader.readVector();
      }
      // was this pointless?
      if (!tx.hasWitnesses())
        throw new Error('Transaction has superfluous witness data');
    }
    tx.locktime = bufferReader.readUInt32();
    if (_NO_STRICT) return tx;
    if (bufferReader.offset !== buffer.length)
      throw new Error('Transaction has unexpected data');
    return tx;
  }
  static fromHex(hex) {
    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);
  }
  static isCoinbaseHash(buffer) {
    typeforce(types.Hash256bit, buffer);
    for (let i = 0; i < 32; ++i) {
      if (buffer[i] !== 0) return false;
    }
    return true;
  }
  isCoinbase() {
    return (
      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)
    );
  }
  addInput(hash, index, sequence, scriptSig) {
    typeforce(
      types.tuple(
        types.Hash256bit,
        types.UInt32,
        types.maybe(types.UInt32),
        types.maybe(types.Buffer),
      ),
      arguments,
    );
    if (types.Null(sequence)) {
      sequence = Transaction.DEFAULT_SEQUENCE;
    }
    // Add the input and return the input's index
    return (
      this.ins.push({
        hash,
        index,
        script: scriptSig || EMPTY_BUFFER,
        sequence: sequence,
        witness: EMPTY_WITNESS,
      }) - 1
    );
  }
  addOutput(scriptPubKey, value) {
    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
    // Add the output and return the output's index
    return (
      this.outs.push({
        script: scriptPubKey,
        value,
      }) - 1
    );
  }
  hasWitnesses() {
    return this.ins.some(x => {
      return x.witness.length !== 0;
    });
  }
  stripWitnesses() {
    this.ins.forEach(input => {
      input.witness = EMPTY_WITNESS; // Set witness data to an empty array
    });
  }
  weight() {
    const base = this.byteLength(false);
    const total = this.byteLength(true);
    return base * 3 + total;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(_ALLOW_WITNESS = true) {
    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
    return (
      (hasWitnesses ? 10 : 8) +
      bufferutils_1.varuint.encodingLength(this.ins.length) +
      bufferutils_1.varuint.encodingLength(this.outs.length) +
      this.ins.reduce((sum, input) => {
        return sum + 40 + varSliceSize(input.script);
      }, 0) +
      this.outs.reduce((sum, output) => {
        return sum + 8 + varSliceSize(output.script);
      }, 0) +
      (hasWitnesses
        ? this.ins.reduce((sum, input) => {
            return sum + vectorSize(input.witness);
          }, 0)
        : 0)
    );
  }
  clone() {
    const newTx = new Transaction();
    newTx.version = this.version;
    newTx.locktime = this.locktime;
    newTx.ins = this.ins.map(txIn => {
      return {
        hash: txIn.hash,
        index: txIn.index,
        script: txIn.script,
        sequence: txIn.sequence,
        witness: txIn.witness,
      };
    });
    newTx.outs = this.outs.map(txOut => {
      return {
        script: txOut.script,
        value: txOut.value,
      };
    });
    return newTx;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(inIndex, prevOutScript, hashType) {
    typeforce(
      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),
      arguments,
    );
    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29
    if (inIndex >= this.ins.length) return ONE;
    // ignore OP_CODESEPARATOR
    const ourScript = bscript.compile(
      bscript.decompile(prevOutScript).filter(x => {
        return x !== script_1.OPS.OP_CODESEPARATOR;
      }),
    );
    const txTmp = this.clone();
    // SIGHASH_NONE: ignore all outputs? (wildcard payee)
    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
      txTmp.outs = [];
      // ignore sequence numbers (except at inIndex)
      txTmp.ins.forEach((input, i) => {
        if (i === inIndex) return;
        input.sequence = 0;
      });
      // SIGHASH_SINGLE: ignore all outputs, except at the same index?
    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60
      if (inIndex >= this.outs.length) return ONE;
      // truncate outputs after
      txTmp.outs.length = inIndex + 1;
      // "blank" outputs before
      for (let i = 0; i < inIndex; i++) {
        txTmp.outs[i] = BLANK_OUTPUT;
      }
      // ignore sequence numbers (except at inIndex)
      txTmp.ins.forEach((input, y) => {
        if (y === inIndex) return;
        input.sequence = 0;
      });
    }
    // SIGHASH_ANYONECANPAY: ignore inputs entirely?
    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
      txTmp.ins = [txTmp.ins[inIndex]];
      txTmp.ins[0].script = ourScript;
      // SIGHASH_ALL: only ignore input scripts
    } else {
      // "blank" others input scripts
      txTmp.ins.forEach(input => {
        input.script = EMPTY_BUFFER;
      });
      txTmp.ins[inIndex].script = ourScript;
    }
    // serialize and hash
    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
    buffer.writeInt32LE(hashType, buffer.length - 4);
    txTmp.__toBuffer(buffer, 0, false);
    return bcrypto.hash256(buffer);
  }
  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message
    typeforce(
      types.tuple(
        types.UInt32,
        typeforce.arrayOf(types.Buffer),
        typeforce.arrayOf(types.Satoshi),
        types.UInt32,
      ),
      arguments,
    );
    if (
      values.length !== this.ins.length ||
      prevOutScripts.length !== this.ins.length
    ) {
      throw new Error('Must supply prevout script and value for all inputs');
    }
    const outputType =
      hashType === Transaction.SIGHASH_DEFAULT
        ? Transaction.SIGHASH_ALL
        : hashType & Transaction.SIGHASH_OUTPUT_MASK;
    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;
    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;
    const isNone = outputType === Transaction.SIGHASH_NONE;
    const isSingle = outputType === Transaction.SIGHASH_SINGLE;
    let hashPrevouts = EMPTY_BUFFER;
    let hashAmounts = EMPTY_BUFFER;
    let hashScriptPubKeys = EMPTY_BUFFER;
    let hashSequences = EMPTY_BUFFER;
    let hashOutputs = EMPTY_BUFFER;
    if (!isAnyoneCanPay) {
      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        36 * this.ins.length,
      );
      this.ins.forEach(txIn => {
        bufferWriter.writeSlice(txIn.hash);
        bufferWriter.writeUInt32(txIn.index);
      });
      hashPrevouts = bcrypto.sha256(bufferWriter.end());
      bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        8 * this.ins.length,
      );
      values.forEach(value => bufferWriter.writeUInt64(value));
      hashAmounts = bcrypto.sha256(bufferWriter.end());
      bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),
      );
      prevOutScripts.forEach(prevOutScript =>
        bufferWriter.writeVarSlice(prevOutScript),
      );
      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());
      bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        4 * this.ins.length,
      );
      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));
      hashSequences = bcrypto.sha256(bufferWriter.end());
    }
    if (!(isNone || isSingle)) {
      const txOutsSize = this.outs
        .map(output => 8 + varSliceSize(output.script))
        .reduce((a, b) => a + b);
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
      this.outs.forEach(out => {
        bufferWriter.writeUInt64(out.value);
        bufferWriter.writeVarSlice(out.script);
      });
      hashOutputs = bcrypto.sha256(bufferWriter.end());
    } else if (isSingle && inIndex < this.outs.length) {
      const output = this.outs[inIndex];
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        8 + varSliceSize(output.script),
      );
      bufferWriter.writeUInt64(output.value);
      bufferWriter.writeVarSlice(output.script);
      hashOutputs = bcrypto.sha256(bufferWriter.end());
    }
    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
    // Length calculation from:
    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14
    // With extension from:
    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation
    const sigMsgSize =
      174 -
      (isAnyoneCanPay ? 49 : 0) -
      (isNone ? 32 : 0) +
      (annex ? 32 : 0) +
      (leafHash ? 37 : 0);
    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
    sigMsgWriter.writeUInt8(hashType);
    // Transaction
    sigMsgWriter.writeInt32(this.version);
    sigMsgWriter.writeUInt32(this.locktime);
    sigMsgWriter.writeSlice(hashPrevouts);
    sigMsgWriter.writeSlice(hashAmounts);
    sigMsgWriter.writeSlice(hashScriptPubKeys);
    sigMsgWriter.writeSlice(hashSequences);
    if (!(isNone || isSingle)) {
      sigMsgWriter.writeSlice(hashOutputs);
    }
    // Input
    sigMsgWriter.writeUInt8(spendType);
    if (isAnyoneCanPay) {
      const input = this.ins[inIndex];
      sigMsgWriter.writeSlice(input.hash);
      sigMsgWriter.writeUInt32(input.index);
      sigMsgWriter.writeUInt64(values[inIndex]);
      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
      sigMsgWriter.writeUInt32(input.sequence);
    } else {
      sigMsgWriter.writeUInt32(inIndex);
    }
    if (annex) {
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        varSliceSize(annex),
      );
      bufferWriter.writeVarSlice(annex);
      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
    }
    // Output
    if (isSingle) {
      sigMsgWriter.writeSlice(hashOutputs);
    }
    // BIP342 extension
    if (leafHash) {
      sigMsgWriter.writeSlice(leafHash);
      sigMsgWriter.writeUInt8(0);
      sigMsgWriter.writeUInt32(0xffffffff);
    }
    // Extra zero byte because:
    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19
    return bcrypto.taggedHash(
      'TapSighash',
      Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]),
    );
  }
  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
    typeforce(
      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
      arguments,
    );
    let tbuffer = Buffer.from([]);
    let bufferWriter;
    let hashOutputs = ZERO;
    let hashPrevouts = ZERO;
    let hashSequence = ZERO;
    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      this.ins.forEach(txIn => {
        bufferWriter.writeSlice(txIn.hash);
        bufferWriter.writeUInt32(txIn.index);
      });
      hashPrevouts = bcrypto.hash256(tbuffer);
    }
    if (
      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&
      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
      (hashType & 0x1f) !== Transaction.SIGHASH_NONE
    ) {
      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      this.ins.forEach(txIn => {
        bufferWriter.writeUInt32(txIn.sequence);
      });
      hashSequence = bcrypto.hash256(tbuffer);
    }
    if (
      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
      (hashType & 0x1f) !== Transaction.SIGHASH_NONE
    ) {
      const txOutsSize = this.outs.reduce((sum, output) => {
        return sum + 8 + varSliceSize(output.script);
      }, 0);
      tbuffer = Buffer.allocUnsafe(txOutsSize);
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      this.outs.forEach(out => {
        bufferWriter.writeUInt64(out.value);
        bufferWriter.writeVarSlice(out.script);
      });
      hashOutputs = bcrypto.hash256(tbuffer);
    } else if (
      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&
      inIndex < this.outs.length
    ) {
      const output = this.outs[inIndex];
      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      bufferWriter.writeUInt64(output.value);
      bufferWriter.writeVarSlice(output.script);
      hashOutputs = bcrypto.hash256(tbuffer);
    }
    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
    const input = this.ins[inIndex];
    bufferWriter.writeInt32(this.version);
    bufferWriter.writeSlice(hashPrevouts);
    bufferWriter.writeSlice(hashSequence);
    bufferWriter.writeSlice(input.hash);
    bufferWriter.writeUInt32(input.index);
    bufferWriter.writeVarSlice(prevOutScript);
    bufferWriter.writeUInt64(value);
    bufferWriter.writeUInt32(input.sequence);
    bufferWriter.writeSlice(hashOutputs);
    bufferWriter.writeUInt32(this.locktime);
    bufferWriter.writeUInt32(hashType);
    return bcrypto.hash256(tbuffer);
  }
  getHash(forWitness) {
    // wtxid for coinbase is always 32 bytes of 0x00
    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));
  }
  getId() {
    // transaction hash's are displayed in reverse order
    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
      'hex',
    );
  }
  toBuffer(buffer, initialOffset) {
    return this.__toBuffer(buffer, initialOffset, true);
  }
  toHex() {
    return this.toBuffer(undefined, undefined).toString('hex');
  }
  setInputScript(index, scriptSig) {
    typeforce(types.tuple(types.Number, types.Buffer), arguments);
    this.ins[index].script = scriptSig;
  }
  setWitness(index, witness) {
    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
    this.ins[index].witness = witness;
  }
  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
    const bufferWriter = new bufferutils_1.BufferWriter(
      buffer,
      initialOffset || 0,
    );
    bufferWriter.writeInt32(this.version);
    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
    if (hasWitnesses) {
      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
    }
    bufferWriter.writeVarInt(this.ins.length);
    this.ins.forEach(txIn => {
      bufferWriter.writeSlice(txIn.hash);
      bufferWriter.writeUInt32(txIn.index);
      bufferWriter.writeVarSlice(txIn.script);
      bufferWriter.writeUInt32(txIn.sequence);
    });
    bufferWriter.writeVarInt(this.outs.length);
    this.outs.forEach(txOut => {
      if (isOutput(txOut)) {
        bufferWriter.writeUInt64(txOut.value);
      } else {
        bufferWriter.writeSlice(txOut.valueBuffer);
      }
      bufferWriter.writeVarSlice(txOut.script);
    });
    if (hasWitnesses) {
      this.ins.forEach(input => {
        bufferWriter.writeVector(input.witness);
      });
    }
    bufferWriter.writeUInt32(this.locktime);
    // avoid slicing unless necessary
    if (initialOffset !== undefined)
      return buffer.slice(initialOffset, bufferWriter.offset);
    return buffer;
  }
}
exports.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 0xffffffff;
Transaction.SIGHASH_DEFAULT = 0x00;
Transaction.SIGHASH_ALL = 0x01;
Transaction.SIGHASH_NONE = 0x02;
Transaction.SIGHASH_SINGLE = 0x03;
Transaction.SIGHASH_ANYONECANPAY = 0x80;
Transaction.SIGHASH_OUTPUT_MASK = 0x03;
Transaction.SIGHASH_INPUT_MASK = 0x80;
Transaction.ADVANCED_TRANSACTION_MARKER = 0x00;
Transaction.ADVANCED_TRANSACTION_FLAG = 0x01;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bufferutils":106,"./crypto":107,"./script":128,"./types":132,"buffer":167}],132:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.oneOf =
  exports.Null =
  exports.BufferN =
  exports.Function =
  exports.UInt32 =
  exports.UInt8 =
  exports.tuple =
  exports.maybe =
  exports.Hex =
  exports.Buffer =
  exports.String =
  exports.Boolean =
  exports.Array =
  exports.Number =
  exports.Hash256bit =
  exports.Hash160bit =
  exports.Buffer256bit =
  exports.isTaptree =
  exports.isTapleaf =
  exports.TAPLEAF_VERSION_MASK =
  exports.Satoshi =
  exports.isPoint =
  exports.stacksEqual =
  exports.typeforce =
    void 0;
const buffer_1 = require('buffer');
exports.typeforce = require('typeforce');
const ZERO32 = buffer_1.Buffer.alloc(32, 0);
const EC_P = buffer_1.Buffer.from(
  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',
  'hex',
);
/**
 * Checks if two arrays of Buffers are equal.
 * @param a - The first array of Buffers.
 * @param b - The second array of Buffers.
 * @returns True if the arrays are equal, false otherwise.
 */
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
exports.stacksEqual = stacksEqual;
/**
 * Checks if the given value is a valid elliptic curve point.
 * @param p - The value to check.
 * @returns True if the value is a valid elliptic curve point, false otherwise.
 */
function isPoint(p) {
  if (!buffer_1.Buffer.isBuffer(p)) return false;
  if (p.length < 33) return false;
  const t = p[0];
  const x = p.slice(1, 33);
  if (x.compare(ZERO32) === 0) return false;
  if (x.compare(EC_P) >= 0) return false;
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    return true;
  }
  const y = p.slice(33);
  if (y.compare(ZERO32) === 0) return false;
  if (y.compare(EC_P) >= 0) return false;
  if (t === 0x04 && p.length === 65) return true;
  return false;
}
exports.isPoint = isPoint;
const SATOSHI_MAX = 21 * 1e14;
function Satoshi(value) {
  return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;
}
exports.Satoshi = Satoshi;
exports.TAPLEAF_VERSION_MASK = 0xfe;
function isTapleaf(o) {
  if (!o || !('output' in o)) return false;
  if (!buffer_1.Buffer.isBuffer(o.output)) return false;
  if (o.version !== undefined)
    return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;
  return true;
}
exports.isTapleaf = isTapleaf;
function isTaptree(scriptTree) {
  if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);
  if (scriptTree.length !== 2) return false;
  return scriptTree.every(t => isTaptree(t));
}
exports.isTaptree = isTaptree;
exports.Buffer256bit = exports.typeforce.BufferN(32);
exports.Hash160bit = exports.typeforce.BufferN(20);
exports.Hash256bit = exports.typeforce.BufferN(32);
exports.Number = exports.typeforce.Number;
exports.Array = exports.typeforce.Array;
exports.Boolean = exports.typeforce.Boolean;
exports.String = exports.typeforce.String;
exports.Buffer = exports.typeforce.Buffer;
exports.Hex = exports.typeforce.Hex;
exports.maybe = exports.typeforce.maybe;
exports.tuple = exports.typeforce.tuple;
exports.UInt8 = exports.typeforce.UInt8;
exports.UInt32 = exports.typeforce.UInt32;
exports.Function = exports.typeforce.Function;
exports.BufferN = exports.typeforce.BufferN;
exports.Null = exports.typeforce.Null;
exports.oneOf = exports.typeforce.oneOf;

},{"buffer":167,"typeforce":359}],133:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    this.length = num === 0 ? 1 : this.length;

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":135}],134:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":135}],135:[function(require,module,exports){

},{}],136:[function(require,module,exports){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES

},{"safe-buffer":327}],137:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
var incr32 = require('./incr32')

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher

},{"./aes":136,"./ghash":141,"./incr32":142,"buffer-xor":166,"cipher-base":176,"inherits":260,"safe-buffer":327}],138:[function(require,module,exports){
var ciphers = require('./encrypter')
var deciphers = require('./decrypter')
var modes = require('./modes/list.json')

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":139,"./encrypter":140,"./modes/list.json":150}],139:[function(require,module,exports){
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

},{"./aes":136,"./authCipher":137,"./modes":149,"./streamCipher":152,"cipher-base":176,"evp_bytestokey":230,"inherits":260,"safe-buffer":327}],140:[function(require,module,exports){
var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

},{"./aes":136,"./authCipher":137,"./modes":149,"./streamCipher":152,"cipher-base":176,"evp_bytestokey":230,"inherits":260,"safe-buffer":327}],141:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH

},{"safe-buffer":327}],142:[function(require,module,exports){
function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32

},{}],143:[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":166}],144:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var xor = require('buffer-xor')

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}

},{"buffer-xor":166,"safe-buffer":327}],145:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":327}],146:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":327}],147:[function(require,module,exports){
var xor = require('buffer-xor')
var Buffer = require('safe-buffer').Buffer
var incr32 = require('../incr32')

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

},{"../incr32":142,"buffer-xor":166,"safe-buffer":327}],148:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],149:[function(require,module,exports){
var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
}

var modes = require('./list.json')

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes

},{"./cbc":143,"./cfb":144,"./cfb1":145,"./cfb8":146,"./ctr":147,"./ecb":148,"./list.json":150,"./ofb":151}],150:[function(require,module,exports){
module.exports={
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

},{}],151:[function(require,module,exports){
(function (Buffer){(function (){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167,"buffer-xor":166}],152:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher

},{"./aes":136,"cipher-base":176,"inherits":260,"safe-buffer":327}],153:[function(require,module,exports){
var DES = require('browserify-des')
var aes = require('browserify-aes/browser')
var aesModes = require('browserify-aes/modes')
var desModes = require('browserify-des/modes')
var ebtk = require('evp_bytestokey')

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"browserify-aes/browser":138,"browserify-aes/modes":149,"browserify-des":154,"browserify-des/modes":155,"evp_bytestokey":230}],154:[function(require,module,exports){
var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}

},{"cipher-base":176,"des.js":186,"inherits":260,"safe-buffer":327}],155:[function(require,module,exports){
exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

},{}],156:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var randomBytes = require('randombytes');
var Buffer = require('safe-buffer').Buffer;

function getr(priv) {
	var len = priv.modulus.byteLength();
	var r;
	do {
		r = new BN(randomBytes(len));
	} while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
	return r;
}

function blind(priv) {
	var r = getr(priv);
	var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
	return { blinder: blinder, unblinder: r.invm(priv.modulus) };
}

function crt(msg, priv) {
	var blinds = blind(priv);
	var len = priv.modulus.byteLength();
	var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
	var c1 = blinded.toRed(BN.mont(priv.prime1));
	var c2 = blinded.toRed(BN.mont(priv.prime2));
	var qinv = priv.coefficient;
	var p = priv.prime1;
	var q = priv.prime2;
	var m1 = c1.redPow(priv.exponent1).fromRed();
	var m2 = c2.redPow(priv.exponent2).fromRed();
	var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
	return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len);
}
crt.getr = getr;

module.exports = crt;

},{"bn.js":133,"randombytes":311,"safe-buffer":327}],157:[function(require,module,exports){
'use strict';

module.exports = require('./browser/algorithms.json');

},{"./browser/algorithms.json":158}],158:[function(require,module,exports){
module.exports={
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}

},{}],159:[function(require,module,exports){
module.exports={
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}

},{}],160:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var createHash = require('create-hash');
var stream = require('readable-stream');
var inherits = require('inherits');
var sign = require('./sign');
var verify = require('./verify');

var algorithms = require('./algorithms.json');
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex');
  algorithms[key.toLowerCase()] = algorithms[key];
});

function Sign(algorithm) {
  stream.Writable.call(this);

  var data = algorithms[algorithm];
  if (!data) { throw new Error('Unknown message digest'); }

  this._hashType = data.hash;
  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}
inherits(Sign, stream.Writable);

Sign.prototype._write = function _write(data, _, done) {
  this._hash.update(data);
  done();
};

Sign.prototype.update = function update(data, enc) {
  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

  return this;
};

Sign.prototype.sign = function signMethod(key, enc) {
  this.end();
  var hash = this._hash.digest();
  var sig = sign(hash, key, this._hashType, this._signType, this._tag);

  return enc ? sig.toString(enc) : sig;
};

function Verify(algorithm) {
  stream.Writable.call(this);

  var data = algorithms[algorithm];
  if (!data) { throw new Error('Unknown message digest'); }

  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}
inherits(Verify, stream.Writable);

Verify.prototype._write = function _write(data, _, done) {
  this._hash.update(data);
  done();
};

Verify.prototype.update = function update(data, enc) {
  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

  return this;
};

Verify.prototype.verify = function verifyMethod(key, sig, enc) {
  var sigBuffer = typeof sig === 'string' ? Buffer.from(sig, enc) : sig;

  this.end();
  var hash = this._hash.digest();
  return verify(sigBuffer, hash, key, this._signType, this._tag);
};

function createSign(algorithm) {
  return new Sign(algorithm);
}

function createVerify(algorithm) {
  return new Verify(algorithm);
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
};

},{"./algorithms.json":158,"./sign":161,"./verify":162,"create-hash":180,"inherits":260,"readable-stream":323,"safe-buffer":327}],161:[function(require,module,exports){
'use strict';

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer;
var createHmac = require('create-hmac');
var crt = require('browserify-rsa');
var EC = require('elliptic').ec;
var BN = require('bn.js');
var parseKeys = require('parse-asn1');
var curves = require('./curves.json');

var RSA_PKCS1_PADDING = 1;

function sign(hash, key, hashType, signType, tag) {
  var priv = parseKeys(key);
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
    return ecSign(hash, priv);
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') { throw new Error('wrong private key type'); }
    return dsaSign(hash, priv, hashType);
  }
  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
  if (key.padding !== undefined && key.padding !== RSA_PKCS1_PADDING) { throw new Error('illegal or unsupported padding mode'); }

  hash = Buffer.concat([tag, hash]);
  var len = priv.modulus.byteLength();
  var pad = [0, 1];
  while (hash.length + pad.length + 1 < len) { pad.push(0xff); }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) { pad.push(hash[i]); }

  var out = crt(pad, priv);
  return out;
}

function ecSign(hash, priv) {
  var curveId = curves[priv.curve.join('.')];
  if (!curveId) { throw new Error('unknown curve ' + priv.curve.join('.')); }

  var curve = new EC(curveId);
  var key = curve.keyFromPrivate(priv.privateKey);
  var out = key.sign(hash);

  return Buffer.from(out.toDER());
}

function dsaSign(hash, priv, algo) {
  var x = priv.params.priv_key;
  var p = priv.params.p;
  var q = priv.params.q;
  var g = priv.params.g;
  var r = new BN(0);
  var k;
  var H = bits2int(hash, q).mod(q);
  var s = false;
  var kv = getKey(x, q, hash, algo);
  while (s === false) {
    k = makeKey(q, kv, algo);
    r = makeR(g, k, p, q);
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
    if (s.cmpn(0) === 0) {
      s = false;
      r = new BN(0);
    }
  }
  return toDER(r, s);
}

function toDER(r, s) {
  r = r.toArray();
  s = s.toArray();

  // Pad values
  if (r[0] & 0x80) { r = [0].concat(r); }
  if (s[0] & 0x80) { s = [0].concat(s); }

  var total = r.length + s.length + 4;
  var res = [
    0x30, total, 0x02, r.length
  ];
  res = res.concat(r, [0x02, s.length], s);
  return Buffer.from(res);
}

function getKey(x, q, hash, algo) {
  x = Buffer.from(x.toArray());
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length);
    x = Buffer.concat([zeros, x]);
  }
  var hlen = hash.length;
  var hbits = bits2octets(hash, q);
  var v = Buffer.alloc(hlen);
  v.fill(1);
  var k = Buffer.alloc(hlen);
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  return { k: k, v: v };
}

function bits2int(obits, q) {
  var bits = new BN(obits);
  var shift = (obits.length << 3) - q.bitLength();
  if (shift > 0) { bits.ishrn(shift); }
  return bits;
}

function bits2octets(bits, q) {
  bits = bits2int(bits, q);
  bits = bits.mod(q);
  var out = Buffer.from(bits.toArray());
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length);
    out = Buffer.concat([zeros, out]);
  }
  return out;
}

function makeKey(q, kv, algo) {
  var t;
  var k;

  do {
    t = Buffer.alloc(0);

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      t = Buffer.concat([t, kv.v]);
    }

    k = bits2int(t, q);
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
    kv.v = createHmac(algo, kv.k).update(kv.v).digest();
  } while (k.cmp(q) !== -1);

  return k;
}

function makeR(g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
}

module.exports = sign;
module.exports.getKey = getKey;
module.exports.makeKey = makeKey;

},{"./curves.json":159,"bn.js":133,"browserify-rsa":156,"create-hmac":182,"elliptic":203,"parse-asn1":294,"safe-buffer":327}],162:[function(require,module,exports){
'use strict';

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer;
var BN = require('bn.js');
var EC = require('elliptic').ec;
var parseKeys = require('parse-asn1');
var curves = require('./curves.json');

function verify(sig, hash, key, signType, tag) {
  var pub = parseKeys(key);
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }
    return ecVerify(sig, hash, pub);
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') { throw new Error('wrong public key type'); }
    return dsaVerify(sig, hash, pub);
  }
  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }

  hash = Buffer.concat([tag, hash]);
  var len = pub.modulus.byteLength();
  var pad = [1];
  var padNum = 0;
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff);
    padNum += 1;
  }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) {
    pad.push(hash[i]);
  }
  pad = Buffer.from(pad);
  var red = BN.mont(pub.modulus);
  sig = new BN(sig).toRed(red);

  sig = sig.redPow(new BN(pub.publicExponent));
  sig = Buffer.from(sig.fromRed().toArray());
  var out = padNum < 8 ? 1 : 0;
  len = Math.min(sig.length, pad.length);
  if (sig.length !== pad.length) { out = 1; }

  i = -1;
  while (++i < len) { out |= sig[i] ^ pad[i]; }
  return out === 0;
}

function ecVerify(sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')];
  if (!curveId) { throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.')); }

  var curve = new EC(curveId);
  var pubkey = pub.data.subjectPrivateKey.data;

  return curve.verify(hash, sig, pubkey);
}

function dsaVerify(sig, hash, pub) {
  var p = pub.data.p;
  var q = pub.data.q;
  var g = pub.data.g;
  var y = pub.data.pub_key;
  var unpacked = parseKeys.signature.decode(sig, 'der');
  var s = unpacked.s;
  var r = unpacked.r;
  checkValue(s, q);
  checkValue(r, q);
  var montp = BN.mont(p);
  var w = s.invm(q);
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q);
  return v.cmp(r) === 0;
}

function checkValue(b, q) {
  if (b.cmpn(0) <= 0) { throw new Error('invalid sig'); }
  if (b.cmp(q) >= 0) { throw new Error('invalid sig'); }
}

module.exports = verify;

},{"./curves.json":159,"bn.js":133,"elliptic":203,"parse-asn1":294,"safe-buffer":327}],163:[function(require,module,exports){
const basex = require('base-x')
const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)

},{"base-x":51}],164:[function(require,module,exports){
'use strict'

var base58 = require('bs58')

module.exports = function (checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode (payload) {
    var payloadU8 = Uint8Array.from(payload)
    var checksum = checksumFn(payloadU8)
    var length = payloadU8.length + 4
    var both = new Uint8Array(length)
    both.set(payloadU8, 0)
    both.set(checksum.subarray(0, 4), payloadU8.length)
    return base58.encode(both, length)
  }

  function decodeRaw (buffer) {
    var payload = buffer.slice(0, -4)
    var checksum = buffer.slice(-4)
    var newChecksum = checksumFn(payload)

    if (checksum[0] ^ newChecksum[0] |
        checksum[1] ^ newChecksum[1] |
        checksum[2] ^ newChecksum[2] |
        checksum[3] ^ newChecksum[3]) return

    return payload
  }

  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe (string) {
    var buffer = base58.decodeUnsafe(string)
    if (!buffer) return

    return decodeRaw(buffer)
  }

  function decode (string) {
    var buffer = base58.decode(string)
    var payload = decodeRaw(buffer, checksumFn)
    if (!payload) throw new Error('Invalid checksum')
    return payload
  }

  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  }
}

},{"bs58":163}],165:[function(require,module,exports){
'use strict'

var { sha256 } = require('@noble/hashes/sha256')
var bs58checkBase = require('./base')

// SHA256(SHA256(buffer))
function sha256x2 (buffer) {
  return sha256(sha256(buffer))
}

module.exports = bs58checkBase(sha256x2)

},{"./base":164,"@noble/hashes/sha256":31}],166:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],167:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":52,"buffer":167,"ieee754":259}],168:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

var $apply = require('./functionApply');
var $call = require('./functionCall');
var $reflectApply = require('./reflectApply');

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);

},{"./functionApply":170,"./functionCall":171,"./reflectApply":173,"function-bind":233}],169:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var $apply = require('./functionApply');
var actualApply = require('./actualApply');

/** @type {import('./applyBind')} */
module.exports = function applyBind() {
	return actualApply(bind, $apply, arguments);
};

},{"./actualApply":168,"./functionApply":170,"function-bind":233}],170:[function(require,module,exports){
'use strict';

/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;

},{}],171:[function(require,module,exports){
'use strict';

/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;

},{}],172:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var $TypeError = require('es-errors/type');

var $call = require('./functionCall');
var $actualApply = require('./actualApply');

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};

},{"./actualApply":168,"./functionCall":171,"es-errors/type":226,"function-bind":233}],173:[function(require,module,exports){
'use strict';

/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;

},{}],174:[function(require,module,exports){
'use strict';

var setFunctionLength = require('set-function-length');

var $defineProperty = require('es-define-property');

var callBindBasic = require('call-bind-apply-helpers');
var applyBind = require('call-bind-apply-helpers/applyBind');

module.exports = function callBind(originalFunction) {
	var func = callBindBasic(arguments);
	var adjustedLength = originalFunction.length - (arguments.length - 1);
	return setFunctionLength(
		func,
		1 + (adjustedLength > 0 ? adjustedLength : 0),
		true
	);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"call-bind-apply-helpers":172,"call-bind-apply-helpers/applyBind":169,"es-define-property":220,"set-function-length":328}],175:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBindBasic = require('call-bind-apply-helpers');

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};

},{"call-bind-apply-helpers":172,"get-intrinsic":234}],176:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var Transform = require('stream').Transform;
var StringDecoder = require('string_decoder').StringDecoder;
var inherits = require('inherits');
var toBuffer = require('to-buffer');

function CipherBase(hashMode) {
	Transform.call(this);
	this.hashMode = typeof hashMode === 'string';
	if (this.hashMode) {
		this[hashMode] = this._finalOrDigest;
	} else {
		this['final'] = this._finalOrDigest;
	}
	if (this._final) {
		this.__final = this._final;
		this._final = null;
	}
	this._decoder = null;
	this._encoding = null;
}
inherits(CipherBase, Transform);

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
	var bufferData = toBuffer(data, inputEnc); // asserts correct input type
	var outData = this._update(bufferData);
	if (this.hashMode) {
		return this;
	}

	if (outputEnc) {
		outData = this._toString(outData, outputEnc);
	}

	return outData;
};

CipherBase.prototype.setAutoPadding = function () {};
CipherBase.prototype.getAuthTag = function () {
	throw new Error('trying to get auth tag in unsupported state');
};

CipherBase.prototype.setAuthTag = function () {
	throw new Error('trying to set auth tag in unsupported state');
};

CipherBase.prototype.setAAD = function () {
	throw new Error('trying to set aad in unsupported state');
};

CipherBase.prototype._transform = function (data, _, next) {
	var err;
	try {
		if (this.hashMode) {
			this._update(data);
		} else {
			this.push(this._update(data));
		}
	} catch (e) {
		err = e;
	} finally {
		next(err);
	}
};
CipherBase.prototype._flush = function (done) {
	var err;
	try {
		this.push(this.__final());
	} catch (e) {
		err = e;
	}

	done(err);
};
CipherBase.prototype._finalOrDigest = function (outputEnc) {
	var outData = this.__final() || Buffer.alloc(0);
	if (outputEnc) {
		outData = this._toString(outData, outputEnc, true);
	}
	return outData;
};

CipherBase.prototype._toString = function (value, enc, fin) {
	if (!this._decoder) {
		this._decoder = new StringDecoder(enc);
		this._encoding = enc;
	}

	if (this._encoding !== enc) {
		throw new Error('can’t switch encodings');
	}

	var out = this._decoder.write(value);
	if (fin) {
		out += this._decoder.end();
	}

	return out;
};

module.exports = CipherBase;

},{"inherits":260,"safe-buffer":327,"stream":337,"string_decoder":352,"to-buffer":354}],177:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('buffer').Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":167}],178:[function(require,module,exports){
(function (Buffer){(function (){
var elliptic = require('elliptic')
var BN = require('bn.js')

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bn.js":179,"buffer":167,"elliptic":203}],179:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"buffer":135,"dup":49}],180:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":176,"inherits":260,"md5.js":285,"ripemd160":324,"sha.js":330}],181:[function(require,module,exports){
var MD5 = require('md5.js')

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}

},{"md5.js":285}],182:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Legacy = require('./legacy')
var Base = require('cipher-base')
var Buffer = require('safe-buffer').Buffer
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')

var sha = require('sha.js')

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}

},{"./legacy":183,"cipher-base":176,"create-hash/md5":181,"inherits":260,"ripemd160":324,"safe-buffer":327,"sha.js":330}],183:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var Base = require('cipher-base')

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac

},{"cipher-base":176,"inherits":260,"safe-buffer":327}],184:[function(require,module,exports){
'use strict';

// eslint-disable-next-line no-multi-assign
exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes');

// eslint-disable-next-line no-multi-assign
exports.createHash = exports.Hash = require('create-hash');

// eslint-disable-next-line no-multi-assign
exports.createHmac = exports.Hmac = require('create-hmac');

var algos = require('browserify-sign/algos');
var algoKeys = Object.keys(algos);
var hashes = [
	'sha1',
	'sha224',
	'sha256',
	'sha384',
	'sha512',
	'md5',
	'rmd160'
].concat(algoKeys);

exports.getHashes = function () {
	return hashes;
};

var p = require('pbkdf2');
exports.pbkdf2 = p.pbkdf2;
exports.pbkdf2Sync = p.pbkdf2Sync;

var aes = require('browserify-cipher');

exports.Cipher = aes.Cipher;
exports.createCipher = aes.createCipher;
exports.Cipheriv = aes.Cipheriv;
exports.createCipheriv = aes.createCipheriv;
exports.Decipher = aes.Decipher;
exports.createDecipher = aes.createDecipher;
exports.Decipheriv = aes.Decipheriv;
exports.createDecipheriv = aes.createDecipheriv;
exports.getCiphers = aes.getCiphers;
exports.listCiphers = aes.listCiphers;

var dh = require('diffie-hellman');

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
exports.getDiffieHellman = dh.getDiffieHellman;
exports.createDiffieHellman = dh.createDiffieHellman;
exports.DiffieHellman = dh.DiffieHellman;

var sign = require('browserify-sign');

exports.createSign = sign.createSign;
exports.Sign = sign.Sign;
exports.createVerify = sign.createVerify;
exports.Verify = sign.Verify;

exports.createECDH = require('create-ecdh');

var publicEncrypt = require('public-encrypt');

exports.publicEncrypt = publicEncrypt.publicEncrypt;
exports.privateEncrypt = publicEncrypt.privateEncrypt;
exports.publicDecrypt = publicEncrypt.publicDecrypt;
exports.privateDecrypt = publicEncrypt.privateDecrypt;

// the least I can do is make error messages for the rest of the node.js/crypto api.
// [
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error('sorry, ' + name + ' is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify');
//   };
// });

var rf = require('randomfill');

exports.randomFill = rf.randomFill;
exports.randomFillSync = rf.randomFillSync;

exports.createCredentials = function () {
	throw new Error('sorry, createCredentials is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify');
};

exports.constants = {
	DH_CHECK_P_NOT_SAFE_PRIME: 2,
	DH_CHECK_P_NOT_PRIME: 1,
	DH_UNABLE_TO_CHECK_GENERATOR: 4,
	DH_NOT_SUITABLE_GENERATOR: 8,
	NPN_ENABLED: 1,
	ALPN_ENABLED: 1,
	RSA_PKCS1_PADDING: 1,
	RSA_SSLV23_PADDING: 2,
	RSA_NO_PADDING: 3,
	RSA_PKCS1_OAEP_PADDING: 4,
	RSA_X931_PADDING: 5,
	RSA_PKCS1_PSS_PADDING: 6,
	POINT_CONVERSION_COMPRESSED: 2,
	POINT_CONVERSION_UNCOMPRESSED: 4,
	POINT_CONVERSION_HYBRID: 6
};

},{"browserify-cipher":153,"browserify-sign":160,"browserify-sign/algos":157,"create-ecdh":178,"create-hash":180,"create-hmac":182,"diffie-hellman":192,"pbkdf2":295,"public-encrypt":304,"randombytes":311,"randomfill":312}],185:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var gopd = require('gopd');

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};

},{"es-define-property":220,"es-errors/syntax":225,"es-errors/type":226,"gopd":239}],186:[function(require,module,exports){
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/cbc":187,"./des/cipher":188,"./des/des":189,"./des/ede":190,"./des/utils":191}],187:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

},{"inherits":260,"minimalistic-assert":288}],188:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
  this.padding = options.padding !== false
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":288}],189:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var utils = require('./utils');
var Cipher = require('./cipher');

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  if (this.padding === false) {
    return false;
  }

  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  if (this.padding === false) {
    return buffer;
  }

  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"./cipher":188,"./utils":191,"inherits":260,"minimalistic-assert":288}],190:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var Cipher = require('./cipher');
var DES = require('./des');

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"./cipher":188,"./des":189,"inherits":260,"minimalistic-assert":288}],191:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],192:[function(require,module,exports){
(function (Buffer){(function (){
var generatePrime = require('./lib/generatePrime')
var primes = require('./lib/primes.json')

var DH = require('./lib/dh')

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

}).call(this)}).call(this,require("buffer").Buffer)
},{"./lib/dh":193,"./lib/generatePrime":194,"./lib/primes.json":195,"buffer":167}],193:[function(require,module,exports){
(function (Buffer){(function (){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./generatePrime":194,"bn.js":196,"buffer":167,"miller-rabin":286,"randombytes":311}],194:[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

},{"bn.js":196,"miller-rabin":286,"randombytes":311}],195:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],196:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"buffer":135,"dup":49}],197:[function(require,module,exports){
'use strict';

var callBind = require('call-bind-apply-helpers');
var gOPD = require('gopd');

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;

},{"call-bind-apply-helpers":172,"gopd":239}],198:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.ECPairFactory = exports.networks = void 0;
const networks = require('./networks');
exports.networks = networks;
const types = require('./types');
const randomBytes = require('randombytes');
const wif = require('wif');
const testecc_1 = require('./testecc');
const isOptions = types.typeforce.maybe(
  types.typeforce.compile({
    compressed: types.maybe(types.Boolean),
    network: types.maybe(types.Network),
  }),
);
const toXOnly = (pubKey) =>
  pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
function ECPairFactory(ecc) {
  (0, testecc_1.testEcc)(ecc);
  function isPoint(maybePoint) {
    return ecc.isPoint(maybePoint);
  }
  function fromPrivateKey(buffer, options) {
    types.typeforce(types.Buffer256bit, buffer);
    if (!ecc.isPrivate(buffer))
      throw new TypeError('Private key not in range [1, n)');
    types.typeforce(isOptions, options);
    return new ECPair(buffer, undefined, options);
  }
  function fromPublicKey(buffer, options) {
    types.typeforce(ecc.isPoint, buffer);
    types.typeforce(isOptions, options);
    return new ECPair(undefined, buffer, options);
  }
  function fromWIF(wifString, network) {
    const decoded = wif.decode(wifString);
    const version = decoded.version;
    // list of networks?
    if (types.Array(network)) {
      network = network
        .filter((x) => {
          return version === x.wif;
        })
        .pop();
      if (!network) throw new Error('Unknown network version');
      // otherwise, assume a network object (or default to bitcoin)
    } else {
      network = network || networks.bitcoin;
      if (version !== network.wif) throw new Error('Invalid network version');
    }
    return fromPrivateKey(decoded.privateKey, {
      compressed: decoded.compressed,
      network: network,
    });
  }
  function makeRandom(options) {
    types.typeforce(isOptions, options);
    if (options === undefined) options = {};
    const rng = options.rng || randomBytes;
    let d;
    do {
      d = rng(32);
      types.typeforce(types.Buffer256bit, d);
    } while (!ecc.isPrivate(d));
    return fromPrivateKey(d, options);
  }
  class ECPair {
    __D;
    __Q;
    compressed;
    network;
    lowR;
    constructor(__D, __Q, options) {
      this.__D = __D;
      this.__Q = __Q;
      this.lowR = false;
      if (options === undefined) options = {};
      this.compressed =
        options.compressed === undefined ? true : options.compressed;
      this.network = options.network || networks.bitcoin;
      if (__Q !== undefined)
        this.__Q = Buffer.from(ecc.pointCompress(__Q, this.compressed));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        // It is not possible for both `__Q` and `__D` to be `undefined` at the same time.
        // The factory methods guard for this.
        const p = ecc.pointFromScalar(this.__D, this.compressed);
        // It is not possible for `p` to be null.
        // `fromPrivateKey()` checks that `__D` is a valid scalar.
        this.__Q = Buffer.from(p);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error('Missing private key');
      return wif.encode(this.network.wif, this.__D, this.compressed);
    }
    tweak(t) {
      if (this.privateKey) return this.tweakFromPrivateKey(t);
      return this.tweakFromPublicKey(t);
    }
    sign(hash, lowR) {
      if (!this.__D) throw new Error('Missing private key');
      if (lowR === undefined) lowR = this.lowR;
      if (lowR === false) {
        return Buffer.from(ecc.sign(hash, this.__D));
      } else {
        let sig = ecc.sign(hash, this.__D);
        const extraData = Buffer.alloc(32, 0);
        let counter = 0;
        // if first try is lowR, skip the loop
        // for second try and on, add extra entropy counting up
        while (sig[0] > 0x7f) {
          counter++;
          extraData.writeUIntLE(counter, 0, 6);
          sig = ecc.sign(hash, this.__D, extraData);
        }
        return Buffer.from(sig);
      }
    }
    signSchnorr(hash) {
      if (!this.privateKey) throw new Error('Missing private key');
      if (!ecc.signSchnorr)
        throw new Error('signSchnorr not supported by ecc library');
      return Buffer.from(ecc.signSchnorr(hash, this.privateKey));
    }
    verify(hash, signature) {
      return ecc.verify(hash, this.publicKey, signature);
    }
    verifySchnorr(hash, signature) {
      if (!ecc.verifySchnorr)
        throw new Error('verifySchnorr not supported by ecc library');
      return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
    }
    tweakFromPublicKey(t) {
      const xOnlyPubKey = toXOnly(this.publicKey);
      const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
      if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
        throw new Error('Cannot tweak public key!');
      const parityByte = Buffer.from([
        tweakedPublicKey.parity === 0 ? 0x02 : 0x03,
      ]);
      return fromPublicKey(
        Buffer.concat([parityByte, tweakedPublicKey.xOnlyPubkey]),
        { network: this.network, compressed: this.compressed },
      );
    }
    tweakFromPrivateKey(t) {
      const hasOddY =
        this.publicKey[0] === 3 ||
        (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);
      const privateKey = hasOddY
        ? ecc.privateNegate(this.privateKey)
        : this.privateKey;
      const tweakedPrivateKey = ecc.privateAdd(privateKey, t);
      if (!tweakedPrivateKey) throw new Error('Invalid tweaked private key!');
      return fromPrivateKey(Buffer.from(tweakedPrivateKey), {
        network: this.network,
        compressed: this.compressed,
      });
    }
  }
  return {
    isPoint,
    fromPrivateKey,
    fromPublicKey,
    fromWIF,
    makeRandom,
  };
}
exports.ECPairFactory = ECPairFactory;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./networks":200,"./testecc":201,"./types":202,"buffer":167,"randombytes":311,"wif":365}],199:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.networks = exports.ECPairFactory = exports.default = void 0;
var ecpair_1 = require('./ecpair');
Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function () {
    return ecpair_1.ECPairFactory;
  },
});
Object.defineProperty(exports, 'ECPairFactory', {
  enumerable: true,
  get: function () {
    return ecpair_1.ECPairFactory;
  },
});
Object.defineProperty(exports, 'networks', {
  enumerable: true,
  get: function () {
    return ecpair_1.networks;
  },
});

},{"./ecpair":198}],200:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.testnet = exports.bitcoin = void 0;
exports.bitcoin = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bc',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80,
};
exports.testnet = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'tb',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};

},{}],201:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.testEcc = void 0;
const h = (hex) => Buffer.from(hex, 'hex');
function testEcc(ecc) {
  assert(
    ecc.isPoint(
      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  assert(
    !ecc.isPoint(
      h('030000000000000000000000000000000000000000000000000000000000000005'),
    ),
  );
  assert(
    ecc.isPrivate(
      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  // order - 1
  assert(
    ecc.isPrivate(
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
    ),
  );
  // 0
  assert(
    !ecc.isPrivate(
      h('0000000000000000000000000000000000000000000000000000000000000000'),
    ),
  );
  // order
  assert(
    !ecc.isPrivate(
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    ),
  );
  // order + 1
  assert(
    !ecc.isPrivate(
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142'),
    ),
  );
  // 1 + 0 == 1
  assert(
    Buffer.from(
      ecc.privateAdd(
        h('0000000000000000000000000000000000000000000000000000000000000001'),
        h('0000000000000000000000000000000000000000000000000000000000000000'),
      ),
    ).equals(
      h('0000000000000000000000000000000000000000000000000000000000000001'),
    ),
  );
  // -3 + 3 == 0
  assert(
    ecc.privateAdd(
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
      h('0000000000000000000000000000000000000000000000000000000000000003'),
    ) === null,
  );
  assert(
    Buffer.from(
      ecc.privateAdd(
        h('e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500'),
        h('b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665'),
      ),
    ).equals(
      h('9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24'),
    ),
  );
  assert(
    Buffer.from(
      ecc.privateNegate(
        h('0000000000000000000000000000000000000000000000000000000000000001'),
      ),
    ).equals(
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
    ),
  );
  assert(
    Buffer.from(
      ecc.privateNegate(
        h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
      ),
    ).equals(
      h('0000000000000000000000000000000000000000000000000000000000000003'),
    ),
  );
  assert(
    Buffer.from(
      ecc.privateNegate(
        h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'),
      ),
    ).equals(
      h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792'),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointCompress(
        h(
          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
        ),
        true,
      ),
    ).equals(
      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointCompress(
        h(
          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
        ),
        false,
      ),
    ).equals(
      h(
        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
      ),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointCompress(
        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        true,
      ),
    ).equals(
      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointCompress(
        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        false,
      ),
    ).equals(
      h(
        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
      ),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointFromScalar(
        h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'),
      ),
    ).equals(
      h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99'),
    ),
  );
  assert(
    ecc.xOnlyPointAddTweak(
      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
    ) === null,
  );
  let xOnlyRes = ecc.xOnlyPointAddTweak(
    h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'),
    h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'),
  );
  assert(
    Buffer.from(xOnlyRes.xOnlyPubkey).equals(
      h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf'),
    ) && xOnlyRes.parity === 1,
  );
  xOnlyRes = ecc.xOnlyPointAddTweak(
    h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'),
    h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'),
  );
  assert(
    Buffer.from(xOnlyRes.xOnlyPubkey).equals(
      h('9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c'),
    ) && xOnlyRes.parity === 0,
  );
  assert(
    Buffer.from(
      ecc.sign(
        h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
        h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
      ),
    ).equals(
      h(
        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',
      ),
    ),
  );
  assert(
    ecc.verify(
      h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
      h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
      h(
        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',
      ),
    ),
  );
  if (ecc.signSchnorr) {
    assert(
      Buffer.from(
        ecc.signSchnorr(
          h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
          h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'),
          h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906'),
        ),
      ).equals(
        h(
          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',
        ),
      ),
    );
  }
  if (ecc.verifySchnorr) {
    assert(
      ecc.verifySchnorr(
        h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
        h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'),
        h(
          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',
        ),
      ),
    );
  }
}
exports.testEcc = testEcc;
function assert(bool) {
  if (!bool) throw new Error('ecc library invalid');
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],202:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.maybe =
  exports.Boolean =
  exports.Array =
  exports.Buffer256bit =
  exports.Network =
  exports.typeforce =
    void 0;
exports.typeforce = require('typeforce');
// exposed, external API
exports.Network = exports.typeforce.compile({
  messagePrefix: exports.typeforce.oneOf(
    exports.typeforce.Buffer,
    exports.typeforce.String,
  ),
  bip32: {
    public: exports.typeforce.UInt32,
    private: exports.typeforce.UInt32,
  },
  pubKeyHash: exports.typeforce.UInt8,
  scriptHash: exports.typeforce.UInt8,
  wif: exports.typeforce.UInt8,
});
exports.Buffer256bit = exports.typeforce.BufferN(32);
exports.Array = exports.typeforce.Array;
exports.Boolean = exports.typeforce.Boolean; // tslint:disable-line variable-name
exports.maybe = exports.typeforce.maybe;

},{"typeforce":359}],203:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":219,"./elliptic/curve":206,"./elliptic/curves":209,"./elliptic/ec":210,"./elliptic/eddsa":213,"./elliptic/utils":217,"brorand":134}],204:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../utils":217,"bn.js":218}],205:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":217,"./base":204,"bn.js":218,"inherits":260}],206:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":204,"./edwards":205,"./mont":207,"./short":208}],207:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../utils":217,"./base":204,"bn.js":218,"inherits":260}],208:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":217,"./base":204,"bn.js":218,"inherits":260}],209:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});

},{"./curve":206,"./precomputed/secp256k1":216,"./utils":217,"hash.js":245}],210:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
  var byteLength;
  if (BN.isBN(msg) || typeof msg === 'number') {
    msg = new BN(msg, 16);
    byteLength = msg.byteLength();
  } else if (typeof msg === 'object') {
    // BN assumes an array-like input and asserts length
    byteLength = msg.length;
    msg = new BN(msg, 16);
  } else {
    // BN converts the value to string
    var str = msg.toString();
    // HEX encoding
    byteLength = (str.length + 1) >>> 1;
    msg = new BN(str, 16);
  }
  // Allow overriding
  if (typeof bitLength !== 'number') {
    bitLength = byteLength * 8;
  }
  var delta = bitLength - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  if (typeof msg !== 'string' && typeof msg !== 'number' && !BN.isBN(msg)) {
    assert(typeof msg === 'object' && msg && typeof msg.length === 'number',
      'Expected message to be an array-like, a hex string, or a BN instance');
    assert((msg.length >>> 0) === msg.length); // non-negative 32-bit integer
    for (var i = 0; i < msg.length; i++) assert((msg[i] & 255) === msg[i]);
  }

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(msg, false, options.msgBitLength);

  // Would fail further checks, but let's make the error message clear
  assert(!msg.isNeg(), 'Can not sign a negative message');

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Recheck nonce to be bijective to msg
  assert((new BN(nonce)).eq(msg), 'Can not sign message');

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc, options) {
  if (!options)
    options = {};

  msg = this._truncateToN(msg, false, options.msgBitLength);
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":209,"../utils":217,"./key":211,"./signature":212,"bn.js":218,"brorand":134,"hmac-drbg":258}],211:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature, options) {
  return this.ec.verify(msg, signature, this, undefined, options);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":217,"bn.js":218}],212:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  if(buf[p.place] === 0x00) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":217,"bn.js":218}],213:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
    return false;
  }
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":209,"../utils":217,"./key":214,"./signature":215,"hash.js":245}],214:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":217}],215:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    assert(sig.length === eddsa.encodingLength * 2, 'Signature has invalid size');
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":217,"bn.js":218}],216:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};

},{}],217:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  var i;
  for (i = 0; i < naf.length; i += 1) {
    naf[i] = 0;
  }

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":218,"minimalistic-assert":288,"minimalistic-crypto-utils":289}],218:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"buffer":135,"dup":49}],219:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "6.6.1",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "test": "npm run lint && npm run unit",
    "version": "grunt dist && git add dist/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": "Fedor Indutny <fedor@indutny.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}

},{}],220:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;

},{}],221:[function(require,module,exports){
'use strict';

/** @type {import('./eval')} */
module.exports = EvalError;

},{}],222:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = Error;

},{}],223:[function(require,module,exports){
'use strict';

/** @type {import('./range')} */
module.exports = RangeError;

},{}],224:[function(require,module,exports){
'use strict';

/** @type {import('./ref')} */
module.exports = ReferenceError;

},{}],225:[function(require,module,exports){
'use strict';

/** @type {import('./syntax')} */
module.exports = SyntaxError;

},{}],226:[function(require,module,exports){
'use strict';

/** @type {import('./type')} */
module.exports = TypeError;

},{}],227:[function(require,module,exports){
'use strict';

/** @type {import('./uri')} */
module.exports = URIError;

},{}],228:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = Object;

},{}],229:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],230:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var MD5 = require('md5.js')

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey

},{"md5.js":285,"safe-buffer":327}],231:[function(require,module,exports){
'use strict';

var isCallable = require('is-callable');

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */
var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */
var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */
var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

/** @type {(x: unknown) => x is readonly unknown[]} */
function isArray(x) {
    return toStr.call(x) === '[object Array]';
}

/** @type {import('.')._internal} */
module.exports = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (isArray(list)) {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

},{"is-callable":262}],232:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],233:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":232}],234:[function(require,module,exports){
'use strict';

var undefined;

var $Object = require('es-object-atoms');

var $Error = require('es-errors');
var $EvalError = require('es-errors/eval');
var $RangeError = require('es-errors/range');
var $ReferenceError = require('es-errors/ref');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $URIError = require('es-errors/uri');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var max = require('math-intrinsics/max');
var min = require('math-intrinsics/min');
var pow = require('math-intrinsics/pow');
var round = require('math-intrinsics/round');
var sign = require('math-intrinsics/sign');

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = require('gopd');
var $defineProperty = require('es-define-property');

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = require('get-proto');
var $ObjectGPO = require('get-proto/Object.getPrototypeOf');
var $ReflectGPO = require('get-proto/Reflect.getPrototypeOf');

var $apply = require('call-bind-apply-helpers/functionApply');
var $call = require('call-bind-apply-helpers/functionCall');

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('hasown');
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"call-bind-apply-helpers/functionApply":170,"call-bind-apply-helpers/functionCall":171,"es-define-property":220,"es-errors":222,"es-errors/eval":221,"es-errors/range":223,"es-errors/ref":224,"es-errors/syntax":225,"es-errors/type":226,"es-errors/uri":227,"es-object-atoms":228,"function-bind":233,"get-proto":237,"get-proto/Object.getPrototypeOf":235,"get-proto/Reflect.getPrototypeOf":236,"gopd":239,"has-symbols":241,"hasown":257,"math-intrinsics/abs":277,"math-intrinsics/floor":278,"math-intrinsics/max":280,"math-intrinsics/min":281,"math-intrinsics/pow":282,"math-intrinsics/round":283,"math-intrinsics/sign":284}],235:[function(require,module,exports){
'use strict';

var $Object = require('es-object-atoms');

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;

},{"es-object-atoms":228}],236:[function(require,module,exports){
'use strict';

/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;

},{}],237:[function(require,module,exports){
'use strict';

var reflectGetProto = require('./Reflect.getPrototypeOf');
var originalGetProto = require('./Object.getPrototypeOf');

var getDunderProto = require('dunder-proto/get');

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;

},{"./Object.getPrototypeOf":235,"./Reflect.getPrototypeOf":236,"dunder-proto/get":197}],238:[function(require,module,exports){
'use strict';

/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;

},{}],239:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
var $gOPD = require('./gOPD');

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"./gOPD":238}],240:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;

},{"es-define-property":220}],241:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":242}],242:[function(require,module,exports){
'use strict';

/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],243:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":242}],244:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var inherits = require('inherits')

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

var useUint8Array = typeof Uint8Array !== 'undefined'
var useArrayBuffer = typeof ArrayBuffer !== 'undefined' &&
  typeof Uint8Array !== 'undefined' &&
  ArrayBuffer.isView &&
  (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT)

function toBuffer (data, encoding) {
  // No need to do anything for exact instance
  // This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed
  if (data instanceof Buffer) return data

  // Convert strings to Buffer
  if (typeof data === 'string') return Buffer.from(data, encoding)

  /*
   * Wrap any TypedArray instances and DataViews
   * Makes sense only on engines with full TypedArray support -- let Buffer detect that
   */
  if (useArrayBuffer && ArrayBuffer.isView(data)) {
    if (data.byteLength === 0) return Buffer.alloc(0) // Bug in Node.js <6.3.1, which treats this as out-of-bounds
    var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength)
    // Recheck result size, as offset/length doesn't work on Node.js <5.10
    // We just go to Uint8Array case if this fails
    if (res.byteLength === data.byteLength) return res
  }

  /*
   * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
   * Doesn't make sense with other TypedArray instances
   */
  if (useUint8Array && data instanceof Uint8Array) return Buffer.from(data)

  /*
   * Old Buffer polyfill on an engine that doesn't have TypedArray support
   * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
   * Convert to our current Buffer implementation
   */
  if (
    Buffer.isBuffer(data) &&
    data.constructor &&
    typeof data.constructor.isBuffer === 'function' &&
    data.constructor.isBuffer(data)
  ) {
    return Buffer.from(data)
  }

  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.')
}

HashBase.prototype.update = function (data, encoding) {
  if (this._finalized) throw new Error('Digest already called')

  data = toBuffer(data, encoding) // asserts correct input type

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":260,"safe-buffer":327,"stream":337}],245:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":246,"./hash/hmac":247,"./hash/ripemd":248,"./hash/sha":249,"./hash/utils":256}],246:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":256,"minimalistic-assert":288}],247:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":256,"minimalistic-assert":288}],248:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./common":246,"./utils":256}],249:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":250,"./sha/224":251,"./sha/256":252,"./sha/384":253,"./sha/512":254}],250:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":246,"../utils":256,"./common":255}],251:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":256,"./256":252}],252:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":246,"../utils":256,"./common":255,"minimalistic-assert":288}],253:[function(require,module,exports){
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":256,"./512":254}],254:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../common":246,"../utils":256,"minimalistic-assert":288}],255:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":256}],256:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":260,"minimalistic-assert":288}],257:[function(require,module,exports){
'use strict';

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = require('function-bind');

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);

},{"function-bind":233}],258:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":245,"minimalistic-assert":288,"minimalistic-crypto-utils":289}],259:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],260:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],261:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],262:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};

},{}],263:[function(require,module,exports){
'use strict';

var whichTypedArray = require('which-typed-array');

/** @type {import('.')} */
module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};

},{"which-typed-array":364}],264:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],265:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletPolicy = exports.DefaultWalletPolicy = exports.PsbtV2 = exports.AppClient = void 0;
const appClient_1 = __importDefault(require("./lib/appClient"));
exports.AppClient = appClient_1.default;
const policy_1 = require("./lib/policy");
Object.defineProperty(exports, "DefaultWalletPolicy", { enumerable: true, get: function () { return policy_1.DefaultWalletPolicy; } });
Object.defineProperty(exports, "WalletPolicy", { enumerable: true, get: function () { return policy_1.WalletPolicy; } });
const psbtv2_1 = require("./lib/psbtv2");
Object.defineProperty(exports, "PsbtV2", { enumerable: true, get: function () { return psbtv2_1.PsbtV2; } });
exports.default = appClient_1.default;

},{"./lib/appClient":266,"./lib/policy":273,"./lib/psbtv2":274}],266:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppClient = exports.PartialSignature = void 0;
const bip32_1 = require("./bip32");
const clientCommands_1 = require("./clientCommands");
const merkelizedPsbt_1 = require("./merkelizedPsbt");
const merkle_1 = require("./merkle");
const psbtv2_1 = require("./psbtv2");
const varint_1 = require("./varint");
const CLA_BTC = 0xe1;
const CLA_FRAMEWORK = 0xf8;
const CURRENT_PROTOCOL_VERSION = 1; // supported from version 2.1.0 of the app
var BitcoinIns;
(function (BitcoinIns) {
    BitcoinIns[BitcoinIns["GET_PUBKEY"] = 0] = "GET_PUBKEY";
    BitcoinIns[BitcoinIns["REGISTER_WALLET"] = 2] = "REGISTER_WALLET";
    BitcoinIns[BitcoinIns["GET_WALLET_ADDRESS"] = 3] = "GET_WALLET_ADDRESS";
    BitcoinIns[BitcoinIns["SIGN_PSBT"] = 4] = "SIGN_PSBT";
    BitcoinIns[BitcoinIns["GET_MASTER_FINGERPRINT"] = 5] = "GET_MASTER_FINGERPRINT";
    BitcoinIns[BitcoinIns["SIGN_MESSAGE"] = 16] = "SIGN_MESSAGE";
})(BitcoinIns || (BitcoinIns = {}));
var FrameworkIns;
(function (FrameworkIns) {
    FrameworkIns[FrameworkIns["CONTINUE_INTERRUPTED"] = 1] = "CONTINUE_INTERRUPTED";
})(FrameworkIns || (FrameworkIns = {}));
/**
 * This class represents a partial signature produced by the app during signing.
 * It always contains the `signature` and the corresponding `pubkey` whose private key
 * was used for signing; in the case of taproot script paths, it also contains the
 * tapleaf hash.
 */
class PartialSignature {
    constructor(pubkey, signature, tapleafHash) {
        this.pubkey = pubkey;
        this.signature = signature;
        this.tapleafHash = tapleafHash;
    }
}
exports.PartialSignature = PartialSignature;
/**
 * Creates an instance of `PartialSignature` from the returned raw augmented pubkey and signature.
 * @param pubkeyAugm the public key, concatenated with the tapleaf hash in the case of taproot script path spend.
 * @param signature the signature
 * @returns an instance of `PartialSignature`.
 */
function makePartialSignature(pubkeyAugm, signature) {
    if (pubkeyAugm.length == 64) {
        // tapscript spend: concatenation of 32-bytes x-only pubkey and 32-bytes tapleaf_hash
        return new PartialSignature(pubkeyAugm.slice(0, 32), signature, pubkeyAugm.slice(32, 64));
    }
    else if (pubkeyAugm.length == 32 || pubkeyAugm.length == 33) {
        // legacy, segwit or taproot keypath spend: pubkeyAugm is just the pubkey
        return new PartialSignature(pubkeyAugm, signature);
    }
    else {
        throw new Error(`Invalid length for pubkeyAugm: ${pubkeyAugm.length} bytes.`);
    }
}
/**
 * Checks whether a descriptor template contains an `a:` fragment.
 */
function containsA(descriptorTemplate) {
    const matches = descriptorTemplate.match(/[asctdvjnlu]+:/g) || [];
    return matches.some(match => match.includes('a'));
}
/**
 * This class encapsulates the APDU protocol documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md
 */
class AppClient {
    constructor(transport) {
        this.transport = transport;
    }
    async makeRequest(ins, data, cci) {
        let response = await this.transport.send(CLA_BTC, ins, 0, CURRENT_PROTOCOL_VERSION, data, [0x9000, 0xe000]);
        while (response.readUInt16BE(response.length - 2) === 0xe000) {
            if (!cci) {
                throw new Error('Unexpected SW_INTERRUPTED_EXECUTION');
            }
            const hwRequest = response.slice(0, -2);
            const commandResponse = cci.execute(hwRequest);
            response = await this.transport.send(CLA_FRAMEWORK, FrameworkIns.CONTINUE_INTERRUPTED, 0, 0, commandResponse, [0x9000, 0xe000]);
        }
        return response.slice(0, -2); // drop the status word (can only be 0x9000 at this point)
    }
    /**
     * Returns an object containing the currently running app's name, version and the device status flags.
     *
     * @returns an object with app name, version and device status flags.
     */
    async getAppAndVersion() {
        const r = await this.transport.send(0xb0, 0x01, 0x00, 0x00);
        let i = 0;
        const format = r[i++];
        if (format !== 1)
            throw new Error("Unexpected response");
        const nameLength = r[i++];
        const name = r.slice(i, (i += nameLength)).toString("ascii");
        const versionLength = r[i++];
        const version = r.slice(i, (i += versionLength)).toString("ascii");
        const flagLength = r[i++];
        const flags = r.slice(i, (i += flagLength));
        return {
            name,
            version,
            flags,
        };
    }
    ;
    /**
     * Requests the BIP-32 extended pubkey to the hardware wallet.
     * If `display` is `false`, only standard paths will be accepted; an error is returned if an unusual path is
     * requested.
     * If `display` is `true`, the requested path is shown on screen for user verification; unusual paths can be
     * requested, and a warning is shown to the user in that case.
     *
     * @param path the requested BIP-32 path as a string
     * @param display `false` to silently retrieve a pubkey for a standard path, `true` to display the path on screen
     * @returns the base58-encoded serialized extended pubkey (xpub)
     */
    async getExtendedPubkey(path, display = false) {
        const pathElements = (0, bip32_1.pathStringToArray)(path);
        if (pathElements.length > 6) {
            throw new Error('Path too long. At most 6 levels allowed.');
        }
        const response = await this.makeRequest(BitcoinIns.GET_PUBKEY, Buffer.concat([
            Buffer.from(display ? [1] : [0]),
            (0, bip32_1.pathElementsToBuffer)(pathElements),
        ]));
        return response.toString('ascii');
    }
    /**
     * Registers a `WalletPolicy`, after interactive verification from the user.
     * On success, after user's approval, this function returns the id (which is the same that can be computed with
     * `walletPolicy.getid()`), followed by the 32-byte hmac. The client should store the hmac to use it for future
     * requests to `getWalletAddress` or `signPsbt` using this `WalletPolicy`.
     *
     * @param walletPolicy the `WalletPolicy` to register
     * @returns a pair of two 32-byte arrays: the id of the Wallet Policy, followed by the policy hmac
     */
    async registerWallet(walletPolicy) {
        await this.validatePolicy(walletPolicy);
        const clientInterpreter = new clientCommands_1.ClientCommandInterpreter();
        clientInterpreter.addKnownWalletPolicy(walletPolicy);
        const serializedWalletPolicy = walletPolicy.serialize();
        const response = await this.makeRequest(BitcoinIns.REGISTER_WALLET, Buffer.concat([
            (0, varint_1.createVarint)(serializedWalletPolicy.length),
            serializedWalletPolicy,
        ]), clientInterpreter);
        if (response.length != 64) {
            throw Error(`Invalid response length. Expected 64 bytes, got ${response.length}`);
        }
        return [response.subarray(0, 32), response.subarray(32)];
    }
    /**
     * Returns the address of `walletPolicy` for the given `change` and `addressIndex`.
     *
     * @param walletPolicy the `WalletPolicy` to use
     * @param walletHMAC the 32-byte hmac returned during wallet registration for a registered policy; otherwise
     * `null` for a standard policy
     * @param change `0` for a normal receive address, `1` for a change address
     * @param addressIndex the address index to retrieve
     * @param display `True` to show the address on screen, `False` to retrieve it silently
     * @returns the address, as an ascii string.
     */
    async getWalletAddress(walletPolicy, walletHMAC, change, addressIndex, display) {
        if (change !== 0 && change !== 1)
            throw new Error('Change can only be 0 or 1');
        if (addressIndex < 0 || !Number.isInteger(addressIndex))
            throw new Error('Invalid address index');
        if (walletHMAC != null && walletHMAC.length != 32) {
            throw new Error('Invalid HMAC length');
        }
        await this.validatePolicy(walletPolicy);
        const clientInterpreter = new clientCommands_1.ClientCommandInterpreter();
        clientInterpreter.addKnownWalletPolicy(walletPolicy);
        const addressIndexBuffer = Buffer.alloc(4);
        addressIndexBuffer.writeUInt32BE(addressIndex, 0);
        const response = await this.makeRequest(BitcoinIns.GET_WALLET_ADDRESS, Buffer.concat([
            Buffer.from(display ? [1] : [0]),
            walletPolicy.getId(),
            walletHMAC || Buffer.alloc(32, 0),
            Buffer.from([change]),
            addressIndexBuffer,
        ]), clientInterpreter);
        return response.toString('ascii');
    }
    /**
     * Signs a psbt using a (standard or registered) `WalletPolicy`. This is an interactive command, as user validation
     * is necessary using the device's secure screen.
     * On success, a map of input indexes and signatures is returned.
     * @param psbt a base64-encoded string, or a psbt in a binary Buffer. Using the `PsbtV2` type is deprecated.
     * @param walletPolicy the `WalletPolicy` to use for signing
     * @param walletHMAC the 32-byte hmac obtained during wallet policy registration, or `null` for a standard policy
     * @param progressCallback optionally, a callback that will be called every time a signature is produced during
     * the signing process. The callback does not receive any argument, but can be used to track progress.
     * @returns an array of of tuples with 2 elements containing:
     *    - the index of the input being signed;
     *    - an instance of PartialSignature
     */
    async signPsbt(psbt, walletPolicy, walletHMAC, progressCallback) {
        await this.validatePolicy(walletPolicy);
        if (typeof psbt === 'string') {
            psbt = Buffer.from(psbt, "base64");
        }
        if (Buffer.isBuffer(psbt)) {
            const psbtObj = new psbtv2_1.PsbtV2();
            psbtObj.deserialize(psbt);
            psbt = psbtObj;
        }
        const merkelizedPsbt = new merkelizedPsbt_1.MerkelizedPsbt(psbt);
        if (walletHMAC != null && walletHMAC.length != 32) {
            throw new Error('Invalid HMAC length');
        }
        const clientInterpreter = new clientCommands_1.ClientCommandInterpreter(progressCallback);
        // prepare ClientCommandInterpreter
        clientInterpreter.addKnownWalletPolicy(walletPolicy);
        clientInterpreter.addKnownMapping(merkelizedPsbt.globalMerkleMap);
        for (const map of merkelizedPsbt.inputMerkleMaps) {
            clientInterpreter.addKnownMapping(map);
        }
        for (const map of merkelizedPsbt.outputMerkleMaps) {
            clientInterpreter.addKnownMapping(map);
        }
        clientInterpreter.addKnownList(merkelizedPsbt.inputMapCommitments);
        const inputMapsRoot = new merkle_1.Merkle(merkelizedPsbt.inputMapCommitments.map((m) => (0, merkle_1.hashLeaf)(m))).getRoot();
        clientInterpreter.addKnownList(merkelizedPsbt.outputMapCommitments);
        const outputMapsRoot = new merkle_1.Merkle(merkelizedPsbt.outputMapCommitments.map((m) => (0, merkle_1.hashLeaf)(m))).getRoot();
        await this.makeRequest(BitcoinIns.SIGN_PSBT, Buffer.concat([
            merkelizedPsbt.getGlobalKeysValuesRoot(),
            (0, varint_1.createVarint)(merkelizedPsbt.getGlobalInputCount()),
            inputMapsRoot,
            (0, varint_1.createVarint)(merkelizedPsbt.getGlobalOutputCount()),
            outputMapsRoot,
            walletPolicy.getId(),
            walletHMAC || Buffer.alloc(32, 0),
        ]), clientInterpreter);
        const yielded = clientInterpreter.getYielded();
        const ret = [];
        for (const inputAndSig of yielded) {
            // inputAndSig contains:
            // <inputIndex : varint> <pubkeyLen : 1 byte> <pubkey : pubkeyLen bytes (32 or 33)> <signature : variable length>
            const [inputIndex, inputIndexLen] = (0, varint_1.parseVarint)(inputAndSig, 0);
            const pubkeyAugmLen = inputAndSig[inputIndexLen];
            const pubkeyAugm = inputAndSig.subarray(inputIndexLen + 1, inputIndexLen + 1 + pubkeyAugmLen);
            const signature = inputAndSig.subarray(inputIndexLen + 1 + pubkeyAugmLen);
            const partialSig = makePartialSignature(pubkeyAugm, signature);
            ret.push([Number(inputIndex), partialSig]);
        }
        return ret;
    }
    /**
     * Returns the fingerprint of the master public key, as per BIP-32 standard.
     * @returns the master key fingerprint as a string of 8 hexadecimal digits.
     */
    async getMasterFingerprint() {
        const fpr = await this.makeRequest(BitcoinIns.GET_MASTER_FINGERPRINT, Buffer.from([]));
        return fpr.toString("hex");
    }
    /**
     * Signs a message using the legacy Bitcoin Message Signing standard. The signed message is
     * the double-sha256 hash of the concatenation of:
     * - "\x18Bitcoin Signed Message:\n";
     * - the length of `message`, encoded as a Bitcoin-style variable length integer;
     * - `message`.
     *
     * @param message the serialized message to sign
     * @param path the BIP-32 path of the key used to sign the message
     * @returns base64-encoded signature of the message.
     */
    async signMessage(message, path) {
        const pathElements = (0, bip32_1.pathStringToArray)(path);
        const clientInterpreter = new clientCommands_1.ClientCommandInterpreter();
        // prepare ClientCommandInterpreter
        const nChunks = Math.ceil(message.length / 64);
        const chunks = [];
        for (let i = 0; i < nChunks; i++) {
            chunks.push(message.subarray(64 * i, 64 * i + 64));
        }
        clientInterpreter.addKnownList(chunks);
        const chunksRoot = new merkle_1.Merkle(chunks.map((m) => (0, merkle_1.hashLeaf)(m))).getRoot();
        const result = await this.makeRequest(BitcoinIns.SIGN_MESSAGE, Buffer.concat([
            (0, bip32_1.pathElementsToBuffer)(pathElements),
            (0, varint_1.createVarint)(message.length),
            chunksRoot,
        ]), clientInterpreter);
        return result.toString('base64');
    }
    /* Performs any additional checks on the policy before using it.*/
    async validatePolicy(walletPolicy) {
        if (containsA(walletPolicy.descriptorTemplate)) {
            const appAndVer = await this.getAppAndVersion();
            if (["2.1.0", "2.1.1"].includes(appAndVer.version)) {
                // Versions 2.1.0 and 2.1.1 produced incorrect scripts for policies containing
                // the `a:` fragment.
                throw new Error("Please update your Ledger Bitcoin app.");
            }
        }
    }
}
exports.AppClient = AppClient;
exports.default = AppClient;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bip32":267,"./clientCommands":269,"./merkelizedPsbt":270,"./merkle":271,"./psbtv2":274,"./varint":275,"buffer":167}],267:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hardenedPathOf = exports.getXpubComponents = exports.pubkeyFromXpub = exports.pathStringToArray = exports.pathArrayToString = exports.bip32asBuffer = exports.pathElementsToBuffer = void 0;
const bip32_path_1 = __importDefault(require("bip32-path")); // TODO: get rid of this dependency
const bs58check_1 = __importDefault(require("bs58check"));
function pathElementsToBuffer(paths) {
    const buffer = Buffer.alloc(1 + paths.length * 4);
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
        buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    return buffer;
}
exports.pathElementsToBuffer = pathElementsToBuffer;
function bip32asBuffer(path) {
    const pathElements = !path ? [] : pathStringToArray(path);
    return pathElementsToBuffer(pathElements);
}
exports.bip32asBuffer = bip32asBuffer;
function pathArrayToString(pathElements) {
    // bippath doesn't handle an empty path.
    if (pathElements.length == 0) {
        return "m";
    }
    return bip32_path_1.default.fromPathArray(pathElements).toString();
}
exports.pathArrayToString = pathArrayToString;
function pathStringToArray(path) {
    // bippath doesn't handle an empty path.
    if (path == "m" || path == "") {
        return [];
    }
    return bip32_path_1.default.fromString(path).toPathArray();
}
exports.pathStringToArray = pathStringToArray;
function pubkeyFromXpub(xpub) {
    const xpubBuf = bs58check_1.default.decode(xpub);
    return xpubBuf.slice(xpubBuf.length - 33);
}
exports.pubkeyFromXpub = pubkeyFromXpub;
function getXpubComponents(xpub) {
    const xpubBuf = bs58check_1.default.decode(xpub);
    return {
        chaincode: xpubBuf.slice(13, 13 + 32),
        pubkey: xpubBuf.slice(xpubBuf.length - 33),
        version: xpubBuf.readUInt32BE(0),
    };
}
exports.getXpubComponents = getXpubComponents;
function hardenedPathOf(pathElements) {
    for (let i = pathElements.length - 1; i >= 0; i--) {
        if (pathElements[i] >= 0x80000000) {
            return pathElements.slice(0, i + 1);
        }
    }
    return [];
}
exports.hardenedPathOf = hardenedPathOf;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bip32-path":84,"bs58check":165,"buffer":167}],268:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferReader = exports.BufferWriter = exports.unsafeFrom64bitLE = exports.unsafeTo64bitLE = void 0;
const varint_1 = require("./varint");
function unsafeTo64bitLE(n) {
    // we want to represent the input as a 8-bytes array
    if (n > Number.MAX_SAFE_INTEGER) {
        throw new Error("Can't convert numbers > MAX_SAFE_INT");
    }
    const byteArray = Buffer.alloc(8, 0);
    for (let index = 0; index < byteArray.length; index++) {
        const byte = n & 0xff;
        byteArray[index] = byte;
        n = (n - byte) / 256;
    }
    return byteArray;
}
exports.unsafeTo64bitLE = unsafeTo64bitLE;
function unsafeFrom64bitLE(byteArray) {
    let value = 0;
    if (byteArray.length != 8) {
        throw new Error('Expected Bufffer of lenght 8');
    }
    if (byteArray[7] != 0) {
        throw new Error("Can't encode numbers > MAX_SAFE_INT");
    }
    if (byteArray[6] > 0x1f) {
        throw new Error("Can't encode numbers > MAX_SAFE_INT");
    }
    for (let i = byteArray.length - 1; i >= 0; i--) {
        value = value * 256 + byteArray[i];
    }
    return value;
}
exports.unsafeFrom64bitLE = unsafeFrom64bitLE;
class BufferWriter {
    constructor() {
        this.bufs = [];
    }
    write(alloc, fn) {
        const b = Buffer.alloc(alloc);
        fn(b);
        this.bufs.push(b);
    }
    writeUInt8(i) {
        this.write(1, (b) => b.writeUInt8(i, 0));
    }
    writeInt32(i) {
        this.write(4, (b) => b.writeInt32LE(i, 0));
    }
    writeUInt32(i) {
        this.write(4, (b) => b.writeUInt32LE(i, 0));
    }
    writeUInt64(i) {
        const bytes = unsafeTo64bitLE(i);
        this.writeSlice(bytes);
    }
    writeVarInt(i) {
        this.bufs.push((0, varint_1.createVarint)(i));
    }
    writeSlice(slice) {
        this.bufs.push(Buffer.from(slice));
    }
    writeVarSlice(slice) {
        this.writeVarInt(slice.length);
        this.writeSlice(slice);
    }
    buffer() {
        return Buffer.concat(this.bufs);
    }
}
exports.BufferWriter = BufferWriter;
class BufferReader {
    constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
    }
    available() {
        return this.buffer.length - this.offset;
    }
    readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
    }
    readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
    }
    readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
    }
    readUInt64() {
        const buf = this.readSlice(8);
        return unsafeFrom64bitLE(buf);
    }
    readVarInt() {
        const [vi, vi_size] = (0, varint_1.parseVarint)(this.buffer, this.offset);
        this.offset += vi_size;
        return vi;
    }
    readSlice(n) {
        if (this.buffer.length < this.offset + n) {
            throw new Error('Cannot read slice out of bounds');
        }
        const result = this.buffer.slice(this.offset, this.offset + n);
        this.offset += n;
        return result;
    }
    readVarSlice() {
        const n = (0, varint_1.sanitizeBigintToNumber)(this.readVarInt());
        return this.readSlice(n);
    }
    readVector() {
        const count = this.readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++)
            vector.push(this.readVarSlice());
        return vector;
    }
}
exports.BufferReader = BufferReader;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./varint":275,"buffer":167}],269:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientCommandInterpreter = exports.GetMoreElementsCommand = exports.GetMerkleLeafIndexCommand = exports.GetMerkleLeafProofCommand = exports.GetPreimageCommand = exports.YieldCommand = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const buffertools_1 = require("./buffertools");
const merkle_1 = require("./merkle");
const varint_1 = require("./varint");
var ClientCommandCode;
(function (ClientCommandCode) {
    ClientCommandCode[ClientCommandCode["YIELD"] = 16] = "YIELD";
    ClientCommandCode[ClientCommandCode["GET_PREIMAGE"] = 64] = "GET_PREIMAGE";
    ClientCommandCode[ClientCommandCode["GET_MERKLE_LEAF_PROOF"] = 65] = "GET_MERKLE_LEAF_PROOF";
    ClientCommandCode[ClientCommandCode["GET_MERKLE_LEAF_INDEX"] = 66] = "GET_MERKLE_LEAF_INDEX";
    ClientCommandCode[ClientCommandCode["GET_MORE_ELEMENTS"] = 160] = "GET_MORE_ELEMENTS";
})(ClientCommandCode || (ClientCommandCode = {}));
class ClientCommand {
}
class YieldCommand extends ClientCommand {
    constructor(results, progressCallback) {
        super();
        this.progressCallback = progressCallback;
        this.code = ClientCommandCode.YIELD;
        this.results = results;
    }
    execute(request) {
        this.results.push(Buffer.from(request.subarray(1)));
        if (this.progressCallback) {
            this.progressCallback();
        }
        return Buffer.from('');
    }
}
exports.YieldCommand = YieldCommand;
class GetPreimageCommand extends ClientCommand {
    constructor(known_preimages, queue) {
        super();
        this.code = ClientCommandCode.GET_PREIMAGE;
        this.known_preimages = known_preimages;
        this.queue = queue;
    }
    execute(request) {
        const req = Buffer.from(request.subarray(1));
        // we expect no more data to read
        if (req.length != 1 + 32) {
            throw new Error('Invalid request, unexpected trailing data');
        }
        if (req[0] != 0) {
            throw new Error('Unsupported request, the first byte should be 0');
        }
        // read the hash
        const hash = Buffer.alloc(32);
        for (let i = 0; i < 32; i++) {
            hash[i] = req[1 + i];
        }
        const req_hash_hex = hash.toString('hex');
        const known_preimage = this.known_preimages.get(req_hash_hex);
        if (known_preimage != undefined) {
            const preimage_len_varint = (0, varint_1.createVarint)(known_preimage.length);
            // We can send at most 255 - len(preimage_len_out) - 1 bytes in a single message;
            // the rest will be stored in the queue for GET_MORE_ELEMENTS
            const max_payload_size = 255 - preimage_len_varint.length - 1;
            const payload_size = Math.min(max_payload_size, known_preimage.length);
            if (payload_size < known_preimage.length) {
                for (let i = payload_size; i < known_preimage.length; i++) {
                    this.queue.push(Buffer.from([known_preimage[i]]));
                }
            }
            return Buffer.concat([
                preimage_len_varint,
                Buffer.from([payload_size]),
                Buffer.from(known_preimage.subarray(0, payload_size)),
            ]);
        }
        throw Error(`Requested unknown preimage for: ${req_hash_hex}`);
    }
}
exports.GetPreimageCommand = GetPreimageCommand;
class GetMerkleLeafProofCommand extends ClientCommand {
    constructor(known_trees, queue) {
        super();
        this.code = ClientCommandCode.GET_MERKLE_LEAF_PROOF;
        this.known_trees = known_trees;
        this.queue = queue;
    }
    execute(request) {
        const req = Buffer.from(request.subarray(1));
        if (req.length < 32 + 1 + 1) {
            throw new Error('Invalid request, expected at least 34 bytes');
        }
        const reqBuf = new buffertools_1.BufferReader(req);
        const hash = reqBuf.readSlice(32);
        const hash_hex = hash.toString('hex');
        let tree_size;
        let leaf_index;
        try {
            tree_size = (0, varint_1.sanitizeBigintToNumber)(reqBuf.readVarInt());
            leaf_index = (0, varint_1.sanitizeBigintToNumber)(reqBuf.readVarInt());
        }
        catch (e) {
            throw new Error("Invalid request, couldn't parse tree_size or leaf_index");
        }
        const mt = this.known_trees.get(hash_hex);
        if (!mt) {
            throw Error(`Requested Merkle leaf proof for unknown tree: ${hash_hex}`);
        }
        if (leaf_index >= tree_size || mt.size() != tree_size) {
            throw Error('Invalid index or tree size.');
        }
        if (this.queue.length != 0) {
            throw Error('This command should not execute when the queue is not empty.');
        }
        const proof = mt.getProof(leaf_index);
        const n_response_elements = Math.min(Math.floor((255 - 32 - 1 - 1) / 32), proof.length);
        const n_leftover_elements = proof.length - n_response_elements;
        // Add to the queue any proof elements that do not fit the response
        if (n_leftover_elements > 0) {
            this.queue.push(...proof.slice(-n_leftover_elements));
        }
        return Buffer.concat([
            mt.getLeafHash(leaf_index),
            Buffer.from([proof.length]),
            Buffer.from([n_response_elements]),
            ...proof.slice(0, n_response_elements),
        ]);
    }
}
exports.GetMerkleLeafProofCommand = GetMerkleLeafProofCommand;
class GetMerkleLeafIndexCommand extends ClientCommand {
    constructor(known_trees) {
        super();
        this.code = ClientCommandCode.GET_MERKLE_LEAF_INDEX;
        this.known_trees = known_trees;
    }
    execute(request) {
        const req = Buffer.from(request.subarray(1));
        if (req.length != 32 + 32) {
            throw new Error('Invalid request, unexpected trailing data');
        }
        // read the root hash
        const root_hash = Buffer.alloc(32);
        for (let i = 0; i < 32; i++) {
            root_hash[i] = req.readUInt8(i);
        }
        const root_hash_hex = root_hash.toString('hex');
        // read the leaf hash
        const leef_hash = Buffer.alloc(32);
        for (let i = 0; i < 32; i++) {
            leef_hash[i] = req.readUInt8(32 + i);
        }
        const leef_hash_hex = leef_hash.toString('hex');
        const mt = this.known_trees.get(root_hash_hex);
        if (!mt) {
            throw Error(`Requested Merkle leaf index for unknown root: ${root_hash_hex}`);
        }
        let leaf_index = 0;
        let found = 0;
        for (let i = 0; i < mt.size(); i++) {
            if (mt.getLeafHash(i).toString('hex') == leef_hash_hex) {
                found = 1;
                leaf_index = i;
                break;
            }
        }
        return Buffer.concat([Buffer.from([found]), (0, varint_1.createVarint)(leaf_index)]);
    }
}
exports.GetMerkleLeafIndexCommand = GetMerkleLeafIndexCommand;
class GetMoreElementsCommand extends ClientCommand {
    constructor(queue) {
        super();
        this.code = ClientCommandCode.GET_MORE_ELEMENTS;
        this.queue = queue;
    }
    execute(request) {
        if (request.length != 1) {
            throw new Error('Invalid request, unexpected trailing data');
        }
        if (this.queue.length === 0) {
            throw new Error('No elements to get');
        }
        // all elements should have the same length
        const element_len = this.queue[0].length;
        if (this.queue.some((el) => el.length != element_len)) {
            throw new Error('The queue contains elements with different byte length, which is not expected');
        }
        const max_elements = Math.floor(253 / element_len);
        const n_returned_elements = Math.min(max_elements, this.queue.length);
        const returned_elements = this.queue.splice(0, n_returned_elements);
        return Buffer.concat([
            Buffer.from([n_returned_elements]),
            Buffer.from([element_len]),
            ...returned_elements,
        ]);
    }
}
exports.GetMoreElementsCommand = GetMoreElementsCommand;
/**
 * This class will dispatch a client command coming from the hardware device to
 * the appropriate client command implementation. Those client commands
 * typically requests data from a merkle tree or merkelized maps.
 *
 * A ClientCommandInterpreter is prepared by adding the merkle trees and
 * merkelized maps it should be able to serve to the hardware device. This class
 * doesn't know anything about the semantics of the data it holds, it just
 * serves merkle data. It doesn't even know in what context it is being
 * executed, ie SignPsbt, getWalletAddress, etc.
 *
 * If the command yelds results to the client, as signPsbt does, the yielded
 * data will be accessible after the command completed by calling getYielded(),
 * which will return the yields in the same order as they came in.
 */
class ClientCommandInterpreter {
    constructor(progressCallback) {
        this.roots = new Map();
        this.preimages = new Map();
        this.yielded = [];
        this.queue = [];
        this.commands = new Map();
        const commands = [
            new YieldCommand(this.yielded, progressCallback),
            new GetPreimageCommand(this.preimages, this.queue),
            new GetMerkleLeafIndexCommand(this.roots),
            new GetMerkleLeafProofCommand(this.roots, this.queue),
            new GetMoreElementsCommand(this.queue),
        ];
        for (const cmd of commands) {
            if (this.commands.has(cmd.code)) {
                throw new Error(`Multiple commands with code ${cmd.code}`);
            }
            this.commands.set(cmd.code, cmd);
        }
    }
    getYielded() {
        return this.yielded;
    }
    addKnownPreimage(preimage) {
        this.preimages.set(bitcoinjs_lib_1.crypto.sha256(preimage).toString('hex'), preimage);
    }
    addKnownList(elements) {
        for (const el of elements) {
            const preimage = Buffer.concat([Buffer.from([0]), el]);
            this.addKnownPreimage(preimage);
        }
        const mt = new merkle_1.Merkle(elements.map((el) => (0, merkle_1.hashLeaf)(el)));
        this.roots.set(mt.getRoot().toString('hex'), mt);
    }
    addKnownMapping(mm) {
        this.addKnownList(mm.keys);
        this.addKnownList(mm.values);
    }
    addKnownWalletPolicy(wp) {
        this.addKnownPreimage(wp.serialize());
        this.addKnownList(wp.keys.map((k) => Buffer.from(k, 'ascii')));
        this.addKnownPreimage(Buffer.from(wp.descriptorTemplate));
    }
    execute(request) {
        if (request.length == 0) {
            throw new Error('Unexpected empty command');
        }
        const cmdCode = request[0];
        const cmd = this.commands.get(cmdCode);
        if (!cmd) {
            throw new Error(`Unexpected command code ${cmdCode}`);
        }
        return cmd.execute(request);
    }
}
exports.ClientCommandInterpreter = ClientCommandInterpreter;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./buffertools":268,"./merkle":271,"./varint":275,"bitcoinjs-lib":109,"buffer":167}],270:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkelizedPsbt = void 0;
const merkleMap_1 = require("./merkleMap");
const psbtv2_1 = require("./psbtv2");
/**
 * This class merkelizes a PSBTv2, by merkelizing the different
 * maps of the psbt. This is used during the transaction signing process,
 * where the hardware app can request specific parts of the psbt from the
 * client code and be sure that the response data actually belong to the psbt.
 * The reason for this is the limited amount of memory available to the app,
 * so it can't always store the full psbt in memory.
 *
 * The signing process is documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#sign_psbt
 */
class MerkelizedPsbt extends psbtv2_1.PsbtV2 {
    constructor(psbt) {
        super();
        this.inputMerkleMaps = [];
        this.outputMerkleMaps = [];
        psbt.copy(this);
        this.globalMerkleMap = MerkelizedPsbt.createMerkleMap(this.globalMap);
        for (let i = 0; i < this.getGlobalInputCount(); i++) {
            this.inputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.inputMaps[i]));
        }
        this.inputMapCommitments = [...this.inputMerkleMaps.values()].map((v) => v.commitment());
        for (let i = 0; i < this.getGlobalOutputCount(); i++) {
            this.outputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.outputMaps[i]));
        }
        this.outputMapCommitments = [...this.outputMerkleMaps.values()].map((v) => v.commitment());
    }
    // These public functions are for MerkelizedPsbt.
    getGlobalSize() {
        return this.globalMap.size;
    }
    getGlobalKeysValuesRoot() {
        return this.globalMerkleMap.commitment();
    }
    static createMerkleMap(map) {
        const sortedKeysStrings = [...map.keys()].sort();
        const values = sortedKeysStrings.map((k) => {
            const v = map.get(k);
            if (!v) {
                throw new Error('No value for key ' + k);
            }
            return v;
        });
        const sortedKeys = sortedKeysStrings.map((k) => Buffer.from(k, 'hex'));
        return new merkleMap_1.MerkleMap(sortedKeys, values);
    }
}
exports.MerkelizedPsbt = MerkelizedPsbt;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./merkleMap":272,"./psbtv2":274,"buffer":167}],271:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashLeaf = exports.Merkle = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
/**
 * This class implements the merkle tree used by Ledger Bitcoin app v2+,
 * which is documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md
 */
class Merkle {
    constructor(leaves, hasher = bitcoinjs_lib_1.crypto.sha256) {
        this.leaves = leaves;
        this.h = hasher;
        const nodes = this.calculateRoot(leaves);
        this.rootNode = nodes.root;
        this.leafNodes = nodes.leaves;
    }
    getRoot() {
        return this.rootNode.hash;
    }
    size() {
        return this.leaves.length;
    }
    getLeaves() {
        return this.leaves;
    }
    getLeafHash(index) {
        return this.leafNodes[index].hash;
    }
    getProof(index) {
        if (index >= this.leaves.length)
            throw Error('Index out of bounds');
        return proveNode(this.leafNodes[index]);
    }
    calculateRoot(leaves) {
        const n = leaves.length;
        if (n == 0) {
            return {
                root: new Node(undefined, undefined, Buffer.alloc(32, 0)),
                leaves: [],
            };
        }
        if (n == 1) {
            const newNode = new Node(undefined, undefined, leaves[0]);
            return { root: newNode, leaves: [newNode] };
        }
        const leftCount = highestPowerOf2LessThan(n);
        const leftBranch = this.calculateRoot(leaves.slice(0, leftCount));
        const rightBranch = this.calculateRoot(leaves.slice(leftCount));
        const leftChild = leftBranch.root;
        const rightChild = rightBranch.root;
        const hash = this.hashNode(leftChild.hash, rightChild.hash);
        const node = new Node(leftChild, rightChild, hash);
        leftChild.parent = node;
        rightChild.parent = node;
        return { root: node, leaves: leftBranch.leaves.concat(rightBranch.leaves) };
    }
    hashNode(left, right) {
        return this.h(Buffer.concat([Buffer.from([1]), left, right]));
    }
}
exports.Merkle = Merkle;
function hashLeaf(buf, hashFunction = bitcoinjs_lib_1.crypto.sha256) {
    return hashConcat(Buffer.from([0]), buf, hashFunction);
}
exports.hashLeaf = hashLeaf;
function hashConcat(bufA, bufB, hashFunction) {
    return hashFunction(Buffer.concat([bufA, bufB]));
}
class Node {
    constructor(left, right, hash) {
        this.leftChild = left;
        this.rightChild = right;
        this.hash = hash;
    }
    isLeaf() {
        return this.leftChild == undefined;
    }
}
function proveNode(node) {
    if (!node.parent) {
        return [];
    }
    if (node.parent.leftChild == node) {
        if (!node.parent.rightChild) {
            throw new Error('Expected right child to exist');
        }
        return [node.parent.rightChild.hash, ...proveNode(node.parent)];
    }
    else {
        if (!node.parent.leftChild) {
            throw new Error('Expected left child to exist');
        }
        return [node.parent.leftChild.hash, ...proveNode(node.parent)];
    }
}
function highestPowerOf2LessThan(n) {
    if (n < 2) {
        throw Error('Expected n >= 2');
    }
    if (isPowerOf2(n)) {
        return n / 2;
    }
    return 1 << Math.floor(Math.log2(n));
}
function isPowerOf2(n) {
    return (n & (n - 1)) == 0;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bitcoinjs-lib":109,"buffer":167}],272:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkleMap = void 0;
const merkle_1 = require("./merkle");
const varint_1 = require("./varint");
/**
 * This implements "Merkelized Maps", documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md#merkleized-maps
 *
 * A merkelized map consist of two merkle trees, one for the keys of
 * a map and one for the values of the same map, thus the two merkle
 * trees have the same shape. The commitment is the number elements
 * in the map followed by the keys' merkle root followed by the
 * values' merkle root.
 */
class MerkleMap {
    /**
     * @param keys Sorted list of (unhashed) keys
     * @param values values, in corresponding order as the keys, and of equal length
     */
    constructor(keys, values) {
        if (keys.length != values.length) {
            throw new Error('keys and values should have the same length');
        }
        // Sanity check: verify that keys are actually sorted and with no duplicates
        for (let i = 0; i < keys.length - 1; i++) {
            if (keys[i].toString('hex') >= keys[i + 1].toString('hex')) {
                throw new Error('keys must be in strictly increasing order');
            }
        }
        this.keys = keys;
        this.keysTree = new merkle_1.Merkle(keys.map((k) => (0, merkle_1.hashLeaf)(k)));
        this.values = values;
        this.valuesTree = new merkle_1.Merkle(values.map((v) => (0, merkle_1.hashLeaf)(v)));
    }
    commitment() {
        // returns a buffer between 65 and 73 (included) bytes long
        return Buffer.concat([
            (0, varint_1.createVarint)(this.keys.length),
            this.keysTree.getRoot(),
            this.valuesTree.getRoot(),
        ]);
    }
}
exports.MerkleMap = MerkleMap;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./merkle":271,"./varint":275,"buffer":167}],273:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultWalletPolicy = exports.WalletPolicy = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const buffertools_1 = require("./buffertools");
const merkle_1 = require("./merkle");
const WALLET_POLICY_V2 = 2;
/**
 * The Bitcon hardware app uses a descriptors-like thing to describe
 * how to construct output scripts from keys. A "Wallet Policy" consists
 * of a "Descriptor Template" and a list of "keys". A key is basically
 * a serialized BIP32 extended public key with some added derivation path
 * information. This is documented at
 * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/wallet.md
 */
class WalletPolicy {
    /**
     * Creates and instance of a wallet policy.
     * @param name an ascii string, up to 16 bytes long; it must be an empty string for default wallet policies
     * @param descriptorTemplate the wallet policy template
     * @param keys and array of the keys, with the key derivation information
     */
    constructor(name, descriptorTemplate, keys) {
        this.name = name;
        this.descriptorTemplate = descriptorTemplate;
        this.keys = keys;
    }
    /**
     * Returns the unique 32-bytes id of this wallet policy.
     */
    getId() {
        return bitcoinjs_lib_1.crypto.sha256(this.serialize());
    }
    /**
     * Serializes the wallet policy for transmission via the hardware wallet protocol.
     * @returns the serialized wallet policy
     */
    serialize() {
        const keyBuffers = this.keys.map((k) => {
            return Buffer.from(k, 'ascii');
        });
        const m = new merkle_1.Merkle(keyBuffers.map((k) => (0, merkle_1.hashLeaf)(k)));
        const buf = new buffertools_1.BufferWriter();
        buf.writeUInt8(WALLET_POLICY_V2); // wallet version
        // length of wallet name, and wallet name
        buf.writeVarSlice(Buffer.from(this.name, 'ascii'));
        // length of descriptor template
        buf.writeVarInt(this.descriptorTemplate.length);
        // sha256 hash of descriptor template
        buf.writeSlice(bitcoinjs_lib_1.crypto.sha256(Buffer.from(this.descriptorTemplate)));
        // number of keys
        buf.writeVarInt(this.keys.length);
        // root of Merkle tree of keys
        buf.writeSlice(m.getRoot());
        return buf.buffer();
    }
}
exports.WalletPolicy = WalletPolicy;
/**
 * Simplified class to handle default wallet policies that can be used without policy registration.
 */
class DefaultWalletPolicy extends WalletPolicy {
    constructor(descriptorTemplate, key) {
        super('', descriptorTemplate, [key]);
    }
}
exports.DefaultWalletPolicy = DefaultWalletPolicy;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./buffertools":268,"./merkle":271,"bitcoinjs-lib":109,"buffer":167}],274:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
/* eslint-disable @typescript-eslint/no-non-null-assertion */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PsbtV2 = exports.NoSuchEntry = exports.psbtOut = exports.psbtIn = exports.psbtGlobal = void 0;
const bjs = __importStar(require("bitcoinjs-lib"));
const buffertools_1 = require("./buffertools");
const varint_1 = require("./varint");
var psbtGlobal;
(function (psbtGlobal) {
    psbtGlobal[psbtGlobal["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
    psbtGlobal[psbtGlobal["XPUB"] = 1] = "XPUB";
    psbtGlobal[psbtGlobal["TX_VERSION"] = 2] = "TX_VERSION";
    psbtGlobal[psbtGlobal["FALLBACK_LOCKTIME"] = 3] = "FALLBACK_LOCKTIME";
    psbtGlobal[psbtGlobal["INPUT_COUNT"] = 4] = "INPUT_COUNT";
    psbtGlobal[psbtGlobal["OUTPUT_COUNT"] = 5] = "OUTPUT_COUNT";
    psbtGlobal[psbtGlobal["TX_MODIFIABLE"] = 6] = "TX_MODIFIABLE";
    psbtGlobal[psbtGlobal["VERSION"] = 251] = "VERSION";
})(psbtGlobal = exports.psbtGlobal || (exports.psbtGlobal = {}));
var psbtIn;
(function (psbtIn) {
    psbtIn[psbtIn["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
    psbtIn[psbtIn["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
    psbtIn[psbtIn["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
    psbtIn[psbtIn["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
    psbtIn[psbtIn["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
    psbtIn[psbtIn["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
    psbtIn[psbtIn["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
    psbtIn[psbtIn["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
    psbtIn[psbtIn["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
    psbtIn[psbtIn["PREVIOUS_TXID"] = 14] = "PREVIOUS_TXID";
    psbtIn[psbtIn["OUTPUT_INDEX"] = 15] = "OUTPUT_INDEX";
    psbtIn[psbtIn["SEQUENCE"] = 16] = "SEQUENCE";
    psbtIn[psbtIn["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
    psbtIn[psbtIn["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
})(psbtIn = exports.psbtIn || (exports.psbtIn = {}));
var psbtOut;
(function (psbtOut) {
    psbtOut[psbtOut["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
    psbtOut[psbtOut["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
    psbtOut[psbtOut["BIP_32_DERIVATION"] = 2] = "BIP_32_DERIVATION";
    psbtOut[psbtOut["AMOUNT"] = 3] = "AMOUNT";
    psbtOut[psbtOut["SCRIPT"] = 4] = "SCRIPT";
    psbtOut[psbtOut["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
})(psbtOut = exports.psbtOut || (exports.psbtOut = {}));
const PSBT_MAGIC_BYTES = Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]);
class NoSuchEntry extends Error {
}
exports.NoSuchEntry = NoSuchEntry;
/**
 * Implements Partially Signed Bitcoin Transaction version 2, BIP370, as
 * documented at https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki
 * and https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki
 *
 * A psbt is a data structure that can carry all relevant information about a
 * transaction through all stages of the signing process. From constructing an
 * unsigned transaction to extracting the final serialized transaction ready for
 * broadcast.
 *
 * This implementation is limited to what's needed in ledgerjs to carry out its
 * duties, which means that support for features like multisig or taproot script
 * path spending are not implemented. Specifically, it supports p2pkh,
 * p2wpkhWrappedInP2sh, p2wpkh and p2tr key path spending.
 *
 * This class is made purposefully dumb, so it's easy to add support for
 * complemantary fields as needed in the future.
 */
class PsbtV2 {
    constructor() {
        this.globalMap = new Map();
        this.inputMaps = [];
        this.outputMaps = [];
    }
    setGlobalTxVersion(version) {
        this.setGlobal(psbtGlobal.TX_VERSION, uint32LE(version));
    }
    getGlobalTxVersion() {
        return this.getGlobal(psbtGlobal.TX_VERSION).readUInt32LE(0);
    }
    setGlobalFallbackLocktime(locktime) {
        this.setGlobal(psbtGlobal.FALLBACK_LOCKTIME, uint32LE(locktime));
    }
    getGlobalFallbackLocktime() {
        var _a;
        return (_a = this.getGlobalOptional(psbtGlobal.FALLBACK_LOCKTIME)) === null || _a === void 0 ? void 0 : _a.readUInt32LE(0);
    }
    setGlobalInputCount(inputCount) {
        this.setGlobal(psbtGlobal.INPUT_COUNT, varint(inputCount));
    }
    getGlobalInputCount() {
        return fromVarint(this.getGlobal(psbtGlobal.INPUT_COUNT));
    }
    setGlobalOutputCount(outputCount) {
        this.setGlobal(psbtGlobal.OUTPUT_COUNT, varint(outputCount));
    }
    getGlobalOutputCount() {
        return fromVarint(this.getGlobal(psbtGlobal.OUTPUT_COUNT));
    }
    setGlobalTxModifiable(byte) {
        this.setGlobal(psbtGlobal.TX_MODIFIABLE, byte);
    }
    getGlobalTxModifiable() {
        return this.getGlobalOptional(psbtGlobal.TX_MODIFIABLE);
    }
    setGlobalPsbtVersion(psbtVersion) {
        this.setGlobal(psbtGlobal.VERSION, uint32LE(psbtVersion));
    }
    getGlobalPsbtVersion() {
        return this.getGlobal(psbtGlobal.VERSION).readUInt32LE(0);
    }
    setInputNonWitnessUtxo(inputIndex, transaction) {
        this.setInput(inputIndex, psbtIn.NON_WITNESS_UTXO, b(), transaction);
    }
    getInputNonWitnessUtxo(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.NON_WITNESS_UTXO, b());
    }
    setInputWitnessUtxo(inputIndex, amount, scriptPubKey) {
        const buf = new buffertools_1.BufferWriter();
        buf.writeSlice(uint64LE(amount));
        buf.writeVarSlice(scriptPubKey);
        this.setInput(inputIndex, psbtIn.WITNESS_UTXO, b(), buf.buffer());
    }
    getInputWitnessUtxo(inputIndex) {
        const utxo = this.getInputOptional(inputIndex, psbtIn.WITNESS_UTXO, b());
        if (!utxo)
            return undefined;
        const buf = new buffertools_1.BufferReader(utxo);
        return {
            amount: (0, buffertools_1.unsafeFrom64bitLE)(buf.readSlice(8)),
            scriptPubKey: buf.readVarSlice()
        };
    }
    setInputPartialSig(inputIndex, pubkey, signature) {
        this.setInput(inputIndex, psbtIn.PARTIAL_SIG, pubkey, signature);
    }
    getInputPartialSig(inputIndex, pubkey) {
        return this.getInputOptional(inputIndex, psbtIn.PARTIAL_SIG, pubkey);
    }
    setInputSighashType(inputIndex, sigHashtype) {
        this.setInput(inputIndex, psbtIn.SIGHASH_TYPE, b(), uint32LE(sigHashtype));
    }
    getInputSighashType(inputIndex) {
        const result = this.getInputOptional(inputIndex, psbtIn.SIGHASH_TYPE, b());
        if (!result)
            return undefined;
        return result.readUInt32LE(0);
    }
    setInputRedeemScript(inputIndex, redeemScript) {
        this.setInput(inputIndex, psbtIn.REDEEM_SCRIPT, b(), redeemScript);
    }
    getInputRedeemScript(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.REDEEM_SCRIPT, b());
    }
    setInputWitnessScript(inputIndex, witnessScript) {
        this.setInput(inputIndex, psbtIn.WITNESS_SCRIPT, b(), witnessScript);
    }
    getInputWitnessScript(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.WITNESS_SCRIPT, b());
    }
    setInputBip32Derivation(inputIndex, pubkey, masterFingerprint, path) {
        if (pubkey.length != 33)
            throw new Error('Invalid pubkey length: ' + pubkey.length);
        this.setInput(inputIndex, psbtIn.BIP32_DERIVATION, pubkey, this.encodeBip32Derivation(masterFingerprint, path));
    }
    getInputBip32Derivation(inputIndex, pubkey) {
        const buf = this.getInputOptional(inputIndex, psbtIn.BIP32_DERIVATION, pubkey);
        if (!buf)
            return undefined;
        return this.decodeBip32Derivation(buf);
    }
    setInputFinalScriptsig(inputIndex, scriptSig) {
        this.setInput(inputIndex, psbtIn.FINAL_SCRIPTSIG, b(), scriptSig);
    }
    getInputFinalScriptsig(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.FINAL_SCRIPTSIG, b());
    }
    setInputFinalScriptwitness(inputIndex, scriptWitness) {
        this.setInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b(), scriptWitness);
    }
    getInputFinalScriptwitness(inputIndex) {
        return this.getInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b());
    }
    setInputPreviousTxId(inputIndex, txid) {
        this.setInput(inputIndex, psbtIn.PREVIOUS_TXID, b(), txid);
    }
    getInputPreviousTxid(inputIndex) {
        return this.getInput(inputIndex, psbtIn.PREVIOUS_TXID, b());
    }
    setInputOutputIndex(inputIndex, outputIndex) {
        this.setInput(inputIndex, psbtIn.OUTPUT_INDEX, b(), uint32LE(outputIndex));
    }
    getInputOutputIndex(inputIndex) {
        return this.getInput(inputIndex, psbtIn.OUTPUT_INDEX, b()).readUInt32LE(0);
    }
    setInputSequence(inputIndex, sequence) {
        this.setInput(inputIndex, psbtIn.SEQUENCE, b(), uint32LE(sequence));
    }
    getInputSequence(inputIndex) {
        var _a, _b;
        return ((_b = (_a = this.getInputOptional(inputIndex, psbtIn.SEQUENCE, b())) === null || _a === void 0 ? void 0 : _a.readUInt32LE(0)) !== null && _b !== void 0 ? _b : 0xffffffff);
    }
    setInputTapKeySig(inputIndex, sig) {
        this.setInput(inputIndex, psbtIn.TAP_KEY_SIG, b(), sig);
    }
    getInputTapKeySig(inputIndex) {
        return this.getInputOptional(inputIndex, psbtIn.TAP_KEY_SIG, b());
    }
    setInputTapBip32Derivation(inputIndex, pubkey, hashes, masterFingerprint, path) {
        if (pubkey.length != 32)
            throw new Error('Invalid pubkey length: ' + pubkey.length);
        const buf = this.encodeTapBip32Derivation(hashes, masterFingerprint, path);
        this.setInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey, buf);
    }
    getInputTapBip32Derivation(inputIndex, pubkey) {
        const buf = this.getInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey);
        return this.decodeTapBip32Derivation(buf);
    }
    getInputKeyDatas(inputIndex, keyType) {
        return this.getKeyDatas(this.inputMaps[inputIndex], keyType);
    }
    setOutputRedeemScript(outputIndex, redeemScript) {
        this.setOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b(), redeemScript);
    }
    getOutputRedeemScript(outputIndex) {
        return this.getOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b());
    }
    setOutputBip32Derivation(outputIndex, pubkey, masterFingerprint, path) {
        this.setOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey, this.encodeBip32Derivation(masterFingerprint, path));
    }
    getOutputBip32Derivation(outputIndex, pubkey) {
        const buf = this.getOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey);
        return this.decodeBip32Derivation(buf);
    }
    setOutputAmount(outputIndex, amount) {
        this.setOutput(outputIndex, psbtOut.AMOUNT, b(), uint64LE(amount));
    }
    getOutputAmount(outputIndex) {
        const buf = this.getOutput(outputIndex, psbtOut.AMOUNT, b());
        return (0, buffertools_1.unsafeFrom64bitLE)(buf);
    }
    setOutputScript(outputIndex, scriptPubKey) {
        this.setOutput(outputIndex, psbtOut.SCRIPT, b(), scriptPubKey);
    }
    getOutputScript(outputIndex) {
        return this.getOutput(outputIndex, psbtOut.SCRIPT, b());
    }
    setOutputTapBip32Derivation(outputIndex, pubkey, hashes, fingerprint, path) {
        const buf = this.encodeTapBip32Derivation(hashes, fingerprint, path);
        this.setOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey, buf);
    }
    getOutputTapBip32Derivation(outputIndex, pubkey) {
        const buf = this.getOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey);
        return this.decodeTapBip32Derivation(buf);
    }
    deleteInputEntries(inputIndex, keyTypes) {
        const map = this.inputMaps[inputIndex];
        map.forEach((_v, k, m) => {
            if (this.isKeyType(k, keyTypes)) {
                m.delete(k);
            }
        });
    }
    copy(to) {
        this.copyMap(this.globalMap, to.globalMap);
        this.copyMaps(this.inputMaps, to.inputMaps);
        this.copyMaps(this.outputMaps, to.outputMaps);
    }
    copyMaps(from, to) {
        from.forEach((m, index) => {
            const to_index = new Map();
            this.copyMap(m, to_index);
            to[index] = to_index;
        });
    }
    copyMap(from, to) {
        from.forEach((v, k) => to.set(k, Buffer.from(v)));
    }
    serialize() {
        const buf = new buffertools_1.BufferWriter();
        buf.writeSlice(Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]));
        serializeMap(buf, this.globalMap);
        this.inputMaps.forEach((map) => {
            serializeMap(buf, map);
        });
        this.outputMaps.forEach((map) => {
            serializeMap(buf, map);
        });
        return buf.buffer();
    }
    deserialize(psbt) {
        const buf = new buffertools_1.BufferReader(psbt);
        if (!buf.readSlice(5).equals(PSBT_MAGIC_BYTES)) {
            throw new Error('Invalid magic bytes');
        }
        while (this.readKeyPair(this.globalMap, buf))
            ;
        let psbtVersion;
        try {
            psbtVersion = this.getGlobalPsbtVersion();
        }
        catch (_a) {
            psbtVersion = 0;
        }
        if (psbtVersion !== 0 && psbtVersion !== 2)
            throw new Error("Only PSBTs of version 0 or 2 are supported");
        let nInputs;
        let nOutputs;
        if (psbtVersion == 0) {
            // if PSBTv0, we parse the PSBT_GLOBAL_UNSIGNED_TX field
            const txRaw = this.getGlobal(psbtGlobal.UNSIGNED_TX);
            const tx = bjs.Transaction.fromBuffer(txRaw);
            nInputs = tx.ins.length;
            nOutputs = tx.outs.length;
        }
        else {
            // if PSBTv2, we already have the counts
            nInputs = this.getGlobalInputCount();
            nOutputs = this.getGlobalOutputCount();
        }
        for (let i = 0; i < nInputs; i++) {
            this.inputMaps[i] = new Map();
            while (this.readKeyPair(this.inputMaps[i], buf))
                ;
        }
        for (let i = 0; i < nOutputs; i++) {
            this.outputMaps[i] = new Map();
            while (this.readKeyPair(this.outputMaps[i], buf))
                ;
        }
        this.normalizeToV2();
    }
    normalizeToV2() {
        var _a;
        // if the psbt is a PsbtV0, convert it to PsbtV2 instead.
        // throw an error for any version other than 0 or 2,
        const psbtVersion = (_a = this.getGlobalOptional(psbtGlobal.VERSION)) === null || _a === void 0 ? void 0 : _a.readInt32LE(0);
        if (psbtVersion === 2)
            return;
        else if (psbtVersion !== undefined) {
            throw new Error('Invalid or unsupported value for PSBT_GLOBAL_VERSION');
        }
        // Convert PsbtV0 to PsbtV2 by parsing the PSBT_GLOBAL_UNSIGNED_TX field
        // and filling in the corresponding fields.
        const txRaw = this.getGlobal(psbtGlobal.UNSIGNED_TX);
        const tx = bjs.Transaction.fromBuffer(txRaw);
        this.setGlobalPsbtVersion(2);
        this.setGlobalTxVersion(tx.version);
        this.setGlobalFallbackLocktime(tx.locktime);
        this.setGlobalInputCount(tx.ins.length);
        this.setGlobalOutputCount(tx.outs.length);
        for (let i = 0; i < tx.ins.length; i++) {
            this.setInputPreviousTxId(i, tx.ins[i].hash);
            this.setInputOutputIndex(i, tx.ins[i].index);
            this.setInputSequence(i, tx.ins[i].sequence);
        }
        for (let i = 0; i < tx.outs.length; i++) {
            this.setOutputAmount(i, tx.outs[i].value);
            this.setOutputScript(i, tx.outs[i].script);
        }
        // PSBT_GLOBAL_UNSIGNED_TX must be removed in a valid PSBTv2
        this.globalMap.delete(psbtGlobal.UNSIGNED_TX.toString(16).padStart(2, '0'));
    }
    /**
     * Imports a BitcoinJS (bitcoinjs-lib) Psbt object.
     * https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/psbt.ts
     *
     * Prepares the fields required for signing a Psbt on a Ledger
     * device. It should be used exclusively before calling
     * `appClient.signPsbt()` and not as a general Psbt conversion method.
     *
     * Note: This method supports all the policies that the Ledger is able to
     * sign, with the exception of taproot: tr(@0).
     */
    fromBitcoinJS(psbtBJS) {
        function isTaprootInput(input) {
            let isP2TR;
            try {
                bjs.payments.p2tr({ output: input.witnessUtxo.script });
                isP2TR = true;
            }
            catch (err) {
                isP2TR = false;
            }
            return (input &&
                !!(input.tapInternalKey ||
                    input.tapMerkleRoot ||
                    (input.tapLeafScript && input.tapLeafScript.length) ||
                    (input.tapBip32Derivation && input.tapBip32Derivation.length) ||
                    isP2TR));
        }
        this.setGlobalPsbtVersion(2);
        this.setGlobalTxVersion(psbtBJS.version);
        this.setGlobalInputCount(psbtBJS.data.inputs.length);
        this.setGlobalOutputCount(psbtBJS.txOutputs.length);
        if (psbtBJS.locktime !== undefined)
            this.setGlobalFallbackLocktime(psbtBJS.locktime);
        psbtBJS.data.inputs.forEach((input, index) => {
            if (isTaprootInput(input))
                throw new Error(`Taproot inputs not supported`);
            this.setInputPreviousTxId(index, psbtBJS.txInputs[index].hash);
            if (psbtBJS.txInputs[index].sequence !== undefined)
                this.setInputSequence(index, psbtBJS.txInputs[index].sequence);
            this.setInputOutputIndex(index, psbtBJS.txInputs[index].index);
            if (input.sighashType !== undefined)
                this.setInputSighashType(index, input.sighashType);
            if (input.nonWitnessUtxo)
                this.setInputNonWitnessUtxo(index, input.nonWitnessUtxo);
            if (input.witnessUtxo) {
                this.setInputWitnessUtxo(index, input.witnessUtxo.value, input.witnessUtxo.script);
            }
            if (input.witnessScript)
                this.setInputWitnessScript(index, input.witnessScript);
            if (input.redeemScript)
                this.setInputRedeemScript(index, input.redeemScript);
            psbtBJS.data.inputs[index].bip32Derivation.forEach(derivation => {
                if (!/^m\//i.test(derivation.path))
                    throw new Error(`Invalid input bip32 derivation`);
                const pathArray = derivation.path
                    .replace(/m\//i, '')
                    .split('/')
                    .map(level => level.match(/['h]/i) ? parseInt(level) + 0x80000000 : Number(level));
                this.setInputBip32Derivation(index, derivation.pubkey, derivation.masterFingerprint, pathArray);
            });
        });
        psbtBJS.txOutputs.forEach((output, index) => {
            this.setOutputAmount(index, output.value);
            this.setOutputScript(index, output.script);
        });
        return this;
    }
    readKeyPair(map, buf) {
        const keyLen = (0, varint_1.sanitizeBigintToNumber)(buf.readVarInt());
        if (keyLen == 0) {
            return false;
        }
        const keyType = buf.readUInt8();
        const keyData = buf.readSlice(keyLen - 1);
        const value = buf.readVarSlice();
        set(map, keyType, keyData, value);
        return true;
    }
    getKeyDatas(map, keyType) {
        const result = [];
        map.forEach((_v, k) => {
            if (this.isKeyType(k, [keyType])) {
                result.push(Buffer.from(k.substring(2), 'hex'));
            }
        });
        return result;
    }
    isKeyType(hexKey, keyTypes) {
        const keyType = Buffer.from(hexKey.substring(0, 2), 'hex').readUInt8(0);
        return keyTypes.some((k) => k == keyType);
    }
    setGlobal(keyType, value) {
        const key = new Key(keyType, Buffer.from([]));
        this.globalMap.set(key.toString(), value);
    }
    getGlobal(keyType) {
        return get(this.globalMap, keyType, b(), false);
    }
    getGlobalOptional(keyType) {
        return get(this.globalMap, keyType, b(), true);
    }
    setInput(index, keyType, keyData, value) {
        set(this.getMap(index, this.inputMaps), keyType, keyData, value);
    }
    getInput(index, keyType, keyData) {
        return get(this.inputMaps[index], keyType, keyData, false);
    }
    getInputOptional(index, keyType, keyData) {
        return get(this.inputMaps[index], keyType, keyData, true);
    }
    setOutput(index, keyType, keyData, value) {
        set(this.getMap(index, this.outputMaps), keyType, keyData, value);
    }
    getOutput(index, keyType, keyData) {
        return get(this.outputMaps[index], keyType, keyData, false);
    }
    getMap(index, maps) {
        if (maps[index]) {
            return maps[index];
        }
        return (maps[index] = new Map());
    }
    encodeBip32Derivation(masterFingerprint, path) {
        const buf = new buffertools_1.BufferWriter();
        this.writeBip32Derivation(buf, masterFingerprint, path);
        return buf.buffer();
    }
    decodeBip32Derivation(buffer) {
        const buf = new buffertools_1.BufferReader(buffer);
        return this.readBip32Derivation(buf);
    }
    writeBip32Derivation(buf, masterFingerprint, path) {
        buf.writeSlice(masterFingerprint);
        path.forEach((element) => {
            buf.writeUInt32(element);
        });
    }
    readBip32Derivation(buf) {
        const masterFingerprint = buf.readSlice(4);
        const path = [];
        while (buf.offset < buf.buffer.length) {
            path.push(buf.readUInt32());
        }
        return { masterFingerprint, path };
    }
    encodeTapBip32Derivation(hashes, masterFingerprint, path) {
        const buf = new buffertools_1.BufferWriter();
        buf.writeVarInt(hashes.length);
        hashes.forEach((h) => {
            buf.writeSlice(h);
        });
        this.writeBip32Derivation(buf, masterFingerprint, path);
        return buf.buffer();
    }
    decodeTapBip32Derivation(buffer) {
        const buf = new buffertools_1.BufferReader(buffer);
        const hashCount = (0, varint_1.sanitizeBigintToNumber)(buf.readVarInt());
        const hashes = [];
        for (let i = 0; i < hashCount; i++) {
            hashes.push(buf.readSlice(32));
        }
        const deriv = this.readBip32Derivation(buf);
        return Object.assign({ hashes }, deriv);
    }
}
exports.PsbtV2 = PsbtV2;
function get(map, keyType, keyData, acceptUndefined) {
    if (!map)
        throw Error('No such map');
    const key = new Key(keyType, keyData);
    const value = map.get(key.toString());
    if (!value) {
        if (acceptUndefined) {
            return undefined;
        }
        throw new NoSuchEntry(key.toString());
    }
    // Make sure to return a copy, to protect the underlying data.
    return Buffer.from(value);
}
class Key {
    constructor(keyType, keyData) {
        this.keyType = keyType;
        this.keyData = keyData;
    }
    toString() {
        const buf = new buffertools_1.BufferWriter();
        this.toBuffer(buf);
        return buf.buffer().toString('hex');
    }
    serialize(buf) {
        buf.writeVarInt(1 + this.keyData.length);
        this.toBuffer(buf);
    }
    toBuffer(buf) {
        buf.writeUInt8(this.keyType);
        buf.writeSlice(this.keyData);
    }
}
class KeyPair {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
    serialize(buf) {
        this.key.serialize(buf);
        buf.writeVarSlice(this.value);
    }
}
function createKey(buf) {
    return new Key(buf.readUInt8(0), buf.slice(1));
}
function serializeMap(buf, map) {
    // serialize in lexicographical order of keys
    for (let [key, value] of [...map].sort(([k1], [k2]) => k1.localeCompare(k2))) {
        const keyPair = new KeyPair(createKey(Buffer.from(key, 'hex')), value);
        keyPair.serialize(buf);
    }
    buf.writeUInt8(0);
}
function b() {
    return Buffer.from([]);
}
function set(map, keyType, keyData, value) {
    const key = new Key(keyType, keyData);
    map.set(key.toString(), value);
}
function uint32LE(n) {
    const buf = Buffer.alloc(4);
    buf.writeUInt32LE(n, 0);
    return buf;
}
function uint64LE(n) {
    return (0, buffertools_1.unsafeTo64bitLE)(n);
}
function varint(n) {
    const buf = new buffertools_1.BufferWriter();
    buf.writeVarInt(n);
    return buf.buffer();
}
function fromVarint(buf) {
    return (0, varint_1.sanitizeBigintToNumber)(new buffertools_1.BufferReader(buf).readVarInt());
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./buffertools":268,"./varint":275,"bitcoinjs-lib":109,"buffer":167}],275:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVarint = exports.parseVarint = exports.sanitizeBigintToNumber = void 0;
function bigintToSmallEndian(value, length, buffer, offset) {
    for (let i = 0; i < length; i++) {
        if (buffer[i + offset] == undefined) {
            throw Error('Buffer too small');
        }
        buffer[i + offset] = Number(value % BigInt(256));
        value = value >> BigInt(8);
    }
}
function smallEndianToBigint(buffer, offset, length) {
    let result = BigInt(0);
    for (let i = 0; i < length; i++) {
        if (buffer[i + offset] == undefined) {
            throw Error('Buffer too small');
        }
        result += BigInt(buffer[i + offset]) << BigInt(i * 8);
    }
    return result;
}
/**
 * Converts a `bigint` to a `number` if it non-negative and at most MAX_SAFE_INTEGER; throws `RangeError` otherwise.
 * Used when converting a Bitcoin-style varint to a `number`, since varints could be larger than what the `Number`
 * class can represent without loss of precision.
 *
 * @param n the number to convert
 * @returns `n` as a `number`
 */
function sanitizeBigintToNumber(n) {
    if (n < 0)
        throw RangeError('Negative bigint is not a valid varint');
    if (n > Number.MAX_SAFE_INTEGER)
        throw RangeError('Too large for a Number');
    return Number(n);
}
exports.sanitizeBigintToNumber = sanitizeBigintToNumber;
function getVarintSize(value) {
    if (typeof value == 'number') {
        value = sanitizeBigintToNumber(value);
    }
    if (value < BigInt(0)) {
        throw new RangeError('Negative numbers are not supported');
    }
    if (value >= BigInt(1) << BigInt(64)) {
        throw new RangeError('Too large for a Bitcoin-style varint');
    }
    if (value < BigInt(0xfd))
        return 1;
    else if (value <= BigInt(0xffff))
        return 3;
    else if (value <= BigInt(0xffffffff))
        return 5;
    else
        return 9;
}
/**
 * Parses a Bitcoin-style variable length integer from a buffer, starting at the given `offset`. Returns a pair
 * containing the parsed `BigInt`, and its length in bytes from the buffer.
 *
 * @param data the `Buffer` from which the variable-length integer is read
 * @param offset a non-negative offset to read from
 * @returns a pair where the first element is the parsed BigInt, and the second element is the length in bytes parsed
 * from the buffer.
 *
 * @throws `RangeError` if offset is negative.
 * @throws `Error` if the buffer's end is reached withut parsing being completed.
 */
function parseVarint(data, offset) {
    if (offset < 0) {
        throw RangeError("Negative offset is invalid");
    }
    if (data[offset] == undefined) {
        throw Error('Buffer too small');
    }
    if (data[offset] < 0xfd) {
        return [BigInt(data[offset]), 1];
    }
    else {
        let size;
        if (data[offset] === 0xfd)
            size = 2;
        else if (data[offset] === 0xfe)
            size = 4;
        else
            size = 8;
        return [smallEndianToBigint(data, offset + 1, size), size + 1];
    }
}
exports.parseVarint = parseVarint;
function createVarint(value) {
    if (typeof value == 'number') {
        value = sanitizeBigintToNumber(value);
    }
    const size = getVarintSize(value);
    value = BigInt(value);
    const buffer = Buffer.alloc(size);
    if (size == 1) {
        buffer[0] = Number(value);
    }
    else {
        if (size == 3)
            buffer[0] = 0xfd;
        else if (size === 5)
            buffer[0] = 0xfe;
        else
            buffer[0] = 0xff;
        bigintToSmallEndian(value, size - 1, buffer, 1);
    }
    return buffer;
}
exports.createVarint = createVarint;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":167}],276:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],277:[function(require,module,exports){
'use strict';

/** @type {import('./abs')} */
module.exports = Math.abs;

},{}],278:[function(require,module,exports){
'use strict';

/** @type {import('./floor')} */
module.exports = Math.floor;

},{}],279:[function(require,module,exports){
'use strict';

/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};

},{}],280:[function(require,module,exports){
'use strict';

/** @type {import('./max')} */
module.exports = Math.max;

},{}],281:[function(require,module,exports){
'use strict';

/** @type {import('./min')} */
module.exports = Math.min;

},{}],282:[function(require,module,exports){
'use strict';

/** @type {import('./pow')} */
module.exports = Math.pow;

},{}],283:[function(require,module,exports){
'use strict';

/** @type {import('./round')} */
module.exports = Math.round;

},{}],284:[function(require,module,exports){
'use strict';

var $isNaN = require('./isNaN');

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};

},{"./isNaN":279}],285:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":244,"inherits":260,"safe-buffer":327}],286:[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":287,"brorand":134}],287:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"buffer":135,"dup":49}],288:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],289:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],290:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],291:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.

'use strict';

var asn1 = require('asn1.js');

exports.certificate = require('./certificate');

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('modulus')['int'](),
		this.key('publicExponent')['int'](),
		this.key('privateExponent')['int'](),
		this.key('prime1')['int'](),
		this.key('prime2')['int'](),
		this.key('exponent1')['int'](),
		this.key('exponent2')['int'](),
		this.key('coefficient')['int']()
	);
});
exports.RSAPrivateKey = RSAPrivateKey;

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
	this.seq().obj(
		this.key('modulus')['int'](),
		this.key('publicExponent')['int']()
	);
});
exports.RSAPublicKey = RSAPublicKey;

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
	this.seq().obj(
		this.key('algorithm').objid(),
		this.key('none').null_().optional(),
		this.key('curve').objid().optional(),
		this.key('params').seq().obj(
			this.key('p')['int'](),
			this.key('q')['int'](),
			this.key('g')['int']()
		).optional()
	);
});

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
	this.seq().obj(
		this.key('algorithm').use(AlgorithmIdentifier),
		this.key('subjectPublicKey').bitstr()
	);
});
exports.PublicKey = PublicKey;

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('algorithm').use(AlgorithmIdentifier),
		this.key('subjectPrivateKey').octstr()
	);
});
exports.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
	this.seq().obj(
		this.key('algorithm').seq().obj(
			this.key('id').objid(),
			this.key('decrypt').seq().obj(
				this.key('kde').seq().obj(
					this.key('id').objid(),
					this.key('kdeparams').seq().obj(
						this.key('salt').octstr(),
						this.key('iters')['int']()
					)
				),
				this.key('cipher').seq().obj(
					this.key('algo').objid(),
					this.key('iv').octstr()
				)
			)
		),
		this.key('subjectPrivateKey').octstr()
	);
});

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('p')['int'](),
		this.key('q')['int'](),
		this.key('g')['int'](),
		this.key('pub_key')['int'](),
		this.key('priv_key')['int']()
	);
});
exports.DSAPrivateKey = DSAPrivateKey;

exports.DSAparam = asn1.define('DSAparam', function () {
	this['int']();
});

var ECParameters = asn1.define('ECParameters', function () {
	this.choice({
		namedCurve: this.objid()
	});
});

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('privateKey').octstr(),
		this.key('parameters').optional().explicit(0).use(ECParameters),
		this.key('publicKey').optional().explicit(1).bitstr()
	);
});
exports.ECPrivateKey = ECPrivateKey;

exports.signature = asn1.define('signature', function () {
	this.seq().obj(
		this.key('r')['int'](),
		this.key('s')['int']()
	);
});

},{"./certificate":292,"asn1.js":35}],292:[function(require,module,exports){
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

'use strict';

var asn = require('asn1.js');

var Time = asn.define('Time', function () {
	this.choice({
		utcTime: this.utctime(),
		generalTime: this.gentime()
	});
});

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
	this.seq().obj(
		this.key('type').objid(),
		this.key('value').any()
	);
});

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
	this.seq().obj(
		this.key('algorithm').objid(),
		this.key('parameters').optional(),
		this.key('curve').objid().optional()
	);
});

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
	this.seq().obj(
		this.key('algorithm').use(AlgorithmIdentifier),
		this.key('subjectPublicKey').bitstr()
	);
});

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
	this.setof(AttributeTypeValue);
});

var RDNSequence = asn.define('RDNSequence', function () {
	this.seqof(RelativeDistinguishedName);
});

var Name = asn.define('Name', function () {
	this.choice({
		rdnSequence: this.use(RDNSequence)
	});
});

var Validity = asn.define('Validity', function () {
	this.seq().obj(
		this.key('notBefore').use(Time),
		this.key('notAfter').use(Time)
	);
});

var Extension = asn.define('Extension', function () {
	this.seq().obj(
		this.key('extnID').objid(),
		this.key('critical').bool().def(false),
		this.key('extnValue').octstr()
	);
});

var TBSCertificate = asn.define('TBSCertificate', function () {
	this.seq().obj(
		this.key('version').explicit(0)['int']().optional(),
		this.key('serialNumber')['int'](),
		this.key('signature').use(AlgorithmIdentifier),
		this.key('issuer').use(Name),
		this.key('validity').use(Validity),
		this.key('subject').use(Name),
		this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
		this.key('issuerUniqueID').implicit(1).bitstr().optional(),
		this.key('subjectUniqueID').implicit(2).bitstr().optional(),
		this.key('extensions').explicit(3).seqof(Extension).optional()
	);
});

var X509Certificate = asn.define('X509Certificate', function () {
	this.seq().obj(
		this.key('tbsCertificate').use(TBSCertificate),
		this.key('signatureAlgorithm').use(AlgorithmIdentifier),
		this.key('signatureValue').bitstr()
	);
});

module.exports = X509Certificate;

},{"asn1.js":35}],293:[function(require,module,exports){
'use strict';

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
var evp = require('evp_bytestokey');
var ciphers = require('browserify-aes');
var Buffer = require('safe-buffer').Buffer;
module.exports = function (okey, password) {
	var key = okey.toString();
	var match = key.match(findProc);
	var decrypted;
	if (!match) {
		var match2 = key.match(fullRegex);
		decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64');
	} else {
		var suite = 'aes' + match[1];
		var iv = Buffer.from(match[2], 'hex');
		var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64');
		var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
		var out = [];
		var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
		out.push(cipher.update(cipherText));
		out.push(cipher['final']());
		decrypted = Buffer.concat(out);
	}
	var tag = key.match(startRegex)[1];
	return {
		tag: tag,
		data: decrypted
	};
};

},{"browserify-aes":138,"evp_bytestokey":230,"safe-buffer":327}],294:[function(require,module,exports){
'use strict';

var asn1 = require('./asn1');
var aesid = require('./aesid.json');
var fixProc = require('./fixProc');
var ciphers = require('browserify-aes');
var pbkdf2Sync = require('pbkdf2').pbkdf2Sync;
var Buffer = require('safe-buffer').Buffer;

function decrypt(data, password) {
	var salt = data.algorithm.decrypt.kde.kdeparams.salt;
	var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
	var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
	var iv = data.algorithm.decrypt.cipher.iv;
	var cipherText = data.subjectPrivateKey;
	var keylen = parseInt(algo.split('-')[1], 10) / 8;
	var key = pbkdf2Sync(password, salt, iters, keylen, 'sha1');
	var cipher = ciphers.createDecipheriv(algo, key, iv);
	var out = [];
	out.push(cipher.update(cipherText));
	out.push(cipher['final']());
	return Buffer.concat(out);
}

function parseKeys(buffer) {
	var password;
	if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
		password = buffer.passphrase;
		buffer = buffer.key;
	}
	if (typeof buffer === 'string') {
		buffer = Buffer.from(buffer);
	}

	var stripped = fixProc(buffer, password);

	var type = stripped.tag;
	var data = stripped.data;
	var subtype, ndata;
	switch (type) {
		case 'CERTIFICATE':
			ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
			// falls through
		case 'PUBLIC KEY':
			if (!ndata) {
				ndata = asn1.PublicKey.decode(data, 'der');
			}
			subtype = ndata.algorithm.algorithm.join('.');
			switch (subtype) {
				case '1.2.840.113549.1.1.1':
					return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
				case '1.2.840.10045.2.1':
					ndata.subjectPrivateKey = ndata.subjectPublicKey;
					return {
						type: 'ec',
						data: ndata
					};
				case '1.2.840.10040.4.1':
					ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
					return {
						type: 'dsa',
						data: ndata.algorithm.params
					};
				default: throw new Error('unknown key id ' + subtype);
			}
			// throw new Error('unknown key type ' + type)
		case 'ENCRYPTED PRIVATE KEY':
			data = asn1.EncryptedPrivateKey.decode(data, 'der');
			data = decrypt(data, password);
			// falls through
		case 'PRIVATE KEY':
			ndata = asn1.PrivateKey.decode(data, 'der');
			subtype = ndata.algorithm.algorithm.join('.');
			switch (subtype) {
				case '1.2.840.113549.1.1.1':
					return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
				case '1.2.840.10045.2.1':
					return {
						curve: ndata.algorithm.curve,
						privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
					};
				case '1.2.840.10040.4.1':
					ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
					return {
						type: 'dsa',
						params: ndata.algorithm.params
					};
				default: throw new Error('unknown key id ' + subtype);
			}
			// throw new Error('unknown key type ' + type)
		case 'RSA PUBLIC KEY':
			return asn1.RSAPublicKey.decode(data, 'der');
		case 'RSA PRIVATE KEY':
			return asn1.RSAPrivateKey.decode(data, 'der');
		case 'DSA PRIVATE KEY':
			return {
				type: 'dsa',
				params: asn1.DSAPrivateKey.decode(data, 'der')
			};
		case 'EC PRIVATE KEY':
			data = asn1.ECPrivateKey.decode(data, 'der');
			return {
				curve: data.parameters.value,
				privateKey: data.privateKey
			};
		default: throw new Error('unknown key type ' + type);
	}
}
parseKeys.signature = asn1.signature;

module.exports = parseKeys;

},{"./aesid.json":290,"./asn1":291,"./fixProc":293,"browserify-aes":138,"pbkdf2":295,"safe-buffer":327}],295:[function(require,module,exports){
'use strict';

exports.pbkdf2 = require('./lib/async');
exports.pbkdf2Sync = require('./lib/sync');

},{"./lib/async":296,"./lib/sync":299}],296:[function(require,module,exports){
(function (global){(function (){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var checkParameters = require('./precondition');
var defaultEncoding = require('./default-encoding');
var sync = require('./sync');
var toBuffer = require('./to-buffer');

var ZERO_BUF;
var subtle = global.crypto && global.crypto.subtle;
var toBrowser = {
	sha: 'SHA-1',
	'sha-1': 'SHA-1',
	sha1: 'SHA-1',
	sha256: 'SHA-256',
	'sha-256': 'SHA-256',
	sha384: 'SHA-384',
	'sha-384': 'SHA-384',
	'sha-512': 'SHA-512',
	sha512: 'SHA-512'
};
var checks = [];
var nextTick;
function getNextTick() {
	if (nextTick) {
		return nextTick;
	}
	if (global.process && global.process.nextTick) {
		nextTick = global.process.nextTick;
	} else if (global.queueMicrotask) {
		nextTick = global.queueMicrotask;
	} else if (global.setImmediate) {
		nextTick = global.setImmediate;
	} else {
		nextTick = global.setTimeout;
	}
	return nextTick;
}
function browserPbkdf2(password, salt, iterations, length, algo) {
	return subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveBits']).then(function (key) {
		return subtle.deriveBits({
			name: 'PBKDF2',
			salt: salt,
			iterations: iterations,
			hash: {
				name: algo
			}
		}, key, length << 3);
	}).then(function (res) {
		return Buffer.from(res);
	});
}
function checkNative(algo) {
	if (global.process && !global.process.browser) {
		return Promise.resolve(false);
	}
	if (!subtle || !subtle.importKey || !subtle.deriveBits) {
		return Promise.resolve(false);
	}
	if (checks[algo] !== undefined) {
		return checks[algo];
	}
	ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
	var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
		.then(
			function () { return true; },
			function () { return false; }
		);
	checks[algo] = prom;
	return prom;
}

function resolvePromise(promise, callback) {
	promise.then(function (out) {
		getNextTick()(function () {
			callback(null, out);
		});
	}, function (e) {
		getNextTick()(function () {
			callback(e);
		});
	});
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
	if (typeof digest === 'function') {
		callback = digest;
		digest = undefined;
	}

	checkParameters(iterations, keylen);
	password = toBuffer(password, defaultEncoding, 'Password');
	salt = toBuffer(salt, defaultEncoding, 'Salt');
	if (typeof callback !== 'function') {
		throw new Error('No callback provided to pbkdf2');
	}

	digest = digest || 'sha1';
	var algo = toBrowser[digest.toLowerCase()];

	if (!algo || typeof global.Promise !== 'function') {
		getNextTick()(function () {
			var out;
			try {
				out = sync(password, salt, iterations, keylen, digest);
			} catch (e) {
				callback(e);
				return;
			}
			callback(null, out);
		});
		return;
	}

	resolvePromise(checkNative(algo).then(function (resp) {
		if (resp) {
			return browserPbkdf2(password, salt, iterations, keylen, algo);
		}

		return sync(password, salt, iterations, keylen, digest);
	}), callback);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./default-encoding":297,"./precondition":298,"./sync":299,"./to-buffer":300,"safe-buffer":327}],297:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var defaultEncoding;
/* istanbul ignore next */
if (global.process && global.process.browser) {
	defaultEncoding = 'utf-8';
} else if (global.process && global.process.version) {
	var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);

	defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
} else {
	defaultEncoding = 'utf-8';
}
module.exports = defaultEncoding;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":303}],298:[function(require,module,exports){
'use strict';

var $isFinite = isFinite;
var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

module.exports = function (iterations, keylen) {
	if (typeof iterations !== 'number') {
		throw new TypeError('Iterations not a number');
	}

	if (iterations < 0 || !$isFinite(iterations)) {
		throw new TypeError('Bad iterations');
	}

	if (typeof keylen !== 'number') {
		throw new TypeError('Key length not a number');
	}

	if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
		throw new TypeError('Bad key length');
	}
};

},{}],299:[function(require,module,exports){
'use strict';

var md5 = require('create-hash/md5');
var RIPEMD160 = require('ripemd160');
var sha = require('sha.js');
var Buffer = require('safe-buffer').Buffer;

var checkParameters = require('./precondition');
var defaultEncoding = require('./default-encoding');
var toBuffer = require('./to-buffer');

var ZEROS = Buffer.alloc(128);
var sizes = {
	__proto__: null,
	md5: 16,
	sha1: 20,
	sha224: 28,
	sha256: 32,
	sha384: 48,
	sha512: 64,
	'sha512-256': 32,
	ripemd160: 20,
	rmd160: 20
};

var mapping = {
	__proto__: null,
	'sha-1': 'sha1',
	'sha-224': 'sha224',
	'sha-256': 'sha256',
	'sha-384': 'sha384',
	'sha-512': 'sha512',
	'ripemd-160': 'ripemd160'
};

function rmd160Func(data) {
	return new RIPEMD160().update(data).digest();
}

function getDigest(alg) {
	function shaFunc(data) {
		return sha(alg).update(data).digest();
	}

	if (alg === 'rmd160' || alg === 'ripemd160') {
		return rmd160Func;
	}
	if (alg === 'md5') {
		return md5;
	}
	return shaFunc;
}

function Hmac(alg, key, saltLen) {
	var hash = getDigest(alg);
	var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;

	if (key.length > blocksize) {
		key = hash(key);
	} else if (key.length < blocksize) {
		key = Buffer.concat([key, ZEROS], blocksize);
	}

	var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
	var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
	for (var i = 0; i < blocksize; i++) {
		ipad[i] = key[i] ^ 0x36;
		opad[i] = key[i] ^ 0x5C;
	}

	var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
	ipad.copy(ipad1, 0, 0, blocksize);
	this.ipad1 = ipad1;
	this.ipad2 = ipad;
	this.opad = opad;
	this.alg = alg;
	this.blocksize = blocksize;
	this.hash = hash;
	this.size = sizes[alg];
}

Hmac.prototype.run = function (data, ipad) {
	data.copy(ipad, this.blocksize);
	var h = this.hash(ipad);
	h.copy(this.opad, this.blocksize);
	return this.hash(this.opad);
};

function pbkdf2(password, salt, iterations, keylen, digest) {
	checkParameters(iterations, keylen);
	password = toBuffer(password, defaultEncoding, 'Password');
	salt = toBuffer(salt, defaultEncoding, 'Salt');

	var lowerDigest = (digest || 'sha1').toLowerCase();
	var mappedDigest = mapping[lowerDigest] || lowerDigest;
	var size = sizes[mappedDigest];
	if (typeof size !== 'number' || !size) {
		throw new TypeError('Digest algorithm not supported: ' + digest);
	}

	var hmac = new Hmac(mappedDigest, password, salt.length);

	var DK = Buffer.allocUnsafe(keylen);
	var block1 = Buffer.allocUnsafe(salt.length + 4);
	salt.copy(block1, 0, 0, salt.length);

	var destPos = 0;
	var hLen = size;
	var l = Math.ceil(keylen / hLen);

	for (var i = 1; i <= l; i++) {
		block1.writeUInt32BE(i, salt.length);

		var T = hmac.run(block1, hmac.ipad1);
		var U = T;

		for (var j = 1; j < iterations; j++) {
			U = hmac.run(U, hmac.ipad2);
			for (var k = 0; k < hLen; k++) {
				T[k] ^= U[k];
			}
		}

		T.copy(DK, destPos);
		destPos += hLen;
	}

	return DK;
}

module.exports = pbkdf2;

},{"./default-encoding":297,"./precondition":298,"./to-buffer":300,"create-hash/md5":181,"ripemd160":324,"safe-buffer":327,"sha.js":330}],300:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var toBuffer = require('to-buffer');

var useUint8Array = typeof Uint8Array !== 'undefined';
var useArrayBuffer = useUint8Array && typeof ArrayBuffer !== 'undefined';
var isView = useArrayBuffer && ArrayBuffer.isView;

module.exports = function (thing, encoding, name) {
	if (
		typeof thing === 'string'
		|| Buffer.isBuffer(thing)
		|| (useUint8Array && thing instanceof Uint8Array)
		|| (isView && isView(thing))
	) {
		return toBuffer(thing, encoding);
	}
	throw new TypeError(name + ' must be a string, a Buffer, a Uint8Array, or a DataView');
};

},{"safe-buffer":327,"to-buffer":354}],301:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = [
	'Float16Array',
	'Float32Array',
	'Float64Array',
	'Int8Array',
	'Int16Array',
	'Int32Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Uint16Array',
	'Uint32Array',
	'BigInt64Array',
	'BigUint64Array'
];

},{}],302:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))
},{"_process":303}],303:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],304:[function(require,module,exports){
exports.publicEncrypt = require('./publicEncrypt')
exports.privateDecrypt = require('./privateDecrypt')

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}

},{"./privateDecrypt":307,"./publicEncrypt":308}],305:[function(require,module,exports){
var createHash = require('create-hash')
var Buffer = require('safe-buffer').Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}

},{"create-hash":180,"safe-buffer":327}],306:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"buffer":135,"dup":49}],307:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var crt = require('browserify-rsa')
var createHash = require('create-hash')
var withPublic = require('./withPublic')
var Buffer = require('safe-buffer').Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}

},{"./mgf":305,"./withPublic":309,"./xor":310,"bn.js":306,"browserify-rsa":156,"create-hash":180,"parse-asn1":294,"safe-buffer":327}],308:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var randomBytes = require('randombytes')
var createHash = require('create-hash')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var withPublic = require('./withPublic')
var crt = require('browserify-rsa')
var Buffer = require('safe-buffer').Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}

},{"./mgf":305,"./withPublic":309,"./xor":310,"bn.js":306,"browserify-rsa":156,"create-hash":180,"parse-asn1":294,"randombytes":311,"safe-buffer":327}],309:[function(require,module,exports){
var BN = require('bn.js')
var Buffer = require('safe-buffer').Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic

},{"bn.js":306,"safe-buffer":327}],310:[function(require,module,exports){
module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}

},{}],311:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":303,"safe-buffer":327}],312:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = require('safe-buffer')
var randombytes = require('randombytes')
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":303,"randombytes":311,"safe-buffer":327}],313:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":315,"./_stream_writable":317,"core-util-is":177,"inherits":260,"process-nextick-args":302}],314:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":316,"core-util-is":177,"inherits":260}],315:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, { hasUnpiped: false });
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":313,"./internal/streams/BufferList":318,"./internal/streams/destroy":319,"./internal/streams/stream":320,"_process":303,"core-util-is":177,"events":229,"inherits":260,"isarray":264,"process-nextick-args":302,"safe-buffer":321,"string_decoder/":322,"util":135}],316:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":313,"core-util-is":177,"inherits":260}],317:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":313,"./internal/streams/destroy":319,"./internal/streams/stream":320,"_process":303,"core-util-is":177,"inherits":260,"process-nextick-args":302,"safe-buffer":321,"timers":353,"util-deprecate":361}],318:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":321,"util":135}],319:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        pna.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        pna.nextTick(emitErrorNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, _this, err);
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":302}],320:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":229}],321:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":167}],322:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":321}],323:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":313,"./lib/_stream_passthrough.js":314,"./lib/_stream_readable.js":315,"./lib/_stream_transform.js":316,"./lib/_stream_writable.js":317}],324:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
var inherits = require('inherits');
var HashBase = require('hash-base');

var ARRAY16 = new Array(16);

var zl = [
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var zr = [
	5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var sl = [
	11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sr = [
	8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

function rotl(x, n) {
	return (x << n) | (x >>> (32 - n));
}

function fn1(a, b, c, d, e, m, k, s) {
	return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0;
}

function fn2(a, b, c, d, e, m, k, s) {
	return (rotl((a + ((b & c) | (~b & d)) + m + k) | 0, s) + e) | 0;
}

function fn3(a, b, c, d, e, m, k, s) {
	return (rotl((a + ((b | ~c) ^ d) + m + k) | 0, s) + e) | 0;
}

function fn4(a, b, c, d, e, m, k, s) {
	return (rotl((a + ((b & d) | (c & ~d)) + m + k) | 0, s) + e) | 0;
}

function fn5(a, b, c, d, e, m, k, s) {
	return (rotl((a + (b ^ (c | ~d)) + m + k) | 0, s) + e) | 0;
}

function RIPEMD160() {
	HashBase.call(this, 64);

	// state
	this._a = 0x67452301;
	this._b = 0xefcdab89;
	this._c = 0x98badcfe;
	this._d = 0x10325476;
	this._e = 0xc3d2e1f0;
}

inherits(RIPEMD160, HashBase);

RIPEMD160.prototype._update = function () {
	var words = ARRAY16;
	for (var j = 0; j < 16; ++j) {
		words[j] = this._block.readInt32LE(j * 4);
	}

	var al = this._a | 0;
	var bl = this._b | 0;
	var cl = this._c | 0;
	var dl = this._d | 0;
	var el = this._e | 0;

	var ar = this._a | 0;
	var br = this._b | 0;
	var cr = this._c | 0;
	var dr = this._d | 0;
	var er = this._e | 0;

	// computation
	for (var i = 0; i < 80; i += 1) {
		var tl;
		var tr;
		if (i < 16) {
			tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
			tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
		} else if (i < 32) {
			tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
			tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
		} else if (i < 48) {
			tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
			tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
		} else if (i < 64) {
			tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
			tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
		} else { // if (i<80) {
			tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
			tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
		}

		al = el;
		el = dl;
		dl = rotl(cl, 10);
		cl = bl;
		bl = tl;

		ar = er;
		er = dr;
		dr = rotl(cr, 10);
		cr = br;
		br = tr;
	}

	// update state
	var t = (this._b + cl + dr) | 0;
	this._b = (this._c + dl + er) | 0;
	this._c = (this._d + el + ar) | 0;
	this._d = (this._e + al + br) | 0;
	this._e = (this._a + bl + cr) | 0;
	this._a = t;
};

RIPEMD160.prototype._digest = function () {
	// create padding and handle blocks
	this._block[this._blockOffset] = 0x80;
	this._blockOffset += 1;
	if (this._blockOffset > 56) {
		this._block.fill(0, this._blockOffset, 64);
		this._update();
		this._blockOffset = 0;
	}

	this._block.fill(0, this._blockOffset, 56);
	this._block.writeUInt32LE(this._length[0], 56);
	this._block.writeUInt32LE(this._length[1], 60);
	this._update();

	// produce result
	var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20); // eslint-disable-line no-buffer-constructor
	buffer.writeInt32LE(this._a, 0);
	buffer.writeInt32LE(this._b, 4);
	buffer.writeInt32LE(this._c, 8);
	buffer.writeInt32LE(this._d, 12);
	buffer.writeInt32LE(this._e, 16);
	return buffer;
};

module.exports = RIPEMD160;

},{"buffer":167,"hash-base":325,"inherits":260}],325:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var toBuffer = require('./to-buffer');
var Transform = require('readable-stream').Transform;
var inherits = require('inherits');

function HashBase(blockSize) {
	Transform.call(this);

	this._block = Buffer.allocUnsafe(blockSize);
	this._blockSize = blockSize;
	this._blockOffset = 0;
	this._length = [0, 0, 0, 0];

	this._finalized = false;
}

inherits(HashBase, Transform);

HashBase.prototype._transform = function (chunk, encoding, callback) {
	var error = null;
	try {
		this.update(chunk, encoding);
	} catch (err) {
		error = err;
	}

	callback(error);
};

HashBase.prototype._flush = function (callback) {
	var error = null;
	try {
		this.push(this.digest());
	} catch (err) {
		error = err;
	}

	callback(error);
};

HashBase.prototype.update = function (data, encoding) {
	if (this._finalized) {
		throw new Error('Digest already called');
	}

	var dataBuffer = toBuffer(data, encoding); // asserts correct input type

	// consume data
	var block = this._block;
	var offset = 0;
	while (this._blockOffset + dataBuffer.length - offset >= this._blockSize) {
		for (var i = this._blockOffset; i < this._blockSize;) {
			block[i] = dataBuffer[offset];
			i += 1;
			offset += 1;
		}
		this._update();
		this._blockOffset = 0;
	}
	while (offset < dataBuffer.length) {
		block[this._blockOffset] = dataBuffer[offset];
		this._blockOffset += 1;
		offset += 1;
	}

	// update length
	for (var j = 0, carry = dataBuffer.length * 8; carry > 0; ++j) {
		this._length[j] += carry;
		carry = (this._length[j] / 0x0100000000) | 0;
		if (carry > 0) {
			this._length[j] -= 0x0100000000 * carry;
		}
	}

	return this;
};

HashBase.prototype._update = function () {
	throw new Error('_update is not implemented');
};

HashBase.prototype.digest = function (encoding) {
	if (this._finalized) {
		throw new Error('Digest already called');
	}
	this._finalized = true;

	var digest = this._digest();
	if (encoding !== undefined) {
		digest = digest.toString(encoding);
	}

	// reset state
	this._block.fill(0);
	this._blockOffset = 0;
	for (var i = 0; i < 4; ++i) {
		this._length[i] = 0;
	}

	return digest;
};

HashBase.prototype._digest = function () {
	throw new Error('_digest is not implemented');
};

module.exports = HashBase;

},{"./to-buffer":326,"inherits":260,"readable-stream":323,"safe-buffer":327}],326:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var toBuffer = require('to-buffer');

var useUint8Array = typeof Uint8Array !== 'undefined';
var useArrayBuffer = useUint8Array && typeof ArrayBuffer !== 'undefined';
var isView = useArrayBuffer && ArrayBuffer.isView;

module.exports = function (thing, encoding) {
	if (
		typeof thing === 'string'
    || Buffer.isBuffer(thing)
    || (useUint8Array && thing instanceof Uint8Array)
    || (isView && isView(thing))
	) {
		return toBuffer(thing, encoding);
	}
	throw new TypeError('The "data" argument must be a string, a Buffer, a Uint8Array, or a DataView');
};

},{"safe-buffer":327,"to-buffer":354}],327:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":167}],328:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var define = require('define-data-property');
var hasDescriptors = require('has-property-descriptors')();
var gOPD = require('gopd');

var $TypeError = require('es-errors/type');
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};

},{"define-data-property":185,"es-errors/type":226,"get-intrinsic":234,"gopd":239,"has-property-descriptors":240}],329:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var toBuffer = require('to-buffer');

// prototype class for hash functions
function Hash(blockSize, finalSize) {
	this._block = Buffer.alloc(blockSize);
	this._finalSize = finalSize;
	this._blockSize = blockSize;
	this._len = 0;
}

Hash.prototype.update = function (data, enc) {
	/* eslint no-param-reassign: 0 */
	data = toBuffer(data, enc || 'utf8');

	var block = this._block;
	var blockSize = this._blockSize;
	var length = data.length;
	var accum = this._len;

	for (var offset = 0; offset < length;) {
		var assigned = accum % blockSize;
		var remainder = Math.min(length - offset, blockSize - assigned);

		for (var i = 0; i < remainder; i++) {
			block[assigned + i] = data[offset + i];
		}

		accum += remainder;
		offset += remainder;

		if ((accum % blockSize) === 0) {
			this._update(block);
		}
	}

	this._len += length;
	return this;
};

Hash.prototype.digest = function (enc) {
	var rem = this._len % this._blockSize;

	this._block[rem] = 0x80;

	/*
	 * zero (rem + 1) trailing bits, where (rem + 1) is the smallest
	 * non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
	 */
	this._block.fill(0, rem + 1);

	if (rem >= this._finalSize) {
		this._update(this._block);
		this._block.fill(0);
	}

	var bits = this._len * 8;

	// uint32
	if (bits <= 0xffffffff) {
		this._block.writeUInt32BE(bits, this._blockSize - 4);

		// uint64
	} else {
		var lowBits = (bits & 0xffffffff) >>> 0;
		var highBits = (bits - lowBits) / 0x100000000;

		this._block.writeUInt32BE(highBits, this._blockSize - 8);
		this._block.writeUInt32BE(lowBits, this._blockSize - 4);
	}

	this._update(this._block);
	var hash = this._hash();

	return enc ? hash.toString(enc) : hash;
};

Hash.prototype._update = function () {
	throw new Error('_update must be implemented by subclass');
};

module.exports = Hash;

},{"safe-buffer":327,"to-buffer":354}],330:[function(require,module,exports){
'use strict';

module.exports = function SHA(algorithm) {
	var alg = algorithm.toLowerCase();

	var Algorithm = module.exports[alg];
	if (!Algorithm) {
		throw new Error(alg + ' is not supported (we accept pull requests)');
	}

	return new Algorithm();
};

module.exports.sha = require('./sha');
module.exports.sha1 = require('./sha1');
module.exports.sha224 = require('./sha224');
module.exports.sha256 = require('./sha256');
module.exports.sha384 = require('./sha384');
module.exports.sha512 = require('./sha512');

},{"./sha":331,"./sha1":332,"./sha224":333,"./sha256":334,"./sha384":335,"./sha512":336}],331:[function(require,module,exports){
'use strict';

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var K = [
	0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
];

var W = new Array(80);

function Sha() {
	this.init();
	this._w = W;

	Hash.call(this, 64, 56);
}

inherits(Sha, Hash);

Sha.prototype.init = function () {
	this._a = 0x67452301;
	this._b = 0xefcdab89;
	this._c = 0x98badcfe;
	this._d = 0x10325476;
	this._e = 0xc3d2e1f0;

	return this;
};

function rotl5(num) {
	return (num << 5) | (num >>> 27);
}

function rotl30(num) {
	return (num << 30) | (num >>> 2);
}

function ft(s, b, c, d) {
	if (s === 0) {
		return (b & c) | (~b & d);
	}
	if (s === 2) {
		return (b & c) | (b & d) | (c & d);
	}
	return b ^ c ^ d;
}

Sha.prototype._update = function (M) {
	var w = this._w;

	var a = this._a | 0;
	var b = this._b | 0;
	var c = this._c | 0;
	var d = this._d | 0;
	var e = this._e | 0;

	for (var i = 0; i < 16; ++i) {
		w[i] = M.readInt32BE(i * 4);
	}
	for (; i < 80; ++i) {
		w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
	}

	for (var j = 0; j < 80; ++j) {
		var s = ~~(j / 20);
		var t = (rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s]) | 0;

		e = d;
		d = c;
		c = rotl30(b);
		b = a;
		a = t;
	}

	this._a = (a + this._a) | 0;
	this._b = (b + this._b) | 0;
	this._c = (c + this._c) | 0;
	this._d = (d + this._d) | 0;
	this._e = (e + this._e) | 0;
};

Sha.prototype._hash = function () {
	var H = Buffer.allocUnsafe(20);

	H.writeInt32BE(this._a | 0, 0);
	H.writeInt32BE(this._b | 0, 4);
	H.writeInt32BE(this._c | 0, 8);
	H.writeInt32BE(this._d | 0, 12);
	H.writeInt32BE(this._e | 0, 16);

	return H;
};

module.exports = Sha;

},{"./hash":329,"inherits":260,"safe-buffer":327}],332:[function(require,module,exports){
'use strict';

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var K = [
	0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
];

var W = new Array(80);

function Sha1() {
	this.init();
	this._w = W;

	Hash.call(this, 64, 56);
}

inherits(Sha1, Hash);

Sha1.prototype.init = function () {
	this._a = 0x67452301;
	this._b = 0xefcdab89;
	this._c = 0x98badcfe;
	this._d = 0x10325476;
	this._e = 0xc3d2e1f0;

	return this;
};

function rotl1(num) {
	return (num << 1) | (num >>> 31);
}

function rotl5(num) {
	return (num << 5) | (num >>> 27);
}

function rotl30(num) {
	return (num << 30) | (num >>> 2);
}

function ft(s, b, c, d) {
	if (s === 0) {
		return (b & c) | (~b & d);
	}
	if (s === 2) {
		return (b & c) | (b & d) | (c & d);
	}
	return b ^ c ^ d;
}

Sha1.prototype._update = function (M) {
	var w = this._w;

	var a = this._a | 0;
	var b = this._b | 0;
	var c = this._c | 0;
	var d = this._d | 0;
	var e = this._e | 0;

	for (var i = 0; i < 16; ++i) {
		w[i] = M.readInt32BE(i * 4);
	}
	for (; i < 80; ++i) {
		w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
	}

	for (var j = 0; j < 80; ++j) {
		var s = ~~(j / 20);
		var t = (rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s]) | 0;

		e = d;
		d = c;
		c = rotl30(b);
		b = a;
		a = t;
	}

	this._a = (a + this._a) | 0;
	this._b = (b + this._b) | 0;
	this._c = (c + this._c) | 0;
	this._d = (d + this._d) | 0;
	this._e = (e + this._e) | 0;
};

Sha1.prototype._hash = function () {
	var H = Buffer.allocUnsafe(20);

	H.writeInt32BE(this._a | 0, 0);
	H.writeInt32BE(this._b | 0, 4);
	H.writeInt32BE(this._c | 0, 8);
	H.writeInt32BE(this._d | 0, 12);
	H.writeInt32BE(this._e | 0, 16);

	return H;
};

module.exports = Sha1;

},{"./hash":329,"inherits":260,"safe-buffer":327}],333:[function(require,module,exports){
'use strict';

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits');
var Sha256 = require('./sha256');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var W = new Array(64);

function Sha224() {
	this.init();

	this._w = W; // new Array(64)

	Hash.call(this, 64, 56);
}

inherits(Sha224, Sha256);

Sha224.prototype.init = function () {
	this._a = 0xc1059ed8;
	this._b = 0x367cd507;
	this._c = 0x3070dd17;
	this._d = 0xf70e5939;
	this._e = 0xffc00b31;
	this._f = 0x68581511;
	this._g = 0x64f98fa7;
	this._h = 0xbefa4fa4;

	return this;
};

Sha224.prototype._hash = function () {
	var H = Buffer.allocUnsafe(28);

	H.writeInt32BE(this._a, 0);
	H.writeInt32BE(this._b, 4);
	H.writeInt32BE(this._c, 8);
	H.writeInt32BE(this._d, 12);
	H.writeInt32BE(this._e, 16);
	H.writeInt32BE(this._f, 20);
	H.writeInt32BE(this._g, 24);

	return H;
};

module.exports = Sha224;

},{"./hash":329,"./sha256":334,"inherits":260,"safe-buffer":327}],334:[function(require,module,exports){
'use strict';

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var K = [
	0x428A2F98,
	0x71374491,
	0xB5C0FBCF,
	0xE9B5DBA5,
	0x3956C25B,
	0x59F111F1,
	0x923F82A4,
	0xAB1C5ED5,
	0xD807AA98,
	0x12835B01,
	0x243185BE,
	0x550C7DC3,
	0x72BE5D74,
	0x80DEB1FE,
	0x9BDC06A7,
	0xC19BF174,
	0xE49B69C1,
	0xEFBE4786,
	0x0FC19DC6,
	0x240CA1CC,
	0x2DE92C6F,
	0x4A7484AA,
	0x5CB0A9DC,
	0x76F988DA,
	0x983E5152,
	0xA831C66D,
	0xB00327C8,
	0xBF597FC7,
	0xC6E00BF3,
	0xD5A79147,
	0x06CA6351,
	0x14292967,
	0x27B70A85,
	0x2E1B2138,
	0x4D2C6DFC,
	0x53380D13,
	0x650A7354,
	0x766A0ABB,
	0x81C2C92E,
	0x92722C85,
	0xA2BFE8A1,
	0xA81A664B,
	0xC24B8B70,
	0xC76C51A3,
	0xD192E819,
	0xD6990624,
	0xF40E3585,
	0x106AA070,
	0x19A4C116,
	0x1E376C08,
	0x2748774C,
	0x34B0BCB5,
	0x391C0CB3,
	0x4ED8AA4A,
	0x5B9CCA4F,
	0x682E6FF3,
	0x748F82EE,
	0x78A5636F,
	0x84C87814,
	0x8CC70208,
	0x90BEFFFA,
	0xA4506CEB,
	0xBEF9A3F7,
	0xC67178F2
];

var W = new Array(64);

function Sha256() {
	this.init();

	this._w = W; // new Array(64)

	Hash.call(this, 64, 56);
}

inherits(Sha256, Hash);

Sha256.prototype.init = function () {
	this._a = 0x6a09e667;
	this._b = 0xbb67ae85;
	this._c = 0x3c6ef372;
	this._d = 0xa54ff53a;
	this._e = 0x510e527f;
	this._f = 0x9b05688c;
	this._g = 0x1f83d9ab;
	this._h = 0x5be0cd19;

	return this;
};

function ch(x, y, z) {
	return z ^ (x & (y ^ z));
}

function maj(x, y, z) {
	return (x & y) | (z & (x | y));
}

function sigma0(x) {
	return ((x >>> 2) | (x << 30)) ^ ((x >>> 13) | (x << 19)) ^ ((x >>> 22) | (x << 10));
}

function sigma1(x) {
	return ((x >>> 6) | (x << 26)) ^ ((x >>> 11) | (x << 21)) ^ ((x >>> 25) | (x << 7));
}

function gamma0(x) {
	return ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);
}

function gamma1(x) {
	return ((x >>> 17) | (x << 15)) ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);
}

Sha256.prototype._update = function (M) {
	var w = this._w;

	var a = this._a | 0;
	var b = this._b | 0;
	var c = this._c | 0;
	var d = this._d | 0;
	var e = this._e | 0;
	var f = this._f | 0;
	var g = this._g | 0;
	var h = this._h | 0;

	for (var i = 0; i < 16; ++i) {
		w[i] = M.readInt32BE(i * 4);
	}
	for (; i < 64; ++i) {
		w[i] = (gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16]) | 0;
	}

	for (var j = 0; j < 64; ++j) {
		var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + w[j]) | 0;
		var T2 = (sigma0(a) + maj(a, b, c)) | 0;

		h = g;
		g = f;
		f = e;
		e = (d + T1) | 0;
		d = c;
		c = b;
		b = a;
		a = (T1 + T2) | 0;
	}

	this._a = (a + this._a) | 0;
	this._b = (b + this._b) | 0;
	this._c = (c + this._c) | 0;
	this._d = (d + this._d) | 0;
	this._e = (e + this._e) | 0;
	this._f = (f + this._f) | 0;
	this._g = (g + this._g) | 0;
	this._h = (h + this._h) | 0;
};

Sha256.prototype._hash = function () {
	var H = Buffer.allocUnsafe(32);

	H.writeInt32BE(this._a, 0);
	H.writeInt32BE(this._b, 4);
	H.writeInt32BE(this._c, 8);
	H.writeInt32BE(this._d, 12);
	H.writeInt32BE(this._e, 16);
	H.writeInt32BE(this._f, 20);
	H.writeInt32BE(this._g, 24);
	H.writeInt32BE(this._h, 28);

	return H;
};

module.exports = Sha256;

},{"./hash":329,"inherits":260,"safe-buffer":327}],335:[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var SHA512 = require('./sha512');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var W = new Array(160);

function Sha384() {
	this.init();
	this._w = W;

	Hash.call(this, 128, 112);
}

inherits(Sha384, SHA512);

Sha384.prototype.init = function () {
	this._ah = 0xcbbb9d5d;
	this._bh = 0x629a292a;
	this._ch = 0x9159015a;
	this._dh = 0x152fecd8;
	this._eh = 0x67332667;
	this._fh = 0x8eb44a87;
	this._gh = 0xdb0c2e0d;
	this._hh = 0x47b5481d;

	this._al = 0xc1059ed8;
	this._bl = 0x367cd507;
	this._cl = 0x3070dd17;
	this._dl = 0xf70e5939;
	this._el = 0xffc00b31;
	this._fl = 0x68581511;
	this._gl = 0x64f98fa7;
	this._hl = 0xbefa4fa4;

	return this;
};

Sha384.prototype._hash = function () {
	var H = Buffer.allocUnsafe(48);

	function writeInt64BE(h, l, offset) {
		H.writeInt32BE(h, offset);
		H.writeInt32BE(l, offset + 4);
	}

	writeInt64BE(this._ah, this._al, 0);
	writeInt64BE(this._bh, this._bl, 8);
	writeInt64BE(this._ch, this._cl, 16);
	writeInt64BE(this._dh, this._dl, 24);
	writeInt64BE(this._eh, this._el, 32);
	writeInt64BE(this._fh, this._fl, 40);

	return H;
};

module.exports = Sha384;

},{"./hash":329,"./sha512":336,"inherits":260,"safe-buffer":327}],336:[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var K = [
	0x428a2f98,
	0xd728ae22,
	0x71374491,
	0x23ef65cd,
	0xb5c0fbcf,
	0xec4d3b2f,
	0xe9b5dba5,
	0x8189dbbc,
	0x3956c25b,
	0xf348b538,
	0x59f111f1,
	0xb605d019,
	0x923f82a4,
	0xaf194f9b,
	0xab1c5ed5,
	0xda6d8118,
	0xd807aa98,
	0xa3030242,
	0x12835b01,
	0x45706fbe,
	0x243185be,
	0x4ee4b28c,
	0x550c7dc3,
	0xd5ffb4e2,
	0x72be5d74,
	0xf27b896f,
	0x80deb1fe,
	0x3b1696b1,
	0x9bdc06a7,
	0x25c71235,
	0xc19bf174,
	0xcf692694,
	0xe49b69c1,
	0x9ef14ad2,
	0xefbe4786,
	0x384f25e3,
	0x0fc19dc6,
	0x8b8cd5b5,
	0x240ca1cc,
	0x77ac9c65,
	0x2de92c6f,
	0x592b0275,
	0x4a7484aa,
	0x6ea6e483,
	0x5cb0a9dc,
	0xbd41fbd4,
	0x76f988da,
	0x831153b5,
	0x983e5152,
	0xee66dfab,
	0xa831c66d,
	0x2db43210,
	0xb00327c8,
	0x98fb213f,
	0xbf597fc7,
	0xbeef0ee4,
	0xc6e00bf3,
	0x3da88fc2,
	0xd5a79147,
	0x930aa725,
	0x06ca6351,
	0xe003826f,
	0x14292967,
	0x0a0e6e70,
	0x27b70a85,
	0x46d22ffc,
	0x2e1b2138,
	0x5c26c926,
	0x4d2c6dfc,
	0x5ac42aed,
	0x53380d13,
	0x9d95b3df,
	0x650a7354,
	0x8baf63de,
	0x766a0abb,
	0x3c77b2a8,
	0x81c2c92e,
	0x47edaee6,
	0x92722c85,
	0x1482353b,
	0xa2bfe8a1,
	0x4cf10364,
	0xa81a664b,
	0xbc423001,
	0xc24b8b70,
	0xd0f89791,
	0xc76c51a3,
	0x0654be30,
	0xd192e819,
	0xd6ef5218,
	0xd6990624,
	0x5565a910,
	0xf40e3585,
	0x5771202a,
	0x106aa070,
	0x32bbd1b8,
	0x19a4c116,
	0xb8d2d0c8,
	0x1e376c08,
	0x5141ab53,
	0x2748774c,
	0xdf8eeb99,
	0x34b0bcb5,
	0xe19b48a8,
	0x391c0cb3,
	0xc5c95a63,
	0x4ed8aa4a,
	0xe3418acb,
	0x5b9cca4f,
	0x7763e373,
	0x682e6ff3,
	0xd6b2b8a3,
	0x748f82ee,
	0x5defb2fc,
	0x78a5636f,
	0x43172f60,
	0x84c87814,
	0xa1f0ab72,
	0x8cc70208,
	0x1a6439ec,
	0x90befffa,
	0x23631e28,
	0xa4506ceb,
	0xde82bde9,
	0xbef9a3f7,
	0xb2c67915,
	0xc67178f2,
	0xe372532b,
	0xca273ece,
	0xea26619c,
	0xd186b8c7,
	0x21c0c207,
	0xeada7dd6,
	0xcde0eb1e,
	0xf57d4f7f,
	0xee6ed178,
	0x06f067aa,
	0x72176fba,
	0x0a637dc5,
	0xa2c898a6,
	0x113f9804,
	0xbef90dae,
	0x1b710b35,
	0x131c471b,
	0x28db77f5,
	0x23047d84,
	0x32caab7b,
	0x40c72493,
	0x3c9ebe0a,
	0x15c9bebc,
	0x431d67c4,
	0x9c100d4c,
	0x4cc5d4be,
	0xcb3e42b6,
	0x597f299c,
	0xfc657e2a,
	0x5fcb6fab,
	0x3ad6faec,
	0x6c44198c,
	0x4a475817
];

var W = new Array(160);

function Sha512() {
	this.init();
	this._w = W;

	Hash.call(this, 128, 112);
}

inherits(Sha512, Hash);

Sha512.prototype.init = function () {
	this._ah = 0x6a09e667;
	this._bh = 0xbb67ae85;
	this._ch = 0x3c6ef372;
	this._dh = 0xa54ff53a;
	this._eh = 0x510e527f;
	this._fh = 0x9b05688c;
	this._gh = 0x1f83d9ab;
	this._hh = 0x5be0cd19;

	this._al = 0xf3bcc908;
	this._bl = 0x84caa73b;
	this._cl = 0xfe94f82b;
	this._dl = 0x5f1d36f1;
	this._el = 0xade682d1;
	this._fl = 0x2b3e6c1f;
	this._gl = 0xfb41bd6b;
	this._hl = 0x137e2179;

	return this;
};

function Ch(x, y, z) {
	return z ^ (x & (y ^ z));
}

function maj(x, y, z) {
	return (x & y) | (z & (x | y));
}

function sigma0(x, xl) {
	return ((x >>> 28) | (xl << 4)) ^ ((xl >>> 2) | (x << 30)) ^ ((xl >>> 7) | (x << 25));
}

function sigma1(x, xl) {
	return ((x >>> 14) | (xl << 18)) ^ ((x >>> 18) | (xl << 14)) ^ ((xl >>> 9) | (x << 23));
}

function Gamma0(x, xl) {
	return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ (x >>> 7);
}

function Gamma0l(x, xl) {
	return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ ((x >>> 7) | (xl << 25));
}

function Gamma1(x, xl) {
	return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ (x >>> 6);
}

function Gamma1l(x, xl) {
	return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ ((x >>> 6) | (xl << 26));
}

function getCarry(a, b) {
	return (a >>> 0) < (b >>> 0) ? 1 : 0;
}

Sha512.prototype._update = function (M) {
	var w = this._w;

	var ah = this._ah | 0;
	var bh = this._bh | 0;
	var ch = this._ch | 0;
	var dh = this._dh | 0;
	var eh = this._eh | 0;
	var fh = this._fh | 0;
	var gh = this._gh | 0;
	var hh = this._hh | 0;

	var al = this._al | 0;
	var bl = this._bl | 0;
	var cl = this._cl | 0;
	var dl = this._dl | 0;
	var el = this._el | 0;
	var fl = this._fl | 0;
	var gl = this._gl | 0;
	var hl = this._hl | 0;

	for (var i = 0; i < 32; i += 2) {
		w[i] = M.readInt32BE(i * 4);
		w[i + 1] = M.readInt32BE((i * 4) + 4);
	}
	for (; i < 160; i += 2) {
		var xh = w[i - (15 * 2)];
		var xl = w[i - (15 * 2) + 1];
		var gamma0 = Gamma0(xh, xl);
		var gamma0l = Gamma0l(xl, xh);

		xh = w[i - (2 * 2)];
		xl = w[i - (2 * 2) + 1];
		var gamma1 = Gamma1(xh, xl);
		var gamma1l = Gamma1l(xl, xh);

		// w[i] = gamma0 + w[i - 7] + gamma1 + w[i - 16]
		var Wi7h = w[i - (7 * 2)];
		var Wi7l = w[i - (7 * 2) + 1];

		var Wi16h = w[i - (16 * 2)];
		var Wi16l = w[i - (16 * 2) + 1];

		var Wil = (gamma0l + Wi7l) | 0;
		var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
		Wil = (Wil + gamma1l) | 0;
		Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
		Wil = (Wil + Wi16l) | 0;
		Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

		w[i] = Wih;
		w[i + 1] = Wil;
	}

	for (var j = 0; j < 160; j += 2) {
		Wih = w[j];
		Wil = w[j + 1];

		var majh = maj(ah, bh, ch);
		var majl = maj(al, bl, cl);

		var sigma0h = sigma0(ah, al);
		var sigma0l = sigma0(al, ah);
		var sigma1h = sigma1(eh, el);
		var sigma1l = sigma1(el, eh);

		// t1 = h + sigma1 + ch + K[j] + w[j]
		var Kih = K[j];
		var Kil = K[j + 1];

		var chh = Ch(eh, fh, gh);
		var chl = Ch(el, fl, gl);

		var t1l = (hl + sigma1l) | 0;
		var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
		t1l = (t1l + chl) | 0;
		t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
		t1l = (t1l + Kil) | 0;
		t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
		t1l = (t1l + Wil) | 0;
		t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

		// t2 = sigma0 + maj
		var t2l = (sigma0l + majl) | 0;
		var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

		hh = gh;
		hl = gl;
		gh = fh;
		gl = fl;
		fh = eh;
		fl = el;
		el = (dl + t1l) | 0;
		eh = (dh + t1h + getCarry(el, dl)) | 0;
		dh = ch;
		dl = cl;
		ch = bh;
		cl = bl;
		bh = ah;
		bl = al;
		al = (t1l + t2l) | 0;
		ah = (t1h + t2h + getCarry(al, t1l)) | 0;
	}

	this._al = (this._al + al) | 0;
	this._bl = (this._bl + bl) | 0;
	this._cl = (this._cl + cl) | 0;
	this._dl = (this._dl + dl) | 0;
	this._el = (this._el + el) | 0;
	this._fl = (this._fl + fl) | 0;
	this._gl = (this._gl + gl) | 0;
	this._hl = (this._hl + hl) | 0;

	this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
	this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
	this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
	this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
	this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
	this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
	this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
	this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
};

Sha512.prototype._hash = function () {
	var H = Buffer.allocUnsafe(64);

	function writeInt64BE(h, l, offset) {
		H.writeInt32BE(h, offset);
		H.writeInt32BE(l, offset + 4);
	}

	writeInt64BE(this._ah, this._al, 0);
	writeInt64BE(this._bh, this._bl, 8);
	writeInt64BE(this._ch, this._cl, 16);
	writeInt64BE(this._dh, this._dl, 24);
	writeInt64BE(this._eh, this._el, 32);
	writeInt64BE(this._fh, this._fl, 40);
	writeInt64BE(this._gh, this._gl, 48);
	writeInt64BE(this._hh, this._hl, 56);

	return H;
};

module.exports = Sha512;

},{"./hash":329,"inherits":260,"safe-buffer":327}],337:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":229,"inherits":260,"readable-stream/lib/_stream_duplex.js":339,"readable-stream/lib/_stream_passthrough.js":340,"readable-stream/lib/_stream_readable.js":341,"readable-stream/lib/_stream_transform.js":342,"readable-stream/lib/_stream_writable.js":343,"readable-stream/lib/internal/streams/end-of-stream.js":347,"readable-stream/lib/internal/streams/pipeline.js":349}],338:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],339:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":341,"./_stream_writable":343,"_process":303,"inherits":260}],340:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":342,"inherits":260}],341:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":338,"./_stream_duplex":339,"./internal/streams/async_iterator":344,"./internal/streams/buffer_list":345,"./internal/streams/destroy":346,"./internal/streams/from":348,"./internal/streams/state":350,"./internal/streams/stream":351,"_process":303,"buffer":167,"events":229,"inherits":260,"string_decoder/":352,"util":135}],342:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var _require$codes = require('../errors').codes,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":338,"./_stream_duplex":339,"inherits":260}],343:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":338,"./_stream_duplex":339,"./internal/streams/destroy":346,"./internal/streams/state":350,"./internal/streams/stream":351,"_process":303,"buffer":167,"inherits":260,"util-deprecate":361}],344:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":347,"_process":303}],345:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = require('buffer'),
  Buffer = _require.Buffer;
var _require2 = require('util'),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();
},{"buffer":167,"util":135}],346:[function(require,module,exports){
(function (process){(function (){
'use strict';

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":303}],347:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;
},{"../../../errors":338}],348:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],349:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;
},{"../../../errors":338,"./end-of-stream":347}],350:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":338}],351:[function(require,module,exports){
arguments[4][320][0].apply(exports,arguments)
},{"dup":320,"events":229}],352:[function(require,module,exports){
arguments[4][322][0].apply(exports,arguments)
},{"dup":322,"safe-buffer":327}],353:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":303,"timers":353}],354:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var isArray = require('isarray');
var typedArrayBuffer = require('typed-array-buffer');

var isView = ArrayBuffer.isView || function isView(obj) {
	try {
		typedArrayBuffer(obj);
		return true;
	} catch (e) {
		return false;
	}
};

var useUint8Array = typeof Uint8Array !== 'undefined';
var useArrayBuffer = typeof ArrayBuffer !== 'undefined'
	&& typeof Uint8Array !== 'undefined';
var useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);

module.exports = function toBuffer(data, encoding) {
	if (Buffer.isBuffer(data)) {
		if (data.constructor && !('isBuffer' in data)) {
			// probably a SlowBuffer
			return Buffer.from(data);
		}
		return data;
	}

	if (typeof data === 'string') {
		return Buffer.from(data, encoding);
	}

	/*
	 * Wrap any TypedArray instances and DataViews
	 * Makes sense only on engines with full TypedArray support -- let Buffer detect that
	 */
	if (useArrayBuffer && isView(data)) {
		// Bug in Node.js <6.3.1, which treats this as out-of-bounds
		if (data.byteLength === 0) {
			return Buffer.alloc(0);
		}

		// When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer
		if (useFromArrayBuffer) {
			var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
			/*
			 * Recheck result size, as offset/length doesn't work on Node.js <5.10
			 * We just go to Uint8Array case if this fails
			 */
			if (res.byteLength === data.byteLength) {
				return res;
			}
		}

		// Convert to Uint8Array bytes and then to Buffer
		var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
		var result = Buffer.from(uint8);

		/*
		 * Let's recheck that conversion succeeded
		 * We have .length but not .byteLength when useFromArrayBuffer is false
		 */
		if (result.length === data.byteLength) {
			return result;
		}
	}

	/*
	 * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
	 * Doesn't make sense with other TypedArray instances
	 */
	if (useUint8Array && data instanceof Uint8Array) {
		return Buffer.from(data);
	}

	var isArr = isArray(data);
	if (isArr) {
		for (var i = 0; i < data.length; i += 1) {
			var x = data[i];
			if (
				typeof x !== 'number'
				|| x < 0
				|| x > 255
				|| ~~x !== x // NaN and integer check
			) {
				throw new RangeError('Array items must be numbers in the range 0-255.');
			}
		}
	}

	/*
	 * Old Buffer polyfill on an engine that doesn't have TypedArray support
	 * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
	 * Convert to our current Buffer implementation
	 */
	if (
		isArr || (
			Buffer.isBuffer(data)
			&& data.constructor
			&& typeof data.constructor.isBuffer === 'function'
			&& data.constructor.isBuffer(data)
		)
	) {
		return Buffer.from(data);
	}

	throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
};

},{"isarray":355,"safe-buffer":327,"typed-array-buffer":356}],355:[function(require,module,exports){
arguments[4][264][0].apply(exports,arguments)
},{"dup":264}],356:[function(require,module,exports){
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

/** @type {undefined | ((thisArg: import('.').TypedArray) => Buffer<ArrayBufferLike>)} */
var $typedArrayBuffer = callBound('TypedArray.prototype.buffer', true);

var isTypedArray = require('is-typed-array');

/** @type {import('.')} */
// node <= 0.10, < 0.11.4 has a nonconfigurable own property instead of a prototype getter
module.exports = $typedArrayBuffer || function typedArrayBuffer(x) {
	if (!isTypedArray(x)) {
		throw new $TypeError('Not a Typed Array');
	}
	return x.buffer;
};

},{"call-bound":175,"es-errors/type":226,"is-typed-array":263}],357:[function(require,module,exports){
var native = require('./native')

function getTypeName (fn) {
  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
}

function getValueTypeName (value) {
  return native.Nil(value) ? '' : getTypeName(value.constructor)
}

function getValue (value) {
  if (native.Function(value)) return ''
  if (native.String(value)) return JSON.stringify(value)
  if (value && native.Object(value)) return ''
  return value
}

function captureStackTrace (e, t) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(e, t)
  }
}

function tfJSON (type) {
  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
  if (native.Array(type)) return 'Array'
  if (type && native.Object(type)) return 'Object'

  return type !== undefined ? type : ''
}

function tfErrorString (type, value, valueTypeName) {
  var valueJson = getValue(value)

  return 'Expected ' + tfJSON(type) + ', got' +
    (valueTypeName !== '' ? ' ' + valueTypeName : '') +
    (valueJson !== '' ? ' ' + valueJson : '')
}

function TfTypeError (type, value, valueTypeName) {
  valueTypeName = valueTypeName || getValueTypeName(value)
  this.message = tfErrorString(type, value, valueTypeName)

  captureStackTrace(this, TfTypeError)
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfTypeError.prototype = Object.create(Error.prototype)
TfTypeError.prototype.constructor = TfTypeError

function tfPropertyErrorString (type, label, name, value, valueTypeName) {
  var description = '" of type '
  if (label === 'key') description = '" with key type '

  return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
}

function TfPropertyTypeError (type, property, label, value, valueTypeName) {
  if (type) {
    valueTypeName = valueTypeName || getValueTypeName(value)
    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
  } else {
    this.message = 'Unexpected property "' + property + '"'
  }

  captureStackTrace(this, TfTypeError)
  this.__label = label
  this.__property = property
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfPropertyTypeError.prototype = Object.create(Error.prototype)
TfPropertyTypeError.prototype.constructor = TfTypeError

function tfCustomError (expected, actual) {
  return new TfTypeError(expected, {}, actual)
}

function tfSubError (e, property, label) {
  // sub child?
  if (e instanceof TfPropertyTypeError) {
    property = property + '.' + e.__property

    e = new TfPropertyTypeError(
      e.__type, property, e.__label, e.__value, e.__valueTypeName
    )

  // child?
  } else if (e instanceof TfTypeError) {
    e = new TfPropertyTypeError(
      e.__type, property, label, e.__value, e.__valueTypeName
    )
  }

  captureStackTrace(e)
  return e
}

module.exports = {
  TfTypeError: TfTypeError,
  TfPropertyTypeError: TfPropertyTypeError,
  tfCustomError: tfCustomError,
  tfSubError: tfSubError,
  tfJSON: tfJSON,
  getValueTypeName: getValueTypeName
}

},{"./native":360}],358:[function(require,module,exports){
(function (Buffer){(function (){
var NATIVE = require('./native')
var ERRORS = require('./errors')

function _Buffer (value) {
  return Buffer.isBuffer(value)
}

function Hex (value) {
  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
}

function _LengthN (type, length) {
  var name = type.toJSON()

  function Length (value) {
    if (!type(value)) return false
    if (value.length === length) return true

    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
  }
  Length.toJSON = function () { return name }

  return Length
}

var _ArrayN = _LengthN.bind(null, NATIVE.Array)
var _BufferN = _LengthN.bind(null, _Buffer)
var _HexN = _LengthN.bind(null, Hex)
var _StringN = _LengthN.bind(null, NATIVE.String)

function Range (a, b, f) {
  f = f || NATIVE.Number
  function _range (value, strict) {
    return f(value, strict) && (value > a) && (value < b)
  }
  _range.toJSON = function () {
    return `${f.toJSON()} between [${a}, ${b}]`
  }
  return _range
}

var INT53_MAX = Math.pow(2, 53) - 1

function Finite (value) {
  return typeof value === 'number' && isFinite(value)
}
function Int8 (value) { return ((value << 24) >> 24) === value }
function Int16 (value) { return ((value << 16) >> 16) === value }
function Int32 (value) { return (value | 0) === value }
function Int53 (value) {
  return typeof value === 'number' &&
    value >= -INT53_MAX &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}
function UInt8 (value) { return (value & 0xff) === value }
function UInt16 (value) { return (value & 0xffff) === value }
function UInt32 (value) { return (value >>> 0) === value }
function UInt53 (value) {
  return typeof value === 'number' &&
    value >= 0 &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}

var types = {
  ArrayN: _ArrayN,
  Buffer: _Buffer,
  BufferN: _BufferN,
  Finite: Finite,
  Hex: Hex,
  HexN: _HexN,
  Int8: Int8,
  Int16: Int16,
  Int32: Int32,
  Int53: Int53,
  Range: Range,
  StringN: _StringN,
  UInt8: UInt8,
  UInt16: UInt16,
  UInt32: UInt32,
  UInt53: UInt53
}

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types

}).call(this)}).call(this,{"isBuffer":require("../is-buffer/index.js")})
},{"../is-buffer/index.js":261,"./errors":357,"./native":360}],359:[function(require,module,exports){
var ERRORS = require('./errors')
var NATIVE = require('./native')

// short-hand
var tfJSON = ERRORS.tfJSON
var TfTypeError = ERRORS.TfTypeError
var TfPropertyTypeError = ERRORS.TfPropertyTypeError
var tfSubError = ERRORS.tfSubError
var getValueTypeName = ERRORS.getValueTypeName

var TYPES = {
  arrayOf: function arrayOf (type, options) {
    type = compile(type)
    options = options || {}

    function _arrayOf (array, strict) {
      if (!NATIVE.Array(array)) return false
      if (NATIVE.Nil(array)) return false
      if (options.minLength !== undefined && array.length < options.minLength) return false
      if (options.maxLength !== undefined && array.length > options.maxLength) return false
      if (options.length !== undefined && array.length !== options.length) return false

      return array.every(function (value, i) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _arrayOf.toJSON = function () {
      var str = '[' + tfJSON(type) + ']'
      if (options.length !== undefined) {
        str += '{' + options.length + '}'
      } else if (options.minLength !== undefined || options.maxLength !== undefined) {
        str += '{' +
          (options.minLength === undefined ? 0 : options.minLength) + ',' +
          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
      }
      return str
    }

    return _arrayOf
  },

  maybe: function maybe (type) {
    type = compile(type)

    function _maybe (value, strict) {
      return NATIVE.Nil(value) || type(value, strict, maybe)
    }
    _maybe.toJSON = function () { return '?' + tfJSON(type) }

    return _maybe
  },

  map: function map (propertyType, propertyKeyType) {
    propertyType = compile(propertyType)
    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)

    function _map (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      for (var propertyName in value) {
        try {
          if (propertyKeyType) {
            typeforce(propertyKeyType, propertyName, strict)
          }
        } catch (e) {
          throw tfSubError(e, propertyName, 'key')
        }

        try {
          var propertyValue = value[propertyName]
          typeforce(propertyType, propertyValue, strict)
        } catch (e) {
          throw tfSubError(e, propertyName)
        }
      }

      return true
    }

    if (propertyKeyType) {
      _map.toJSON = function () {
        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
      }
    } else {
      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }
    }

    return _map
  },

  object: function object (uncompiled) {
    var type = {}

    for (var typePropertyName in uncompiled) {
      type[typePropertyName] = compile(uncompiled[typePropertyName])
    }

    function _object (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      var propertyName

      try {
        for (propertyName in type) {
          var propertyType = type[propertyName]
          var propertyValue = value[propertyName]

          typeforce(propertyType, propertyValue, strict)
        }
      } catch (e) {
        throw tfSubError(e, propertyName)
      }

      if (strict) {
        for (propertyName in value) {
          if (type[propertyName]) continue

          throw new TfPropertyTypeError(undefined, propertyName)
        }
      }

      return true
    }
    _object.toJSON = function () { return tfJSON(type) }

    return _object
  },

  anyOf: function anyOf () {
    var types = [].slice.call(arguments).map(compile)

    function _anyOf (value, strict) {
      return types.some(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }

    return _anyOf
  },

  allOf: function allOf () {
    var types = [].slice.call(arguments).map(compile)

    function _allOf (value, strict) {
      return types.every(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }

    return _allOf
  },

  quacksLike: function quacksLike (type) {
    function _quacksLike (value) {
      return type === getValueTypeName(value)
    }
    _quacksLike.toJSON = function () { return type }

    return _quacksLike
  },

  tuple: function tuple () {
    var types = [].slice.call(arguments).map(compile)

    function _tuple (values, strict) {
      if (NATIVE.Nil(values)) return false
      if (NATIVE.Nil(values.length)) return false
      if (strict && (values.length !== types.length)) return false

      return types.every(function (type, i) {
        try {
          return typeforce(type, values[i], strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }

    return _tuple
  },

  value: function value (expected) {
    function _value (actual) {
      return actual === expected
    }
    _value.toJSON = function () { return expected }

    return _value
  }
}

// TODO: deprecate
TYPES.oneOf = TYPES.anyOf

function compile (type) {
  if (NATIVE.String(type)) {
    if (type[0] === '?') return TYPES.maybe(type.slice(1))

    return NATIVE[type] || TYPES.quacksLike(type)
  } else if (type && NATIVE.Object(type)) {
    if (NATIVE.Array(type)) {
      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
      return TYPES.arrayOf(type[0])
    }

    return TYPES.object(type)
  } else if (NATIVE.Function(type)) {
    return type
  }

  return TYPES.value(type)
}

function typeforce (type, value, strict, surrogate) {
  if (NATIVE.Function(type)) {
    if (type(value, strict)) return true

    throw new TfTypeError(surrogate || type, value)
  }

  // JIT
  return typeforce(compile(type), value, strict)
}

// assign types to typeforce function
for (var typeName in NATIVE) {
  typeforce[typeName] = NATIVE[typeName]
}

for (typeName in TYPES) {
  typeforce[typeName] = TYPES[typeName]
}

var EXTRA = require('./extra')
for (typeName in EXTRA) {
  typeforce[typeName] = EXTRA[typeName]
}

typeforce.compile = compile
typeforce.TfTypeError = TfTypeError
typeforce.TfPropertyTypeError = TfPropertyTypeError

module.exports = typeforce

},{"./errors":357,"./extra":358,"./native":360}],360:[function(require,module,exports){
var types = {
  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
  Boolean: function (value) { return typeof value === 'boolean' },
  Function: function (value) { return typeof value === 'function' },
  Nil: function (value) { return value === undefined || value === null },
  Number: function (value) { return typeof value === 'number' },
  Object: function (value) { return typeof value === 'object' },
  String: function (value) { return typeof value === 'string' },
  '': function () { return true }
}

// TODO: deprecate
types.Null = types.Nil

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types

},{}],361:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],362:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer

// Number.MAX_SAFE_INTEGER
var MAX_SAFE_INTEGER = 9007199254740991

function checkUInt53 (n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')
}

function encode (number, buffer, offset) {
  checkUInt53(number)

  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  // 8 bit
  if (number < 0xfd) {
    buffer.writeUInt8(number, offset)
    encode.bytes = 1

  // 16 bit
  } else if (number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset)
    buffer.writeUInt16LE(number, offset + 1)
    encode.bytes = 3

  // 32 bit
  } else if (number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset)
    buffer.writeUInt32LE(number, offset + 1)
    encode.bytes = 5

  // 64 bit
  } else {
    buffer.writeUInt8(0xff, offset)
    buffer.writeUInt32LE(number >>> 0, offset + 1)
    buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)
    encode.bytes = 9
  }

  return buffer
}

function decode (buffer, offset) {
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  var first = buffer.readUInt8(offset)

  // 8 bit
  if (first < 0xfd) {
    decode.bytes = 1
    return first

  // 16 bit
  } else if (first === 0xfd) {
    decode.bytes = 3
    return buffer.readUInt16LE(offset + 1)

  // 32 bit
  } else if (first === 0xfe) {
    decode.bytes = 5
    return buffer.readUInt32LE(offset + 1)

  // 64 bit
  } else {
    decode.bytes = 9
    var lo = buffer.readUInt32LE(offset + 1)
    var hi = buffer.readUInt32LE(offset + 5)
    var number = hi * 0x0100000000 + lo
    checkUInt53(number)

    return number
  }
}

function encodingLength (number) {
  checkUInt53(number)

  return (
    number < 0xfd ? 1
      : number <= 0xffff ? 3
        : number <= 0xffffffff ? 5
          : 9
  )
}

module.exports = { encode: encode, decode: decode, encodingLength: encodingLength }

},{"safe-buffer":327}],363:[function(require,module,exports){
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{}],364:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBind = require('call-bind');
var callBound = require('call-bound');
var gOPD = require('gopd');
var getProto = require('get-proto');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};

/** @typedef {import('./types').Getter} Getter */
/** @type {import('./types').Cache} */
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getProto) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr && getProto) {
			var proto = getProto(arr);
			// @ts-expect-error TS won't narrow inside a closure
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor && proto) {
				var superProto = getProto(proto);
				// @ts-expect-error TS won't narrow inside a closure
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			// @ts-expect-error TODO: fix
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		var fn = arr.slice || arr.set;
		if (fn) {
			cache[
				/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)
			] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */ (
				// @ts-expect-error TODO FIXME
				callBind(fn)
			);
		}
	});
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */ (cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
		function (getter, typedArray) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					if ('$' + getter(value) === typedArray) {
						found = /** @type {import('.').TypedArrayName} */ ($slice(typedArray, 1));
					}
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
	/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */(cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					getter(value);
					found = /** @type {import('.').TypedArrayName} */ ($slice(name, 1));
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		/** @type {string} */
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":50,"call-bind":174,"call-bound":175,"for-each":231,"get-proto":237,"gopd":239,"has-tostringtag/shams":243}],365:[function(require,module,exports){
(function (Buffer){(function (){
var bs58check = require('bs58check')

function decodeRaw (buffer, version) {
  // check version only if defined
  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')

  // uncompressed
  if (buffer.length === 33) {
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: false
    }
  }

  // invalid length
  if (buffer.length !== 34) throw new Error('Invalid WIF length')

  // invalid compression flag
  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')

  return {
    version: buffer[0],
    privateKey: buffer.slice(1, 33),
    compressed: true
  }
}

function encodeRaw (version, privateKey, compressed) {
  var result = new Buffer(compressed ? 34 : 33)

  result.writeUInt8(version, 0)
  privateKey.copy(result, 1)

  if (compressed) {
    result[33] = 0x01
  }

  return result
}

function decode (string, version) {
  return decodeRaw(bs58check.decode(string), version)
}

function encode (version, privateKey, compressed) {
  if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))

  return bs58check.encode(
    encodeRaw(
      version.version,
      version.privateKey,
      version.compressed
    )
  )
}

module.exports = {
  decode: decode,
  decodeRaw: decodeRaw,
  encode: encode,
  encodeRaw: encodeRaw
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bs58check":369,"buffer":167}],366:[function(require,module,exports){
'use strict'
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = require('safe-buffer').Buffer
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (psz < source.length) {
            // Find code of next character
      var charCode = source.charCodeAt(psz)
            // Base map can not be indexed using char code
      if (charCode > 255) { return }
            // Decode character
      var carry = BASE_MAP[charCode]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
    vch.fill(0x00, 0, zeroes)
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base

},{"safe-buffer":327}],367:[function(require,module,exports){
var basex = require('base-x')
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)

},{"base-x":366}],368:[function(require,module,exports){
'use strict'

var base58 = require('bs58')
var Buffer = require('safe-buffer').Buffer

module.exports = function (checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode (payload) {
    var checksum = checksumFn(payload)

    return base58.encode(Buffer.concat([
      payload,
      checksum
    ], payload.length + 4))
  }

  function decodeRaw (buffer) {
    var payload = buffer.slice(0, -4)
    var checksum = buffer.slice(-4)
    var newChecksum = checksumFn(payload)

    if (checksum[0] ^ newChecksum[0] |
        checksum[1] ^ newChecksum[1] |
        checksum[2] ^ newChecksum[2] |
        checksum[3] ^ newChecksum[3]) return

    return payload
  }

  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe (string) {
    var buffer = base58.decodeUnsafe(string)
    if (!buffer) return

    return decodeRaw(buffer)
  }

  function decode (string) {
    var buffer = base58.decode(string)
    var payload = decodeRaw(buffer, checksumFn)
    if (!payload) throw new Error('Invalid checksum')
    return payload
  }

  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  }
}

},{"bs58":367,"safe-buffer":327}],369:[function(require,module,exports){
'use strict'

var createHash = require('create-hash')
var bs58checkBase = require('./base')

// SHA256(SHA256(buffer))
function sha256x2 (buffer) {
  var tmp = createHash('sha256').update(buffer).digest()
  return createHash('sha256').update(tmp).digest()
}

module.exports = bs58checkBase(sha256x2)

},{"./base":368,"create-hash":180}],370:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
// Distributed under the MIT software license
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
const secp256k1 = __importStar(require("@bitcoinerlab/secp256k1"));
const descriptors = __importStar(require("@bitcoinerlab/descriptors"));
const miniscript_1 = require("@bitcoinerlab/miniscript");
const bip39_1 = require("bip39");
const bip65_1 = require("bip65");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const crypto_1 = require("crypto");
// https://coinfaucet.eu/en/btc-testnet/      =>  tb1qerzrlxcfu24davlur5sqmgzzgsal6wusda40er
// https://bitcoinfaucet.uo1.net/                   =>  b1qlj64u6fqutr0xue85kl55fx0gt4m4urun25p7q
// Address faucet devolver utxos
const TESTNET3_FAUCET = 'tb1qerzrlxcfu24davlur5sqmgzzgsal6wusda40er';
const TESTNET4_FAUCET = 'tb1qn9rvr53m7qvrpysx48svuxsgahs88xfsskx367';
// Importar herramientas de descriptores
const { wpkhBIP32 } = descriptors.scriptExpressions;
const { Output, BIP32 } = descriptors.DescriptorsFactory(secp256k1);
// Comisiones de la red
const FEE = 200;
// El purpuse se puede elegir libremiente
const WSH_ORIGIN_PATH_DAILY1 = `/101'/1'/0'`;
const WSH_ORIGIN_PATH_DAILY2 = `/102'/1'/0'`;
const WSH_ORIGIN_PATH_DAILY3 = `/103'/1'/0'`;
const WSH_ORIGIN_PATH_RECOVERY1 = `/105'/1'/0'`;
const WSH_ORIGIN_PATH_RECOVERY2 = `/106'/1'/0'`;
const WSH_ORIGIN_PATH_EMERGENCY = `/107'/1'/0'`;
// 0/0 es la primera dirección derivada de la cuenta 0, se usa para todas las claves
const WSH_KEY_PATH = `/0/0`;
// Semilla se utliza para calcular las claves, se dejan harcodeadas,  se podrían guardar en localStorage
const MNEMONIC = 'fábula medalla sastre pronto mármol rutina diez poder fuente pulpo empate lagarto';
// Bloqueos
const BLOCKS_RECOVERY = 3;
const BLOCKS_EMERGENCY = 5;
// Consola pagina web
const outputConsole = document.getElementById('output-console');
/************************ FUNCIONES AUXILIARES  ************************/
// Funcion que toma el valor de la poliza de gasto
const POLICY = (after_rec, after_eme) => `or(thresh(2,pk(@key_daily1),pk(@key_daily2),pk(@key_daily3)),or(and(after(${after_rec}),thresh(1,pk(@key_recovery_1),pk(@key_recovery_2))),thresh(2,pk(@key_emergency),after(${after_eme}))))`;
// Función para mostrar por pantalla el fingerprint del nodo maestro y las xpubkeys
function calculateFingerprint(masterNode) {
    // Obtener la clave pública del nodo maestro
    const publicKey = masterNode.publicKey;
    // Calcular el hash SHA256 seguido de RIPEMD160 = H
    const sha256Hash = (0, crypto_1.createHash)('sha256').update(publicKey).digest();
    const ripemd160Hash = (0, crypto_1.createHash)('ripemd160').update(sha256Hash).digest();
    // Usar Uint8Array.prototype.slice() para tomar los primeros 4 bytes como fingerprint
    const fingerprint = Buffer.from(new Uint8Array(ripemd160Hash).slice(0, 4)).toString('hex');
    // Ver el extended pubkey Daily
    const childDaily1 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_DAILY1}`);
    const xpubDaily1 = childDaily1.neutered().toBase58();
    const childDaily2 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_DAILY2}`);
    const xpubDaily2 = childDaily2.neutered().toBase58();
    const childDaily3 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_DAILY3}`);
    const xpubDaily3 = childDaily3.neutered().toBase58();
    // Ver el extended pubkey Recovery
    const childRecover1 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_RECOVERY1}`);
    const xpubRecover1 = childRecover1.neutered().toBase58();
    const childRecover2 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_RECOVERY2}`);
    const xpubRecover2 = childRecover2.neutered().toBase58();
    // Ver el extended pubkey Emergency
    const childEmergency = masterNode.derivePath(`m${WSH_ORIGIN_PATH_EMERGENCY}`);
    const xpubEmergency = childEmergency.neutered().toBase58();
    // Mostrar los resultados en la consola
    console.log('Masternode fingerprint:', fingerprint);
    console.log('Extended pubKey Diario 1:', xpubDaily1);
    console.log('Extended pubKey Diario 2:', xpubDaily2);
    console.log('Extended pubKey Custodio:', xpubDaily3);
    console.log('Extended pubKey Recovery  1:', xpubRecover1);
    console.log('Extended pubKey Recovery 2:', xpubRecover2);
    console.log('Extended pubKey Emergency:', xpubEmergency);
}
// Función auxiliar para obtener el nombre de la red según el explorer
const getNetworkName = (explorer) => {
    if (explorer.includes('testnet4'))
        return 'Testnet 4';
    if (explorer.includes('testnet'))
        return 'Testnet 3';
    return 'Desconocida';
};
// Leer número de bloques desde la interfaz para Autocustodia
function getBlocksFromUIAutocustodia() {
    try {
        const r = document.getElementById('blocks-recovery-autocustodia');
        const e = document.getElementById('blocks-emergency-autocustodia');
        const rec = r ? parseInt(r.value, 10) : BLOCKS_RECOVERY;
        const eme = e ? parseInt(e.value, 10) : BLOCKS_EMERGENCY;
        return {
            recovery: Number.isNaN(rec) ? BLOCKS_RECOVERY : Math.max(1, rec),
            emergency: Number.isNaN(eme) ? BLOCKS_EMERGENCY : Math.max(1, eme),
        };
    }
    catch (e) {
        return { recovery: BLOCKS_RECOVERY, emergency: BLOCKS_EMERGENCY };
    }
}
// Función para mostrar mensajes en la interfaz de usuario
const logToOutput = (outputContainer, message, type = 'info') => {
    const paragraph = document.createElement('p');
    paragraph.innerHTML = message;
    paragraph.classList.add('output-line', `output-${type}`);
    outputContainer.appendChild(paragraph);
    outputContainer.scrollTop = outputContainer.scrollHeight;
};
// Habilitar los botones de la pagina web despues de la inicializacion
function enableButtons() {
    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => {
        if (button.id !== 'initTestnet4Btn' && button.id !== 'initTestnet3Btn') {
            button.disabled = false;
        }
        // Deshabilitar el botón de inicialización si ya se ha inicializado
        else {
            button.disabled = true;
        }
    });
}
// Mensaje de bienvenida
logToOutput(outputConsole, '<span aria-hidden="true">🚀</span> Iniciar en red de pruebas: <a href="#" onclick="document.getElementById(\'initTestnet3Btn\').click();return false;">Testnet 3</a> o <a href="#" onclick="document.getElementById(\'initTestnet4Btn\').click();return false;">Testnet 4</a>', 'info');
/************************ ▶️ INICIALIZAR EL MINISCRIPT  ************************/
const initMiniscriptObjet = (network, explorer) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Nodo maestro del que se derivan el resto de hijos
        const masterNode = BIP32.fromSeed((0, bip39_1.mnemonicToSeedSync)(MNEMONIC), network);
        // Obtener la altura actual del bloque desde el explorador
        const originalBlockHeight = parseInt(yield (yield fetch(`${explorer}/api/blocks/tip/height`)).text());
        // Obtener el hash del último bloque
        const blockHash = yield (yield fetch(`${explorer}/api/block-height/${originalBlockHeight}`)).text();
        // Obtener los detalles del bloque (incluye el timestamp)
        const blockDetails = yield (yield fetch(`${explorer}/api/block/${blockHash}`)).json();
        // El timestamp viene en segundos desde Epoch, conviértelo a fecha legible
        const blockDate = new Date(blockDetails.timestamp * 1000);
        // Obtener el nombre de la red
        const networkName = getNetworkName(explorer);
        logToOutput(outputConsole, `<span aria-hidden="true">🌐</span> Iniciando la wallet en la red  <strong>${networkName}</strong>`, 'info');
        logToOutput(outputConsole, '<span aria-hidden="true">🌟</span> ¡El Playground ha sido inicializado con éxito! <span aria-hidden="true">🌟</span>', 'success');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
        // Leer valores configurables desde la UI (si el usuario ha cambiado los inputs)
        const { recovery: blocksRecUI, emergency: blocksEmerUI } = getBlocksFromUIAutocustodia();
        // Calcular el valor de "after" basado en la altura actual del bloque y el número de bloques de espera
        const recovery = (0, bip65_1.encode)({ blocks: originalBlockHeight + blocksRecUI });
        const emergency = (0, bip65_1.encode)({ blocks: originalBlockHeight + blocksEmerUI });
        // Crear la política de gasto basada en el valor de "after"
        const policy = POLICY(recovery, emergency);
        // Compilar la política de gasto en Miniscript y verificar si es válida
        const { miniscript, issane } = (0, miniscript_1.compilePolicy)(policy);
        if (!issane)
            throw new Error('Miniscript no válido.');
        // Derivar las claves públicas de los nodos hijos
        const key_daily1 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_DAILY1}${WSH_KEY_PATH}`).publicKey;
        const key_daily2 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_DAILY2}${WSH_KEY_PATH}`).publicKey;
        const key_daily3 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_DAILY3}${WSH_KEY_PATH}`).publicKey;
        const key_recovery_1 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_RECOVERY1}${WSH_KEY_PATH}`).publicKey;
        const key_recovery_2 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_RECOVERY2}${WSH_KEY_PATH}`).publicKey;
        const key_emergency = masterNode.derivePath(`m${WSH_ORIGIN_PATH_EMERGENCY}${WSH_KEY_PATH}`).publicKey;
        // Crear el descriptor Miniscript reemplazando las claves públicas en la política
        const wshDescriptor = `wsh(${miniscript
            .replace('@key_daily1', descriptors.keyExpressionBIP32({
            masterNode: masterNode,
            originPath: WSH_ORIGIN_PATH_DAILY1,
            keyPath: WSH_KEY_PATH
        }))
            .replace('@key_daily2', descriptors.keyExpressionBIP32({
            masterNode: masterNode,
            originPath: WSH_ORIGIN_PATH_DAILY2,
            keyPath: WSH_KEY_PATH
        }))
            .replace('@key_daily3', descriptors.keyExpressionBIP32({
            masterNode: masterNode,
            originPath: WSH_ORIGIN_PATH_DAILY3,
            keyPath: WSH_KEY_PATH
        }))
            .replace('@key_recovery_1', descriptors.keyExpressionBIP32({
            masterNode: masterNode,
            originPath: WSH_ORIGIN_PATH_RECOVERY1,
            keyPath: WSH_KEY_PATH
        }))
            .replace('@key_recovery_2', descriptors.keyExpressionBIP32({
            masterNode: masterNode,
            originPath: WSH_ORIGIN_PATH_RECOVERY2,
            keyPath: WSH_KEY_PATH
        }))
            .replace('@key_emergency', descriptors.keyExpressionBIP32({
            masterNode: masterNode,
            originPath: WSH_ORIGIN_PATH_EMERGENCY,
            keyPath: WSH_KEY_PATH
        }))})`;
        // Crear el objeto Output con el descriptor y la red, por defecto se utiliza la clave de key_emergency
        const MiniscriptObjet = new Output({
            descriptor: wshDescriptor,
            network,
            signersPubKeys: [key_emergency]
        });
        // Obtener la dirección derivada del Miniscript
        const miniscriptAddress = MiniscriptObjet.getAddress();
        // Habilitar los botones de la interfaz de usuario después de la inicialización
        enableButtons();
        // Mostrar información en la consola
        console.log(`Bloque, fecha y hora:${originalBlockHeight}: ${blockDate.toLocaleString()}`);
        console.log(`Frase mnemónica: ${MNEMONIC}`);
        console.log('Public key Diario 1', key_daily1.toString('hex'));
        console.log('Public key Diario 2', key_daily2.toString('hex'));
        console.log('Public key Custodio', key_daily3.toString('hex'));
        console.log('Public key Recovery 1:', key_recovery_1.toString('hex'));
        console.log('Public key Recovery 2:', key_recovery_2.toString('hex'));
        console.log('Public key Emergency:', key_emergency.toString('hex'));
        calculateFingerprint(masterNode);
        console.log(`Policy: ${policy}`);
        console.log('Generated Miniscript :', miniscript);
        console.log(`Miniscript address: ${miniscriptAddress}`);
        console.log('Descriptor:', wshDescriptor);
        console.log('Miniscript object:', MiniscriptObjet.expand());
        // Retornar el descriptor Miniscript, la altura actual del bloque y la política de gasto
        return { MiniscriptObjet, originalBlockHeight, masterNode, wshDescriptor };
    }
    catch (error) {
        // Manejar errores durante la inicialización del Miniscript, initiazeNetwork muestra el error en la interfaz
        console.error(`<span aria-hidden="true">❌</span> Error al inicializar Miniscript: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'error');
        throw error;
    }
});
/************************ 📜 CONSULTAR MINISCRIPT ************************/
const mostrarMiniscript = (MiniscriptObjet, originalBlockHeight, explorer) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Obtener el nombre de la red
        const networkName = getNetworkName(explorer);
        const actualBlockHeight = parseInt(yield (yield fetch(`${explorer}/api/blocks/tip/height`)).text());
        const restingBlocksDiario = originalBlockHeight - actualBlockHeight;
        const { recovery: blocksRec2, emergency: blocksEmer2 } = getBlocksFromUIAutocustodia();
        const restingBlocksRec = originalBlockHeight + blocksRec2 - actualBlockHeight;
        const restingBlocksEmer = originalBlockHeight + blocksEmer2 - actualBlockHeight;
        // Control sobre el número de bloques restantes
        const displayDiario = restingBlocksDiario <= 0 ? 0 : restingBlocksDiario;
        const displayRec = restingBlocksRec <= 0 ? 0 : restingBlocksRec;
        const displayEmerg = restingBlocksEmer <= 0 ? 0 : restingBlocksEmer;
        // Asignar clase de color según si el contador ha llegado a cero
        const diarioClass = restingBlocksDiario > 0 ? 'output-error' : 'output-success';
        const recClass = restingBlocksRec > 0 ? 'output-error' : 'output-success';
        const emergClass = restingBlocksEmer > 0 ? 'output-error' : 'output-success';
        // Mostrar información detallada
        logToOutput(outputConsole, `<span aria-hidden="true">🛜</span> Red actual: <strong>${networkName}</strong>`, 'info');
        logToOutput(outputConsole, `<span aria-hidden="true">🧱</span> Altura actual de bloque: <strong>${actualBlockHeight}</strong>`, 'info');
        logToOutput(outputConsole, `<span aria-hidden="true">🗓️</span> Bloques para poder gastar en la rama de uso diario: <strong class="${diarioClass}">${displayDiario}</strong>`, 'info');
        logToOutput(outputConsole, `<span aria-hidden="true">🛡️</span> Bloques para poder gastar en la rama de recuperación: <strong class="${recClass}">${displayRec}</strong>`, 'info');
        logToOutput(outputConsole, `<span aria-hidden="true">🚨</span> Bloques para poder gastar en la rama de emergencia: <strong class="${emergClass}">${displayEmerg}</strong>`, 'info');
        const miniscriptAddress = MiniscriptObjet.getAddress();
        logToOutput(outputConsole, `<span aria-hidden="true">📩</span> Dirección del miniscript: <a href="${explorer}/address/${miniscriptAddress}" target="_blank">${miniscriptAddress}</a>`, 'info');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
    catch (error) {
        logToOutput(outputConsole, `<span aria-hidden="true">❌</span> Error al mostrar el Miniscript: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'error');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
});
/************************ 🔍 BUSCAR FONDOS  **********************/
const fetchUtxosMini = (MiniscriptObjet, explorer) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Obtener la dirección desde el objeto pasado como argumento
        const miniscriptAddress = MiniscriptObjet.getAddress();
        logToOutput(outputConsole, `<span aria-hidden="true">🔍</span> Consultando fondos...`, 'info');
        // Consultar los UTXOs asociados a la dirección
        const utxos = yield (yield fetch(`${explorer}/api/address/${miniscriptAddress}/utxo`)).json();
        console.log('UTXOs:', utxos);
        // Verificar si se encontraron UTXOs
        if (utxos.length === 0) {
            const networkName = getNetworkName(explorer);
            logToOutput(outputConsole, `<span aria-hidden="true">🚫</span> No se encontraron fondos en la dirección: <a href="${explorer}/address/${miniscriptAddress}" target="_blank">${miniscriptAddress}</a>`, 'error');
            if (networkName === 'Testnet 4') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir fondos a través de <a href="https://faucet.testnet4.dev/" target="_blank">faucet Testnet 4</a>`, 'info');
            }
            else if (networkName === 'Testnet 3') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir fondos a través de <a href="https://bitcoinfaucet.uo1.net/send.php" target="_blank">faucet Testnet 3</a>`, 'info');
            }
            else {
                logToOutput(outputConsole, `<span aria-hidden="true">⚠️</span> La red seleccionada no tiene faucet disponible.`, 'info');
            }
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
            return;
        }
        logToOutput(outputConsole, `<span aria-hidden="true">✅</span> Fondos encontrados: <a href="${explorer}/address/${miniscriptAddress}" target="_blank">${miniscriptAddress}</a>`, 'success');
        // Calcular el total de todos los UTXOs
        const totalValue = utxos.reduce((sum, utxo) => sum + utxo.value, 0);
        // Ordenar los UTXOs por block_height en orden ascendente (de más antiguo a más reciente)
        const sortedUtxos = utxos.sort((a, b) => (a.status.block_height || 0) - (b.status.block_height || 0));
        // Mostrar cada UTXO individualmente con estado de confirmación y bloque al que pertenece
        sortedUtxos.forEach((utxo, index) => {
            const confirmationStatus = utxo.status.confirmed ? '<span class="output-success"><span aria-hidden="true">✅</span> confirmado</span>' : '<span class="output-error"><span aria-hidden="true">❓</span> no confirmado</span>';
            const blockHeight = utxo.status.block_height || 'Desconocido';
            logToOutput(outputConsole, `<span aria-hidden="true">🪙</span> Fondos: <strong>${utxo.value}</strong> sats ${confirmationStatus} - Bloque: <strong>${blockHeight}</strong>`, 'info');
        });
        // Mostrar el total de los UTXOs
        logToOutput(outputConsole, `<span aria-hidden="true">💰</span> Total fondos: <strong>${totalValue}</strong> sats`, 'info');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
    catch (error) {
        logToOutput(outputConsole, `<span aria-hidden="true">❌</span> Error al consultar los UTXOs: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'error');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
});
/************************ 🚛 ULTIMA  TX  ************************/
const fetchTransaction = (MiniscriptObjet, explorer) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const miniscriptAddress = MiniscriptObjet.getAddress();
        logToOutput(outputConsole, `<span aria-hidden="true">🚛</span> Consultando última transacción...`, 'info');
        // Obtener historial de transacciones
        const txHistory = yield (yield fetch(`${explorer}/api/address/${miniscriptAddress}/txs`)).json();
        console.log('Transacciones:', txHistory);
        if (!Array.isArray(txHistory) || txHistory.length === 0) {
            const networkName = getNetworkName(explorer);
            logToOutput(outputConsole, `<span aria-hidden="true">🚫</span> No se encontraron transacciones en la dirección: <a href="${explorer}/address/${miniscriptAddress}" target="_blank">${miniscriptAddress}</a>`, 'error');
            if (networkName === 'Testnet 4') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir transacción a través de <a href="https://faucet.testnet4.dev/" target="_blank">faucet Testnet 4</a>`, 'info');
            }
            else if (networkName === 'Testnet 3') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir transacción a través de <a href="https://bitcoinfaucet.uo1.net/send.php" target="_blank">faucet Testnet 3</a>`, 'info');
            }
            else {
                logToOutput(outputConsole, `<span aria-hidden="true">⚠️</span> La red seleccionada no tiene faucet disponible.`, 'info');
            }
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
            return;
        }
        // Obtener detalles de la transacción con el block_height más alto, que indica la última transacción
        const txnID = txHistory.sort((a, b) => b.status.block_height - a.status.block_height)[0].txid;
        const txDetails = yield (yield fetch(`${explorer}/api/tx/${txnID}`)).json();
        // Determinar si es envío o recepción
        const esEmisor = txDetails.vin.some((vin) => { var _a; return ((_a = vin.prevout) === null || _a === void 0 ? void 0 : _a.scriptpubkey_address) === miniscriptAddress; });
        const esReceptor = txDetails.vout.some((vout) => vout.scriptpubkey_address === miniscriptAddress);
        let tipo;
        if (esEmisor && esReceptor) {
            tipo = '<span aria-hidden="true">📤📥</span> Envío + Recepción (cambio)';
        }
        else if (esEmisor) {
            tipo = '<span aria-hidden="true">📤</span> Envío';
        }
        else if (esReceptor) {
            tipo = '<span aria-hidden="true">📥</span> Recepción';
        }
        else {
            tipo = '<span aria-hidden="true">🔍</span> Participación no directa';
        }
        const confirmationStatus = txDetails.status.confirmed ? '<span class="output-success"><span aria-hidden="true">✅</span> confirmada</span>' : '<span class="output-error"><span aria-hidden="true">❓</span> no confirmada</span>';
        logToOutput(outputConsole, `<span aria-hidden="true">✅</span> Transacción encontrada: <a href="${explorer}/tx/${txnID}"target="_blank"><code>${txnID}</code></a>`, 'success');
        const blockHeight = txDetails.status.block_height || 'Desconocido';
        logToOutput(outputConsole, `${tipo} ${confirmationStatus} - Bloque: <strong>${blockHeight}</strong>`);
        // Mostrar detalles de las entradas SOLO si la dirección es la del miniscript
        if (esEmisor) {
            txDetails.vin.forEach((vin, index) => {
                var _a, _b;
                const prevoutAddress = ((_a = vin.prevout) === null || _a === void 0 ? void 0 : _a.scriptpubkey_address) || 'Desconocido';
                const prevoutValue = ((_b = vin.prevout) === null || _b === void 0 ? void 0 : _b.value) || 'Desconocido';
                if (prevoutAddress === miniscriptAddress) {
                    logToOutput(outputConsole, `<span aria-hidden="true">🪙</span> Fondos enviados: <strong>${prevoutValue}</strong> sats → ${prevoutAddress} <span aria-hidden="true">✔️</span>`, 'info');
                }
            });
        }
        // Mostrar detalles de las salidas SOLO si la dirección es la del miniscript
        if (esReceptor) {
            txDetails.vout.forEach((vout, index) => {
                if (vout.scriptpubkey_address === miniscriptAddress) {
                    logToOutput(outputConsole, `<span aria-hidden="true">🪙</span> Fondos recibidos: <strong>${vout.value}</strong> sats → ${vout.scriptpubkey_address} <span aria-hidden="true">✔️</span>`, 'info');
                }
            });
        }
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
    catch (error) {
        logToOutput(outputConsole, `<span aria-hidden="true">❌</span> Error al consultar la transacción: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'error');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
});
/************************ 🗓️ DIARIO 🔑🔑:🔑🔑🔑  ************************/
const dailyPSBT = (masterNode, network, explorer, wshDescriptor, originalBlockHeight) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        console.log('Descriptor WSH:', wshDescriptor);
        const actualBlockHeight = parseInt(yield (yield fetch(`${explorer}/api/blocks/tip/height`)).text());
        const restingBlocks = originalBlockHeight - actualBlockHeight;
        const displayBlocks = restingBlocks <= 0 ? 0 : restingBlocks;
        // Crear un nuevo objeto para la clave de emergencia
        const dailyKey1 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_DAILY1}${WSH_KEY_PATH}`).publicKey;
        const dailyKey2 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_DAILY2}${WSH_KEY_PATH}`).publicKey;
        const localMiniscriptObjet = new Output({
            descriptor: wshDescriptor,
            network,
            signersPubKeys: [dailyKey1, dailyKey2]
        });
        logToOutput(outputConsole, `<span aria-hidden="true">🗓️</span> Se ha pulsado el botón "Uso diario..."`, 'info');
        // Obtener la dirección de recepción 
        const miniscriptAddress = localMiniscriptObjet.getAddress();
        // Consultar UTXOs disponibles en la direccion del Miniscript
        const utxos = yield (yield fetch(`${explorer}/api/address/${miniscriptAddress}/utxo`)).json();
        console.log('UTXOs:', utxos);
        if (!Array.isArray(utxos) || utxos.length === 0) {
            const networkName = getNetworkName(explorer);
            logToOutput(outputConsole, `<span aria-hidden="true">🚫</span> No se encontraron fondos en la dirección: <a href="${explorer}/address/${miniscriptAddress}" target="_blank">${miniscriptAddress}</a>`, 'error');
            if (networkName === 'Testnet 4') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir fondos a través de <a href="https://faucet.testnet4.dev/" target="_blank">faucet Testnet 4</a>`, 'info');
            }
            else if (networkName === 'Testnet 3') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir fondos a través de <a href="https://bitcoinfaucet.uo1.net/send.php" target="_blank">faucet Testnet 3</a>`, 'info');
            }
            else {
                logToOutput(outputConsole, `<span aria-hidden="true">⚠️</span> La red seleccionada no tiene faucet disponible.`, 'info');
            }
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
            return;
        }
        // Determinar el faucet según la red
        const networkName = getNetworkName(explorer);
        let selectedFaucet = TESTNET3_FAUCET;
        if (networkName === 'Testnet 4') {
            selectedFaucet = TESTNET4_FAUCET;
        }
        // Mostrar mensaje de inicio solo si hay UTXOs disponibles
        const faucetMsg = networkName === 'Testnet 4'
            ? '<span aria-hidden="true">📦</span> Devolviendo fondos a <code><strong>Faucet Testnet 4</strong></code>'
            : networkName === 'Testnet 3'
                ? '<span aria-hidden="true">📦</span> Devolviendo fondos a <code><strong>Faucet Testnet 3</strong></code>'
                : '<span aria-hidden="true">⚠️</span> La red seleccionada no tiene faucet disponible</strong></code>';
        logToOutput(outputConsole, faucetMsg, 'info');
        // Seleccionar el UTXO más antiguo
        const utxo = utxos.sort((a, b) => a.status.block_height - b.status.block_height)[0];
        const { txid, vout, value: valueIn } = utxo;
        console.log('UTXOS:', utxos.sort((a, b) => b.status.block_height - a.status.block_height));
        console.log('UTXO:', utxo);
        // Obtener la transacción  en formato HEX
        const txHex = yield (yield fetch(`${explorer}/api/tx/${txid}/hex`)).text();
        // Lanzar error si el UTXO no cubre la comisión
        const valueOut = valueIn - FEE;
        if (valueOut <= 0)
            throw new Error('El valor del UTXO no cubre la comisión');
        // Crear la transacción PSBT
        const psbt = new bitcoinjs_lib_1.Psbt({ network });
        // Crear el finalizador con los inputs
        const finalizer = localMiniscriptObjet.updatePsbtAsInput({ psbt, vout, txHex });
        // Crear un Output WSH para usar como output en la transacción y enviar los fondos
        const wshOutput = new Output({
            descriptor: `addr(${selectedFaucet})`,
            network
        });
        console.log('Objeto wsh expandido:', wshOutput.expand());
        wshOutput.updatePsbtAsOutput({ psbt, value: valueOut });
        // Firmar y finalizar la transacción
        descriptors.signers.signBIP32({ psbt, masterNode });
        finalizer({ psbt });
        // Extraer y transmitir la transacción
        const txFinal = psbt.extractTransaction();
        const txResponse = yield (yield fetch(`${explorer}/api/tx`, {
            method: 'POST',
            body: txFinal.toHex()
        })).text();
        console.log(`Pushing TX: ${txFinal.toHex()}`);
        console.log('Resultado TXID:', txResponse);
        // Manejar el error "non-final"
        if (txResponse.match('non-BIP68-final') || txResponse.match('non-final')) {
            const blocksClass = restingBlocks > 0 ? 'output-error' : 'output-success';
            logToOutput(outputConsole, `<span aria-hidden="true">🧱</span> Bloques para poder gastar en la rama de uso diario: <strong class="${blocksClass}">${displayBlocks}</strong>`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">⛏️</span> Los mineros han bloqueado la transacción`, 'error');
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
        }
        else {
            logToOutput(outputConsole, `<span aria-hidden="true">🪙</span> Fondos enviados: <strong>${valueIn}</strong> sats`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">💸</span> Comisión: <strong>${FEE}</strong> sats`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">💰</span> Total transacción: <strong>${valueOut}</strong> sats`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">✍🏻✍🏼</span> Firmando la transacción con las claves principal y secundaria...`, 'info');
            const txId = txFinal.getId();
            logToOutput(outputConsole, `<span aria-hidden="true">🚚</span> Transacción enviada: <a href="${explorer}/tx/${txId}?expand" target="_blank">${txId}</a>`, 'success');
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
        }
    }
    catch (error) {
        logToOutput(outputConsole, `<span aria-hidden="true">❌</span> Error al enviar la transacción: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'error');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
});
/************************  🛡️ RECUPERACIÓN 🕒 🔑:🔑🔑  ************************/
const recoveryPSBT = (masterNode, network, explorer, wshDescriptor, originalBlockHeight) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        console.log('Descriptor WSH:', wshDescriptor);
        const actualBlockHeight = parseInt(yield (yield fetch(`${explorer}/api/blocks/tip/height`)).text());
        const restingBlocks = originalBlockHeight + BLOCKS_RECOVERY - actualBlockHeight;
        const displayBlocks = restingBlocks <= 0 ? 0 : restingBlocks;
        // Crear un nuevo output para la clave de emergencia
        const key_recovery_1 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_RECOVERY1}${WSH_KEY_PATH}`).publicKey;
        const key_recovery_2 = masterNode.derivePath(`m${WSH_ORIGIN_PATH_RECOVERY2}${WSH_KEY_PATH}`).publicKey;
        const localMiniscriptObjet = new Output({
            descriptor: wshDescriptor,
            network,
            signersPubKeys: [key_recovery_1]
        });
        logToOutput(outputConsole, `<span aria-hidden="true">🛡️</span> Se ha pulsado el botón "Recuperación"... `, 'info');
        // Obtener la dirección de recepción
        const miniscriptAddress = localMiniscriptObjet.getAddress();
        // Consultar UTXOs disponibles en la direccion del Miniscript
        const utxos = yield (yield fetch(`${explorer}/api/address/${miniscriptAddress}/utxo`)).json();
        console.log('UTXOs:', utxos);
        if (!Array.isArray(utxos) || utxos.length === 0) {
            const networkName = getNetworkName(explorer);
            logToOutput(outputConsole, `<span aria-hidden="true">🚫</span> No se encontraron fondos en la dirección: <a href="${explorer}/address/${miniscriptAddress}" target="_blank">${miniscriptAddress}</a>`, 'error');
            if (networkName === 'Testnet 4') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir fondos a través de <a href="https://faucet.testnet4.dev/" target="_blank">faucet Testnet 4</a>`, 'info');
            }
            else if (networkName === 'Testnet 3') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir fondos a través de <a href="https://bitcoinfaucet.uo1.net/send.php" target="_blank">faucet Testnet 3</a>`, 'info');
            }
            else {
                logToOutput(outputConsole, `<span aria-hidden="true">⚠️</span> La red seleccionada no tiene faucet disponible.`, 'info');
            }
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
            return;
        }
        // Determinar el faucet según la red
        const networkName = getNetworkName(explorer);
        let selectedFaucet = TESTNET3_FAUCET;
        if (networkName === 'Testnet 4') {
            selectedFaucet = TESTNET4_FAUCET;
        }
        // Mostrar mensaje de inicio solo si hay UTXOs disponibles
        const faucetMsg = networkName === 'Testnet 4'
            ? '<span aria-hidden="true">📦</span> Devolviendo fondos a <code><strong>Faucet Testnet 4</strong></code>'
            : networkName === 'Testnet 3'
                ? '<span aria-hidden="true">📦</span> Devolviendo fondos a <code><strong>Faucet Testnet 3</strong></code>'
                : '<span aria-hidden="true">⚠️</span> La red seleccionada no tiene faucet disponible</strong></code>';
        logToOutput(outputConsole, faucetMsg, 'info');
        // Seleccionar el UTXO más antiguo
        const utxo = utxos.sort((a, b) => a.status.block_height - b.status.block_height)[0];
        const { txid, vout, value: valueIn } = utxo;
        console.log('UTXOS:', utxos.sort((a, b) => b.status.block_height - a.status.block_height));
        console.log('UTXO:', utxo);
        // Obtener la transacción  en formato HEX 
        const txHex = yield (yield fetch(`${explorer}/api/tx/${txid}/hex`)).text();
        // Lanzar error si el UTXO no cubre la comisión
        const valueOut = valueIn - FEE;
        if (valueOut <= 0)
            throw new Error('El valor del UTXO no cubre la comisión');
        // Crear la transacción PSBT
        const psbt = new bitcoinjs_lib_1.Psbt({ network });
        // Crear el finalizador con los inputs
        const finalizer = localMiniscriptObjet.updatePsbtAsInput({ psbt, vout, txHex });
        // Crear un Output WSH para usar como output en la transacción y enviar los fondos
        const wshOutput = new Output({
            descriptor: `addr(${selectedFaucet})`,
            network
        });
        console.log('Objeto wsh expandido:', wshOutput.expand());
        wshOutput.updatePsbtAsOutput({ psbt, value: valueOut });
        // Firmar y finalizar la transacción
        descriptors.signers.signBIP32({ psbt, masterNode });
        finalizer({ psbt });
        // Extraer y transmitir la transacción
        const txFinal = psbt.extractTransaction();
        const txResponse = yield (yield fetch(`${explorer}/api/tx`, {
            method: 'POST',
            body: txFinal.toHex()
        })).text();
        console.log(`Pushing TX: ${txFinal.toHex()}`);
        console.log('Resultado TXID:', txResponse);
        // Manejar el error "non-final"
        if (txResponse.match('non-BIP68-final') || txResponse.match('non-final')) {
            const blocksClass = restingBlocks > 0 ? 'output-error' : 'output-success';
            logToOutput(outputConsole, `<span aria-hidden="true">🧱</span> Bloques para poder gastar en la rama de recuperación: <strong class="${blocksClass}">${displayBlocks}</strong>`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">⛏️</span> Los mineros han bloqueado la transacción`, 'error');
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
        }
        else {
            logToOutput(outputConsole, `<span aria-hidden="true">🪙</span> Fondos enviados: <strong>${valueIn}</strong> sats`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">💸</span> Comisión: <strong>${FEE}</strong> sats`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">💰</span> Total transacción: <strong>${valueOut}</strong> sats`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">✍🏻</span> Firmando la transacción con la clave de respaldo principal...`, 'info');
            const txId = txFinal.getId();
            logToOutput(outputConsole, `<span aria-hidden="true">🚚</span> Transacción enviada: <a href="${explorer}/tx/${txId}?expand" target="_blank">${txId}</a>`, 'success');
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
        }
    }
    catch (error) {
        logToOutput(outputConsole, `<span aria-hidden="true">❌</span> Error al enviar la transacción: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'error');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
});
/************************ 🚨 EMERGENCIA ⏰ 🔑 ************************/
const emergencyPSBT = (masterNode, network, explorer, wshDescriptor, originalBlockHeight) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        console.log('Descriptor WSH:', wshDescriptor);
        const actualBlockHeight = parseInt(yield (yield fetch(`${explorer}/api/blocks/tip/height`)).text());
        const restingBlocks = originalBlockHeight + BLOCKS_EMERGENCY - actualBlockHeight;
        const displayBlocks = restingBlocks <= 0 ? 0 : restingBlocks;
        // Crear un nuevo output para la clave de emergencia
        const emergencyKey = masterNode.derivePath(`m${WSH_ORIGIN_PATH_EMERGENCY}${WSH_KEY_PATH}`).publicKey;
        const localMiniscriptObjet = new Output({
            descriptor: wshDescriptor,
            network,
            signersPubKeys: [emergencyKey]
        });
        logToOutput(outputConsole, `<span aria-hidden="true">🚨</span> Se ha pulsado el botón "Apertura de emergencia"... `, 'info');
        // Obtener la dirección de envio
        const miniscriptAddress = localMiniscriptObjet.getAddress();
        // Consultar UTXOs disponibles en la direccion del Miniscript
        const utxos = yield (yield fetch(`${explorer}/api/address/${miniscriptAddress}/utxo`)).json();
        console.log('UTXOs:', utxos);
        if (!Array.isArray(utxos) || utxos.length === 0) {
            const networkName = getNetworkName(explorer);
            logToOutput(outputConsole, `<span aria-hidden="true">🚫</span> No se encontraron fondos en la dirección: <a href="${explorer}/address/${miniscriptAddress}" target="_blank">${miniscriptAddress}</a>`, 'error');
            if (networkName === 'Testnet 4') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir fondos a través de <a href="https://faucet.testnet4.dev/" target="_blank">faucet Testnet 4</a>`, 'info');
            }
            else if (networkName === 'Testnet 3') {
                logToOutput(outputConsole, `<span aria-hidden="true">💧</span> Recibir fondos a través de <a href="https://bitcoinfaucet.uo1.net/send.php" target="_blank">faucet Testnet 3</a>`, 'info');
            }
            else {
                logToOutput(outputConsole, `<span aria-hidden="true">⚠️</span> La red seleccionada no tiene faucet disponible.`, 'info');
            }
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
            return;
        }
        // Determinar el faucet según la red
        const networkName = getNetworkName(explorer);
        let selectedFaucet = TESTNET3_FAUCET;
        if (networkName === 'Testnet 4') {
            selectedFaucet = TESTNET4_FAUCET;
        }
        // Mostrar mensaje de inicio solo si hay UTXOs disponibles
        const faucetMsg = networkName === 'Testnet 4'
            ? '<span aria-hidden="true">📦</span> Devolviendo fondos a <code><strong>Faucet Testnet 4</strong></code>'
            : networkName === 'Testnet 3'
                ? '<span aria-hidden="true">📦</span> Devolviendo fondos a <code><strong>Faucet Testnet 3</strong></code>'
                : '<span aria-hidden="true">⚠️</span> La red seleccionada no tiene faucet disponible</strong></code>';
        logToOutput(outputConsole, faucetMsg, 'info');
        // Seleccionar el UTXO más antiguo
        const utxo = utxos.sort((a, b) => a.status.block_height - b.status.block_height)[0];
        const { txid, vout, value: valueIn } = utxo;
        console.log('UTXOS:', utxos.sort((a, b) => b.status.block_height - a.status.block_height));
        console.log('UTXO:', utxo);
        const txHex = yield (yield fetch(`${explorer}/api/tx/${txid}/hex`)).text();
        // Lanzar error si el UTXO no cubre la comisión
        const valueOut = valueIn - FEE;
        if (valueOut <= 0)
            throw new Error('El valor del UTXO no cubre la comisión');
        // Crear la transacción PSBT
        const psbt = new bitcoinjs_lib_1.Psbt({ network });
        // Crear el finalizador con los inputs
        const finalizer = localMiniscriptObjet.updatePsbtAsInput({ psbt, vout, txHex });
        // Crear un Output WSH para usar como output en la transacción y enviar los fondos
        const wshOutput = new Output({
            descriptor: `addr(${selectedFaucet})`,
            network
        });
        console.log('Objeto wsh expandido:', wshOutput.expand());
        wshOutput.updatePsbtAsOutput({ psbt, value: valueOut });
        // Firmar y finalizar la transacción
        descriptors.signers.signBIP32({ psbt, masterNode });
        finalizer({ psbt });
        // Extraer y transmitir la transacción
        const txFinal = psbt.extractTransaction();
        const txResponse = yield (yield fetch(`${explorer}/api/tx`, {
            method: 'POST',
            body: txFinal.toHex()
        })).text();
        console.log(`Pushing TX: ${txFinal.toHex()}`);
        console.log('Resultado TXID:', txResponse);
        // Manejar el error "non-final"
        if (txResponse.match('non-BIP68-final') || txResponse.match('non-final')) {
            const blocksClass = restingBlocks > 0 ? 'output-error' : 'output-success';
            logToOutput(outputConsole, `<span aria-hidden="true">🧱</span> Bloques para poder gastar en la rama de emergencia: <strong class="${blocksClass}">${displayBlocks}</strong>`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">⛏️</span> Los mineros han bloqueado la transacción`, 'error');
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
        }
        else {
            logToOutput(outputConsole, `<span aria-hidden="true">🪙</span> Fondos enviados: <strong>${valueIn}</strong> sats`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">💸</span> Comisión: <strong>${FEE}</strong> sats`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">💰</span> Total transacción: <strong>${valueOut}</strong> sats`, 'info');
            logToOutput(outputConsole, `<span aria-hidden="true">✍🏻</span> Firmando la transacción con la clave de apertura por perdida...`, 'info');
            const txId = txFinal.getId();
            logToOutput(outputConsole, `<span aria-hidden="true">🚚</span> Transacción enviada: <a href="${explorer}/tx/${txId}?expand" target="_blank">${txId}</a>`, 'success');
            logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
        }
    }
    catch (error) {
        logToOutput(outputConsole, `<span aria-hidden="true">❌</span> Error al enviar la transacción: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'error');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
});
/************************ 🛜 CONECTAR CON LA RED BITCOIN Y LLAMADAS AL RESTO DE BOTONES  ************************/
const initializeNetwork = (network, explorer) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f;
    try {
        const { MiniscriptObjet, originalBlockHeight, masterNode, wshDescriptor } = yield initMiniscriptObjet(network, explorer);
        (_a = document.getElementById('showMiniscriptBtn')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', () => mostrarMiniscript(MiniscriptObjet, originalBlockHeight, explorer));
        (_b = document.getElementById('fetchUtxosBtn')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', () => fetchUtxosMini(MiniscriptObjet, explorer));
        (_c = document.getElementById('fetchTransactionBtn')) === null || _c === void 0 ? void 0 : _c.addEventListener('click', () => fetchTransaction(MiniscriptObjet, explorer));
        (_d = document.getElementById('dailyBtn')) === null || _d === void 0 ? void 0 : _d.addEventListener('click', () => dailyPSBT(masterNode, network, explorer, wshDescriptor, originalBlockHeight));
        (_e = document.getElementById('recoveryBtn')) === null || _e === void 0 ? void 0 : _e.addEventListener('click', () => recoveryPSBT(masterNode, network, explorer, wshDescriptor, originalBlockHeight));
        (_f = document.getElementById('emergencyBtn')) === null || _f === void 0 ? void 0 : _f.addEventListener('click', () => emergencyPSBT(masterNode, network, explorer, wshDescriptor, originalBlockHeight));
    }
    catch (error) {
        logToOutput(outputConsole, `<span aria-hidden="true">❌</span> Error al inicializar el Miniscript: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'error');
        logToOutput(outputConsole, `<hr style="border:1px dashed #ccc;">`);
    }
});
/************************ 🔘 LLAMADAS A LOS BOTONES INICAR  RED   ************************/
// Inicializar el Miniscript en la red de testnet3
(_a = document.getElementById('initTestnet3Btn')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', () => initializeNetwork(bitcoinjs_lib_1.networks.testnet, 'https://mempool.space/testnet'));
// Inicializar el Miniscript en la red de testnet4
(_b = document.getElementById('initTestnet4Btn')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', () => initializeNetwork(bitcoinjs_lib_1.networks.testnet, 'https://mempool.space/testnet4'));
// Borrar consola
(_c = document.getElementById('clearOutputBtn')) === null || _c === void 0 ? void 0 : _c.addEventListener('click', () => {
    outputConsole.innerHTML = '';
});

}).call(this)}).call(this,require("buffer").Buffer)
},{"@bitcoinerlab/descriptors":4,"@bitcoinerlab/miniscript":12,"@bitcoinerlab/secp256k1":13,"bip39":90,"bip65":101,"bitcoinjs-lib":109,"buffer":167,"crypto":184}]},{},[370]);
